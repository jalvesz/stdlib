#:include "common.fypp" 
submodule(stdlib_lapack) stdlib_lapack_eigv_gen
  implicit none(type,external)


  contains

     module subroutine stdlib_sgeesx( jobvs, sort, select, sense, n, a, lda, sdim,wr, wi, vs, ldvs, &
     !! SGEESX computes for an N-by-N real nonsymmetric matrix A, the
     !! eigenvalues, the real Schur form T, and, optionally, the matrix of
     !! Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).
     !! Optionally, it also orders the eigenvalues on the diagonal of the
     !! real Schur form so that selected eigenvalues are at the top left;
     !! computes a reciprocal condition number for the average of the
     !! selected eigenvalues (RCONDE); and computes a reciprocal condition
     !! number for the right invariant subspace corresponding to the
     !! selected eigenvalues (RCONDV).  The leading columns of Z form an
     !! orthonormal basis for this invariant subspace.
     !! For further explanation of the reciprocal condition numbers RCONDE
     !! and RCONDV, see Section 4.10_sp of the LAPACK Users' Guide (where
     !! these quantities are called s and sep respectively).
     !! A real matrix is in real Schur form if it is upper quasi-triangular
     !! with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in
     !! the form
     !! [  a  b  ]
     !! [  c  a  ]
     !! where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).
               rconde, rcondv, work, lwork,iwork, liwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvs, sense, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldvs, liwork, lwork, n
           real(sp), intent(out) :: rconde, rcondv
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: vs(ldvs,*), wi(*), work(*), wr(*)
           ! Function Arguments 
           procedure(stdlib_select_s) :: select
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: cursl, lastsl, lquery, lst2sl, scalea, wantsb, wantse, wantsn, wantst, &
                     wantsv, wantvs
           integer(ilp) :: hswork, i, i1, i2, ibal, icond, ierr, ieval, ihi, ilo, inxt, ip, itau, &
                     iwrk, lwrk, liwrk, maxwrk, minwrk
           real(sp) :: anrm, bignum, cscale, eps, smlnum
           ! Local Arrays 
           real(sp) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           wantvs = stdlib_lsame( jobvs, 'V' )
           wantst = stdlib_lsame( sort, 'S' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( ( .not.wantvs ) .and. ( .not.stdlib_lsame( jobvs, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -2
           else if( .not.( wantsn .or. wantse .or. wantsv .or. wantsb ) .or.( .not.wantst .and. &
                     .not.wantsn ) ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldvs<1 .or. ( wantvs .and. ldvs<n ) ) then
              info = -12
           end if
           ! compute workspace
            ! (note: comments in the code beginning "rworkspace:" describe the
             ! minimal amount of real workspace needed at that point in the
             ! code, as well as the preferred amount for good performance.
             ! iworkspace refers to integer workspace.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_shseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.
             ! if sense = 'e', 'v' or 'b', then the amount of workspace needed
             ! depends on sdim, which is computed by the routine stdlib_strsen later
             ! in the code.)
           if( info==0 ) then
              liwrk = 1
              if( n==0 ) then
                 minwrk = 1
                 lwrk = 1
              else
                 maxwrk = 2*n + n*stdlib_ilaenv( 1, 'SGEHRD', ' ', n, 1, n, 0 )
                 minwrk = 3*n
                 call stdlib_shseqr( 'S', jobvs, n, 1, n, a, lda, wr, wi, vs, ldvs,work, -1, &
                           ieval )
                 hswork = work( 1 )
                 if( .not.wantvs ) then
                    maxwrk = max( maxwrk, n + hswork )
                 else
                    maxwrk = max( maxwrk, 2*n + ( n - 1 )*stdlib_ilaenv( 1,'SORGHR', ' ', n, 1, n,&
                               -1 ) )
                    maxwrk = max( maxwrk, n + hswork )
                 end if
                 lwrk = maxwrk
                 if( .not.wantsn )lwrk = max( lwrk, n + ( n*n )/2 )
                 if( wantsv .or. wantsb )liwrk = ( n*n )/4
              end if
              iwork( 1 ) = liwrk
              work( 1 ) = lwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -16
              else if( liwork<1 .and. .not.lquery ) then
                 info = -18
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGEESX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_slange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_slascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (rworkspace: need n)
           ibal = 1
           call stdlib_sgebal( 'P', n, a, lda, ilo, ihi, work( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (rworkspace: need 3*n, prefer 2*n+n*nb)
           itau = n + ibal
           iwrk = n + itau
           call stdlib_sgehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvs ) then
              ! copy householder vectors to vs
              call stdlib_slacpy( 'L', n, n, a, lda, vs, ldvs )
              ! generate orthogonal matrix in vs
              ! (rworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
              call stdlib_sorghr( n, ilo, ihi, vs, ldvs, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
           end if
           sdim = 0
           ! perform qr iteration, accumulating schur vectors in vs if desired
           ! (rworkspace: need n+1, prefer n+hswork (see comments) )
           iwrk = itau
           call stdlib_shseqr( 'S', jobvs, n, ilo, ihi, a, lda, wr, wi, vs, ldvs,work( iwrk ), &
                     lwork-iwrk+1, ieval )
           if( ieval>0 )info = ieval
           ! sort eigenvalues if desired
           if( wantst .and. info==0 ) then
              if( scalea ) then
                 call stdlib_slascl( 'G', 0, 0, cscale, anrm, n, 1, wr, n, ierr )
                 call stdlib_slascl( 'G', 0, 0, cscale, anrm, n, 1, wi, n, ierr )
              end if
              do i = 1, n
                 bwork( i ) = select( wr( i ), wi( i ) )
              end do
              ! reorder eigenvalues, transform schur vectors, and compute
              ! reciprocal condition numbers
              ! (rworkspace: if sense is not 'n', need n+2*sdim*(n-sdim)
                           ! otherwise, need n )
              ! (iworkspace: if sense is 'v' or 'b', need sdim*(n-sdim)
                           ! otherwise, need 0 )
              call stdlib_strsen( sense, jobvs, bwork, n, a, lda, vs, ldvs, wr, wi,sdim, rconde, &
                        rcondv, work( iwrk ), lwork-iwrk+1,iwork, liwork, icond )
              if( .not.wantsn )maxwrk = max( maxwrk, n+2*sdim*( n-sdim ) )
              if( icond==-15 ) then
                 ! not enough real workspace
                 info = -16
              else if( icond==-17 ) then
                 ! not enough integer workspace
                 info = -18
              else if( icond>0 ) then
                 ! stdlib_strsen failed to reorder or to restore standard schur form
                 info = icond + n
              end if
           end if
           if( wantvs ) then
              ! undo balancing
              ! (rworkspace: need n)
              call stdlib_sgebak( 'P', 'R', n, ilo, ihi, work( ibal ), n, vs, ldvs,ierr )
           end if
           if( scalea ) then
              ! undo scaling for the schur form of a
              call stdlib_slascl( 'H', 0, 0, cscale, anrm, n, n, a, lda, ierr )
              call stdlib_scopy( n, a, lda+1, wr, 1 )
              if( ( wantsv .or. wantsb ) .and. info==0 ) then
                 dum( 1 ) = rcondv
                 call stdlib_slascl( 'G', 0, 0, cscale, anrm, 1, 1, dum, 1, ierr )
                 rcondv = dum( 1 )
              end if
              if( cscale==smlnum ) then
                 ! if scaling back towards underflow, adjust wi if an
                 ! offdiagonal element of a 2-by-2 block in the schur form
                 ! underflows.
                 if( ieval>0 ) then
                    i1 = ieval + 1
                    i2 = ihi - 1
                    call stdlib_slascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wi, n,ierr )
                 else if( wantst ) then
                    i1 = 1
                    i2 = n - 1
                 else
                    i1 = ilo
                    i2 = ihi - 1
                 end if
                 inxt = i1 - 1
                 loop_20: do i = i1, i2
                    if( i<inxt )cycle loop_20
                    if( wi( i )==zero ) then
                       inxt = i + 1
                    else
                       if( a( i+1, i )==zero ) then
                          wi( i ) = zero
                          wi( i+1 ) = zero
                       else if( a( i+1, i )/=zero .and. a( i, i+1 )==zero ) then
                          wi( i ) = zero
                          wi( i+1 ) = zero
                          if( i>1 )call stdlib_sswap( i-1, a( 1, i ), 1, a( 1, i+1 ), 1 )
                          if( n>i+1 )call stdlib_sswap( n-i-1, a( i, i+2 ), lda,a( i+1, i+2 ), &
                                    lda )
                          if( wantvs ) then
                            call stdlib_sswap( n, vs( 1, i ), 1, vs( 1, i+1 ), 1 )
                          end if
                          a( i, i+1 ) = a( i+1, i )
                          a( i+1, i ) = zero
                       end if
                       inxt = i + 2
                    end if
                 end do loop_20
              end if
              call stdlib_slascl( 'G', 0, 0, cscale, anrm, n-ieval, 1,wi( ieval+1 ), max( n-ieval,&
                         1 ), ierr )
           end if
           if( wantst .and. info==0 ) then
              ! check if reordering successful
              lastsl = .true.
              lst2sl = .true.
              sdim = 0
              ip = 0
              do i = 1, n
                 cursl = select( wr( i ), wi( i ) )
                 if( wi( i )==zero ) then
                    if( cursl )sdim = sdim + 1
                    ip = 0
                    if( cursl .and. .not.lastsl )info = n + 2
                 else
                    if( ip==1 ) then
                       ! last eigenvalue of conjugate pair
                       cursl = cursl .or. lastsl
                       lastsl = cursl
                       if( cursl )sdim = sdim + 2
                       ip = -1
                       if( cursl .and. .not.lst2sl )info = n + 2
                    else
                       ! first eigenvalue of conjugate pair
                       ip = 1
                    end if
                 end if
                 lst2sl = lastsl
                 lastsl = cursl
              end do
           end if
           work( 1 ) = maxwrk
           if( wantsv .or. wantsb ) then
              iwork( 1 ) = sdim*(n-sdim)
           else
              iwork( 1 ) = 1
           end if
           return
     end subroutine stdlib_sgeesx

     module subroutine stdlib_dgeesx( jobvs, sort, select, sense, n, a, lda, sdim,wr, wi, vs, ldvs, &
     !! DGEESX computes for an N-by-N real nonsymmetric matrix A, the
     !! eigenvalues, the real Schur form T, and, optionally, the matrix of
     !! Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).
     !! Optionally, it also orders the eigenvalues on the diagonal of the
     !! real Schur form so that selected eigenvalues are at the top left;
     !! computes a reciprocal condition number for the average of the
     !! selected eigenvalues (RCONDE); and computes a reciprocal condition
     !! number for the right invariant subspace corresponding to the
     !! selected eigenvalues (RCONDV).  The leading columns of Z form an
     !! orthonormal basis for this invariant subspace.
     !! For further explanation of the reciprocal condition numbers RCONDE
     !! and RCONDV, see Section 4.10_dp of the LAPACK Users' Guide (where
     !! these quantities are called s and sep respectively).
     !! A real matrix is in real Schur form if it is upper quasi-triangular
     !! with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in
     !! the form
     !! [  a  b  ]
     !! [  c  a  ]
     !! where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).
               rconde, rcondv, work, lwork,iwork, liwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvs, sense, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldvs, liwork, lwork, n
           real(dp), intent(out) :: rconde, rcondv
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: vs(ldvs,*), wi(*), work(*), wr(*)
           ! Function Arguments 
           procedure(stdlib_select_d) :: select
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: cursl, lastsl, lquery, lst2sl, scalea, wantsb, wantse, wantsn, wantst, &
                     wantsv, wantvs
           integer(ilp) :: hswork, i, i1, i2, ibal, icond, ierr, ieval, ihi, ilo, inxt, ip, itau, &
                     iwrk, liwrk, lwrk, maxwrk, minwrk
           real(dp) :: anrm, bignum, cscale, eps, smlnum
           ! Local Arrays 
           real(dp) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           wantvs = stdlib_lsame( jobvs, 'V' )
           wantst = stdlib_lsame( sort, 'S' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( ( .not.wantvs ) .and. ( .not.stdlib_lsame( jobvs, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -2
           else if( .not.( wantsn .or. wantse .or. wantsv .or. wantsb ) .or.( .not.wantst .and. &
                     .not.wantsn ) ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldvs<1 .or. ( wantvs .and. ldvs<n ) ) then
              info = -12
           end if
           ! compute workspace
            ! (note: comments in the code beginning "rworkspace:" describe the
             ! minimal amount of real workspace needed at that point in the
             ! code, as well as the preferred amount for good performance.
             ! iworkspace refers to integer workspace.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_dhseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.
             ! if sense = 'e', 'v' or 'b', then the amount of workspace needed
             ! depends on sdim, which is computed by the routine stdlib_dtrsen later
             ! in the code.)
           if( info==0 ) then
              liwrk = 1
              if( n==0 ) then
                 minwrk = 1
                 lwrk = 1
              else
                 maxwrk = 2*n + n*stdlib_ilaenv( 1, 'DGEHRD', ' ', n, 1, n, 0 )
                 minwrk = 3*n
                 call stdlib_dhseqr( 'S', jobvs, n, 1, n, a, lda, wr, wi, vs, ldvs,work, -1, &
                           ieval )
                 hswork = work( 1 )
                 if( .not.wantvs ) then
                    maxwrk = max( maxwrk, n + hswork )
                 else
                    maxwrk = max( maxwrk, 2*n + ( n - 1 )*stdlib_ilaenv( 1,'DORGHR', ' ', n, 1, n,&
                               -1 ) )
                    maxwrk = max( maxwrk, n + hswork )
                 end if
                 lwrk = maxwrk
                 if( .not.wantsn )lwrk = max( lwrk, n + ( n*n )/2 )
                 if( wantsv .or. wantsb )liwrk = ( n*n )/4
              end if
              iwork( 1 ) = liwrk
              work( 1 ) = lwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -16
              else if( liwork<1 .and. .not.lquery ) then
                 info = -18
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEESX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' )
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_dlange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_dlascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (rworkspace: need n)
           ibal = 1
           call stdlib_dgebal( 'P', n, a, lda, ilo, ihi, work( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (rworkspace: need 3*n, prefer 2*n+n*nb)
           itau = n + ibal
           iwrk = n + itau
           call stdlib_dgehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvs ) then
              ! copy householder vectors to vs
              call stdlib_dlacpy( 'L', n, n, a, lda, vs, ldvs )
              ! generate orthogonal matrix in vs
              ! (rworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
              call stdlib_dorghr( n, ilo, ihi, vs, ldvs, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
           end if
           sdim = 0
           ! perform qr iteration, accumulating schur vectors in vs if desired
           ! (rworkspace: need n+1, prefer n+hswork (see comments) )
           iwrk = itau
           call stdlib_dhseqr( 'S', jobvs, n, ilo, ihi, a, lda, wr, wi, vs, ldvs,work( iwrk ), &
                     lwork-iwrk+1, ieval )
           if( ieval>0 )info = ieval
           ! sort eigenvalues if desired
           if( wantst .and. info==0 ) then
              if( scalea ) then
                 call stdlib_dlascl( 'G', 0, 0, cscale, anrm, n, 1, wr, n, ierr )
                 call stdlib_dlascl( 'G', 0, 0, cscale, anrm, n, 1, wi, n, ierr )
              end if
              do i = 1, n
                 bwork( i ) = select( wr( i ), wi( i ) )
              end do
              ! reorder eigenvalues, transform schur vectors, and compute
              ! reciprocal condition numbers
              ! (rworkspace: if sense is not 'n', need n+2*sdim*(n-sdim)
                           ! otherwise, need n )
              ! (iworkspace: if sense is 'v' or 'b', need sdim*(n-sdim)
                           ! otherwise, need 0 )
              call stdlib_dtrsen( sense, jobvs, bwork, n, a, lda, vs, ldvs, wr, wi,sdim, rconde, &
                        rcondv, work( iwrk ), lwork-iwrk+1,iwork, liwork, icond )
              if( .not.wantsn )maxwrk = max( maxwrk, n+2*sdim*( n-sdim ) )
              if( icond==-15 ) then
                 ! not enough real workspace
                 info = -16
              else if( icond==-17 ) then
                 ! not enough integer workspace
                 info = -18
              else if( icond>0 ) then
                 ! stdlib_dtrsen failed to reorder or to restore standard schur form
                 info = icond + n
              end if
           end if
           if( wantvs ) then
              ! undo balancing
              ! (rworkspace: need n)
              call stdlib_dgebak( 'P', 'R', n, ilo, ihi, work( ibal ), n, vs, ldvs,ierr )
           end if
           if( scalea ) then
              ! undo scaling for the schur form of a
              call stdlib_dlascl( 'H', 0, 0, cscale, anrm, n, n, a, lda, ierr )
              call stdlib_dcopy( n, a, lda+1, wr, 1 )
              if( ( wantsv .or. wantsb ) .and. info==0 ) then
                 dum( 1 ) = rcondv
                 call stdlib_dlascl( 'G', 0, 0, cscale, anrm, 1, 1, dum, 1, ierr )
                 rcondv = dum( 1 )
              end if
              if( cscale==smlnum ) then
                 ! if scaling back towards underflow, adjust wi if an
                 ! offdiagonal element of a 2-by-2 block in the schur form
                 ! underflows.
                 if( ieval>0 ) then
                    i1 = ieval + 1
                    i2 = ihi - 1
                    call stdlib_dlascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wi, n,ierr )
                 else if( wantst ) then
                    i1 = 1
                    i2 = n - 1
                 else
                    i1 = ilo
                    i2 = ihi - 1
                 end if
                 inxt = i1 - 1
                 loop_20: do i = i1, i2
                    if( i<inxt )cycle loop_20
                    if( wi( i )==zero ) then
                       inxt = i + 1
                    else
                       if( a( i+1, i )==zero ) then
                          wi( i ) = zero
                          wi( i+1 ) = zero
                       else if( a( i+1, i )/=zero .and. a( i, i+1 )==zero ) then
                          wi( i ) = zero
                          wi( i+1 ) = zero
                          if( i>1 )call stdlib_dswap( i-1, a( 1, i ), 1, a( 1, i+1 ), 1 )
                          if( n>i+1 )call stdlib_dswap( n-i-1, a( i, i+2 ), lda,a( i+1, i+2 ), &
                                    lda )
                          if( wantvs ) then
                            call stdlib_dswap( n, vs( 1, i ), 1, vs( 1, i+1 ), 1 )
                          end if
                          a( i, i+1 ) = a( i+1, i )
                          a( i+1, i ) = zero
                       end if
                       inxt = i + 2
                    end if
                 end do loop_20
              end if
              call stdlib_dlascl( 'G', 0, 0, cscale, anrm, n-ieval, 1,wi( ieval+1 ), max( n-ieval,&
                         1 ), ierr )
           end if
           if( wantst .and. info==0 ) then
              ! check if reordering successful
              lastsl = .true.
              lst2sl = .true.
              sdim = 0
              ip = 0
              do i = 1, n
                 cursl = select( wr( i ), wi( i ) )
                 if( wi( i )==zero ) then
                    if( cursl )sdim = sdim + 1
                    ip = 0
                    if( cursl .and. .not.lastsl )info = n + 2
                 else
                    if( ip==1 ) then
                       ! last eigenvalue of conjugate pair
                       cursl = cursl .or. lastsl
                       lastsl = cursl
                       if( cursl )sdim = sdim + 2
                       ip = -1
                       if( cursl .and. .not.lst2sl )info = n + 2
                    else
                       ! first eigenvalue of conjugate pair
                       ip = 1
                    end if
                 end if
                 lst2sl = lastsl
                 lastsl = cursl
              end do
           end if
           work( 1 ) = maxwrk
           if( wantsv .or. wantsb ) then
              iwork( 1 ) = max( 1, sdim*( n-sdim ) )
           else
              iwork( 1 ) = 1
           end if
           return
     end subroutine stdlib_dgeesx

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$geesx( jobvs, sort, select, sense, n, a, lda, sdim,wr, wi, vs, ldvs, &
     !! DGEESX: computes for an N-by-N real nonsymmetric matrix A, the
     !! eigenvalues, the real Schur form T, and, optionally, the matrix of
     !! Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).
     !! Optionally, it also orders the eigenvalues on the diagonal of the
     !! real Schur form so that selected eigenvalues are at the top left;
     !! computes a reciprocal condition number for the average of the
     !! selected eigenvalues (RCONDE); and computes a reciprocal condition
     !! number for the right invariant subspace corresponding to the
     !! selected eigenvalues (RCONDV).  The leading columns of Z form an
     !! orthonormal basis for this invariant subspace.
     !! For further explanation of the reciprocal condition numbers RCONDE
     !! and RCONDV, see Section 4.10_${rk}$ of the LAPACK Users' Guide (where
     !! these quantities are called s and sep respectively).
     !! A real matrix is in real Schur form if it is upper quasi-triangular
     !! with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in
     !! the form
     !! [  a  b  ]
     !! [  c  a  ]
     !! where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).
               rconde, rcondv, work, lwork,iwork, liwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvs, sense, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldvs, liwork, lwork, n
           real(${rk}$), intent(out) :: rconde, rcondv
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: vs(ldvs,*), wi(*), work(*), wr(*)
           ! Function Arguments 
           procedure(stdlib_select_${ri}$) :: select
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: cursl, lastsl, lquery, lst2sl, scalea, wantsb, wantse, wantsn, wantst, &
                     wantsv, wantvs
           integer(ilp) :: hswork, i, i1, i2, ibal, icond, ierr, ieval, ihi, ilo, inxt, ip, itau, &
                     iwrk, liwrk, lwrk, maxwrk, minwrk
           real(${rk}$) :: anrm, bignum, cscale, eps, smlnum
           ! Local Arrays 
           real(${rk}$) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           wantvs = stdlib_lsame( jobvs, 'V' )
           wantst = stdlib_lsame( sort, 'S' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( ( .not.wantvs ) .and. ( .not.stdlib_lsame( jobvs, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -2
           else if( .not.( wantsn .or. wantse .or. wantsv .or. wantsb ) .or.( .not.wantst .and. &
                     .not.wantsn ) ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldvs<1 .or. ( wantvs .and. ldvs<n ) ) then
              info = -12
           end if
           ! compute workspace
            ! (note: comments in the code beginning "rworkspace:" describe the
             ! minimal amount of real workspace needed at that point in the
             ! code, as well as the preferred amount for good performance.
             ! iworkspace refers to integer workspace.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_${ri}$hseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.
             ! if sense = 'e', 'v' or 'b', then the amount of workspace needed
             ! depends on sdim, which is computed by the routine stdlib_${ri}$trsen later
             ! in the code.)
           if( info==0 ) then
              liwrk = 1
              if( n==0 ) then
                 minwrk = 1
                 lwrk = 1
              else
                 maxwrk = 2*n + n*stdlib_ilaenv( 1, 'DGEHRD', ' ', n, 1, n, 0 )
                 minwrk = 3*n
                 call stdlib_${ri}$hseqr( 'S', jobvs, n, 1, n, a, lda, wr, wi, vs, ldvs,work, -1, &
                           ieval )
                 hswork = work( 1 )
                 if( .not.wantvs ) then
                    maxwrk = max( maxwrk, n + hswork )
                 else
                    maxwrk = max( maxwrk, 2*n + ( n - 1 )*stdlib_ilaenv( 1,'DORGHR', ' ', n, 1, n,&
                               -1 ) )
                    maxwrk = max( maxwrk, n + hswork )
                 end if
                 lwrk = maxwrk
                 if( .not.wantsn )lwrk = max( lwrk, n + ( n*n )/2 )
                 if( wantsv .or. wantsb )liwrk = ( n*n )/4
              end if
              iwork( 1 ) = liwrk
              work( 1 ) = lwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -16
              else if( liwork<1 .and. .not.lquery ) then
                 info = -18
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEESX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_${ri}$lascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (rworkspace: need n)
           ibal = 1
           call stdlib_${ri}$gebal( 'P', n, a, lda, ilo, ihi, work( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (rworkspace: need 3*n, prefer 2*n+n*nb)
           itau = n + ibal
           iwrk = n + itau
           call stdlib_${ri}$gehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvs ) then
              ! copy householder vectors to vs
              call stdlib_${ri}$lacpy( 'L', n, n, a, lda, vs, ldvs )
              ! generate orthogonal matrix in vs
              ! (rworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
              call stdlib_${ri}$orghr( n, ilo, ihi, vs, ldvs, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
           end if
           sdim = 0
           ! perform qr iteration, accumulating schur vectors in vs if desired
           ! (rworkspace: need n+1, prefer n+hswork (see comments) )
           iwrk = itau
           call stdlib_${ri}$hseqr( 'S', jobvs, n, ilo, ihi, a, lda, wr, wi, vs, ldvs,work( iwrk ), &
                     lwork-iwrk+1, ieval )
           if( ieval>0 )info = ieval
           ! sort eigenvalues if desired
           if( wantst .and. info==0 ) then
              if( scalea ) then
                 call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, n, 1, wr, n, ierr )
                 call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, n, 1, wi, n, ierr )
              end if
              do i = 1, n
                 bwork( i ) = select( wr( i ), wi( i ) )
              end do
              ! reorder eigenvalues, transform schur vectors, and compute
              ! reciprocal condition numbers
              ! (rworkspace: if sense is not 'n', need n+2*sdim*(n-sdim)
                           ! otherwise, need n )
              ! (iworkspace: if sense is 'v' or 'b', need sdim*(n-sdim)
                           ! otherwise, need 0 )
              call stdlib_${ri}$trsen( sense, jobvs, bwork, n, a, lda, vs, ldvs, wr, wi,sdim, rconde, &
                        rcondv, work( iwrk ), lwork-iwrk+1,iwork, liwork, icond )
              if( .not.wantsn )maxwrk = max( maxwrk, n+2*sdim*( n-sdim ) )
              if( icond==-15 ) then
                 ! not enough real workspace
                 info = -16
              else if( icond==-17 ) then
                 ! not enough integer workspace
                 info = -18
              else if( icond>0 ) then
                 ! stdlib_${ri}$trsen failed to reorder or to restore standard schur form
                 info = icond + n
              end if
           end if
           if( wantvs ) then
              ! undo balancing
              ! (rworkspace: need n)
              call stdlib_${ri}$gebak( 'P', 'R', n, ilo, ihi, work( ibal ), n, vs, ldvs,ierr )
           end if
           if( scalea ) then
              ! undo scaling for the schur form of a
              call stdlib_${ri}$lascl( 'H', 0, 0, cscale, anrm, n, n, a, lda, ierr )
              call stdlib_${ri}$copy( n, a, lda+1, wr, 1 )
              if( ( wantsv .or. wantsb ) .and. info==0 ) then
                 dum( 1 ) = rcondv
                 call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, 1, 1, dum, 1, ierr )
                 rcondv = dum( 1 )
              end if
              if( cscale==smlnum ) then
                 ! if scaling back towards underflow, adjust wi if an
                 ! offdiagonal element of a 2-by-2 block in the schur form
                 ! underflows.
                 if( ieval>0 ) then
                    i1 = ieval + 1
                    i2 = ihi - 1
                    call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wi, n,ierr )
                 else if( wantst ) then
                    i1 = 1
                    i2 = n - 1
                 else
                    i1 = ilo
                    i2 = ihi - 1
                 end if
                 inxt = i1 - 1
                 loop_20: do i = i1, i2
                    if( i<inxt )cycle loop_20
                    if( wi( i )==zero ) then
                       inxt = i + 1
                    else
                       if( a( i+1, i )==zero ) then
                          wi( i ) = zero
                          wi( i+1 ) = zero
                       else if( a( i+1, i )/=zero .and. a( i, i+1 )==zero ) then
                          wi( i ) = zero
                          wi( i+1 ) = zero
                          if( i>1 )call stdlib_${ri}$swap( i-1, a( 1, i ), 1, a( 1, i+1 ), 1 )
                          if( n>i+1 )call stdlib_${ri}$swap( n-i-1, a( i, i+2 ), lda,a( i+1, i+2 ), &
                                    lda )
                          if( wantvs ) then
                            call stdlib_${ri}$swap( n, vs( 1, i ), 1, vs( 1, i+1 ), 1 )
                          end if
                          a( i, i+1 ) = a( i+1, i )
                          a( i+1, i ) = zero
                       end if
                       inxt = i + 2
                    end if
                 end do loop_20
              end if
              call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, n-ieval, 1,wi( ieval+1 ), max( n-ieval,&
                         1 ), ierr )
           end if
           if( wantst .and. info==0 ) then
              ! check if reordering successful
              lastsl = .true.
              lst2sl = .true.
              sdim = 0
              ip = 0
              do i = 1, n
                 cursl = select( wr( i ), wi( i ) )
                 if( wi( i )==zero ) then
                    if( cursl )sdim = sdim + 1
                    ip = 0
                    if( cursl .and. .not.lastsl )info = n + 2
                 else
                    if( ip==1 ) then
                       ! last eigenvalue of conjugate pair
                       cursl = cursl .or. lastsl
                       lastsl = cursl
                       if( cursl )sdim = sdim + 2
                       ip = -1
                       if( cursl .and. .not.lst2sl )info = n + 2
                    else
                       ! first eigenvalue of conjugate pair
                       ip = 1
                    end if
                 end if
                 lst2sl = lastsl
                 lastsl = cursl
              end do
           end if
           work( 1 ) = maxwrk
           if( wantsv .or. wantsb ) then
              iwork( 1 ) = max( 1, sdim*( n-sdim ) )
           else
              iwork( 1 ) = 1
           end if
           return
     end subroutine stdlib_${ri}$geesx

#:endif
#:endfor

     module subroutine stdlib_cgeesx( jobvs, sort, select, sense, n, a, lda, sdim, w,vs, ldvs, rconde, &
     !! CGEESX computes for an N-by-N complex nonsymmetric matrix A, the
     !! eigenvalues, the Schur form T, and, optionally, the matrix of Schur
     !! vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).
     !! Optionally, it also orders the eigenvalues on the diagonal of the
     !! Schur form so that selected eigenvalues are at the top left;
     !! computes a reciprocal condition number for the average of the
     !! selected eigenvalues (RCONDE); and computes a reciprocal condition
     !! number for the right invariant subspace corresponding to the
     !! selected eigenvalues (RCONDV).  The leading columns of Z form an
     !! orthonormal basis for this invariant subspace.
     !! For further explanation of the reciprocal condition numbers RCONDE
     !! and RCONDV, see Section 4.10_sp of the LAPACK Users' Guide (where
     !! these quantities are called s and sep respectively).
     !! A complex matrix is in Schur form if it is upper triangular.
               rcondv, work, lwork, rwork,bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvs, sense, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldvs, lwork, n
           real(sp), intent(out) :: rconde, rcondv
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: vs(ldvs,*), w(*), work(*)
           ! Function Arguments 
           procedure(stdlib_select_c) :: select
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantsb, wantse, wantsn, wantst, wantsv, wantvs
           integer(ilp) :: hswork, i, ibal, icond, ierr, ieval, ihi, ilo, itau, iwrk, lwrk, &
                     maxwrk, minwrk
           real(sp) :: anrm, bignum, cscale, eps, smlnum
           ! Local Arrays 
           real(sp) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           wantvs = stdlib_lsame( jobvs, 'V' )
           wantst = stdlib_lsame( sort, 'S' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           lquery = ( lwork==-1 )
           if( ( .not.wantvs ) .and. ( .not.stdlib_lsame( jobvs, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -2
           else if( .not.( wantsn .or. wantse .or. wantsv .or. wantsb ) .or.( .not.wantst .and. &
                     .not.wantsn ) ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldvs<1 .or. ( wantvs .and. ldvs<n ) ) then
              info = -11
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of real workspace needed at that point in the
             ! code, as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to real
             ! workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_chseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.
             ! if sense = 'e', 'v' or 'b', then the amount of workspace needed
             ! depends on sdim, which is computed by the routine stdlib_ctrsen later
             ! in the code.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 lwrk = 1
              else
                 maxwrk = n + n*stdlib_ilaenv( 1, 'CGEHRD', ' ', n, 1, n, 0 )
                 minwrk = 2*n
                 call stdlib_chseqr( 'S', jobvs, n, 1, n, a, lda, w, vs, ldvs,work, -1, ieval )
                           
                 hswork = real( work( 1 ),KIND=sp)
                 if( .not.wantvs ) then
                    maxwrk = max( maxwrk, hswork )
                 else
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'CUNGHR',' ', n, 1, n, -&
                              1 ) )
                    maxwrk = max( maxwrk, hswork )
                 end if
                 lwrk = maxwrk
                 if( .not.wantsn )lwrk = max( lwrk, ( n*n )/2 )
              end if
              work( 1 ) = lwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -15
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEESX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_clascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (cworkspace: none)
           ! (rworkspace: need n)
           ibal = 1
           call stdlib_cgebal( 'P', n, a, lda, ilo, ihi, rwork( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (cworkspace: need 2*n, prefer n+n*nb)
           ! (rworkspace: none)
           itau = 1
           iwrk = n + itau
           call stdlib_cgehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvs ) then
              ! copy householder vectors to vs
              call stdlib_clacpy( 'L', n, n, a, lda, vs, ldvs )
              ! generate unitary matrix in vs
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_cunghr( n, ilo, ihi, vs, ldvs, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
           end if
           sdim = 0
           ! perform qr iteration, accumulating schur vectors in vs if desired
           ! (cworkspace: need 1, prefer hswork (see comments) )
           ! (rworkspace: none)
           iwrk = itau
           call stdlib_chseqr( 'S', jobvs, n, ilo, ihi, a, lda, w, vs, ldvs,work( iwrk ), lwork-&
                     iwrk+1, ieval )
           if( ieval>0 )info = ieval
           ! sort eigenvalues if desired
           if( wantst .and. info==0 ) then
              if( scalea )call stdlib_clascl( 'G', 0, 0, cscale, anrm, n, 1, w, n, ierr )
              do i = 1, n
                 bwork( i ) = select( w( i ) )
              end do
              ! reorder eigenvalues, transform schur vectors, and compute
              ! reciprocal condition numbers
              ! (cworkspace: if sense is not 'n', need 2*sdim*(n-sdim)
                           ! otherwise, need none )
              ! (rworkspace: none)
              call stdlib_ctrsen( sense, jobvs, bwork, n, a, lda, vs, ldvs, w, sdim,rconde, &
                        rcondv, work( iwrk ), lwork-iwrk+1,icond )
              if( .not.wantsn )maxwrk = max( maxwrk, 2*sdim*( n-sdim ) )
              if( icond==-14 ) then
                 ! not enough complex workspace
                 info = -15
              end if
           end if
           if( wantvs ) then
              ! undo balancing
              ! (cworkspace: none)
              ! (rworkspace: need n)
              call stdlib_cgebak( 'P', 'R', n, ilo, ihi, rwork( ibal ), n, vs, ldvs,ierr )
           end if
           if( scalea ) then
              ! undo scaling for the schur form of a
              call stdlib_clascl( 'U', 0, 0, cscale, anrm, n, n, a, lda, ierr )
              call stdlib_ccopy( n, a, lda+1, w, 1 )
              if( ( wantsv .or. wantsb ) .and. info==0 ) then
                 dum( 1 ) = rcondv
                 call stdlib_slascl( 'G', 0, 0, cscale, anrm, 1, 1, dum, 1, ierr )
                 rcondv = dum( 1 )
              end if
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_cgeesx

     module subroutine stdlib_zgeesx( jobvs, sort, select, sense, n, a, lda, sdim, w,vs, ldvs, rconde, &
     !! ZGEESX computes for an N-by-N complex nonsymmetric matrix A, the
     !! eigenvalues, the Schur form T, and, optionally, the matrix of Schur
     !! vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).
     !! Optionally, it also orders the eigenvalues on the diagonal of the
     !! Schur form so that selected eigenvalues are at the top left;
     !! computes a reciprocal condition number for the average of the
     !! selected eigenvalues (RCONDE); and computes a reciprocal condition
     !! number for the right invariant subspace corresponding to the
     !! selected eigenvalues (RCONDV).  The leading columns of Z form an
     !! orthonormal basis for this invariant subspace.
     !! For further explanation of the reciprocal condition numbers RCONDE
     !! and RCONDV, see Section 4.10_dp of the LAPACK Users' Guide (where
     !! these quantities are called s and sep respectively).
     !! A complex matrix is in Schur form if it is upper triangular.
               rcondv, work, lwork, rwork,bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvs, sense, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldvs, lwork, n
           real(dp), intent(out) :: rconde, rcondv
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: vs(ldvs,*), w(*), work(*)
           ! Function Arguments 
           procedure(stdlib_select_z) :: select
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantsb, wantse, wantsn, wantst, wantsv, wantvs
           integer(ilp) :: hswork, i, ibal, icond, ierr, ieval, ihi, ilo, itau, iwrk, lwrk, &
                     maxwrk, minwrk
           real(dp) :: anrm, bignum, cscale, eps, smlnum
           ! Local Arrays 
           real(dp) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           wantvs = stdlib_lsame( jobvs, 'V' )
           wantst = stdlib_lsame( sort, 'S' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           lquery = ( lwork==-1 )
           if( ( .not.wantvs ) .and. ( .not.stdlib_lsame( jobvs, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -2
           else if( .not.( wantsn .or. wantse .or. wantsv .or. wantsb ) .or.( .not.wantst .and. &
                     .not.wantsn ) ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldvs<1 .or. ( wantvs .and. ldvs<n ) ) then
              info = -11
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of real workspace needed at that point in the
             ! code, as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to real
             ! workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_zhseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.
             ! if sense = 'e', 'v' or 'b', then the amount of workspace needed
             ! depends on sdim, which is computed by the routine stdlib_ztrsen later
             ! in the code.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 lwrk = 1
              else
                 maxwrk = n + n*stdlib_ilaenv( 1, 'ZGEHRD', ' ', n, 1, n, 0 )
                 minwrk = 2*n
                 call stdlib_zhseqr( 'S', jobvs, n, 1, n, a, lda, w, vs, ldvs,work, -1, ieval )
                           
                 hswork = real( work( 1 ),KIND=dp)
                 if( .not.wantvs ) then
                    maxwrk = max( maxwrk, hswork )
                 else
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'ZUNGHR',' ', n, 1, n, -&
                              1 ) )
                    maxwrk = max( maxwrk, hswork )
                 end if
                 lwrk = maxwrk
                 if( .not.wantsn )lwrk = max( lwrk, ( n*n )/2 )
              end if
              work( 1 ) = lwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -15
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEESX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' )
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_zlange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_zlascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (cworkspace: none)
           ! (rworkspace: need n)
           ibal = 1
           call stdlib_zgebal( 'P', n, a, lda, ilo, ihi, rwork( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (cworkspace: need 2*n, prefer n+n*nb)
           ! (rworkspace: none)
           itau = 1
           iwrk = n + itau
           call stdlib_zgehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvs ) then
              ! copy householder vectors to vs
              call stdlib_zlacpy( 'L', n, n, a, lda, vs, ldvs )
              ! generate unitary matrix in vs
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_zunghr( n, ilo, ihi, vs, ldvs, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
           end if
           sdim = 0
           ! perform qr iteration, accumulating schur vectors in vs if desired
           ! (cworkspace: need 1, prefer hswork (see comments) )
           ! (rworkspace: none)
           iwrk = itau
           call stdlib_zhseqr( 'S', jobvs, n, ilo, ihi, a, lda, w, vs, ldvs,work( iwrk ), lwork-&
                     iwrk+1, ieval )
           if( ieval>0 )info = ieval
           ! sort eigenvalues if desired
           if( wantst .and. info==0 ) then
              if( scalea )call stdlib_zlascl( 'G', 0, 0, cscale, anrm, n, 1, w, n, ierr )
              do i = 1, n
                 bwork( i ) = select( w( i ) )
              end do
              ! reorder eigenvalues, transform schur vectors, and compute
              ! reciprocal condition numbers
              ! (cworkspace: if sense is not 'n', need 2*sdim*(n-sdim)
                           ! otherwise, need none )
              ! (rworkspace: none)
              call stdlib_ztrsen( sense, jobvs, bwork, n, a, lda, vs, ldvs, w, sdim,rconde, &
                        rcondv, work( iwrk ), lwork-iwrk+1,icond )
              if( .not.wantsn )maxwrk = max( maxwrk, 2*sdim*( n-sdim ) )
              if( icond==-14 ) then
                 ! not enough complex workspace
                 info = -15
              end if
           end if
           if( wantvs ) then
              ! undo balancing
              ! (cworkspace: none)
              ! (rworkspace: need n)
              call stdlib_zgebak( 'P', 'R', n, ilo, ihi, rwork( ibal ), n, vs, ldvs,ierr )
           end if
           if( scalea ) then
              ! undo scaling for the schur form of a
              call stdlib_zlascl( 'U', 0, 0, cscale, anrm, n, n, a, lda, ierr )
              call stdlib_zcopy( n, a, lda+1, w, 1 )
              if( ( wantsv .or. wantsb ) .and. info==0 ) then
                 dum( 1 ) = rcondv
                 call stdlib_dlascl( 'G', 0, 0, cscale, anrm, 1, 1, dum, 1, ierr )
                 rcondv = dum( 1 )
              end if
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_zgeesx

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$geesx( jobvs, sort, select, sense, n, a, lda, sdim, w,vs, ldvs, rconde, &
     !! ZGEESX: computes for an N-by-N complex nonsymmetric matrix A, the
     !! eigenvalues, the Schur form T, and, optionally, the matrix of Schur
     !! vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).
     !! Optionally, it also orders the eigenvalues on the diagonal of the
     !! Schur form so that selected eigenvalues are at the top left;
     !! computes a reciprocal condition number for the average of the
     !! selected eigenvalues (RCONDE); and computes a reciprocal condition
     !! number for the right invariant subspace corresponding to the
     !! selected eigenvalues (RCONDV).  The leading columns of Z form an
     !! orthonormal basis for this invariant subspace.
     !! For further explanation of the reciprocal condition numbers RCONDE
     !! and RCONDV, see Section 4.10_${ck}$ of the LAPACK Users' Guide (where
     !! these quantities are called s and sep respectively).
     !! A complex matrix is in Schur form if it is upper triangular.
               rcondv, work, lwork, rwork,bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvs, sense, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldvs, lwork, n
           real(${ck}$), intent(out) :: rconde, rcondv
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: vs(ldvs,*), w(*), work(*)
           ! Function Arguments 
           procedure(stdlib_select_${ci}$) :: select
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantsb, wantse, wantsn, wantst, wantsv, wantvs
           integer(ilp) :: hswork, i, ibal, icond, ierr, ieval, ihi, ilo, itau, iwrk, lwrk, &
                     maxwrk, minwrk
           real(${ck}$) :: anrm, bignum, cscale, eps, smlnum
           ! Local Arrays 
           real(${ck}$) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           wantvs = stdlib_lsame( jobvs, 'V' )
           wantst = stdlib_lsame( sort, 'S' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           lquery = ( lwork==-1 )
           if( ( .not.wantvs ) .and. ( .not.stdlib_lsame( jobvs, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -2
           else if( .not.( wantsn .or. wantse .or. wantsv .or. wantsb ) .or.( .not.wantst .and. &
                     .not.wantsn ) ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldvs<1 .or. ( wantvs .and. ldvs<n ) ) then
              info = -11
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of real workspace needed at that point in the
             ! code, as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to real
             ! workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_${ci}$hseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.
             ! if sense = 'e', 'v' or 'b', then the amount of workspace needed
             ! depends on sdim, which is computed by the routine stdlib_${ci}$trsen later
             ! in the code.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 lwrk = 1
              else
                 maxwrk = n + n*stdlib_ilaenv( 1, 'ZGEHRD', ' ', n, 1, n, 0 )
                 minwrk = 2*n
                 call stdlib_${ci}$hseqr( 'S', jobvs, n, 1, n, a, lda, w, vs, ldvs,work, -1, ieval )
                           
                 hswork = real( work( 1 ),KIND=${ck}$)
                 if( .not.wantvs ) then
                    maxwrk = max( maxwrk, hswork )
                 else
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'ZUNGHR',' ', n, 1, n, -&
                              1 ) )
                    maxwrk = max( maxwrk, hswork )
                 end if
                 lwrk = maxwrk
                 if( .not.wantsn )lwrk = max( lwrk, ( n*n )/2 )
              end if
              work( 1 ) = lwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -15
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEESX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_${c2ri(ci)}$lamch( 'P' )
           smlnum = stdlib_${c2ri(ci)}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${c2ri(ci)}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ci}$lange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_${ci}$lascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (cworkspace: none)
           ! (rworkspace: need n)
           ibal = 1
           call stdlib_${ci}$gebal( 'P', n, a, lda, ilo, ihi, rwork( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (cworkspace: need 2*n, prefer n+n*nb)
           ! (rworkspace: none)
           itau = 1
           iwrk = n + itau
           call stdlib_${ci}$gehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvs ) then
              ! copy householder vectors to vs
              call stdlib_${ci}$lacpy( 'L', n, n, a, lda, vs, ldvs )
              ! generate unitary matrix in vs
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_${ci}$unghr( n, ilo, ihi, vs, ldvs, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
           end if
           sdim = 0
           ! perform qr iteration, accumulating schur vectors in vs if desired
           ! (cworkspace: need 1, prefer hswork (see comments) )
           ! (rworkspace: none)
           iwrk = itau
           call stdlib_${ci}$hseqr( 'S', jobvs, n, ilo, ihi, a, lda, w, vs, ldvs,work( iwrk ), lwork-&
                     iwrk+1, ieval )
           if( ieval>0 )info = ieval
           ! sort eigenvalues if desired
           if( wantst .and. info==0 ) then
              if( scalea )call stdlib_${ci}$lascl( 'G', 0, 0, cscale, anrm, n, 1, w, n, ierr )
              do i = 1, n
                 bwork( i ) = select( w( i ) )
              end do
              ! reorder eigenvalues, transform schur vectors, and compute
              ! reciprocal condition numbers
              ! (cworkspace: if sense is not 'n', need 2*sdim*(n-sdim)
                           ! otherwise, need none )
              ! (rworkspace: none)
              call stdlib_${ci}$trsen( sense, jobvs, bwork, n, a, lda, vs, ldvs, w, sdim,rconde, &
                        rcondv, work( iwrk ), lwork-iwrk+1,icond )
              if( .not.wantsn )maxwrk = max( maxwrk, 2*sdim*( n-sdim ) )
              if( icond==-14 ) then
                 ! not enough complex workspace
                 info = -15
              end if
           end if
           if( wantvs ) then
              ! undo balancing
              ! (cworkspace: none)
              ! (rworkspace: need n)
              call stdlib_${ci}$gebak( 'P', 'R', n, ilo, ihi, rwork( ibal ), n, vs, ldvs,ierr )
           end if
           if( scalea ) then
              ! undo scaling for the schur form of a
              call stdlib_${ci}$lascl( 'U', 0, 0, cscale, anrm, n, n, a, lda, ierr )
              call stdlib_${ci}$copy( n, a, lda+1, w, 1 )
              if( ( wantsv .or. wantsb ) .and. info==0 ) then
                 dum( 1 ) = rcondv
                 call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, cscale, anrm, 1, 1, dum, 1, ierr )
                 rcondv = dum( 1 )
              end if
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_${ci}$geesx

#:endif
#:endfor



     module subroutine stdlib_shsein( side, eigsrc, initv, select, n, h, ldh, wr, wi,vl, ldvl, vr, ldvr, &
     !! SHSEIN uses inverse iteration to find specified right and/or left
     !! eigenvectors of a real upper Hessenberg matrix H.
     !! The right eigenvector x and the left eigenvector y of the matrix H
     !! corresponding to an eigenvalue w are defined by:
     !! H * x = w * x,     y**h * H = w * y**h
     !! where y**h denotes the conjugate transpose of the vector y.
               mm, m, work, ifaill,ifailr, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: eigsrc, initv, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldh, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(inout) :: select(*)
           integer(ilp), intent(out) :: ifaill(*), ifailr(*)
           real(sp), intent(in) :: h(ldh,*), wi(*)
           real(sp), intent(inout) :: vl(ldvl,*), vr(ldvr,*), wr(*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: bothv, fromqr, leftv, noinit, pair, rightv
           integer(ilp) :: i, iinfo, k, kl, kln, kr, ksi, ksr, ldwork
           real(sp) :: bignum, eps3, hnorm, smlnum, ulp, unfl, wki, wkr
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           bothv = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv = stdlib_lsame( side, 'L' ) .or. bothv
           fromqr = stdlib_lsame( eigsrc, 'Q' )
           noinit = stdlib_lsame( initv, 'N' )
           ! set m to the number of columns required to store the selected
           ! eigenvectors, and standardize the array select.
           m = 0
           pair = .false.
           do k = 1, n
              if( pair ) then
                 pair = .false.
                 select( k ) = .false.
              else
                 if( wi( k )==zero ) then
                    if( select( k ) )m = m + 1
                 else
                    pair = .true.
                    if( select( k ) .or. select( k+1 ) ) then
                       select( k ) = .true.
                       m = m + 2
                    end if
                 end if
              end if
           end do
           info = 0
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.fromqr .and. .not.stdlib_lsame( eigsrc, 'N' ) ) then
              info = -2
           else if( .not.noinit .and. .not.stdlib_lsame( initv, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( ldh<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -11
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -13
           else if( mm<m ) then
              info = -14
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SHSEIN', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! set machine-dependent constants.
           unfl = stdlib_slamch( 'SAFE MINIMUM' )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           bignum = ( one-ulp ) / smlnum
           ldwork = n + 1
           kl = 1
           kln = 0
           if( fromqr ) then
              kr = 0
           else
              kr = n
           end if
           ksr = 1
           loop_120: do k = 1, n
              if( select( k ) ) then
                 ! compute eigenvector(s) corresponding to w(k).
                 if( fromqr ) then
                    ! if affiliation of eigenvalues is known, check whether
                    ! the matrix splits.
                    ! determine kl and kr such that 1 <= kl <= k <= kr <= n
                    ! and h(kl,kl-1) and h(kr+1,kr) are zero (or kl = 1 or
                    ! kr = n).
                    ! then inverse iteration can be performed with the
                    ! submatrix h(kl:n,kl:n) for a left eigenvector, and with
                    ! the submatrix h(1:kr,1:kr) for a right eigenvector.
                    do i = k, kl + 1, -1
                       if( h( i, i-1 )==zero )go to 30
                    end do
                    30 continue
                    kl = i
                    if( k>kr ) then
                       do i = k, n - 1
                          if( h( i+1, i )==zero )go to 50
                       end do
                       50 continue
                       kr = i
                    end if
                 end if
                 if( kl/=kln ) then
                    kln = kl
                    ! compute infinity-norm of submatrix h(kl:kr,kl:kr) if it
                    ! has not ben computed before.
                    hnorm = stdlib_slanhs( 'I', kr-kl+1, h( kl, kl ), ldh, work )
                    if( stdlib_sisnan( hnorm ) ) then
                       info = -6
                       return
                    else if( hnorm>zero ) then
                       eps3 = hnorm*ulp
                    else
                       eps3 = smlnum
                    end if
                 end if
                 ! perturb eigenvalue if it is close to any previous
                 ! selected eigenvalues affiliated to the submatrix
                 ! h(kl:kr,kl:kr). close roots are modified by eps3.
                 wkr = wr( k )
                 wki = wi( k )
                 60 continue
                 do i = k - 1, kl, -1
                    if( select( i ) .and. abs( wr( i )-wkr )+abs( wi( i )-wki )<eps3 ) &
                              then
                       wkr = wkr + eps3
                       go to 60
                    end if
                 end do
                 wr( k ) = wkr
                 pair = wki/=zero
                 if( pair ) then
                    ksi = ksr + 1
                 else
                    ksi = ksr
                 end if
                 if( leftv ) then
                    ! compute left eigenvector.
                    call stdlib_slaein( .false., noinit, n-kl+1, h( kl, kl ), ldh,wkr, wki, vl( &
                    kl, ksr ), vl( kl, ksi ),work, ldwork, work( n*n+n+1 ), eps3, smlnum,bignum, &
                              iinfo )
                    if( iinfo>0 ) then
                       if( pair ) then
                          info = info + 2
                       else
                          info = info + 1
                       end if
                       ifaill( ksr ) = k
                       ifaill( ksi ) = k
                    else
                       ifaill( ksr ) = 0
                       ifaill( ksi ) = 0
                    end if
                    do i = 1, kl - 1
                       vl( i, ksr ) = zero
                    end do
                    if( pair ) then
                       do i = 1, kl - 1
                          vl( i, ksi ) = zero
                       end do
                    end if
                 end if
                 if( rightv ) then
                    ! compute right eigenvector.
                    call stdlib_slaein( .true., noinit, kr, h, ldh, wkr, wki,vr( 1, ksr ), vr( 1, &
                              ksi ), work, ldwork,work( n*n+n+1 ), eps3, smlnum, bignum,iinfo )
                    if( iinfo>0 ) then
                       if( pair ) then
                          info = info + 2
                       else
                          info = info + 1
                       end if
                       ifailr( ksr ) = k
                       ifailr( ksi ) = k
                    else
                       ifailr( ksr ) = 0
                       ifailr( ksi ) = 0
                    end if
                    do i = kr + 1, n
                       vr( i, ksr ) = zero
                    end do
                    if( pair ) then
                       do i = kr + 1, n
                          vr( i, ksi ) = zero
                       end do
                    end if
                 end if
                 if( pair ) then
                    ksr = ksr + 2
                 else
                    ksr = ksr + 1
                 end if
              end if
           end do loop_120
           return
     end subroutine stdlib_shsein

     module subroutine stdlib_dhsein( side, eigsrc, initv, select, n, h, ldh, wr, wi,vl, ldvl, vr, ldvr, &
     !! DHSEIN uses inverse iteration to find specified right and/or left
     !! eigenvectors of a real upper Hessenberg matrix H.
     !! The right eigenvector x and the left eigenvector y of the matrix H
     !! corresponding to an eigenvalue w are defined by:
     !! H * x = w * x,     y**h * H = w * y**h
     !! where y**h denotes the conjugate transpose of the vector y.
               mm, m, work, ifaill,ifailr, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: eigsrc, initv, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldh, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(inout) :: select(*)
           integer(ilp), intent(out) :: ifaill(*), ifailr(*)
           real(dp), intent(in) :: h(ldh,*), wi(*)
           real(dp), intent(inout) :: vl(ldvl,*), vr(ldvr,*), wr(*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: bothv, fromqr, leftv, noinit, pair, rightv
           integer(ilp) :: i, iinfo, k, kl, kln, kr, ksi, ksr, ldwork
           real(dp) :: bignum, eps3, hnorm, smlnum, ulp, unfl, wki, wkr
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           bothv = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv = stdlib_lsame( side, 'L' ) .or. bothv
           fromqr = stdlib_lsame( eigsrc, 'Q' )
           noinit = stdlib_lsame( initv, 'N' )
           ! set m to the number of columns required to store the selected
           ! eigenvectors, and standardize the array select.
           m = 0
           pair = .false.
           do k = 1, n
              if( pair ) then
                 pair = .false.
                 select( k ) = .false.
              else
                 if( wi( k )==zero ) then
                    if( select( k ) )m = m + 1
                 else
                    pair = .true.
                    if( select( k ) .or. select( k+1 ) ) then
                       select( k ) = .true.
                       m = m + 2
                    end if
                 end if
              end if
           end do
           info = 0
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.fromqr .and. .not.stdlib_lsame( eigsrc, 'N' ) ) then
              info = -2
           else if( .not.noinit .and. .not.stdlib_lsame( initv, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( ldh<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -11
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -13
           else if( mm<m ) then
              info = -14
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DHSEIN', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! set machine-dependent constants.
           unfl = stdlib_dlamch( 'SAFE MINIMUM' )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           bignum = ( one-ulp ) / smlnum
           ldwork = n + 1
           kl = 1
           kln = 0
           if( fromqr ) then
              kr = 0
           else
              kr = n
           end if
           ksr = 1
           loop_120: do k = 1, n
              if( select( k ) ) then
                 ! compute eigenvector(s) corresponding to w(k).
                 if( fromqr ) then
                    ! if affiliation of eigenvalues is known, check whether
                    ! the matrix splits.
                    ! determine kl and kr such that 1 <= kl <= k <= kr <= n
                    ! and h(kl,kl-1) and h(kr+1,kr) are zero (or kl = 1 or
                    ! kr = n).
                    ! then inverse iteration can be performed with the
                    ! submatrix h(kl:n,kl:n) for a left eigenvector, and with
                    ! the submatrix h(1:kr,1:kr) for a right eigenvector.
                    do i = k, kl + 1, -1
                       if( h( i, i-1 )==zero )go to 30
                    end do
                    30 continue
                    kl = i
                    if( k>kr ) then
                       do i = k, n - 1
                          if( h( i+1, i )==zero )go to 50
                       end do
                       50 continue
                       kr = i
                    end if
                 end if
                 if( kl/=kln ) then
                    kln = kl
                    ! compute infinity-norm of submatrix h(kl:kr,kl:kr) if it
                    ! has not ben computed before.
                    hnorm = stdlib_dlanhs( 'I', kr-kl+1, h( kl, kl ), ldh, work )
                    if( stdlib_disnan( hnorm ) ) then
                       info = -6
                       return
                    else if( hnorm>zero ) then
                       eps3 = hnorm*ulp
                    else
                       eps3 = smlnum
                    end if
                 end if
                 ! perturb eigenvalue if it is close to any previous
                 ! selected eigenvalues affiliated to the submatrix
                 ! h(kl:kr,kl:kr). close roots are modified by eps3.
                 wkr = wr( k )
                 wki = wi( k )
                 60 continue
                 do i = k - 1, kl, -1
                    if( select( i ) .and. abs( wr( i )-wkr )+abs( wi( i )-wki )<eps3 ) &
                              then
                       wkr = wkr + eps3
                       go to 60
                    end if
                 end do
                 wr( k ) = wkr
                 pair = wki/=zero
                 if( pair ) then
                    ksi = ksr + 1
                 else
                    ksi = ksr
                 end if
                 if( leftv ) then
                    ! compute left eigenvector.
                    call stdlib_dlaein( .false., noinit, n-kl+1, h( kl, kl ), ldh,wkr, wki, vl( &
                    kl, ksr ), vl( kl, ksi ),work, ldwork, work( n*n+n+1 ), eps3, smlnum,bignum, &
                              iinfo )
                    if( iinfo>0 ) then
                       if( pair ) then
                          info = info + 2
                       else
                          info = info + 1
                       end if
                       ifaill( ksr ) = k
                       ifaill( ksi ) = k
                    else
                       ifaill( ksr ) = 0
                       ifaill( ksi ) = 0
                    end if
                    do i = 1, kl - 1
                       vl( i, ksr ) = zero
                    end do
                    if( pair ) then
                       do i = 1, kl - 1
                          vl( i, ksi ) = zero
                       end do
                    end if
                 end if
                 if( rightv ) then
                    ! compute right eigenvector.
                    call stdlib_dlaein( .true., noinit, kr, h, ldh, wkr, wki,vr( 1, ksr ), vr( 1, &
                              ksi ), work, ldwork,work( n*n+n+1 ), eps3, smlnum, bignum,iinfo )
                    if( iinfo>0 ) then
                       if( pair ) then
                          info = info + 2
                       else
                          info = info + 1
                       end if
                       ifailr( ksr ) = k
                       ifailr( ksi ) = k
                    else
                       ifailr( ksr ) = 0
                       ifailr( ksi ) = 0
                    end if
                    do i = kr + 1, n
                       vr( i, ksr ) = zero
                    end do
                    if( pair ) then
                       do i = kr + 1, n
                          vr( i, ksi ) = zero
                       end do
                    end if
                 end if
                 if( pair ) then
                    ksr = ksr + 2
                 else
                    ksr = ksr + 1
                 end if
              end if
           end do loop_120
           return
     end subroutine stdlib_dhsein

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$hsein( side, eigsrc, initv, select, n, h, ldh, wr, wi,vl, ldvl, vr, ldvr, &
     !! DHSEIN: uses inverse iteration to find specified right and/or left
     !! eigenvectors of a real upper Hessenberg matrix H.
     !! The right eigenvector x and the left eigenvector y of the matrix H
     !! corresponding to an eigenvalue w are defined by:
     !! H * x = w * x,     y**h * H = w * y**h
     !! where y**h denotes the conjugate transpose of the vector y.
               mm, m, work, ifaill,ifailr, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: eigsrc, initv, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldh, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(inout) :: select(*)
           integer(ilp), intent(out) :: ifaill(*), ifailr(*)
           real(${rk}$), intent(in) :: h(ldh,*), wi(*)
           real(${rk}$), intent(inout) :: vl(ldvl,*), vr(ldvr,*), wr(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: bothv, fromqr, leftv, noinit, pair, rightv
           integer(ilp) :: i, iinfo, k, kl, kln, kr, ksi, ksr, ldwork
           real(${rk}$) :: bignum, eps3, hnorm, smlnum, ulp, unfl, wki, wkr
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           bothv = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv = stdlib_lsame( side, 'L' ) .or. bothv
           fromqr = stdlib_lsame( eigsrc, 'Q' )
           noinit = stdlib_lsame( initv, 'N' )
           ! set m to the number of columns required to store the selected
           ! eigenvectors, and standardize the array select.
           m = 0
           pair = .false.
           do k = 1, n
              if( pair ) then
                 pair = .false.
                 select( k ) = .false.
              else
                 if( wi( k )==zero ) then
                    if( select( k ) )m = m + 1
                 else
                    pair = .true.
                    if( select( k ) .or. select( k+1 ) ) then
                       select( k ) = .true.
                       m = m + 2
                    end if
                 end if
              end if
           end do
           info = 0
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.fromqr .and. .not.stdlib_lsame( eigsrc, 'N' ) ) then
              info = -2
           else if( .not.noinit .and. .not.stdlib_lsame( initv, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( ldh<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -11
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -13
           else if( mm<m ) then
              info = -14
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DHSEIN', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! set machine-dependent constants.
           unfl = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           ulp = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           bignum = ( one-ulp ) / smlnum
           ldwork = n + 1
           kl = 1
           kln = 0
           if( fromqr ) then
              kr = 0
           else
              kr = n
           end if
           ksr = 1
           loop_120: do k = 1, n
              if( select( k ) ) then
                 ! compute eigenvector(s) corresponding to w(k).
                 if( fromqr ) then
                    ! if affiliation of eigenvalues is known, check whether
                    ! the matrix splits.
                    ! determine kl and kr such that 1 <= kl <= k <= kr <= n
                    ! and h(kl,kl-1) and h(kr+1,kr) are zero (or kl = 1 or
                    ! kr = n).
                    ! then inverse iteration can be performed with the
                    ! submatrix h(kl:n,kl:n) for a left eigenvector, and with
                    ! the submatrix h(1:kr,1:kr) for a right eigenvector.
                    do i = k, kl + 1, -1
                       if( h( i, i-1 )==zero )go to 30
                    end do
                    30 continue
                    kl = i
                    if( k>kr ) then
                       do i = k, n - 1
                          if( h( i+1, i )==zero )go to 50
                       end do
                       50 continue
                       kr = i
                    end if
                 end if
                 if( kl/=kln ) then
                    kln = kl
                    ! compute infinity-norm of submatrix h(kl:kr,kl:kr) if it
                    ! has not ben computed before.
                    hnorm = stdlib_${ri}$lanhs( 'I', kr-kl+1, h( kl, kl ), ldh, work )
                    if( stdlib_${ri}$isnan( hnorm ) ) then
                       info = -6
                       return
                    else if( hnorm>zero ) then
                       eps3 = hnorm*ulp
                    else
                       eps3 = smlnum
                    end if
                 end if
                 ! perturb eigenvalue if it is close to any previous
                 ! selected eigenvalues affiliated to the submatrix
                 ! h(kl:kr,kl:kr). close roots are modified by eps3.
                 wkr = wr( k )
                 wki = wi( k )
                 60 continue
                 do i = k - 1, kl, -1
                    if( select( i ) .and. abs( wr( i )-wkr )+abs( wi( i )-wki )<eps3 ) &
                              then
                       wkr = wkr + eps3
                       go to 60
                    end if
                 end do
                 wr( k ) = wkr
                 pair = wki/=zero
                 if( pair ) then
                    ksi = ksr + 1
                 else
                    ksi = ksr
                 end if
                 if( leftv ) then
                    ! compute left eigenvector.
                    call stdlib_${ri}$laein( .false., noinit, n-kl+1, h( kl, kl ), ldh,wkr, wki, vl( &
                    kl, ksr ), vl( kl, ksi ),work, ldwork, work( n*n+n+1 ), eps3, smlnum,bignum, &
                              iinfo )
                    if( iinfo>0 ) then
                       if( pair ) then
                          info = info + 2
                       else
                          info = info + 1
                       end if
                       ifaill( ksr ) = k
                       ifaill( ksi ) = k
                    else
                       ifaill( ksr ) = 0
                       ifaill( ksi ) = 0
                    end if
                    do i = 1, kl - 1
                       vl( i, ksr ) = zero
                    end do
                    if( pair ) then
                       do i = 1, kl - 1
                          vl( i, ksi ) = zero
                       end do
                    end if
                 end if
                 if( rightv ) then
                    ! compute right eigenvector.
                    call stdlib_${ri}$laein( .true., noinit, kr, h, ldh, wkr, wki,vr( 1, ksr ), vr( 1, &
                              ksi ), work, ldwork,work( n*n+n+1 ), eps3, smlnum, bignum,iinfo )
                    if( iinfo>0 ) then
                       if( pair ) then
                          info = info + 2
                       else
                          info = info + 1
                       end if
                       ifailr( ksr ) = k
                       ifailr( ksi ) = k
                    else
                       ifailr( ksr ) = 0
                       ifailr( ksi ) = 0
                    end if
                    do i = kr + 1, n
                       vr( i, ksr ) = zero
                    end do
                    if( pair ) then
                       do i = kr + 1, n
                          vr( i, ksi ) = zero
                       end do
                    end if
                 end if
                 if( pair ) then
                    ksr = ksr + 2
                 else
                    ksr = ksr + 1
                 end if
              end if
           end do loop_120
           return
     end subroutine stdlib_${ri}$hsein

#:endif
#:endfor

     module subroutine stdlib_chsein( side, eigsrc, initv, select, n, h, ldh, w, vl,ldvl, vr, ldvr, mm, &
     !! CHSEIN uses inverse iteration to find specified right and/or left
     !! eigenvectors of a complex upper Hessenberg matrix H.
     !! The right eigenvector x and the left eigenvector y of the matrix H
     !! corresponding to an eigenvalue w are defined by:
     !! H * x = w * x,     y**h * H = w * y**h
     !! where y**h denotes the conjugate transpose of the vector y.
               m, work, rwork, ifaill,ifailr, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: eigsrc, initv, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldh, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: ifaill(*), ifailr(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(in) :: h(ldh,*)
           complex(sp), intent(inout) :: vl(ldvl,*), vr(ldvr,*), w(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: rzero = 0.0e+0_sp
           
           
           ! Local Scalars 
           logical(lk) :: bothv, fromqr, leftv, noinit, rightv
           integer(ilp) :: i, iinfo, k, kl, kln, kr, ks, ldwork
           real(sp) :: eps3, hnorm, smlnum, ulp, unfl
           complex(sp) :: cdum, wk
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters.
           bothv = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv = stdlib_lsame( side, 'L' ) .or. bothv
           fromqr = stdlib_lsame( eigsrc, 'Q' )
           noinit = stdlib_lsame( initv, 'N' )
           ! set m to the number of columns required to store the selected
           ! eigenvectors.
           m = 0
           do k = 1, n
              if( select( k ) )m = m + 1
           end do
           info = 0
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.fromqr .and. .not.stdlib_lsame( eigsrc, 'N' ) ) then
              info = -2
           else if( .not.noinit .and. .not.stdlib_lsame( initv, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( ldh<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -10
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -12
           else if( mm<m ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHSEIN', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! set machine-dependent constants.
           unfl = stdlib_slamch( 'SAFE MINIMUM' )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           ldwork = n
           kl = 1
           kln = 0
           if( fromqr ) then
              kr = 0
           else
              kr = n
           end if
           ks = 1
           loop_100: do k = 1, n
              if( select( k ) ) then
                 ! compute eigenvector(s) corresponding to w(k).
                 if( fromqr ) then
                    ! if affiliation of eigenvalues is known, check whether
                    ! the matrix splits.
                    ! determine kl and kr such that 1 <= kl <= k <= kr <= n
                    ! and h(kl,kl-1) and h(kr+1,kr) are czero (or kl = 1 or
                    ! kr = n).
                    ! then inverse iteration can be performed with the
                    ! submatrix h(kl:n,kl:n) for a left eigenvector, and with
                    ! the submatrix h(1:kr,1:kr) for a right eigenvector.
                    do i = k, kl + 1, -1
                       if( h( i, i-1 )==czero )go to 30
                    end do
                    30 continue
                    kl = i
                    if( k>kr ) then
                       do i = k, n - 1
                          if( h( i+1, i )==czero )go to 50
                       end do
                       50 continue
                       kr = i
                    end if
                 end if
                 if( kl/=kln ) then
                    kln = kl
                    ! compute infinity-norm of submatrix h(kl:kr,kl:kr) if it
                    ! has not ben computed before.
                    hnorm = stdlib_clanhs( 'I', kr-kl+1, h( kl, kl ), ldh, rwork )
                    if( stdlib_sisnan( hnorm ) ) then
                       info = -6
                       return
                    else if( (hnorm>rzero) ) then
                       eps3 = hnorm*ulp
                    else
                       eps3 = smlnum
                    end if
                 end if
                 ! perturb eigenvalue if it is close to any previous
                 ! selected eigenvalues affiliated to the submatrix
                 ! h(kl:kr,kl:kr). close roots are modified by eps3.
                 wk = w( k )
                 60 continue
                 do i = k - 1, kl, -1
                    if( select( i ) .and. cabs1( w( i )-wk )<eps3 ) then
                       wk = wk + eps3
                       go to 60
                    end if
                 end do
                 w( k ) = wk
                 if( leftv ) then
                    ! compute left eigenvector.
                    call stdlib_claein( .false., noinit, n-kl+1, h( kl, kl ), ldh,wk, vl( kl, ks )&
                              , work, ldwork, rwork, eps3,smlnum, iinfo )
                    if( iinfo>0 ) then
                       info = info + 1
                       ifaill( ks ) = k
                    else
                       ifaill( ks ) = 0
                    end if
                    do i = 1, kl - 1
                       vl( i, ks ) = czero
                    end do
                 end if
                 if( rightv ) then
                    ! compute right eigenvector.
                    call stdlib_claein( .true., noinit, kr, h, ldh, wk, vr( 1, ks ),work, ldwork, &
                              rwork, eps3, smlnum, iinfo )
                    if( iinfo>0 ) then
                       info = info + 1
                       ifailr( ks ) = k
                    else
                       ifailr( ks ) = 0
                    end if
                    do i = kr + 1, n
                       vr( i, ks ) = czero
                    end do
                 end if
                 ks = ks + 1
              end if
           end do loop_100
           return
     end subroutine stdlib_chsein

     module subroutine stdlib_zhsein( side, eigsrc, initv, select, n, h, ldh, w, vl,ldvl, vr, ldvr, mm, &
     !! ZHSEIN uses inverse iteration to find specified right and/or left
     !! eigenvectors of a complex upper Hessenberg matrix H.
     !! The right eigenvector x and the left eigenvector y of the matrix H
     !! corresponding to an eigenvalue w are defined by:
     !! H * x = w * x,     y**h * H = w * y**h
     !! where y**h denotes the conjugate transpose of the vector y.
               m, work, rwork, ifaill,ifailr, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: eigsrc, initv, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldh, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: ifaill(*), ifailr(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(in) :: h(ldh,*)
           complex(dp), intent(inout) :: vl(ldvl,*), vr(ldvr,*), w(*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: rzero = 0.0e+0_dp
           
           
           ! Local Scalars 
           logical(lk) :: bothv, fromqr, leftv, noinit, rightv
           integer(ilp) :: i, iinfo, k, kl, kln, kr, ks, ldwork
           real(dp) :: eps3, hnorm, smlnum, ulp, unfl
           complex(dp) :: cdum, wk
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters.
           bothv = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv = stdlib_lsame( side, 'L' ) .or. bothv
           fromqr = stdlib_lsame( eigsrc, 'Q' )
           noinit = stdlib_lsame( initv, 'N' )
           ! set m to the number of columns required to store the selected
           ! eigenvectors.
           m = 0
           do k = 1, n
              if( select( k ) )m = m + 1
           end do
           info = 0
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.fromqr .and. .not.stdlib_lsame( eigsrc, 'N' ) ) then
              info = -2
           else if( .not.noinit .and. .not.stdlib_lsame( initv, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( ldh<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -10
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -12
           else if( mm<m ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHSEIN', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! set machine-dependent constants.
           unfl = stdlib_dlamch( 'SAFE MINIMUM' )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           ldwork = n
           kl = 1
           kln = 0
           if( fromqr ) then
              kr = 0
           else
              kr = n
           end if
           ks = 1
           loop_100: do k = 1, n
              if( select( k ) ) then
                 ! compute eigenvector(s) corresponding to w(k).
                 if( fromqr ) then
                    ! if affiliation of eigenvalues is known, check whether
                    ! the matrix splits.
                    ! determine kl and kr such that 1 <= kl <= k <= kr <= n
                    ! and h(kl,kl-1) and h(kr+1,kr) are czero (or kl = 1 or
                    ! kr = n).
                    ! then inverse iteration can be performed with the
                    ! submatrix h(kl:n,kl:n) for a left eigenvector, and with
                    ! the submatrix h(1:kr,1:kr) for a right eigenvector.
                    do i = k, kl + 1, -1
                       if( h( i, i-1 )==czero )go to 30
                    end do
                    30 continue
                    kl = i
                    if( k>kr ) then
                       do i = k, n - 1
                          if( h( i+1, i )==czero )go to 50
                       end do
                       50 continue
                       kr = i
                    end if
                 end if
                 if( kl/=kln ) then
                    kln = kl
                    ! compute infinity-norm of submatrix h(kl:kr,kl:kr) if it
                    ! has not ben computed before.
                    hnorm = stdlib_zlanhs( 'I', kr-kl+1, h( kl, kl ), ldh, rwork )
                    if( stdlib_disnan( hnorm ) ) then
                       info = -6
                       return
                    else if( hnorm>rzero ) then
                       eps3 = hnorm*ulp
                    else
                       eps3 = smlnum
                    end if
                 end if
                 ! perturb eigenvalue if it is close to any previous
                 ! selected eigenvalues affiliated to the submatrix
                 ! h(kl:kr,kl:kr). close roots are modified by eps3.
                 wk = w( k )
                 60 continue
                 do i = k - 1, kl, -1
                    if( select( i ) .and. cabs1( w( i )-wk )<eps3 ) then
                       wk = wk + eps3
                       go to 60
                    end if
                 end do
                 w( k ) = wk
                 if( leftv ) then
                    ! compute left eigenvector.
                    call stdlib_zlaein( .false., noinit, n-kl+1, h( kl, kl ), ldh,wk, vl( kl, ks )&
                              , work, ldwork, rwork, eps3,smlnum, iinfo )
                    if( iinfo>0 ) then
                       info = info + 1
                       ifaill( ks ) = k
                    else
                       ifaill( ks ) = 0
                    end if
                    do i = 1, kl - 1
                       vl( i, ks ) = czero
                    end do
                 end if
                 if( rightv ) then
                    ! compute right eigenvector.
                    call stdlib_zlaein( .true., noinit, kr, h, ldh, wk, vr( 1, ks ),work, ldwork, &
                              rwork, eps3, smlnum, iinfo )
                    if( iinfo>0 ) then
                       info = info + 1
                       ifailr( ks ) = k
                    else
                       ifailr( ks ) = 0
                    end if
                    do i = kr + 1, n
                       vr( i, ks ) = czero
                    end do
                 end if
                 ks = ks + 1
              end if
           end do loop_100
           return
     end subroutine stdlib_zhsein

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$hsein( side, eigsrc, initv, select, n, h, ldh, w, vl,ldvl, vr, ldvr, mm, &
     !! ZHSEIN: uses inverse iteration to find specified right and/or left
     !! eigenvectors of a complex upper Hessenberg matrix H.
     !! The right eigenvector x and the left eigenvector y of the matrix H
     !! corresponding to an eigenvalue w are defined by:
     !! H * x = w * x,     y**h * H = w * y**h
     !! where y**h denotes the conjugate transpose of the vector y.
               m, work, rwork, ifaill,ifailr, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: eigsrc, initv, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldh, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: ifaill(*), ifailr(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(in) :: h(ldh,*)
           complex(${ck}$), intent(inout) :: vl(ldvl,*), vr(ldvr,*), w(*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: rzero = 0.0e+0_${ck}$
           
           
           ! Local Scalars 
           logical(lk) :: bothv, fromqr, leftv, noinit, rightv
           integer(ilp) :: i, iinfo, k, kl, kln, kr, ks, ldwork
           real(${ck}$) :: eps3, hnorm, smlnum, ulp, unfl
           complex(${ck}$) :: cdum, wk
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters.
           bothv = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv = stdlib_lsame( side, 'L' ) .or. bothv
           fromqr = stdlib_lsame( eigsrc, 'Q' )
           noinit = stdlib_lsame( initv, 'N' )
           ! set m to the number of columns required to store the selected
           ! eigenvectors.
           m = 0
           do k = 1, n
              if( select( k ) )m = m + 1
           end do
           info = 0
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.fromqr .and. .not.stdlib_lsame( eigsrc, 'N' ) ) then
              info = -2
           else if( .not.noinit .and. .not.stdlib_lsame( initv, 'U' ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( ldh<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -10
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -12
           else if( mm<m ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHSEIN', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! set machine-dependent constants.
           unfl = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           ulp = stdlib_${c2ri(ci)}$lamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           ldwork = n
           kl = 1
           kln = 0
           if( fromqr ) then
              kr = 0
           else
              kr = n
           end if
           ks = 1
           loop_100: do k = 1, n
              if( select( k ) ) then
                 ! compute eigenvector(s) corresponding to w(k).
                 if( fromqr ) then
                    ! if affiliation of eigenvalues is known, check whether
                    ! the matrix splits.
                    ! determine kl and kr such that 1 <= kl <= k <= kr <= n
                    ! and h(kl,kl-1) and h(kr+1,kr) are czero (or kl = 1 or
                    ! kr = n).
                    ! then inverse iteration can be performed with the
                    ! submatrix h(kl:n,kl:n) for a left eigenvector, and with
                    ! the submatrix h(1:kr,1:kr) for a right eigenvector.
                    do i = k, kl + 1, -1
                       if( h( i, i-1 )==czero )go to 30
                    end do
                    30 continue
                    kl = i
                    if( k>kr ) then
                       do i = k, n - 1
                          if( h( i+1, i )==czero )go to 50
                       end do
                       50 continue
                       kr = i
                    end if
                 end if
                 if( kl/=kln ) then
                    kln = kl
                    ! compute infinity-norm of submatrix h(kl:kr,kl:kr) if it
                    ! has not ben computed before.
                    hnorm = stdlib_${ci}$lanhs( 'I', kr-kl+1, h( kl, kl ), ldh, rwork )
                    if( stdlib_${c2ri(ci)}$isnan( hnorm ) ) then
                       info = -6
                       return
                    else if( hnorm>rzero ) then
                       eps3 = hnorm*ulp
                    else
                       eps3 = smlnum
                    end if
                 end if
                 ! perturb eigenvalue if it is close to any previous
                 ! selected eigenvalues affiliated to the submatrix
                 ! h(kl:kr,kl:kr). close roots are modified by eps3.
                 wk = w( k )
                 60 continue
                 do i = k - 1, kl, -1
                    if( select( i ) .and. cabs1( w( i )-wk )<eps3 ) then
                       wk = wk + eps3
                       go to 60
                    end if
                 end do
                 w( k ) = wk
                 if( leftv ) then
                    ! compute left eigenvector.
                    call stdlib_${ci}$laein( .false., noinit, n-kl+1, h( kl, kl ), ldh,wk, vl( kl, ks )&
                              , work, ldwork, rwork, eps3,smlnum, iinfo )
                    if( iinfo>0 ) then
                       info = info + 1
                       ifaill( ks ) = k
                    else
                       ifaill( ks ) = 0
                    end if
                    do i = 1, kl - 1
                       vl( i, ks ) = czero
                    end do
                 end if
                 if( rightv ) then
                    ! compute right eigenvector.
                    call stdlib_${ci}$laein( .true., noinit, kr, h, ldh, wk, vr( 1, ks ),work, ldwork, &
                              rwork, eps3, smlnum, iinfo )
                    if( iinfo>0 ) then
                       info = info + 1
                       ifailr( ks ) = k
                    else
                       ifailr( ks ) = 0
                    end if
                    do i = kr + 1, n
                       vr( i, ks ) = czero
                    end do
                 end if
                 ks = ks + 1
              end if
           end do loop_100
           return
     end subroutine stdlib_${ci}$hsein

#:endif
#:endfor



     module pure subroutine stdlib_sggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, info )
     !! SGGBAL balances a pair of general real matrices (A,B).  This
     !! involves, first, permuting A and B by similarity transformations to
     !! isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
     !! elements on the diagonal; and second, applying a diagonal similarity
     !! transformation to rows and columns ILO to IHI to make the rows
     !! and columns as close in norm as possible. Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrices, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors in the
     !! generalized eigenvalue problem A*x = lambda*B*x.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldb, n
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: lscale(*), rscale(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sclfac = 1.0e+1_sp
           
           
           ! Local Scalars 
           integer(ilp) :: i, icab, iflow, ip1, ir, irab, it, j, jc, jp1, k, kount, l, lcab, lm1, &
                     lrab, lsfmax, lsfmin, m, nr, nrp2
           real(sp) :: alpha, basl, beta, cab, cmax, coef, coef2, coef5, cor, ew, ewc, gamma, &
                     pgamma, rab, sfmax, sfmin, sum, t, ta, tb, tc
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGGBAL', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              ilo = 1
              ihi = n
              return
           end if
           if( n==1 ) then
              ilo = 1
              ihi = n
              lscale( 1 ) = one
              rscale( 1 ) = one
              return
           end if
           if( stdlib_lsame( job, 'N' ) ) then
              ilo = 1
              ihi = n
              do i = 1, n
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           k = 1
           l = n
           if( stdlib_lsame( job, 'S' ) )go to 190
           go to 30
           ! permute the matrices a and b to isolate the eigenvalues.
           ! find row with one nonzero in columns 1 through l
           20 continue
           l = lm1
           if( l/=1 )go to 30
           rscale( 1 ) = one
           lscale( 1 ) = one
           go to 190
           30 continue
           lm1 = l - 1
           loop_80: do i = l, 1, -1
              do j = 1, lm1
                 jp1 = j + 1
                 if( a( i, j )/=zero .or. b( i, j )/=zero )go to 50
              end do
              j = l
              go to 70
              50 continue
              do j = jp1, l
                 if( a( i, j )/=zero .or. b( i, j )/=zero )cycle loop_80
              end do
              j = jp1 - 1
              70 continue
              m = l
              iflow = 1
              go to 160
           end do loop_80
           go to 100
           ! find column with one nonzero in rows k through n
           90 continue
           k = k + 1
           100 continue
           loop_150: do j = k, l
              do i = k, lm1
                 ip1 = i + 1
                 if( a( i, j )/=zero .or. b( i, j )/=zero )go to 120
              end do
              i = l
              go to 140
              120 continue
              do i = ip1, l
                 if( a( i, j )/=zero .or. b( i, j )/=zero )cycle loop_150
              end do
              i = ip1 - 1
              140 continue
              m = k
              iflow = 2
              go to 160
           end do loop_150
           go to 190
           ! permute rows m and i
           160 continue
           lscale( m ) = i
           if( i==m )go to 170
           call stdlib_sswap( n-k+1, a( i, k ), lda, a( m, k ), lda )
           call stdlib_sswap( n-k+1, b( i, k ), ldb, b( m, k ), ldb )
           ! permute columns m and j
           170 continue
           rscale( m ) = j
           if( j==m )go to 180
           call stdlib_sswap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_sswap( l, b( 1, j ), 1, b( 1, m ), 1 )
           180 continue
           go to ( 20, 90 )iflow
           190 continue
           ilo = k
           ihi = l
           if( stdlib_lsame( job, 'P' ) ) then
              do i = ilo, ihi
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           if( ilo==ihi )return
           ! balance the submatrix in rows ilo to ihi.
           nr = ihi - ilo + 1
           do i = ilo, ihi
              rscale( i ) = zero
              lscale( i ) = zero
              work( i ) = zero
              work( i+n ) = zero
              work( i+2*n ) = zero
              work( i+3*n ) = zero
              work( i+4*n ) = zero
              work( i+5*n ) = zero
           end do
           ! compute right side vector in resulting linear equations
           basl = log10( sclfac )
           do i = ilo, ihi
              do j = ilo, ihi
                 tb = b( i, j )
                 ta = a( i, j )
                 if( ta==zero )go to 210
                 ta = log10( abs( ta ) ) / basl
                 210 continue
                 if( tb==zero )go to 220
                 tb = log10( abs( tb ) ) / basl
                 220 continue
                 work( i+4*n ) = work( i+4*n ) - ta - tb
                 work( j+5*n ) = work( j+5*n ) - ta - tb
              end do
           end do
           coef = one / real( 2*nr,KIND=sp)
           coef2 = coef*coef
           coef5 = half*coef2
           nrp2 = nr + 2
           beta = zero
           it = 1
           ! start generalized conjugate gradient iteration
           250 continue
           gamma = stdlib_sdot( nr, work( ilo+4*n ), 1, work( ilo+4*n ), 1 ) +stdlib_sdot( nr, &
                     work( ilo+5*n ), 1, work( ilo+5*n ), 1 )
           ew = zero
           ewc = zero
           do i = ilo, ihi
              ew = ew + work( i+4*n )
              ewc = ewc + work( i+5*n )
           end do
           gamma = coef*gamma - coef2*( ew**2+ewc**2 ) - coef5*( ew-ewc )**2
           if( gamma==zero )go to 350
           if( it/=1 )beta = gamma / pgamma
           t = coef5*( ewc-three*ew )
           tc = coef5*( ew-three*ewc )
           call stdlib_sscal( nr, beta, work( ilo ), 1 )
           call stdlib_sscal( nr, beta, work( ilo+n ), 1 )
           call stdlib_saxpy( nr, coef, work( ilo+4*n ), 1, work( ilo+n ), 1 )
           call stdlib_saxpy( nr, coef, work( ilo+5*n ), 1, work( ilo ), 1 )
           do i = ilo, ihi
              work( i ) = work( i ) + tc
              work( i+n ) = work( i+n ) + t
           end do
           ! apply matrix to vector
           do i = ilo, ihi
              kount = 0
              sum = zero
              loop_290: do j = ilo, ihi
                 if( a( i, j )==zero )go to 280
                 kount = kount + 1
                 sum = sum + work( j )
                 280 continue
                 if( b( i, j )==zero )cycle loop_290
                 kount = kount + 1
                 sum = sum + work( j )
              end do loop_290
              work( i+2*n ) = real( kount,KIND=sp)*work( i+n ) + sum
           end do
           do j = ilo, ihi
              kount = 0
              sum = zero
              loop_320: do i = ilo, ihi
                 if( a( i, j )==zero )go to 310
                 kount = kount + 1
                 sum = sum + work( i+n )
                 310 continue
                 if( b( i, j )==zero )cycle loop_320
                 kount = kount + 1
                 sum = sum + work( i+n )
              end do loop_320
              work( j+3*n ) = real( kount,KIND=sp)*work( j ) + sum
           end do
           sum = stdlib_sdot( nr, work( ilo+n ), 1, work( ilo+2*n ), 1 ) +stdlib_sdot( nr, work( &
                     ilo ), 1, work( ilo+3*n ), 1 )
           alpha = gamma / sum
           ! determine correction to current iteration
           cmax = zero
           do i = ilo, ihi
              cor = alpha*work( i+n )
              if( abs( cor )>cmax )cmax = abs( cor )
              lscale( i ) = lscale( i ) + cor
              cor = alpha*work( i )
              if( abs( cor )>cmax )cmax = abs( cor )
              rscale( i ) = rscale( i ) + cor
           end do
           if( cmax<half )go to 350
           call stdlib_saxpy( nr, -alpha, work( ilo+2*n ), 1, work( ilo+4*n ), 1 )
           call stdlib_saxpy( nr, -alpha, work( ilo+3*n ), 1, work( ilo+5*n ), 1 )
           pgamma = gamma
           it = it + 1
           if( it<=nrp2 )go to 250
           ! end generalized conjugate gradient iteration
           350 continue
           sfmin = stdlib_slamch( 'S' )
           sfmax = one / sfmin
           lsfmin = int( log10( sfmin ) / basl+one,KIND=ilp)
           lsfmax = int( log10( sfmax ) / basl,KIND=ilp)
           do i = ilo, ihi
              irab = stdlib_isamax( n-ilo+1, a( i, ilo ), lda )
              rab = abs( a( i, irab+ilo-1 ) )
              irab = stdlib_isamax( n-ilo+1, b( i, ilo ), ldb )
              rab = max( rab, abs( b( i, irab+ilo-1 ) ) )
              lrab = int( log10( rab+sfmin ) / basl+one,KIND=ilp)
              ir = lscale( i ) + sign( half, lscale( i ) )
              ir = min( max( ir, lsfmin ), lsfmax, lsfmax-lrab )
              lscale( i ) = sclfac**ir
              icab = stdlib_isamax( ihi, a( 1, i ), 1 )
              cab = abs( a( icab, i ) )
              icab = stdlib_isamax( ihi, b( 1, i ), 1 )
              cab = max( cab, abs( b( icab, i ) ) )
              lcab = int( log10( cab+sfmin ) / basl+one,KIND=ilp)
              jc = rscale( i ) + sign( half, rscale( i ) )
              jc = min( max( jc, lsfmin ), lsfmax, lsfmax-lcab )
              rscale( i ) = sclfac**jc
           end do
           ! row scaling of matrices a and b
           do i = ilo, ihi
              call stdlib_sscal( n-ilo+1, lscale( i ), a( i, ilo ), lda )
              call stdlib_sscal( n-ilo+1, lscale( i ), b( i, ilo ), ldb )
           end do
           ! column scaling of matrices a and b
           do j = ilo, ihi
              call stdlib_sscal( ihi, rscale( j ), a( 1, j ), 1 )
              call stdlib_sscal( ihi, rscale( j ), b( 1, j ), 1 )
           end do
           return
     end subroutine stdlib_sggbal

     module pure subroutine stdlib_dggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, info )
     !! DGGBAL balances a pair of general real matrices (A,B).  This
     !! involves, first, permuting A and B by similarity transformations to
     !! isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
     !! elements on the diagonal; and second, applying a diagonal similarity
     !! transformation to rows and columns ILO to IHI to make the rows
     !! and columns as close in norm as possible. Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrices, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors in the
     !! generalized eigenvalue problem A*x = lambda*B*x.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldb, n
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: lscale(*), rscale(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sclfac = 1.0e+1_dp
           
           
           ! Local Scalars 
           integer(ilp) :: i, icab, iflow, ip1, ir, irab, it, j, jc, jp1, k, kount, l, lcab, lm1, &
                     lrab, lsfmax, lsfmin, m, nr, nrp2
           real(dp) :: alpha, basl, beta, cab, cmax, coef, coef2, coef5, cor, ew, ewc, gamma, &
                     pgamma, rab, sfmax, sfmin, sum, t, ta, tb, tc
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGBAL', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              ilo = 1
              ihi = n
              return
           end if
           if( n==1 ) then
              ilo = 1
              ihi = n
              lscale( 1 ) = one
              rscale( 1 ) = one
              return
           end if
           if( stdlib_lsame( job, 'N' ) ) then
              ilo = 1
              ihi = n
              do i = 1, n
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           k = 1
           l = n
           if( stdlib_lsame( job, 'S' ) )go to 190
           go to 30
           ! permute the matrices a and b to isolate the eigenvalues.
           ! find row with one nonzero in columns 1 through l
           20 continue
           l = lm1
           if( l/=1 )go to 30
           rscale( 1 ) = one
           lscale( 1 ) = one
           go to 190
           30 continue
           lm1 = l - 1
           loop_80: do i = l, 1, -1
              do j = 1, lm1
                 jp1 = j + 1
                 if( a( i, j )/=zero .or. b( i, j )/=zero )go to 50
              end do
              j = l
              go to 70
              50 continue
              do j = jp1, l
                 if( a( i, j )/=zero .or. b( i, j )/=zero )cycle loop_80
              end do
              j = jp1 - 1
              70 continue
              m = l
              iflow = 1
              go to 160
           end do loop_80
           go to 100
           ! find column with one nonzero in rows k through n
           90 continue
           k = k + 1
           100 continue
           loop_150: do j = k, l
              do i = k, lm1
                 ip1 = i + 1
                 if( a( i, j )/=zero .or. b( i, j )/=zero )go to 120
              end do
              i = l
              go to 140
              120 continue
              do i = ip1, l
                 if( a( i, j )/=zero .or. b( i, j )/=zero )cycle loop_150
              end do
              i = ip1 - 1
              140 continue
              m = k
              iflow = 2
              go to 160
           end do loop_150
           go to 190
           ! permute rows m and i
           160 continue
           lscale( m ) = i
           if( i==m )go to 170
           call stdlib_dswap( n-k+1, a( i, k ), lda, a( m, k ), lda )
           call stdlib_dswap( n-k+1, b( i, k ), ldb, b( m, k ), ldb )
           ! permute columns m and j
           170 continue
           rscale( m ) = j
           if( j==m )go to 180
           call stdlib_dswap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_dswap( l, b( 1, j ), 1, b( 1, m ), 1 )
           180 continue
           go to ( 20, 90 )iflow
           190 continue
           ilo = k
           ihi = l
           if( stdlib_lsame( job, 'P' ) ) then
              do i = ilo, ihi
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           if( ilo==ihi )return
           ! balance the submatrix in rows ilo to ihi.
           nr = ihi - ilo + 1
           do i = ilo, ihi
              rscale( i ) = zero
              lscale( i ) = zero
              work( i ) = zero
              work( i+n ) = zero
              work( i+2*n ) = zero
              work( i+3*n ) = zero
              work( i+4*n ) = zero
              work( i+5*n ) = zero
           end do
           ! compute right side vector in resulting linear equations
           basl = log10( sclfac )
           do i = ilo, ihi
              do j = ilo, ihi
                 tb = b( i, j )
                 ta = a( i, j )
                 if( ta==zero )go to 210
                 ta = log10( abs( ta ) ) / basl
                 210 continue
                 if( tb==zero )go to 220
                 tb = log10( abs( tb ) ) / basl
                 220 continue
                 work( i+4*n ) = work( i+4*n ) - ta - tb
                 work( j+5*n ) = work( j+5*n ) - ta - tb
              end do
           end do
           coef = one / real( 2*nr,KIND=dp)
           coef2 = coef*coef
           coef5 = half*coef2
           nrp2 = nr + 2
           beta = zero
           it = 1
           ! start generalized conjugate gradient iteration
           250 continue
           gamma = stdlib_ddot( nr, work( ilo+4*n ), 1, work( ilo+4*n ), 1 ) +stdlib_ddot( nr, &
                     work( ilo+5*n ), 1, work( ilo+5*n ), 1 )
           ew = zero
           ewc = zero
           do i = ilo, ihi
              ew = ew + work( i+4*n )
              ewc = ewc + work( i+5*n )
           end do
           gamma = coef*gamma - coef2*( ew**2+ewc**2 ) - coef5*( ew-ewc )**2
           if( gamma==zero )go to 350
           if( it/=1 )beta = gamma / pgamma
           t = coef5*( ewc-three*ew )
           tc = coef5*( ew-three*ewc )
           call stdlib_dscal( nr, beta, work( ilo ), 1 )
           call stdlib_dscal( nr, beta, work( ilo+n ), 1 )
           call stdlib_daxpy( nr, coef, work( ilo+4*n ), 1, work( ilo+n ), 1 )
           call stdlib_daxpy( nr, coef, work( ilo+5*n ), 1, work( ilo ), 1 )
           do i = ilo, ihi
              work( i ) = work( i ) + tc
              work( i+n ) = work( i+n ) + t
           end do
           ! apply matrix to vector
           do i = ilo, ihi
              kount = 0
              sum = zero
              loop_290: do j = ilo, ihi
                 if( a( i, j )==zero )go to 280
                 kount = kount + 1
                 sum = sum + work( j )
                 280 continue
                 if( b( i, j )==zero )cycle loop_290
                 kount = kount + 1
                 sum = sum + work( j )
              end do loop_290
              work( i+2*n ) = real( kount,KIND=dp)*work( i+n ) + sum
           end do
           do j = ilo, ihi
              kount = 0
              sum = zero
              loop_320: do i = ilo, ihi
                 if( a( i, j )==zero )go to 310
                 kount = kount + 1
                 sum = sum + work( i+n )
                 310 continue
                 if( b( i, j )==zero )cycle loop_320
                 kount = kount + 1
                 sum = sum + work( i+n )
              end do loop_320
              work( j+3*n ) = real( kount,KIND=dp)*work( j ) + sum
           end do
           sum = stdlib_ddot( nr, work( ilo+n ), 1, work( ilo+2*n ), 1 ) +stdlib_ddot( nr, work( &
                     ilo ), 1, work( ilo+3*n ), 1 )
           alpha = gamma / sum
           ! determine correction to current iteration
           cmax = zero
           do i = ilo, ihi
              cor = alpha*work( i+n )
              if( abs( cor )>cmax )cmax = abs( cor )
              lscale( i ) = lscale( i ) + cor
              cor = alpha*work( i )
              if( abs( cor )>cmax )cmax = abs( cor )
              rscale( i ) = rscale( i ) + cor
           end do
           if( cmax<half )go to 350
           call stdlib_daxpy( nr, -alpha, work( ilo+2*n ), 1, work( ilo+4*n ), 1 )
           call stdlib_daxpy( nr, -alpha, work( ilo+3*n ), 1, work( ilo+5*n ), 1 )
           pgamma = gamma
           it = it + 1
           if( it<=nrp2 )go to 250
           ! end generalized conjugate gradient iteration
           350 continue
           sfmin = stdlib_dlamch( 'S' )
           sfmax = one / sfmin
           lsfmin = int( log10( sfmin ) / basl+one,KIND=ilp)
           lsfmax = int( log10( sfmax ) / basl,KIND=ilp)
           do i = ilo, ihi
              irab = stdlib_idamax( n-ilo+1, a( i, ilo ), lda )
              rab = abs( a( i, irab+ilo-1 ) )
              irab = stdlib_idamax( n-ilo+1, b( i, ilo ), ldb )
              rab = max( rab, abs( b( i, irab+ilo-1 ) ) )
              lrab = int( log10( rab+sfmin ) / basl+one,KIND=ilp)
              ir = int(lscale( i ) + sign( half, lscale( i ) ),KIND=ilp)
              ir = min( max( ir, lsfmin ), lsfmax, lsfmax-lrab )
              lscale( i ) = sclfac**ir
              icab = stdlib_idamax( ihi, a( 1, i ), 1 )
              cab = abs( a( icab, i ) )
              icab = stdlib_idamax( ihi, b( 1, i ), 1 )
              cab = max( cab, abs( b( icab, i ) ) )
              lcab = int( log10( cab+sfmin ) / basl+one,KIND=ilp)
              jc = int(rscale( i ) + sign( half, rscale( i ) ),KIND=ilp)
              jc = min( max( jc, lsfmin ), lsfmax, lsfmax-lcab )
              rscale( i ) = sclfac**jc
           end do
           ! row scaling of matrices a and b
           do i = ilo, ihi
              call stdlib_dscal( n-ilo+1, lscale( i ), a( i, ilo ), lda )
              call stdlib_dscal( n-ilo+1, lscale( i ), b( i, ilo ), ldb )
           end do
           ! column scaling of matrices a and b
           do j = ilo, ihi
              call stdlib_dscal( ihi, rscale( j ), a( 1, j ), 1 )
              call stdlib_dscal( ihi, rscale( j ), b( 1, j ), 1 )
           end do
           return
     end subroutine stdlib_dggbal

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$ggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, info )
     !! DGGBAL: balances a pair of general real matrices (A,B).  This
     !! involves, first, permuting A and B by similarity transformations to
     !! isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
     !! elements on the diagonal; and second, applying a diagonal similarity
     !! transformation to rows and columns ILO to IHI to make the rows
     !! and columns as close in norm as possible. Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrices, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors in the
     !! generalized eigenvalue problem A*x = lambda*B*x.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldb, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: lscale(*), rscale(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: sclfac = 1.0e+1_${rk}$
           
           
           ! Local Scalars 
           integer(ilp) :: i, icab, iflow, ip1, ir, irab, it, j, jc, jp1, k, kount, l, lcab, lm1, &
                     lrab, lsfmax, lsfmin, m, nr, nrp2
           real(${rk}$) :: alpha, basl, beta, cab, cmax, coef, coef2, coef5, cor, ew, ewc, gamma, &
                     pgamma, rab, sfmax, sfmin, sum, t, ta, tb, tc
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGBAL', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              ilo = 1
              ihi = n
              return
           end if
           if( n==1 ) then
              ilo = 1
              ihi = n
              lscale( 1 ) = one
              rscale( 1 ) = one
              return
           end if
           if( stdlib_lsame( job, 'N' ) ) then
              ilo = 1
              ihi = n
              do i = 1, n
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           k = 1
           l = n
           if( stdlib_lsame( job, 'S' ) )go to 190
           go to 30
           ! permute the matrices a and b to isolate the eigenvalues.
           ! find row with one nonzero in columns 1 through l
           20 continue
           l = lm1
           if( l/=1 )go to 30
           rscale( 1 ) = one
           lscale( 1 ) = one
           go to 190
           30 continue
           lm1 = l - 1
           loop_80: do i = l, 1, -1
              do j = 1, lm1
                 jp1 = j + 1
                 if( a( i, j )/=zero .or. b( i, j )/=zero )go to 50
              end do
              j = l
              go to 70
              50 continue
              do j = jp1, l
                 if( a( i, j )/=zero .or. b( i, j )/=zero )cycle loop_80
              end do
              j = jp1 - 1
              70 continue
              m = l
              iflow = 1
              go to 160
           end do loop_80
           go to 100
           ! find column with one nonzero in rows k through n
           90 continue
           k = k + 1
           100 continue
           loop_150: do j = k, l
              do i = k, lm1
                 ip1 = i + 1
                 if( a( i, j )/=zero .or. b( i, j )/=zero )go to 120
              end do
              i = l
              go to 140
              120 continue
              do i = ip1, l
                 if( a( i, j )/=zero .or. b( i, j )/=zero )cycle loop_150
              end do
              i = ip1 - 1
              140 continue
              m = k
              iflow = 2
              go to 160
           end do loop_150
           go to 190
           ! permute rows m and i
           160 continue
           lscale( m ) = i
           if( i==m )go to 170
           call stdlib_${ri}$swap( n-k+1, a( i, k ), lda, a( m, k ), lda )
           call stdlib_${ri}$swap( n-k+1, b( i, k ), ldb, b( m, k ), ldb )
           ! permute columns m and j
           170 continue
           rscale( m ) = j
           if( j==m )go to 180
           call stdlib_${ri}$swap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_${ri}$swap( l, b( 1, j ), 1, b( 1, m ), 1 )
           180 continue
           go to ( 20, 90 )iflow
           190 continue
           ilo = k
           ihi = l
           if( stdlib_lsame( job, 'P' ) ) then
              do i = ilo, ihi
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           if( ilo==ihi )return
           ! balance the submatrix in rows ilo to ihi.
           nr = ihi - ilo + 1
           do i = ilo, ihi
              rscale( i ) = zero
              lscale( i ) = zero
              work( i ) = zero
              work( i+n ) = zero
              work( i+2*n ) = zero
              work( i+3*n ) = zero
              work( i+4*n ) = zero
              work( i+5*n ) = zero
           end do
           ! compute right side vector in resulting linear equations
           basl = log10( sclfac )
           do i = ilo, ihi
              do j = ilo, ihi
                 tb = b( i, j )
                 ta = a( i, j )
                 if( ta==zero )go to 210
                 ta = log10( abs( ta ) ) / basl
                 210 continue
                 if( tb==zero )go to 220
                 tb = log10( abs( tb ) ) / basl
                 220 continue
                 work( i+4*n ) = work( i+4*n ) - ta - tb
                 work( j+5*n ) = work( j+5*n ) - ta - tb
              end do
           end do
           coef = one / real( 2*nr,KIND=${rk}$)
           coef2 = coef*coef
           coef5 = half*coef2
           nrp2 = nr + 2
           beta = zero
           it = 1
           ! start generalized conjugate gradient iteration
           250 continue
           gamma = stdlib_${ri}$dot( nr, work( ilo+4*n ), 1, work( ilo+4*n ), 1 ) +stdlib_${ri}$dot( nr, &
                     work( ilo+5*n ), 1, work( ilo+5*n ), 1 )
           ew = zero
           ewc = zero
           do i = ilo, ihi
              ew = ew + work( i+4*n )
              ewc = ewc + work( i+5*n )
           end do
           gamma = coef*gamma - coef2*( ew**2+ewc**2 ) - coef5*( ew-ewc )**2
           if( gamma==zero )go to 350
           if( it/=1 )beta = gamma / pgamma
           t = coef5*( ewc-three*ew )
           tc = coef5*( ew-three*ewc )
           call stdlib_${ri}$scal( nr, beta, work( ilo ), 1 )
           call stdlib_${ri}$scal( nr, beta, work( ilo+n ), 1 )
           call stdlib_${ri}$axpy( nr, coef, work( ilo+4*n ), 1, work( ilo+n ), 1 )
           call stdlib_${ri}$axpy( nr, coef, work( ilo+5*n ), 1, work( ilo ), 1 )
           do i = ilo, ihi
              work( i ) = work( i ) + tc
              work( i+n ) = work( i+n ) + t
           end do
           ! apply matrix to vector
           do i = ilo, ihi
              kount = 0
              sum = zero
              loop_290: do j = ilo, ihi
                 if( a( i, j )==zero )go to 280
                 kount = kount + 1
                 sum = sum + work( j )
                 280 continue
                 if( b( i, j )==zero )cycle loop_290
                 kount = kount + 1
                 sum = sum + work( j )
              end do loop_290
              work( i+2*n ) = real( kount,KIND=${rk}$)*work( i+n ) + sum
           end do
           do j = ilo, ihi
              kount = 0
              sum = zero
              loop_320: do i = ilo, ihi
                 if( a( i, j )==zero )go to 310
                 kount = kount + 1
                 sum = sum + work( i+n )
                 310 continue
                 if( b( i, j )==zero )cycle loop_320
                 kount = kount + 1
                 sum = sum + work( i+n )
              end do loop_320
              work( j+3*n ) = real( kount,KIND=${rk}$)*work( j ) + sum
           end do
           sum = stdlib_${ri}$dot( nr, work( ilo+n ), 1, work( ilo+2*n ), 1 ) +stdlib_${ri}$dot( nr, work( &
                     ilo ), 1, work( ilo+3*n ), 1 )
           alpha = gamma / sum
           ! determine correction to current iteration
           cmax = zero
           do i = ilo, ihi
              cor = alpha*work( i+n )
              if( abs( cor )>cmax )cmax = abs( cor )
              lscale( i ) = lscale( i ) + cor
              cor = alpha*work( i )
              if( abs( cor )>cmax )cmax = abs( cor )
              rscale( i ) = rscale( i ) + cor
           end do
           if( cmax<half )go to 350
           call stdlib_${ri}$axpy( nr, -alpha, work( ilo+2*n ), 1, work( ilo+4*n ), 1 )
           call stdlib_${ri}$axpy( nr, -alpha, work( ilo+3*n ), 1, work( ilo+5*n ), 1 )
           pgamma = gamma
           it = it + 1
           if( it<=nrp2 )go to 250
           ! end generalized conjugate gradient iteration
           350 continue
           sfmin = stdlib_${ri}$lamch( 'S' )
           sfmax = one / sfmin
           lsfmin = int( log10( sfmin ) / basl+one,KIND=ilp)
           lsfmax = int( log10( sfmax ) / basl,KIND=ilp)
           do i = ilo, ihi
              irab = stdlib_i${ri}$amax( n-ilo+1, a( i, ilo ), lda )
              rab = abs( a( i, irab+ilo-1 ) )
              irab = stdlib_i${ri}$amax( n-ilo+1, b( i, ilo ), ldb )
              rab = max( rab, abs( b( i, irab+ilo-1 ) ) )
              lrab = int( log10( rab+sfmin ) / basl+one,KIND=ilp)
              ir = int(lscale( i ) + sign( half, lscale( i ) ),KIND=ilp)
              ir = min( max( ir, lsfmin ), lsfmax, lsfmax-lrab )
              lscale( i ) = sclfac**ir
              icab = stdlib_i${ri}$amax( ihi, a( 1, i ), 1 )
              cab = abs( a( icab, i ) )
              icab = stdlib_i${ri}$amax( ihi, b( 1, i ), 1 )
              cab = max( cab, abs( b( icab, i ) ) )
              lcab = int( log10( cab+sfmin ) / basl+one,KIND=ilp)
              jc = int(rscale( i ) + sign( half, rscale( i ) ),KIND=ilp)
              jc = min( max( jc, lsfmin ), lsfmax, lsfmax-lcab )
              rscale( i ) = sclfac**jc
           end do
           ! row scaling of matrices a and b
           do i = ilo, ihi
              call stdlib_${ri}$scal( n-ilo+1, lscale( i ), a( i, ilo ), lda )
              call stdlib_${ri}$scal( n-ilo+1, lscale( i ), b( i, ilo ), ldb )
           end do
           ! column scaling of matrices a and b
           do j = ilo, ihi
              call stdlib_${ri}$scal( ihi, rscale( j ), a( 1, j ), 1 )
              call stdlib_${ri}$scal( ihi, rscale( j ), b( 1, j ), 1 )
           end do
           return
     end subroutine stdlib_${ri}$ggbal

#:endif
#:endfor

     module pure subroutine stdlib_cggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, info )
     !! CGGBAL balances a pair of general complex matrices (A,B).  This
     !! involves, first, permuting A and B by similarity transformations to
     !! isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
     !! elements on the diagonal; and second, applying a diagonal similarity
     !! transformation to rows and columns ILO to IHI to make the rows
     !! and columns as close in norm as possible. Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrices, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors in the
     !! generalized eigenvalue problem A*x = lambda*B*x.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldb, n
           ! Array Arguments 
           real(sp), intent(out) :: lscale(*), rscale(*), work(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sclfac = 1.0e+1_sp
           
           
           
           ! Local Scalars 
           integer(ilp) :: i, icab, iflow, ip1, ir, irab, it, j, jc, jp1, k, kount, l, lcab, lm1, &
                     lrab, lsfmax, lsfmin, m, nr, nrp2
           real(sp) :: alpha, basl, beta, cab, cmax, coef, coef2, coef5, cor, ew, ewc, gamma, &
                     pgamma, rab, sfmax, sfmin, sum, t, ta, tb, tc
           complex(sp) :: cdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGBAL', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              ilo = 1
              ihi = n
              return
           end if
           if( n==1 ) then
              ilo = 1
              ihi = n
              lscale( 1 ) = one
              rscale( 1 ) = one
              return
           end if
           if( stdlib_lsame( job, 'N' ) ) then
              ilo = 1
              ihi = n
              do i = 1, n
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           k = 1
           l = n
           if( stdlib_lsame( job, 'S' ) )go to 190
           go to 30
           ! permute the matrices a and b to isolate the eigenvalues.
           ! find row with one nonzero in columns 1 through l
           20 continue
           l = lm1
           if( l/=1 )go to 30
           rscale( 1 ) = one
           lscale( 1 ) = one
           go to 190
           30 continue
           lm1 = l - 1
           loop_80: do i = l, 1, -1
              do j = 1, lm1
                 jp1 = j + 1
                 if( a( i, j )/=czero .or. b( i, j )/=czero )go to 50
              end do
              j = l
              go to 70
              50 continue
              do j = jp1, l
                 if( a( i, j )/=czero .or. b( i, j )/=czero )cycle loop_80
              end do
              j = jp1 - 1
              70 continue
              m = l
              iflow = 1
              go to 160
           end do loop_80
           go to 100
           ! find column with one nonzero in rows k through n
           90 continue
           k = k + 1
           100 continue
           loop_150: do j = k, l
              do i = k, lm1
                 ip1 = i + 1
                 if( a( i, j )/=czero .or. b( i, j )/=czero )go to 120
              end do
              i = l
              go to 140
              120 continue
              do i = ip1, l
                 if( a( i, j )/=czero .or. b( i, j )/=czero )cycle loop_150
              end do
              i = ip1 - 1
              140 continue
              m = k
              iflow = 2
              go to 160
           end do loop_150
           go to 190
           ! permute rows m and i
           160 continue
           lscale( m ) = i
           if( i==m )go to 170
           call stdlib_cswap( n-k+1, a( i, k ), lda, a( m, k ), lda )
           call stdlib_cswap( n-k+1, b( i, k ), ldb, b( m, k ), ldb )
           ! permute columns m and j
           170 continue
           rscale( m ) = j
           if( j==m )go to 180
           call stdlib_cswap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_cswap( l, b( 1, j ), 1, b( 1, m ), 1 )
           180 continue
           go to ( 20, 90 )iflow
           190 continue
           ilo = k
           ihi = l
           if( stdlib_lsame( job, 'P' ) ) then
              do i = ilo, ihi
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           if( ilo==ihi )return
           ! balance the submatrix in rows ilo to ihi.
           nr = ihi - ilo + 1
           do i = ilo, ihi
              rscale( i ) = zero
              lscale( i ) = zero
              work( i ) = zero
              work( i+n ) = zero
              work( i+2*n ) = zero
              work( i+3*n ) = zero
              work( i+4*n ) = zero
              work( i+5*n ) = zero
           end do
           ! compute right side vector in resulting linear equations
           basl = log10( sclfac )
           do i = ilo, ihi
              do j = ilo, ihi
                 if( a( i, j )==czero ) then
                    ta = zero
                    go to 210
                 end if
                 ta = log10( cabs1( a( i, j ) ) ) / basl
                 210 continue
                 if( b( i, j )==czero ) then
                    tb = zero
                    go to 220
                 end if
                 tb = log10( cabs1( b( i, j ) ) ) / basl
                 220 continue
                 work( i+4*n ) = work( i+4*n ) - ta - tb
                 work( j+5*n ) = work( j+5*n ) - ta - tb
              end do
           end do
           coef = one / real( 2*nr,KIND=sp)
           coef2 = coef*coef
           coef5 = half*coef2
           nrp2 = nr + 2
           beta = zero
           it = 1
           ! start generalized conjugate gradient iteration
           250 continue
           gamma = stdlib_sdot( nr, work( ilo+4*n ), 1, work( ilo+4*n ), 1 ) +stdlib_sdot( nr, &
                     work( ilo+5*n ), 1, work( ilo+5*n ), 1 )
           ew = zero
           ewc = zero
           do i = ilo, ihi
              ew = ew + work( i+4*n )
              ewc = ewc + work( i+5*n )
           end do
           gamma = coef*gamma - coef2*( ew**2+ewc**2 ) - coef5*( ew-ewc )**2
           if( gamma==zero )go to 350
           if( it/=1 )beta = gamma / pgamma
           t = coef5*( ewc-three*ew )
           tc = coef5*( ew-three*ewc )
           call stdlib_sscal( nr, beta, work( ilo ), 1 )
           call stdlib_sscal( nr, beta, work( ilo+n ), 1 )
           call stdlib_saxpy( nr, coef, work( ilo+4*n ), 1, work( ilo+n ), 1 )
           call stdlib_saxpy( nr, coef, work( ilo+5*n ), 1, work( ilo ), 1 )
           do i = ilo, ihi
              work( i ) = work( i ) + tc
              work( i+n ) = work( i+n ) + t
           end do
           ! apply matrix to vector
           do i = ilo, ihi
              kount = 0
              sum = zero
              loop_290: do j = ilo, ihi
                 if( a( i, j )==czero )go to 280
                 kount = kount + 1
                 sum = sum + work( j )
                 280 continue
                 if( b( i, j )==czero )cycle loop_290
                 kount = kount + 1
                 sum = sum + work( j )
              end do loop_290
              work( i+2*n ) = real( kount,KIND=sp)*work( i+n ) + sum
           end do
           do j = ilo, ihi
              kount = 0
              sum = zero
              loop_320: do i = ilo, ihi
                 if( a( i, j )==czero )go to 310
                 kount = kount + 1
                 sum = sum + work( i+n )
                 310 continue
                 if( b( i, j )==czero )cycle loop_320
                 kount = kount + 1
                 sum = sum + work( i+n )
              end do loop_320
              work( j+3*n ) = real( kount,KIND=sp)*work( j ) + sum
           end do
           sum = stdlib_sdot( nr, work( ilo+n ), 1, work( ilo+2*n ), 1 ) +stdlib_sdot( nr, work( &
                     ilo ), 1, work( ilo+3*n ), 1 )
           alpha = gamma / sum
           ! determine correction to current iteration
           cmax = zero
           do i = ilo, ihi
              cor = alpha*work( i+n )
              if( abs( cor )>cmax )cmax = abs( cor )
              lscale( i ) = lscale( i ) + cor
              cor = alpha*work( i )
              if( abs( cor )>cmax )cmax = abs( cor )
              rscale( i ) = rscale( i ) + cor
           end do
           if( cmax<half )go to 350
           call stdlib_saxpy( nr, -alpha, work( ilo+2*n ), 1, work( ilo+4*n ), 1 )
           call stdlib_saxpy( nr, -alpha, work( ilo+3*n ), 1, work( ilo+5*n ), 1 )
           pgamma = gamma
           it = it + 1
           if( it<=nrp2 )go to 250
           ! end generalized conjugate gradient iteration
           350 continue
           sfmin = stdlib_slamch( 'S' )
           sfmax = one / sfmin
           lsfmin = int( log10( sfmin ) / basl+one,KIND=ilp)
           lsfmax = int( log10( sfmax ) / basl,KIND=ilp)
           do i = ilo, ihi
              irab = stdlib_icamax( n-ilo+1, a( i, ilo ), lda )
              rab = abs( a( i, irab+ilo-1 ) )
              irab = stdlib_icamax( n-ilo+1, b( i, ilo ), ldb )
              rab = max( rab, abs( b( i, irab+ilo-1 ) ) )
              lrab = int( log10( rab+sfmin ) / basl+one,KIND=ilp)
              ir = lscale( i ) + sign( half, lscale( i ) )
              ir = min( max( ir, lsfmin ), lsfmax, lsfmax-lrab )
              lscale( i ) = sclfac**ir
              icab = stdlib_icamax( ihi, a( 1, i ), 1 )
              cab = abs( a( icab, i ) )
              icab = stdlib_icamax( ihi, b( 1, i ), 1 )
              cab = max( cab, abs( b( icab, i ) ) )
              lcab = int( log10( cab+sfmin ) / basl+one,KIND=ilp)
              jc = rscale( i ) + sign( half, rscale( i ) )
              jc = min( max( jc, lsfmin ), lsfmax, lsfmax-lcab )
              rscale( i ) = sclfac**jc
           end do
           ! row scaling of matrices a and b
           do i = ilo, ihi
              call stdlib_csscal( n-ilo+1, lscale( i ), a( i, ilo ), lda )
              call stdlib_csscal( n-ilo+1, lscale( i ), b( i, ilo ), ldb )
           end do
           ! column scaling of matrices a and b
           do j = ilo, ihi
              call stdlib_csscal( ihi, rscale( j ), a( 1, j ), 1 )
              call stdlib_csscal( ihi, rscale( j ), b( 1, j ), 1 )
           end do
           return
     end subroutine stdlib_cggbal

     module pure subroutine stdlib_zggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, info )
     !! ZGGBAL balances a pair of general complex matrices (A,B).  This
     !! involves, first, permuting A and B by similarity transformations to
     !! isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
     !! elements on the diagonal; and second, applying a diagonal similarity
     !! transformation to rows and columns ILO to IHI to make the rows
     !! and columns as close in norm as possible. Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrices, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors in the
     !! generalized eigenvalue problem A*x = lambda*B*x.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldb, n
           ! Array Arguments 
           real(dp), intent(out) :: lscale(*), rscale(*), work(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sclfac = 1.0e+1_dp
           
           
           
           ! Local Scalars 
           integer(ilp) :: i, icab, iflow, ip1, ir, irab, it, j, jc, jp1, k, kount, l, lcab, lm1, &
                     lrab, lsfmax, lsfmin, m, nr, nrp2
           real(dp) :: alpha, basl, beta, cab, cmax, coef, coef2, coef5, cor, ew, ewc, gamma, &
                     pgamma, rab, sfmax, sfmin, sum, t, ta, tb, tc
           complex(dp) :: cdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGBAL', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              ilo = 1
              ihi = n
              return
           end if
           if( n==1 ) then
              ilo = 1
              ihi = n
              lscale( 1 ) = one
              rscale( 1 ) = one
              return
           end if
           if( stdlib_lsame( job, 'N' ) ) then
              ilo = 1
              ihi = n
              do i = 1, n
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           k = 1
           l = n
           if( stdlib_lsame( job, 'S' ) )go to 190
           go to 30
           ! permute the matrices a and b to isolate the eigenvalues.
           ! find row with one nonzero in columns 1 through l
           20 continue
           l = lm1
           if( l/=1 )go to 30
           rscale( 1 ) = 1
           lscale( 1 ) = 1
           go to 190
           30 continue
           lm1 = l - 1
           loop_80: do i = l, 1, -1
              do j = 1, lm1
                 jp1 = j + 1
                 if( a( i, j )/=czero .or. b( i, j )/=czero )go to 50
              end do
              j = l
              go to 70
              50 continue
              do j = jp1, l
                 if( a( i, j )/=czero .or. b( i, j )/=czero )cycle loop_80
              end do
              j = jp1 - 1
              70 continue
              m = l
              iflow = 1
              go to 160
           end do loop_80
           go to 100
           ! find column with one nonzero in rows k through n
           90 continue
           k = k + 1
           100 continue
           loop_150: do j = k, l
              do i = k, lm1
                 ip1 = i + 1
                 if( a( i, j )/=czero .or. b( i, j )/=czero )go to 120
              end do
              i = l
              go to 140
              120 continue
              do i = ip1, l
                 if( a( i, j )/=czero .or. b( i, j )/=czero )cycle loop_150
              end do
              i = ip1 - 1
              140 continue
              m = k
              iflow = 2
              go to 160
           end do loop_150
           go to 190
           ! permute rows m and i
           160 continue
           lscale( m ) = i
           if( i==m )go to 170
           call stdlib_zswap( n-k+1, a( i, k ), lda, a( m, k ), lda )
           call stdlib_zswap( n-k+1, b( i, k ), ldb, b( m, k ), ldb )
           ! permute columns m and j
           170 continue
           rscale( m ) = j
           if( j==m )go to 180
           call stdlib_zswap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_zswap( l, b( 1, j ), 1, b( 1, m ), 1 )
           180 continue
           go to ( 20, 90 )iflow
           190 continue
           ilo = k
           ihi = l
           if( stdlib_lsame( job, 'P' ) ) then
              do i = ilo, ihi
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           if( ilo==ihi )return
           ! balance the submatrix in rows ilo to ihi.
           nr = ihi - ilo + 1
           do i = ilo, ihi
              rscale( i ) = zero
              lscale( i ) = zero
              work( i ) = zero
              work( i+n ) = zero
              work( i+2*n ) = zero
              work( i+3*n ) = zero
              work( i+4*n ) = zero
              work( i+5*n ) = zero
           end do
           ! compute right side vector in resulting linear equations
           basl = log10( sclfac )
           do i = ilo, ihi
              do j = ilo, ihi
                 if( a( i, j )==czero ) then
                    ta = zero
                    go to 210
                 end if
                 ta = log10( cabs1( a( i, j ) ) ) / basl
                 210 continue
                 if( b( i, j )==czero ) then
                    tb = zero
                    go to 220
                 end if
                 tb = log10( cabs1( b( i, j ) ) ) / basl
                 220 continue
                 work( i+4*n ) = work( i+4*n ) - ta - tb
                 work( j+5*n ) = work( j+5*n ) - ta - tb
              end do
           end do
           coef = one / real( 2*nr,KIND=dp)
           coef2 = coef*coef
           coef5 = half*coef2
           nrp2 = nr + 2
           beta = zero
           it = 1
           ! start generalized conjugate gradient iteration
           250 continue
           gamma = stdlib_ddot( nr, work( ilo+4*n ), 1, work( ilo+4*n ), 1 ) +stdlib_ddot( nr, &
                     work( ilo+5*n ), 1, work( ilo+5*n ), 1 )
           ew = zero
           ewc = zero
           do i = ilo, ihi
              ew = ew + work( i+4*n )
              ewc = ewc + work( i+5*n )
           end do
           gamma = coef*gamma - coef2*( ew**2+ewc**2 ) - coef5*( ew-ewc )**2
           if( gamma==zero )go to 350
           if( it/=1 )beta = gamma / pgamma
           t = coef5*( ewc-three*ew )
           tc = coef5*( ew-three*ewc )
           call stdlib_dscal( nr, beta, work( ilo ), 1 )
           call stdlib_dscal( nr, beta, work( ilo+n ), 1 )
           call stdlib_daxpy( nr, coef, work( ilo+4*n ), 1, work( ilo+n ), 1 )
           call stdlib_daxpy( nr, coef, work( ilo+5*n ), 1, work( ilo ), 1 )
           do i = ilo, ihi
              work( i ) = work( i ) + tc
              work( i+n ) = work( i+n ) + t
           end do
           ! apply matrix to vector
           do i = ilo, ihi
              kount = 0
              sum = zero
              loop_290: do j = ilo, ihi
                 if( a( i, j )==czero )go to 280
                 kount = kount + 1
                 sum = sum + work( j )
                 280 continue
                 if( b( i, j )==czero )cycle loop_290
                 kount = kount + 1
                 sum = sum + work( j )
              end do loop_290
              work( i+2*n ) = real( kount,KIND=dp)*work( i+n ) + sum
           end do
           do j = ilo, ihi
              kount = 0
              sum = zero
              loop_320: do i = ilo, ihi
                 if( a( i, j )==czero )go to 310
                 kount = kount + 1
                 sum = sum + work( i+n )
                 310 continue
                 if( b( i, j )==czero )cycle loop_320
                 kount = kount + 1
                 sum = sum + work( i+n )
              end do loop_320
              work( j+3*n ) = real( kount,KIND=dp)*work( j ) + sum
           end do
           sum = stdlib_ddot( nr, work( ilo+n ), 1, work( ilo+2*n ), 1 ) +stdlib_ddot( nr, work( &
                     ilo ), 1, work( ilo+3*n ), 1 )
           alpha = gamma / sum
           ! determine correction to current iteration
           cmax = zero
           do i = ilo, ihi
              cor = alpha*work( i+n )
              if( abs( cor )>cmax )cmax = abs( cor )
              lscale( i ) = lscale( i ) + cor
              cor = alpha*work( i )
              if( abs( cor )>cmax )cmax = abs( cor )
              rscale( i ) = rscale( i ) + cor
           end do
           if( cmax<half )go to 350
           call stdlib_daxpy( nr, -alpha, work( ilo+2*n ), 1, work( ilo+4*n ), 1 )
           call stdlib_daxpy( nr, -alpha, work( ilo+3*n ), 1, work( ilo+5*n ), 1 )
           pgamma = gamma
           it = it + 1
           if( it<=nrp2 )go to 250
           ! end generalized conjugate gradient iteration
           350 continue
           sfmin = stdlib_dlamch( 'S' )
           sfmax = one / sfmin
           lsfmin = int( log10( sfmin ) / basl+one,KIND=ilp)
           lsfmax = int( log10( sfmax ) / basl,KIND=ilp)
           do i = ilo, ihi
              irab = stdlib_izamax( n-ilo+1, a( i, ilo ), lda )
              rab = abs( a( i, irab+ilo-1 ) )
              irab = stdlib_izamax( n-ilo+1, b( i, ilo ), ldb )
              rab = max( rab, abs( b( i, irab+ilo-1 ) ) )
              lrab = int( log10( rab+sfmin ) / basl+one,KIND=ilp)
              ir = int(lscale( i ) + sign( half, lscale( i ) ),KIND=ilp)
              ir = min( max( ir, lsfmin ), lsfmax, lsfmax-lrab )
              lscale( i ) = sclfac**ir
              icab = stdlib_izamax( ihi, a( 1, i ), 1 )
              cab = abs( a( icab, i ) )
              icab = stdlib_izamax( ihi, b( 1, i ), 1 )
              cab = max( cab, abs( b( icab, i ) ) )
              lcab = int( log10( cab+sfmin ) / basl+one,KIND=ilp)
              jc = int(rscale( i ) + sign( half, rscale( i ) ),KIND=ilp)
              jc = min( max( jc, lsfmin ), lsfmax, lsfmax-lcab )
              rscale( i ) = sclfac**jc
           end do
           ! row scaling of matrices a and b
           do i = ilo, ihi
              call stdlib_zdscal( n-ilo+1, lscale( i ), a( i, ilo ), lda )
              call stdlib_zdscal( n-ilo+1, lscale( i ), b( i, ilo ), ldb )
           end do
           ! column scaling of matrices a and b
           do j = ilo, ihi
              call stdlib_zdscal( ihi, rscale( j ), a( 1, j ), 1 )
              call stdlib_zdscal( ihi, rscale( j ), b( 1, j ), 1 )
           end do
           return
     end subroutine stdlib_zggbal

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$ggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, info )
     !! ZGGBAL: balances a pair of general complex matrices (A,B).  This
     !! involves, first, permuting A and B by similarity transformations to
     !! isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
     !! elements on the diagonal; and second, applying a diagonal similarity
     !! transformation to rows and columns ILO to IHI to make the rows
     !! and columns as close in norm as possible. Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrices, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors in the
     !! generalized eigenvalue problem A*x = lambda*B*x.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldb, n
           ! Array Arguments 
           real(${ck}$), intent(out) :: lscale(*), rscale(*), work(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: sclfac = 1.0e+1_${ck}$
           
           
           
           ! Local Scalars 
           integer(ilp) :: i, icab, iflow, ip1, ir, irab, it, j, jc, jp1, k, kount, l, lcab, lm1, &
                     lrab, lsfmax, lsfmin, m, nr, nrp2
           real(${ck}$) :: alpha, basl, beta, cab, cmax, coef, coef2, coef5, cor, ew, ewc, gamma, &
                     pgamma, rab, sfmax, sfmin, sum, t, ta, tb, tc
           complex(${ck}$) :: cdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGBAL', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              ilo = 1
              ihi = n
              return
           end if
           if( n==1 ) then
              ilo = 1
              ihi = n
              lscale( 1 ) = one
              rscale( 1 ) = one
              return
           end if
           if( stdlib_lsame( job, 'N' ) ) then
              ilo = 1
              ihi = n
              do i = 1, n
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           k = 1
           l = n
           if( stdlib_lsame( job, 'S' ) )go to 190
           go to 30
           ! permute the matrices a and b to isolate the eigenvalues.
           ! find row with one nonzero in columns 1 through l
           20 continue
           l = lm1
           if( l/=1 )go to 30
           rscale( 1 ) = 1
           lscale( 1 ) = 1
           go to 190
           30 continue
           lm1 = l - 1
           loop_80: do i = l, 1, -1
              do j = 1, lm1
                 jp1 = j + 1
                 if( a( i, j )/=czero .or. b( i, j )/=czero )go to 50
              end do
              j = l
              go to 70
              50 continue
              do j = jp1, l
                 if( a( i, j )/=czero .or. b( i, j )/=czero )cycle loop_80
              end do
              j = jp1 - 1
              70 continue
              m = l
              iflow = 1
              go to 160
           end do loop_80
           go to 100
           ! find column with one nonzero in rows k through n
           90 continue
           k = k + 1
           100 continue
           loop_150: do j = k, l
              do i = k, lm1
                 ip1 = i + 1
                 if( a( i, j )/=czero .or. b( i, j )/=czero )go to 120
              end do
              i = l
              go to 140
              120 continue
              do i = ip1, l
                 if( a( i, j )/=czero .or. b( i, j )/=czero )cycle loop_150
              end do
              i = ip1 - 1
              140 continue
              m = k
              iflow = 2
              go to 160
           end do loop_150
           go to 190
           ! permute rows m and i
           160 continue
           lscale( m ) = i
           if( i==m )go to 170
           call stdlib_${ci}$swap( n-k+1, a( i, k ), lda, a( m, k ), lda )
           call stdlib_${ci}$swap( n-k+1, b( i, k ), ldb, b( m, k ), ldb )
           ! permute columns m and j
           170 continue
           rscale( m ) = j
           if( j==m )go to 180
           call stdlib_${ci}$swap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_${ci}$swap( l, b( 1, j ), 1, b( 1, m ), 1 )
           180 continue
           go to ( 20, 90 )iflow
           190 continue
           ilo = k
           ihi = l
           if( stdlib_lsame( job, 'P' ) ) then
              do i = ilo, ihi
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           if( ilo==ihi )return
           ! balance the submatrix in rows ilo to ihi.
           nr = ihi - ilo + 1
           do i = ilo, ihi
              rscale( i ) = zero
              lscale( i ) = zero
              work( i ) = zero
              work( i+n ) = zero
              work( i+2*n ) = zero
              work( i+3*n ) = zero
              work( i+4*n ) = zero
              work( i+5*n ) = zero
           end do
           ! compute right side vector in resulting linear equations
           basl = log10( sclfac )
           do i = ilo, ihi
              do j = ilo, ihi
                 if( a( i, j )==czero ) then
                    ta = zero
                    go to 210
                 end if
                 ta = log10( cabs1( a( i, j ) ) ) / basl
                 210 continue
                 if( b( i, j )==czero ) then
                    tb = zero
                    go to 220
                 end if
                 tb = log10( cabs1( b( i, j ) ) ) / basl
                 220 continue
                 work( i+4*n ) = work( i+4*n ) - ta - tb
                 work( j+5*n ) = work( j+5*n ) - ta - tb
              end do
           end do
           coef = one / real( 2*nr,KIND=${ck}$)
           coef2 = coef*coef
           coef5 = half*coef2
           nrp2 = nr + 2
           beta = zero
           it = 1
           ! start generalized conjugate gradient iteration
           250 continue
           gamma = stdlib_${c2ri(ci)}$dot( nr, work( ilo+4*n ), 1, work( ilo+4*n ), 1 ) +stdlib_${c2ri(ci)}$dot( nr, &
                     work( ilo+5*n ), 1, work( ilo+5*n ), 1 )
           ew = zero
           ewc = zero
           do i = ilo, ihi
              ew = ew + work( i+4*n )
              ewc = ewc + work( i+5*n )
           end do
           gamma = coef*gamma - coef2*( ew**2+ewc**2 ) - coef5*( ew-ewc )**2
           if( gamma==zero )go to 350
           if( it/=1 )beta = gamma / pgamma
           t = coef5*( ewc-three*ew )
           tc = coef5*( ew-three*ewc )
           call stdlib_${c2ri(ci)}$scal( nr, beta, work( ilo ), 1 )
           call stdlib_${c2ri(ci)}$scal( nr, beta, work( ilo+n ), 1 )
           call stdlib_${c2ri(ci)}$axpy( nr, coef, work( ilo+4*n ), 1, work( ilo+n ), 1 )
           call stdlib_${c2ri(ci)}$axpy( nr, coef, work( ilo+5*n ), 1, work( ilo ), 1 )
           do i = ilo, ihi
              work( i ) = work( i ) + tc
              work( i+n ) = work( i+n ) + t
           end do
           ! apply matrix to vector
           do i = ilo, ihi
              kount = 0
              sum = zero
              loop_290: do j = ilo, ihi
                 if( a( i, j )==czero )go to 280
                 kount = kount + 1
                 sum = sum + work( j )
                 280 continue
                 if( b( i, j )==czero )cycle loop_290
                 kount = kount + 1
                 sum = sum + work( j )
              end do loop_290
              work( i+2*n ) = real( kount,KIND=${ck}$)*work( i+n ) + sum
           end do
           do j = ilo, ihi
              kount = 0
              sum = zero
              loop_320: do i = ilo, ihi
                 if( a( i, j )==czero )go to 310
                 kount = kount + 1
                 sum = sum + work( i+n )
                 310 continue
                 if( b( i, j )==czero )cycle loop_320
                 kount = kount + 1
                 sum = sum + work( i+n )
              end do loop_320
              work( j+3*n ) = real( kount,KIND=${ck}$)*work( j ) + sum
           end do
           sum = stdlib_${c2ri(ci)}$dot( nr, work( ilo+n ), 1, work( ilo+2*n ), 1 ) +stdlib_${c2ri(ci)}$dot( nr, work( &
                     ilo ), 1, work( ilo+3*n ), 1 )
           alpha = gamma / sum
           ! determine correction to current iteration
           cmax = zero
           do i = ilo, ihi
              cor = alpha*work( i+n )
              if( abs( cor )>cmax )cmax = abs( cor )
              lscale( i ) = lscale( i ) + cor
              cor = alpha*work( i )
              if( abs( cor )>cmax )cmax = abs( cor )
              rscale( i ) = rscale( i ) + cor
           end do
           if( cmax<half )go to 350
           call stdlib_${c2ri(ci)}$axpy( nr, -alpha, work( ilo+2*n ), 1, work( ilo+4*n ), 1 )
           call stdlib_${c2ri(ci)}$axpy( nr, -alpha, work( ilo+3*n ), 1, work( ilo+5*n ), 1 )
           pgamma = gamma
           it = it + 1
           if( it<=nrp2 )go to 250
           ! end generalized conjugate gradient iteration
           350 continue
           sfmin = stdlib_${c2ri(ci)}$lamch( 'S' )
           sfmax = one / sfmin
           lsfmin = int( log10( sfmin ) / basl+one,KIND=ilp)
           lsfmax = int( log10( sfmax ) / basl,KIND=ilp)
           do i = ilo, ihi
              irab = stdlib_i${ci}$amax( n-ilo+1, a( i, ilo ), lda )
              rab = abs( a( i, irab+ilo-1 ) )
              irab = stdlib_i${ci}$amax( n-ilo+1, b( i, ilo ), ldb )
              rab = max( rab, abs( b( i, irab+ilo-1 ) ) )
              lrab = int( log10( rab+sfmin ) / basl+one,KIND=ilp)
              ir = int(lscale( i ) + sign( half, lscale( i ) ),KIND=ilp)
              ir = min( max( ir, lsfmin ), lsfmax, lsfmax-lrab )
              lscale( i ) = sclfac**ir
              icab = stdlib_i${ci}$amax( ihi, a( 1, i ), 1 )
              cab = abs( a( icab, i ) )
              icab = stdlib_i${ci}$amax( ihi, b( 1, i ), 1 )
              cab = max( cab, abs( b( icab, i ) ) )
              lcab = int( log10( cab+sfmin ) / basl+one,KIND=ilp)
              jc = int(rscale( i ) + sign( half, rscale( i ) ),KIND=ilp)
              jc = min( max( jc, lsfmin ), lsfmax, lsfmax-lcab )
              rscale( i ) = sclfac**jc
           end do
           ! row scaling of matrices a and b
           do i = ilo, ihi
              call stdlib_${ci}$dscal( n-ilo+1, lscale( i ), a( i, ilo ), lda )
              call stdlib_${ci}$dscal( n-ilo+1, lscale( i ), b( i, ilo ), ldb )
           end do
           ! column scaling of matrices a and b
           do j = ilo, ihi
              call stdlib_${ci}$dscal( ihi, rscale( j ), a( 1, j ), 1 )
              call stdlib_${ci}$dscal( ihi, rscale( j ), b( 1, j ), 1 )
           end do
           return
     end subroutine stdlib_${ci}$ggbal

#:endif
#:endfor



     module pure subroutine stdlib_sgghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! SGGHD3 reduces a pair of real matrices (A,B) to generalized upper
     !! Hessenberg form using orthogonal transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the orthogonal matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**T*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**T*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**T*x.
     !! The orthogonal matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T
     !! Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T
     !! If Q1 is the orthogonal matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then SGGHD3 reduces the original
     !! problem to generalized Hessenberg form.
     !! This is a blocked variant of SGGHRD, using matrix-matrix
     !! multiplications for parts of the computation to enhance performance.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: blk22, initq, initz, lquery, wantq, wantz
           character :: compq2, compz2
           integer(ilp) :: cola, i, ierr, j, j0, jcol, jj, jrow, k, kacc22, len, lwkopt, n2nb, nb,&
                      nblst, nbmin, nh, nnb, nx, ppw, ppwo, pw, top, topq
           real(sp) :: c, c1, c2, s, s1, s2, temp, temp1, temp2, temp3
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           info = 0
           nb = stdlib_ilaenv( 1, 'SGGHD3', ' ', n, ilo, ihi, -1 )
           lwkopt = max( 6*n*nb, 1 )
           work( 1 ) = real( lwkopt,KIND=sp)
           initq = stdlib_lsame( compq, 'I' )
           wantq = initq .or. stdlib_lsame( compq, 'V' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( wantq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( wantz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           else if( lwork<1 .and. .not.lquery ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGGHD3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! initialize q and z if desired.
           if( initq )call stdlib_slaset( 'ALL', n, n, zero, one, q, ldq )
           if( initz )call stdlib_slaset( 'ALL', n, n, zero, one, z, ldz )
           ! zero out lower triangle of b.
           if( n>1 )call stdlib_slaset( 'LOWER', n-1, n-1, zero, zero, b(2, 1), ldb )
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = one
              return
           end if
           ! determine the blocksize.
           nbmin = stdlib_ilaenv( 2, 'SGGHD3', ' ', n, ilo, ihi, -1 )
           if( nb>1 .and. nb<nh ) then
              ! determine when to use unblocked instead of blocked code.
              nx = max( nb, stdlib_ilaenv( 3, 'SGGHD3', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code.
                 if( lwork<lwkopt ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code.
                    nbmin = max( 2, stdlib_ilaenv( 2, 'SGGHD3', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=6*n*nbmin ) then
                       nb = lwork / ( 6*n )
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              jcol = ilo
           else
              ! use blocked code
              kacc22 = stdlib_ilaenv( 16, 'SGGHD3', ' ', n, ilo, ihi, -1 )
              blk22 = kacc22==2
              do jcol = ilo, ihi-2, nb
                 nnb = min( nb, ihi-jcol-1 )
                 ! initialize small orthogonal factors that will hold the
                 ! accumulated givens rotations in workspace.
                 ! n2nb   denotes the number of 2*nnb-by-2*nnb factors
                 ! nblst  denotes the (possibly smaller) order of the last
                        ! factor.
                 n2nb = ( ihi-jcol-1 ) / nnb - 1
                 nblst = ihi - jcol - n2nb*nnb
                 call stdlib_slaset( 'ALL', nblst, nblst, zero, one, work, nblst )
                 pw = nblst * nblst + 1
                 do i = 1, n2nb
                    call stdlib_slaset( 'ALL', 2*nnb, 2*nnb, zero, one,work( pw ), 2*nnb )
                    pw = pw + 4*nnb*nnb
                 end do
                 ! reduce columns jcol:jcol+nnb-1 of a to hessenberg form.
                 do j = jcol, jcol+nnb-1
                    ! reduce jth column of a. store cosines and sines in jth
                    ! column of a and b, respectively.
                    do i = ihi, j+2, -1
                       temp = a( i-1, j )
                       call stdlib_slartg( temp, a( i, j ), c, s, a( i-1, j ) )
                       a( i, j ) = c
                       b( i, j ) = s
                    end do
                    ! accumulate givens rotations into workspace array.
                    ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                    len  = 2 + j - jcol
                    jrow = j + n2nb*nnb + 2
                    do i = ihi, jrow, -1
                       c = a( i, j )
                       s = b( i, j )
                       do jj = ppw, ppw+len-1
                          temp = work( jj + nblst )
                          work( jj + nblst ) = c*temp - s*work( jj )
                          work( jj ) = s*temp + c*work( jj )
                       end do
                       len = len + 1
                       ppw = ppw - nblst - 1
                    end do
                    ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                    j0 = jrow - nnb
                    do jrow = j0, j+2, -nnb
                       ppw = ppwo
                       len  = 2 + j - jcol
                       do i = jrow+nnb-1, jrow, -1
                          c = a( i, j )
                          s = b( i, j )
                          do jj = ppw, ppw+len-1
                             temp = work( jj + 2*nnb )
                             work( jj + 2*nnb ) = c*temp - s*work( jj )
                             work( jj ) = s*temp + c*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - 2*nnb - 1
                       end do
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    ! top denotes the number of top rows in a and b that will
                    ! not be updated during the next steps.
                    if( jcol<=2 ) then
                       top = 0
                    else
                       top = jcol
                    end if
                    ! propagate transformations through b and replace stored
                    ! left sines/cosines by right sines/cosines.
                    do jj = n, j+1, -1
                       ! update jjth column of b.
                       do i = min( jj+1, ihi ), j+2, -1
                          c = a( i, j )
                          s = b( i, j )
                          temp = b( i, jj )
                          b( i, jj ) = c*temp - s*b( i-1, jj )
                          b( i-1, jj ) = s*temp + c*b( i-1, jj )
                       end do
                       ! annihilate b( jj+1, jj ).
                       if( jj<ihi ) then
                          temp = b( jj+1, jj+1 )
                          call stdlib_slartg( temp, b( jj+1, jj ), c, s,b( jj+1, jj+1 ) )
                          b( jj+1, jj ) = zero
                          call stdlib_srot( jj-top, b( top+1, jj+1 ), 1,b( top+1, jj ), 1, c, s )
                                    
                          a( jj+1, j ) = c
                          b( jj+1, j ) = -s
                       end if
                    end do
                    ! update a by transformations from right.
                    ! explicit loop unrolling provides better performance
                    ! compared to stdlib_slasr.
                     ! call stdlib_slasr( 'right', 'variable', 'backward', ihi-top,
           ! $                     ihi-j, a( j+2, j ), b( j+2, j ),
           ! $                     a( top+1, j+1 ), lda )
                    jj = mod( ihi-j-1, 3 )
                    do i = ihi-j-3, jj+1, -3
                       c = a( j+1+i, j )
                       s = -b( j+1+i, j )
                       c1 = a( j+2+i, j )
                       s1 = -b( j+2+i, j )
                       c2 = a( j+3+i, j )
                       s2 = -b( j+3+i, j )
                       do k = top+1, ihi
                          temp = a( k, j+i  )
                          temp1 = a( k, j+i+1 )
                          temp2 = a( k, j+i+2 )
                          temp3 = a( k, j+i+3 )
                          a( k, j+i+3 ) = c2*temp3 + s2*temp2
                          temp2 = -s2*temp3 + c2*temp2
                          a( k, j+i+2 ) = c1*temp2 + s1*temp1
                          temp1 = -s1*temp2 + c1*temp1
                          a( k, j+i+1 ) = c*temp1 + s*temp
                          a( k, j+i ) = -s*temp1 + c*temp
                       end do
                    end do
                    if( jj>0 ) then
                       do i = jj, 1, -1
                          call stdlib_srot( ihi-top, a( top+1, j+i+1 ), 1,a( top+1, j+i ), 1, a( &
                                    j+1+i, j ),-b( j+1+i, j ) )
                       end do
                    end if
                    ! update (j+1)th column of a by transformations from left.
                    if ( j < jcol + nnb - 1 ) then
                       len  = 1 + j - jcol
                       ! multiply with the trailing accumulated orthogonal
                       ! matrix, which takes the form
                              ! [  u11  u12  ]
                          ! u = [            ],
                              ! [  u21  u22  ]
                       ! where u21 is a len-by-len matrix and u12 is lower
                       ! triangular.
                       jrow = ihi - nblst + 1
                       call stdlib_sgemv( 'TRANSPOSE', nblst, len, one, work,nblst, a( jrow, j+1 )&
                                 , 1, zero,work( pw ), 1 )
                       ppw = pw + len
                       do i = jrow, jrow+nblst-len-1
                          work( ppw ) = a( i, j+1 )
                          ppw = ppw + 1
                       end do
                       call stdlib_strmv( 'LOWER', 'TRANSPOSE', 'NON-UNIT',nblst-len, work( &
                                 len*nblst + 1 ), nblst,work( pw+len ), 1 )
                       call stdlib_sgemv( 'TRANSPOSE', len, nblst-len, one,work( (len+1)*nblst - &
                       len + 1 ), nblst,a( jrow+nblst-len, j+1 ), 1, one,work( pw+len ), 1 )
                                 
                       ppw = pw
                       do i = jrow, jrow+nblst-1
                          a( i, j+1 ) = work( ppw )
                          ppw = ppw + 1
                       end do
                       ! multiply with the other accumulated orthogonal
                       ! matrices, which take the form
                              ! [  u11  u12   0  ]
                              ! [                ]
                          ! u = [  u21  u22   0  ],
                              ! [                ]
                              ! [   0    0    i  ]
                       ! where i denotes the (nnb-len)-by-(nnb-len) identity
                       ! matrix, u21 is a len-by-len upper triangular matrix
                       ! and u12 is an nnb-by-nnb lower triangular matrix.
                       ppwo = 1 + nblst*nblst
                       j0 = jrow - nnb
                       do jrow = j0, jcol+1, -nnb
                          ppw = pw + len
                          do i = jrow, jrow+nnb-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          ppw = pw
                          do i = jrow+nnb, jrow+nnb+len-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          call stdlib_strmv( 'UPPER', 'TRANSPOSE', 'NON-UNIT', len,work( ppwo + &
                                    nnb ), 2*nnb, work( pw ),1 )
                          call stdlib_strmv( 'LOWER', 'TRANSPOSE', 'NON-UNIT', nnb,work( ppwo + &
                                    2*len*nnb ),2*nnb, work( pw + len ), 1 )
                          call stdlib_sgemv( 'TRANSPOSE', nnb, len, one,work( ppwo ), 2*nnb, a( &
                                    jrow, j+1 ), 1,one, work( pw ), 1 )
                          call stdlib_sgemv( 'TRANSPOSE', len, nnb, one,work( ppwo + 2*len*nnb + &
                                    nnb ), 2*nnb,a( jrow+nnb, j+1 ), 1, one,work( pw+len ), 1 )
                          ppw = pw
                          do i = jrow, jrow+len+nnb-1
                             a( i, j+1 ) = work( ppw )
                             ppw = ppw + 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end if
                 end do
                 ! apply accumulated orthogonal matrices to a.
                 cola = n - jcol - nnb + 1
                 j = ihi - nblst + 1
                 call stdlib_sgemm( 'TRANSPOSE', 'NO TRANSPOSE', nblst,cola, nblst, one, work, &
                           nblst,a( j, jcol+nnb ), lda, zero, work( pw ),nblst )
                 call stdlib_slacpy( 'ALL', nblst, cola, work( pw ), nblst,a( j, jcol+nnb ), lda )
                           
                 ppwo = nblst*nblst + 1
                 j0 = j - nnb
                 do j = j0, jcol+1, -nnb
                    if ( blk22 ) then
                       ! exploit the structure of
                              ! [  u11  u12  ]
                          ! u = [            ]
                              ! [  u21  u22  ],
                       ! where all blocks are nnb-by-nnb, u21 is upper
                       ! triangular and u12 is lower triangular.
                       call stdlib_sorm22( 'LEFT', 'TRANSPOSE', 2*nnb, cola, nnb,nnb, work( ppwo )&
                                 , 2*nnb,a( j, jcol+nnb ), lda, work( pw ),lwork-pw+1, ierr )
                    else
                       ! ignore the structure of u.
                       call stdlib_sgemm( 'TRANSPOSE', 'NO TRANSPOSE', 2*nnb,cola, 2*nnb, one, &
                                 work( ppwo ), 2*nnb,a( j, jcol+nnb ), lda, zero, work( pw ),2*nnb )
                       call stdlib_slacpy( 'ALL', 2*nnb, cola, work( pw ), 2*nnb,a( j, jcol+nnb ),&
                                  lda )
                    end if
                    ppwo = ppwo + 4*nnb*nnb
                 end do
                 ! apply accumulated orthogonal matrices to q.
                 if( wantq ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_sgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, one, q( &
                              topq, j ), ldq,work, nblst, zero, work( pw ), nh )
                    call stdlib_slacpy( 'ALL', nh, nblst, work( pw ), nh,q( topq, j ), ldq )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_sorm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,q( topq, j ), ldq, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_sgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, one,&
                                     q( topq, j ), ldq,work( ppwo ), 2*nnb, zero, work( pw ),nh )
                          call stdlib_slacpy( 'ALL', nh, 2*nnb, work( pw ), nh,q( topq, j ), ldq )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! accumulate right givens rotations if required.
                 if ( wantz .or. top>0 ) then
                    ! initialize small orthogonal factors that will hold the
                    ! accumulated givens rotations in workspace.
                    call stdlib_slaset( 'ALL', nblst, nblst, zero, one, work,nblst )
                    pw = nblst * nblst + 1
                    do i = 1, n2nb
                       call stdlib_slaset( 'ALL', 2*nnb, 2*nnb, zero, one,work( pw ), 2*nnb )
                                 
                       pw = pw + 4*nnb*nnb
                    end do
                    ! accumulate givens rotations into workspace array.
                    do j = jcol, jcol+nnb-1
                       ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                       len  = 2 + j - jcol
                       jrow = j + n2nb*nnb + 2
                       do i = ihi, jrow, -1
                          c = a( i, j )
                          a( i, j ) = zero
                          s = b( i, j )
                          b( i, j ) = zero
                          do jj = ppw, ppw+len-1
                             temp = work( jj + nblst )
                             work( jj + nblst ) = c*temp - s*work( jj )
                             work( jj ) = s*temp + c*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - nblst - 1
                       end do
                       ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                       j0 = jrow - nnb
                       do jrow = j0, j+2, -nnb
                          ppw = ppwo
                          len  = 2 + j - jcol
                          do i = jrow+nnb-1, jrow, -1
                             c = a( i, j )
                             a( i, j ) = zero
                             s = b( i, j )
                             b( i, j ) = zero
                             do jj = ppw, ppw+len-1
                                temp = work( jj + 2*nnb )
                                work( jj + 2*nnb ) = c*temp - s*work( jj )
                                work( jj ) = s*temp + c*work( jj )
                             end do
                             len = len + 1
                             ppw = ppw - 2*nnb - 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end do
                 else
                    call stdlib_slaset( 'LOWER', ihi - jcol - 1, nnb, zero, zero,a( jcol + 2, &
                              jcol ), lda )
                    call stdlib_slaset( 'LOWER', ihi - jcol - 1, nnb, zero, zero,b( jcol + 2, &
                              jcol ), ldb )
                 end if
                 ! apply accumulated orthogonal matrices to a and b.
                 if ( top>0 ) then
                    j = ihi - nblst + 1
                    call stdlib_sgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, one, a( &
                              1, j ), lda,work, nblst, zero, work( pw ), top )
                    call stdlib_slacpy( 'ALL', top, nblst, work( pw ), top,a( 1, j ), lda )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_sorm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,a( 1, j ), lda, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_sgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                                    one, a( 1, j ), lda,work( ppwo ), 2*nnb, zero,work( pw ), top )
                          call stdlib_slacpy( 'ALL', top, 2*nnb, work( pw ), top,a( 1, j ), lda )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    j = ihi - nblst + 1
                    call stdlib_sgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, one, b( &
                              1, j ), ldb,work, nblst, zero, work( pw ), top )
                    call stdlib_slacpy( 'ALL', top, nblst, work( pw ), top,b( 1, j ), ldb )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_sorm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,b( 1, j ), ldb, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_sgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                                    one, b( 1, j ), ldb,work( ppwo ), 2*nnb, zero,work( pw ), top )
                          call stdlib_slacpy( 'ALL', top, 2*nnb, work( pw ), top,b( 1, j ), ldb )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! apply accumulated orthogonal matrices to z.
                 if( wantz ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_sgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, one, z( &
                              topq, j ), ldz,work, nblst, zero, work( pw ), nh )
                    call stdlib_slacpy( 'ALL', nh, nblst, work( pw ), nh,z( topq, j ), ldz )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                          if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_sorm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,z( topq, j ), ldz, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_sgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, one,&
                                     z( topq, j ), ldz,work( ppwo ), 2*nnb, zero, work( pw ),nh )
                          call stdlib_slacpy( 'ALL', nh, 2*nnb, work( pw ), nh,z( topq, j ), ldz )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           ! avoid re-initialization of modified q and z.
           compq2 = compq
           compz2 = compz
           if ( jcol/=ilo ) then
              if ( wantq )compq2 = 'V'
              if ( wantz )compz2 = 'V'
           end if
           if ( jcol<ihi )call stdlib_sgghrd( compq2, compz2, n, jcol, ihi, a, lda, b, ldb, q,ldq,&
                      z, ldz, ierr )
           work( 1 ) = real( lwkopt,KIND=sp)
           return
     end subroutine stdlib_sgghd3

     module pure subroutine stdlib_dgghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! DGGHD3 reduces a pair of real matrices (A,B) to generalized upper
     !! Hessenberg form using orthogonal transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the orthogonal matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**T*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**T*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**T*x.
     !! The orthogonal matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T
     !! Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T
     !! If Q1 is the orthogonal matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then DGGHD3 reduces the original
     !! problem to generalized Hessenberg form.
     !! This is a blocked variant of DGGHRD, using matrix-matrix
     !! multiplications for parts of the computation to enhance performance.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(dp), intent(out) :: work(*)
       ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: blk22, initq, initz, lquery, wantq, wantz
           character :: compq2, compz2
           integer(ilp) :: cola, i, ierr, j, j0, jcol, jj, jrow, k, kacc22, len, lwkopt, n2nb, nb,&
                      nblst, nbmin, nh, nnb, nx, ppw, ppwo, pw, top, topq
           real(dp) :: c, c1, c2, s, s1, s2, temp, temp1, temp2, temp3
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           info = 0
           nb = stdlib_ilaenv( 1, 'DGGHD3', ' ', n, ilo, ihi, -1 )
           lwkopt = max( 6*n*nb, 1 )
           work( 1 ) = real( lwkopt,KIND=dp)
           initq = stdlib_lsame( compq, 'I' )
           wantq = initq .or. stdlib_lsame( compq, 'V' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( wantq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( wantz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           else if( lwork<1 .and. .not.lquery ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGHD3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! initialize q and z if desired.
           if( initq )call stdlib_dlaset( 'ALL', n, n, zero, one, q, ldq )
           if( initz )call stdlib_dlaset( 'ALL', n, n, zero, one, z, ldz )
           ! zero out lower triangle of b.
           if( n>1 )call stdlib_dlaset( 'LOWER', n-1, n-1, zero, zero, b(2, 1), ldb )
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = one
              return
           end if
           ! determine the blocksize.
           nbmin = stdlib_ilaenv( 2, 'DGGHD3', ' ', n, ilo, ihi, -1 )
           if( nb>1 .and. nb<nh ) then
              ! determine when to use unblocked instead of blocked code.
              nx = max( nb, stdlib_ilaenv( 3, 'DGGHD3', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code.
                 if( lwork<lwkopt ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code.
                    nbmin = max( 2, stdlib_ilaenv( 2, 'DGGHD3', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=6*n*nbmin ) then
                       nb = lwork / ( 6*n )
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              jcol = ilo
           else
              ! use blocked code
              kacc22 = stdlib_ilaenv( 16, 'DGGHD3', ' ', n, ilo, ihi, -1 )
              blk22 = kacc22==2
              do jcol = ilo, ihi-2, nb
                 nnb = min( nb, ihi-jcol-1 )
                 ! initialize small orthogonal factors that will hold the
                 ! accumulated givens rotations in workspace.
                 ! n2nb   denotes the number of 2*nnb-by-2*nnb factors
                 ! nblst  denotes the (possibly smaller) order of the last
                        ! factor.
                 n2nb = ( ihi-jcol-1 ) / nnb - 1
                 nblst = ihi - jcol - n2nb*nnb
                 call stdlib_dlaset( 'ALL', nblst, nblst, zero, one, work, nblst )
                 pw = nblst * nblst + 1
                 do i = 1, n2nb
                    call stdlib_dlaset( 'ALL', 2*nnb, 2*nnb, zero, one,work( pw ), 2*nnb )
                    pw = pw + 4*nnb*nnb
                 end do
                 ! reduce columns jcol:jcol+nnb-1 of a to hessenberg form.
                 do j = jcol, jcol+nnb-1
                    ! reduce jth column of a. store cosines and sines in jth
                    ! column of a and b, respectively.
                    do i = ihi, j+2, -1
                       temp = a( i-1, j )
                       call stdlib_dlartg( temp, a( i, j ), c, s, a( i-1, j ) )
                       a( i, j ) = c
                       b( i, j ) = s
                    end do
                    ! accumulate givens rotations into workspace array.
                    ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                    len  = 2 + j - jcol
                    jrow = j + n2nb*nnb + 2
                    do i = ihi, jrow, -1
                       c = a( i, j )
                       s = b( i, j )
                       do jj = ppw, ppw+len-1
                          temp = work( jj + nblst )
                          work( jj + nblst ) = c*temp - s*work( jj )
                          work( jj ) = s*temp + c*work( jj )
                       end do
                       len = len + 1
                       ppw = ppw - nblst - 1
                    end do
                    ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                    j0 = jrow - nnb
                    do jrow = j0, j+2, -nnb
                       ppw = ppwo
                       len  = 2 + j - jcol
                       do i = jrow+nnb-1, jrow, -1
                          c = a( i, j )
                          s = b( i, j )
                          do jj = ppw, ppw+len-1
                             temp = work( jj + 2*nnb )
                             work( jj + 2*nnb ) = c*temp - s*work( jj )
                             work( jj ) = s*temp + c*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - 2*nnb - 1
                       end do
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    ! top denotes the number of top rows in a and b that will
                    ! not be updated during the next steps.
                    if( jcol<=2 ) then
                       top = 0
                    else
                       top = jcol
                    end if
                    ! propagate transformations through b and replace stored
                    ! left sines/cosines by right sines/cosines.
                    do jj = n, j+1, -1
                       ! update jjth column of b.
                       do i = min( jj+1, ihi ), j+2, -1
                          c = a( i, j )
                          s = b( i, j )
                          temp = b( i, jj )
                          b( i, jj ) = c*temp - s*b( i-1, jj )
                          b( i-1, jj ) = s*temp + c*b( i-1, jj )
                       end do
                       ! annihilate b( jj+1, jj ).
                       if( jj<ihi ) then
                          temp = b( jj+1, jj+1 )
                          call stdlib_dlartg( temp, b( jj+1, jj ), c, s,b( jj+1, jj+1 ) )
                          b( jj+1, jj ) = zero
                          call stdlib_drot( jj-top, b( top+1, jj+1 ), 1,b( top+1, jj ), 1, c, s )
                                    
                          a( jj+1, j ) = c
                          b( jj+1, j ) = -s
                       end if
                    end do
                    ! update a by transformations from right.
                    ! explicit loop unrolling provides better performance
                    ! compared to stdlib_dlasr.
                     ! call stdlib_dlasr( 'right', 'variable', 'backward', ihi-top,
           ! $                     ihi-j, a( j+2, j ), b( j+2, j ),
           ! $                     a( top+1, j+1 ), lda )
                    jj = mod( ihi-j-1, 3 )
                    do i = ihi-j-3, jj+1, -3
                       c = a( j+1+i, j )
                       s = -b( j+1+i, j )
                       c1 = a( j+2+i, j )
                       s1 = -b( j+2+i, j )
                       c2 = a( j+3+i, j )
                       s2 = -b( j+3+i, j )
                       do k = top+1, ihi
                          temp = a( k, j+i  )
                          temp1 = a( k, j+i+1 )
                          temp2 = a( k, j+i+2 )
                          temp3 = a( k, j+i+3 )
                          a( k, j+i+3 ) = c2*temp3 + s2*temp2
                          temp2 = -s2*temp3 + c2*temp2
                          a( k, j+i+2 ) = c1*temp2 + s1*temp1
                          temp1 = -s1*temp2 + c1*temp1
                          a( k, j+i+1 ) = c*temp1 + s*temp
                          a( k, j+i ) = -s*temp1 + c*temp
                       end do
                    end do
                    if( jj>0 ) then
                       do i = jj, 1, -1
                          call stdlib_drot( ihi-top, a( top+1, j+i+1 ), 1,a( top+1, j+i ), 1, a( &
                                    j+1+i, j ),-b( j+1+i, j ) )
                       end do
                    end if
                    ! update (j+1)th column of a by transformations from left.
                    if ( j < jcol + nnb - 1 ) then
                       len  = 1 + j - jcol
                       ! multiply with the trailing accumulated orthogonal
                       ! matrix, which takes the form
                              ! [  u11  u12  ]
                          ! u = [            ],
                              ! [  u21  u22  ]
                       ! where u21 is a len-by-len matrix and u12 is lower
                       ! triangular.
                       jrow = ihi - nblst + 1
                       call stdlib_dgemv( 'TRANSPOSE', nblst, len, one, work,nblst, a( jrow, j+1 )&
                                 , 1, zero,work( pw ), 1 )
                       ppw = pw + len
                       do i = jrow, jrow+nblst-len-1
                          work( ppw ) = a( i, j+1 )
                          ppw = ppw + 1
                       end do
                       call stdlib_dtrmv( 'LOWER', 'TRANSPOSE', 'NON-UNIT',nblst-len, work( &
                                 len*nblst + 1 ), nblst,work( pw+len ), 1 )
                       call stdlib_dgemv( 'TRANSPOSE', len, nblst-len, one,work( (len+1)*nblst - &
                       len + 1 ), nblst,a( jrow+nblst-len, j+1 ), 1, one,work( pw+len ), 1 )
                                 
                       ppw = pw
                       do i = jrow, jrow+nblst-1
                          a( i, j+1 ) = work( ppw )
                          ppw = ppw + 1
                       end do
                       ! multiply with the other accumulated orthogonal
                       ! matrices, which take the form
                              ! [  u11  u12   0  ]
                              ! [                ]
                          ! u = [  u21  u22   0  ],
                              ! [                ]
                              ! [   0    0    i  ]
                       ! where i denotes the (nnb-len)-by-(nnb-len) identity
                       ! matrix, u21 is a len-by-len upper triangular matrix
                       ! and u12 is an nnb-by-nnb lower triangular matrix.
                       ppwo = 1 + nblst*nblst
                       j0 = jrow - nnb
                       do jrow = j0, jcol+1, -nnb
                          ppw = pw + len
                          do i = jrow, jrow+nnb-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          ppw = pw
                          do i = jrow+nnb, jrow+nnb+len-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          call stdlib_dtrmv( 'UPPER', 'TRANSPOSE', 'NON-UNIT', len,work( ppwo + &
                                    nnb ), 2*nnb, work( pw ),1 )
                          call stdlib_dtrmv( 'LOWER', 'TRANSPOSE', 'NON-UNIT', nnb,work( ppwo + &
                                    2*len*nnb ),2*nnb, work( pw + len ), 1 )
                          call stdlib_dgemv( 'TRANSPOSE', nnb, len, one,work( ppwo ), 2*nnb, a( &
                                    jrow, j+1 ), 1,one, work( pw ), 1 )
                          call stdlib_dgemv( 'TRANSPOSE', len, nnb, one,work( ppwo + 2*len*nnb + &
                                    nnb ), 2*nnb,a( jrow+nnb, j+1 ), 1, one,work( pw+len ), 1 )
                          ppw = pw
                          do i = jrow, jrow+len+nnb-1
                             a( i, j+1 ) = work( ppw )
                             ppw = ppw + 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end if
                 end do
                 ! apply accumulated orthogonal matrices to a.
                 cola = n - jcol - nnb + 1
                 j = ihi - nblst + 1
                 call stdlib_dgemm( 'TRANSPOSE', 'NO TRANSPOSE', nblst,cola, nblst, one, work, &
                           nblst,a( j, jcol+nnb ), lda, zero, work( pw ),nblst )
                 call stdlib_dlacpy( 'ALL', nblst, cola, work( pw ), nblst,a( j, jcol+nnb ), lda )
                           
                 ppwo = nblst*nblst + 1
                 j0 = j - nnb
                 do j = j0, jcol+1, -nnb
                    if ( blk22 ) then
                       ! exploit the structure of
                              ! [  u11  u12  ]
                          ! u = [            ]
                              ! [  u21  u22  ],
                       ! where all blocks are nnb-by-nnb, u21 is upper
                       ! triangular and u12 is lower triangular.
                       call stdlib_dorm22( 'LEFT', 'TRANSPOSE', 2*nnb, cola, nnb,nnb, work( ppwo )&
                                 , 2*nnb,a( j, jcol+nnb ), lda, work( pw ),lwork-pw+1, ierr )
                    else
                       ! ignore the structure of u.
                       call stdlib_dgemm( 'TRANSPOSE', 'NO TRANSPOSE', 2*nnb,cola, 2*nnb, one, &
                                 work( ppwo ), 2*nnb,a( j, jcol+nnb ), lda, zero, work( pw ),2*nnb )
                       call stdlib_dlacpy( 'ALL', 2*nnb, cola, work( pw ), 2*nnb,a( j, jcol+nnb ),&
                                  lda )
                    end if
                    ppwo = ppwo + 4*nnb*nnb
                 end do
                 ! apply accumulated orthogonal matrices to q.
                 if( wantq ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_dgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, one, q( &
                              topq, j ), ldq,work, nblst, zero, work( pw ), nh )
                    call stdlib_dlacpy( 'ALL', nh, nblst, work( pw ), nh,q( topq, j ), ldq )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_dorm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,q( topq, j ), ldq, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_dgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, one,&
                                     q( topq, j ), ldq,work( ppwo ), 2*nnb, zero, work( pw ),nh )
                          call stdlib_dlacpy( 'ALL', nh, 2*nnb, work( pw ), nh,q( topq, j ), ldq )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! accumulate right givens rotations if required.
                 if ( wantz .or. top>0 ) then
                    ! initialize small orthogonal factors that will hold the
                    ! accumulated givens rotations in workspace.
                    call stdlib_dlaset( 'ALL', nblst, nblst, zero, one, work,nblst )
                    pw = nblst * nblst + 1
                    do i = 1, n2nb
                       call stdlib_dlaset( 'ALL', 2*nnb, 2*nnb, zero, one,work( pw ), 2*nnb )
                                 
                       pw = pw + 4*nnb*nnb
                    end do
                    ! accumulate givens rotations into workspace array.
                    do j = jcol, jcol+nnb-1
                       ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                       len  = 2 + j - jcol
                       jrow = j + n2nb*nnb + 2
                       do i = ihi, jrow, -1
                          c = a( i, j )
                          a( i, j ) = zero
                          s = b( i, j )
                          b( i, j ) = zero
                          do jj = ppw, ppw+len-1
                             temp = work( jj + nblst )
                             work( jj + nblst ) = c*temp - s*work( jj )
                             work( jj ) = s*temp + c*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - nblst - 1
                       end do
                       ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                       j0 = jrow - nnb
                       do jrow = j0, j+2, -nnb
                          ppw = ppwo
                          len  = 2 + j - jcol
                          do i = jrow+nnb-1, jrow, -1
                             c = a( i, j )
                             a( i, j ) = zero
                             s = b( i, j )
                             b( i, j ) = zero
                             do jj = ppw, ppw+len-1
                                temp = work( jj + 2*nnb )
                                work( jj + 2*nnb ) = c*temp - s*work( jj )
                                work( jj ) = s*temp + c*work( jj )
                             end do
                             len = len + 1
                             ppw = ppw - 2*nnb - 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end do
                 else
                    call stdlib_dlaset( 'LOWER', ihi - jcol - 1, nnb, zero, zero,a( jcol + 2, &
                              jcol ), lda )
                    call stdlib_dlaset( 'LOWER', ihi - jcol - 1, nnb, zero, zero,b( jcol + 2, &
                              jcol ), ldb )
                 end if
                 ! apply accumulated orthogonal matrices to a and b.
                 if ( top>0 ) then
                    j = ihi - nblst + 1
                    call stdlib_dgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, one, a( &
                              1, j ), lda,work, nblst, zero, work( pw ), top )
                    call stdlib_dlacpy( 'ALL', top, nblst, work( pw ), top,a( 1, j ), lda )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_dorm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,a( 1, j ), lda, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_dgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                                    one, a( 1, j ), lda,work( ppwo ), 2*nnb, zero,work( pw ), top )
                          call stdlib_dlacpy( 'ALL', top, 2*nnb, work( pw ), top,a( 1, j ), lda )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    j = ihi - nblst + 1
                    call stdlib_dgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, one, b( &
                              1, j ), ldb,work, nblst, zero, work( pw ), top )
                    call stdlib_dlacpy( 'ALL', top, nblst, work( pw ), top,b( 1, j ), ldb )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_dorm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,b( 1, j ), ldb, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_dgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                                    one, b( 1, j ), ldb,work( ppwo ), 2*nnb, zero,work( pw ), top )
                          call stdlib_dlacpy( 'ALL', top, 2*nnb, work( pw ), top,b( 1, j ), ldb )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! apply accumulated orthogonal matrices to z.
                 if( wantz ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_dgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, one, z( &
                              topq, j ), ldz,work, nblst, zero, work( pw ), nh )
                    call stdlib_dlacpy( 'ALL', nh, nblst, work( pw ), nh,z( topq, j ), ldz )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                          if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_dorm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,z( topq, j ), ldz, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_dgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, one,&
                                     z( topq, j ), ldz,work( ppwo ), 2*nnb, zero, work( pw ),nh )
                          call stdlib_dlacpy( 'ALL', nh, 2*nnb, work( pw ), nh,z( topq, j ), ldz )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           ! avoid re-initialization of modified q and z.
           compq2 = compq
           compz2 = compz
           if ( jcol/=ilo ) then
              if ( wantq )compq2 = 'V'
              if ( wantz )compz2 = 'V'
           end if
           if ( jcol<ihi )call stdlib_dgghrd( compq2, compz2, n, jcol, ihi, a, lda, b, ldb, q,ldq,&
                      z, ldz, ierr )
           work( 1 ) = real( lwkopt,KIND=dp)
           return
     end subroutine stdlib_dgghd3

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$gghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! DGGHD3: reduces a pair of real matrices (A,B) to generalized upper
     !! Hessenberg form using orthogonal transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the orthogonal matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**T*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**T*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**T*x.
     !! The orthogonal matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T
     !! Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T
     !! If Q1 is the orthogonal matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then DGGHD3 reduces the original
     !! problem to generalized Hessenberg form.
     !! This is a blocked variant of DGGHRD, using matrix-matrix
     !! multiplications for parts of the computation to enhance performance.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(${rk}$), intent(out) :: work(*)
       ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: blk22, initq, initz, lquery, wantq, wantz
           character :: compq2, compz2
           integer(ilp) :: cola, i, ierr, j, j0, jcol, jj, jrow, k, kacc22, len, lwkopt, n2nb, nb,&
                      nblst, nbmin, nh, nnb, nx, ppw, ppwo, pw, top, topq
           real(${rk}$) :: c, c1, c2, s, s1, s2, temp, temp1, temp2, temp3
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           info = 0
           nb = stdlib_ilaenv( 1, 'DGGHD3', ' ', n, ilo, ihi, -1 )
           lwkopt = max( 6*n*nb, 1 )
           work( 1 ) = real( lwkopt,KIND=${rk}$)
           initq = stdlib_lsame( compq, 'I' )
           wantq = initq .or. stdlib_lsame( compq, 'V' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( wantq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( wantz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           else if( lwork<1 .and. .not.lquery ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGHD3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! initialize q and z if desired.
           if( initq )call stdlib_${ri}$laset( 'ALL', n, n, zero, one, q, ldq )
           if( initz )call stdlib_${ri}$laset( 'ALL', n, n, zero, one, z, ldz )
           ! zero out lower triangle of b.
           if( n>1 )call stdlib_${ri}$laset( 'LOWER', n-1, n-1, zero, zero, b(2, 1), ldb )
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = one
              return
           end if
           ! determine the blocksize.
           nbmin = stdlib_ilaenv( 2, 'DGGHD3', ' ', n, ilo, ihi, -1 )
           if( nb>1 .and. nb<nh ) then
              ! determine when to use unblocked instead of blocked code.
              nx = max( nb, stdlib_ilaenv( 3, 'DGGHD3', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code.
                 if( lwork<lwkopt ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code.
                    nbmin = max( 2, stdlib_ilaenv( 2, 'DGGHD3', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=6*n*nbmin ) then
                       nb = lwork / ( 6*n )
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              jcol = ilo
           else
              ! use blocked code
              kacc22 = stdlib_ilaenv( 16, 'DGGHD3', ' ', n, ilo, ihi, -1 )
              blk22 = kacc22==2
              do jcol = ilo, ihi-2, nb
                 nnb = min( nb, ihi-jcol-1 )
                 ! initialize small orthogonal factors that will hold the
                 ! accumulated givens rotations in workspace.
                 ! n2nb   denotes the number of 2*nnb-by-2*nnb factors
                 ! nblst  denotes the (possibly smaller) order of the last
                        ! factor.
                 n2nb = ( ihi-jcol-1 ) / nnb - 1
                 nblst = ihi - jcol - n2nb*nnb
                 call stdlib_${ri}$laset( 'ALL', nblst, nblst, zero, one, work, nblst )
                 pw = nblst * nblst + 1
                 do i = 1, n2nb
                    call stdlib_${ri}$laset( 'ALL', 2*nnb, 2*nnb, zero, one,work( pw ), 2*nnb )
                    pw = pw + 4*nnb*nnb
                 end do
                 ! reduce columns jcol:jcol+nnb-1 of a to hessenberg form.
                 do j = jcol, jcol+nnb-1
                    ! reduce jth column of a. store cosines and sines in jth
                    ! column of a and b, respectively.
                    do i = ihi, j+2, -1
                       temp = a( i-1, j )
                       call stdlib_${ri}$lartg( temp, a( i, j ), c, s, a( i-1, j ) )
                       a( i, j ) = c
                       b( i, j ) = s
                    end do
                    ! accumulate givens rotations into workspace array.
                    ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                    len  = 2 + j - jcol
                    jrow = j + n2nb*nnb + 2
                    do i = ihi, jrow, -1
                       c = a( i, j )
                       s = b( i, j )
                       do jj = ppw, ppw+len-1
                          temp = work( jj + nblst )
                          work( jj + nblst ) = c*temp - s*work( jj )
                          work( jj ) = s*temp + c*work( jj )
                       end do
                       len = len + 1
                       ppw = ppw - nblst - 1
                    end do
                    ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                    j0 = jrow - nnb
                    do jrow = j0, j+2, -nnb
                       ppw = ppwo
                       len  = 2 + j - jcol
                       do i = jrow+nnb-1, jrow, -1
                          c = a( i, j )
                          s = b( i, j )
                          do jj = ppw, ppw+len-1
                             temp = work( jj + 2*nnb )
                             work( jj + 2*nnb ) = c*temp - s*work( jj )
                             work( jj ) = s*temp + c*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - 2*nnb - 1
                       end do
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    ! top denotes the number of top rows in a and b that will
                    ! not be updated during the next steps.
                    if( jcol<=2 ) then
                       top = 0
                    else
                       top = jcol
                    end if
                    ! propagate transformations through b and replace stored
                    ! left sines/cosines by right sines/cosines.
                    do jj = n, j+1, -1
                       ! update jjth column of b.
                       do i = min( jj+1, ihi ), j+2, -1
                          c = a( i, j )
                          s = b( i, j )
                          temp = b( i, jj )
                          b( i, jj ) = c*temp - s*b( i-1, jj )
                          b( i-1, jj ) = s*temp + c*b( i-1, jj )
                       end do
                       ! annihilate b( jj+1, jj ).
                       if( jj<ihi ) then
                          temp = b( jj+1, jj+1 )
                          call stdlib_${ri}$lartg( temp, b( jj+1, jj ), c, s,b( jj+1, jj+1 ) )
                          b( jj+1, jj ) = zero
                          call stdlib_${ri}$rot( jj-top, b( top+1, jj+1 ), 1,b( top+1, jj ), 1, c, s )
                                    
                          a( jj+1, j ) = c
                          b( jj+1, j ) = -s
                       end if
                    end do
                    ! update a by transformations from right.
                    ! explicit loop unrolling provides better performance
                    ! compared to stdlib_${ri}$lasr.
                     ! call stdlib_${ri}$lasr( 'right', 'variable', 'backward', ihi-top,
           ! $                     ihi-j, a( j+2, j ), b( j+2, j ),
           ! $                     a( top+1, j+1 ), lda )
                    jj = mod( ihi-j-1, 3 )
                    do i = ihi-j-3, jj+1, -3
                       c = a( j+1+i, j )
                       s = -b( j+1+i, j )
                       c1 = a( j+2+i, j )
                       s1 = -b( j+2+i, j )
                       c2 = a( j+3+i, j )
                       s2 = -b( j+3+i, j )
                       do k = top+1, ihi
                          temp = a( k, j+i  )
                          temp1 = a( k, j+i+1 )
                          temp2 = a( k, j+i+2 )
                          temp3 = a( k, j+i+3 )
                          a( k, j+i+3 ) = c2*temp3 + s2*temp2
                          temp2 = -s2*temp3 + c2*temp2
                          a( k, j+i+2 ) = c1*temp2 + s1*temp1
                          temp1 = -s1*temp2 + c1*temp1
                          a( k, j+i+1 ) = c*temp1 + s*temp
                          a( k, j+i ) = -s*temp1 + c*temp
                       end do
                    end do
                    if( jj>0 ) then
                       do i = jj, 1, -1
                          call stdlib_${ri}$rot( ihi-top, a( top+1, j+i+1 ), 1,a( top+1, j+i ), 1, a( &
                                    j+1+i, j ),-b( j+1+i, j ) )
                       end do
                    end if
                    ! update (j+1)th column of a by transformations from left.
                    if ( j < jcol + nnb - 1 ) then
                       len  = 1 + j - jcol
                       ! multiply with the trailing accumulated orthogonal
                       ! matrix, which takes the form
                              ! [  u11  u12  ]
                          ! u = [            ],
                              ! [  u21  u22  ]
                       ! where u21 is a len-by-len matrix and u12 is lower
                       ! triangular.
                       jrow = ihi - nblst + 1
                       call stdlib_${ri}$gemv( 'TRANSPOSE', nblst, len, one, work,nblst, a( jrow, j+1 )&
                                 , 1, zero,work( pw ), 1 )
                       ppw = pw + len
                       do i = jrow, jrow+nblst-len-1
                          work( ppw ) = a( i, j+1 )
                          ppw = ppw + 1
                       end do
                       call stdlib_${ri}$trmv( 'LOWER', 'TRANSPOSE', 'NON-UNIT',nblst-len, work( &
                                 len*nblst + 1 ), nblst,work( pw+len ), 1 )
                       call stdlib_${ri}$gemv( 'TRANSPOSE', len, nblst-len, one,work( (len+1)*nblst - &
                       len + 1 ), nblst,a( jrow+nblst-len, j+1 ), 1, one,work( pw+len ), 1 )
                                 
                       ppw = pw
                       do i = jrow, jrow+nblst-1
                          a( i, j+1 ) = work( ppw )
                          ppw = ppw + 1
                       end do
                       ! multiply with the other accumulated orthogonal
                       ! matrices, which take the form
                              ! [  u11  u12   0  ]
                              ! [                ]
                          ! u = [  u21  u22   0  ],
                              ! [                ]
                              ! [   0    0    i  ]
                       ! where i denotes the (nnb-len)-by-(nnb-len) identity
                       ! matrix, u21 is a len-by-len upper triangular matrix
                       ! and u12 is an nnb-by-nnb lower triangular matrix.
                       ppwo = 1 + nblst*nblst
                       j0 = jrow - nnb
                       do jrow = j0, jcol+1, -nnb
                          ppw = pw + len
                          do i = jrow, jrow+nnb-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          ppw = pw
                          do i = jrow+nnb, jrow+nnb+len-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          call stdlib_${ri}$trmv( 'UPPER', 'TRANSPOSE', 'NON-UNIT', len,work( ppwo + &
                                    nnb ), 2*nnb, work( pw ),1 )
                          call stdlib_${ri}$trmv( 'LOWER', 'TRANSPOSE', 'NON-UNIT', nnb,work( ppwo + &
                                    2*len*nnb ),2*nnb, work( pw + len ), 1 )
                          call stdlib_${ri}$gemv( 'TRANSPOSE', nnb, len, one,work( ppwo ), 2*nnb, a( &
                                    jrow, j+1 ), 1,one, work( pw ), 1 )
                          call stdlib_${ri}$gemv( 'TRANSPOSE', len, nnb, one,work( ppwo + 2*len*nnb + &
                                    nnb ), 2*nnb,a( jrow+nnb, j+1 ), 1, one,work( pw+len ), 1 )
                          ppw = pw
                          do i = jrow, jrow+len+nnb-1
                             a( i, j+1 ) = work( ppw )
                             ppw = ppw + 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end if
                 end do
                 ! apply accumulated orthogonal matrices to a.
                 cola = n - jcol - nnb + 1
                 j = ihi - nblst + 1
                 call stdlib_${ri}$gemm( 'TRANSPOSE', 'NO TRANSPOSE', nblst,cola, nblst, one, work, &
                           nblst,a( j, jcol+nnb ), lda, zero, work( pw ),nblst )
                 call stdlib_${ri}$lacpy( 'ALL', nblst, cola, work( pw ), nblst,a( j, jcol+nnb ), lda )
                           
                 ppwo = nblst*nblst + 1
                 j0 = j - nnb
                 do j = j0, jcol+1, -nnb
                    if ( blk22 ) then
                       ! exploit the structure of
                              ! [  u11  u12  ]
                          ! u = [            ]
                              ! [  u21  u22  ],
                       ! where all blocks are nnb-by-nnb, u21 is upper
                       ! triangular and u12 is lower triangular.
                       call stdlib_${ri}$orm22( 'LEFT', 'TRANSPOSE', 2*nnb, cola, nnb,nnb, work( ppwo )&
                                 , 2*nnb,a( j, jcol+nnb ), lda, work( pw ),lwork-pw+1, ierr )
                    else
                       ! ignore the structure of u.
                       call stdlib_${ri}$gemm( 'TRANSPOSE', 'NO TRANSPOSE', 2*nnb,cola, 2*nnb, one, &
                                 work( ppwo ), 2*nnb,a( j, jcol+nnb ), lda, zero, work( pw ),2*nnb )
                       call stdlib_${ri}$lacpy( 'ALL', 2*nnb, cola, work( pw ), 2*nnb,a( j, jcol+nnb ),&
                                  lda )
                    end if
                    ppwo = ppwo + 4*nnb*nnb
                 end do
                 ! apply accumulated orthogonal matrices to q.
                 if( wantq ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, one, q( &
                              topq, j ), ldq,work, nblst, zero, work( pw ), nh )
                    call stdlib_${ri}$lacpy( 'ALL', nh, nblst, work( pw ), nh,q( topq, j ), ldq )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_${ri}$orm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,q( topq, j ), ldq, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, one,&
                                     q( topq, j ), ldq,work( ppwo ), 2*nnb, zero, work( pw ),nh )
                          call stdlib_${ri}$lacpy( 'ALL', nh, 2*nnb, work( pw ), nh,q( topq, j ), ldq )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! accumulate right givens rotations if required.
                 if ( wantz .or. top>0 ) then
                    ! initialize small orthogonal factors that will hold the
                    ! accumulated givens rotations in workspace.
                    call stdlib_${ri}$laset( 'ALL', nblst, nblst, zero, one, work,nblst )
                    pw = nblst * nblst + 1
                    do i = 1, n2nb
                       call stdlib_${ri}$laset( 'ALL', 2*nnb, 2*nnb, zero, one,work( pw ), 2*nnb )
                                 
                       pw = pw + 4*nnb*nnb
                    end do
                    ! accumulate givens rotations into workspace array.
                    do j = jcol, jcol+nnb-1
                       ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                       len  = 2 + j - jcol
                       jrow = j + n2nb*nnb + 2
                       do i = ihi, jrow, -1
                          c = a( i, j )
                          a( i, j ) = zero
                          s = b( i, j )
                          b( i, j ) = zero
                          do jj = ppw, ppw+len-1
                             temp = work( jj + nblst )
                             work( jj + nblst ) = c*temp - s*work( jj )
                             work( jj ) = s*temp + c*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - nblst - 1
                       end do
                       ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                       j0 = jrow - nnb
                       do jrow = j0, j+2, -nnb
                          ppw = ppwo
                          len  = 2 + j - jcol
                          do i = jrow+nnb-1, jrow, -1
                             c = a( i, j )
                             a( i, j ) = zero
                             s = b( i, j )
                             b( i, j ) = zero
                             do jj = ppw, ppw+len-1
                                temp = work( jj + 2*nnb )
                                work( jj + 2*nnb ) = c*temp - s*work( jj )
                                work( jj ) = s*temp + c*work( jj )
                             end do
                             len = len + 1
                             ppw = ppw - 2*nnb - 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end do
                 else
                    call stdlib_${ri}$laset( 'LOWER', ihi - jcol - 1, nnb, zero, zero,a( jcol + 2, &
                              jcol ), lda )
                    call stdlib_${ri}$laset( 'LOWER', ihi - jcol - 1, nnb, zero, zero,b( jcol + 2, &
                              jcol ), ldb )
                 end if
                 ! apply accumulated orthogonal matrices to a and b.
                 if ( top>0 ) then
                    j = ihi - nblst + 1
                    call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, one, a( &
                              1, j ), lda,work, nblst, zero, work( pw ), top )
                    call stdlib_${ri}$lacpy( 'ALL', top, nblst, work( pw ), top,a( 1, j ), lda )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_${ri}$orm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,a( 1, j ), lda, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                                    one, a( 1, j ), lda,work( ppwo ), 2*nnb, zero,work( pw ), top )
                          call stdlib_${ri}$lacpy( 'ALL', top, 2*nnb, work( pw ), top,a( 1, j ), lda )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    j = ihi - nblst + 1
                    call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, one, b( &
                              1, j ), ldb,work, nblst, zero, work( pw ), top )
                    call stdlib_${ri}$lacpy( 'ALL', top, nblst, work( pw ), top,b( 1, j ), ldb )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_${ri}$orm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,b( 1, j ), ldb, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                                    one, b( 1, j ), ldb,work( ppwo ), 2*nnb, zero,work( pw ), top )
                          call stdlib_${ri}$lacpy( 'ALL', top, 2*nnb, work( pw ), top,b( 1, j ), ldb )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! apply accumulated orthogonal matrices to z.
                 if( wantz ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, one, z( &
                              topq, j ), ldz,work, nblst, zero, work( pw ), nh )
                    call stdlib_${ri}$lacpy( 'ALL', nh, nblst, work( pw ), nh,z( topq, j ), ldz )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                          if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_${ri}$orm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,z( topq, j ), ldz, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, one,&
                                     z( topq, j ), ldz,work( ppwo ), 2*nnb, zero, work( pw ),nh )
                          call stdlib_${ri}$lacpy( 'ALL', nh, 2*nnb, work( pw ), nh,z( topq, j ), ldz )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           ! avoid re-initialization of modified q and z.
           compq2 = compq
           compz2 = compz
           if ( jcol/=ilo ) then
              if ( wantq )compq2 = 'V'
              if ( wantz )compz2 = 'V'
           end if
           if ( jcol<ihi )call stdlib_${ri}$gghrd( compq2, compz2, n, jcol, ihi, a, lda, b, ldb, q,ldq,&
                      z, ldz, ierr )
           work( 1 ) = real( lwkopt,KIND=${rk}$)
           return
     end subroutine stdlib_${ri}$gghd3

#:endif
#:endfor

     module pure subroutine stdlib_cgghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! CGGHD3 reduces a pair of complex matrices (A,B) to generalized upper
     !! Hessenberg form using unitary transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the unitary matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**H*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**H*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**H*x.
     !! The unitary matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H
     !! Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H
     !! If Q1 is the unitary matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then CGGHD3 reduces the original
     !! problem to generalized Hessenberg form.
     !! This is a blocked variant of CGGHRD, using matrix-matrix
     !! multiplications for parts of the computation to enhance performance.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: blk22, initq, initz, lquery, wantq, wantz
           character :: compq2, compz2
           integer(ilp) :: cola, i, ierr, j, j0, jcol, jj, jrow, k, kacc22, len, lwkopt, n2nb, nb,&
                      nblst, nbmin, nh, nnb, nx, ppw, ppwo, pw, top, topq
           real(sp) :: c
           complex(sp) :: c1, c2, ctemp, s, s1, s2, temp, temp1, temp2, temp3
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           info = 0
           nb = stdlib_ilaenv( 1, 'CGGHD3', ' ', n, ilo, ihi, -1 )
           lwkopt = max( 6*n*nb, 1 )
           work( 1 ) = cmplx( lwkopt,KIND=sp)
           initq = stdlib_lsame( compq, 'I' )
           wantq = initq .or. stdlib_lsame( compq, 'V' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( wantq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( wantz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           else if( lwork<1 .and. .not.lquery ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGHD3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! initialize q and z if desired.
           if( initq )call stdlib_claset( 'ALL', n, n, czero, cone, q, ldq )
           if( initz )call stdlib_claset( 'ALL', n, n, czero, cone, z, ldz )
           ! zero out lower triangle of b.
           if( n>1 )call stdlib_claset( 'LOWER', n-1, n-1, czero, czero, b(2, 1), ldb )
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = cone
              return
           end if
           ! determine the blocksize.
           nbmin = stdlib_ilaenv( 2, 'CGGHD3', ' ', n, ilo, ihi, -1 )
           if( nb>1 .and. nb<nh ) then
              ! determine when to use unblocked instead of blocked code.
              nx = max( nb, stdlib_ilaenv( 3, 'CGGHD3', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code.
                 if( lwork<lwkopt ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code.
                    nbmin = max( 2, stdlib_ilaenv( 2, 'CGGHD3', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=6*n*nbmin ) then
                       nb = lwork / ( 6*n )
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              jcol = ilo
           else
              ! use blocked code
              kacc22 = stdlib_ilaenv( 16, 'CGGHD3', ' ', n, ilo, ihi, -1 )
              blk22 = kacc22==2
              do jcol = ilo, ihi-2, nb
                 nnb = min( nb, ihi-jcol-1 )
                 ! initialize small unitary factors that will hold the
                 ! accumulated givens rotations in workspace.
                 ! n2nb   denotes the number of 2*nnb-by-2*nnb factors
                 ! nblst  denotes the (possibly smaller) order of the last
                        ! factor.
                 n2nb = ( ihi-jcol-1 ) / nnb - 1
                 nblst = ihi - jcol - n2nb*nnb
                 call stdlib_claset( 'ALL', nblst, nblst, czero, cone, work, nblst )
                 pw = nblst * nblst + 1
                 do i = 1, n2nb
                    call stdlib_claset( 'ALL', 2*nnb, 2*nnb, czero, cone,work( pw ), 2*nnb )
                              
                    pw = pw + 4*nnb*nnb
                 end do
                 ! reduce columns jcol:jcol+nnb-1 of a to hessenberg form.
                 do j = jcol, jcol+nnb-1
                    ! reduce jth column of a. store cosines and sines in jth
                    ! column of a and b, respectively.
                    do i = ihi, j+2, -1
                       temp = a( i-1, j )
                       call stdlib_clartg( temp, a( i, j ), c, s, a( i-1, j ) )
                       a( i, j ) = cmplx( c,KIND=sp)
                       b( i, j ) = s
                    end do
                    ! accumulate givens rotations into workspace array.
                    ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                    len  = 2 + j - jcol
                    jrow = j + n2nb*nnb + 2
                    do i = ihi, jrow, -1
                       ctemp = a( i, j )
                       s = b( i, j )
                       do jj = ppw, ppw+len-1
                          temp = work( jj + nblst )
                          work( jj + nblst ) = ctemp*temp - s*work( jj )
                          work( jj ) = conjg( s )*temp + ctemp*work( jj )
                       end do
                       len = len + 1
                       ppw = ppw - nblst - 1
                    end do
                    ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                    j0 = jrow - nnb
                    do jrow = j0, j+2, -nnb
                       ppw = ppwo
                       len  = 2 + j - jcol
                       do i = jrow+nnb-1, jrow, -1
                          ctemp = a( i, j )
                          s = b( i, j )
                          do jj = ppw, ppw+len-1
                             temp = work( jj + 2*nnb )
                             work( jj + 2*nnb ) = ctemp*temp - s*work( jj )
                             work( jj ) = conjg( s )*temp + ctemp*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - 2*nnb - 1
                       end do
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    ! top denotes the number of top rows in a and b that will
                    ! not be updated during the next steps.
                    if( jcol<=2 ) then
                       top = 0
                    else
                       top = jcol
                    end if
                    ! propagate transformations through b and replace stored
                    ! left sines/cosines by right sines/cosines.
                    do jj = n, j+1, -1
                       ! update jjth column of b.
                       do i = min( jj+1, ihi ), j+2, -1
                          ctemp = a( i, j )
                          s = b( i, j )
                          temp = b( i, jj )
                          b( i, jj ) = ctemp*temp - conjg( s )*b( i-1, jj )
                          b( i-1, jj ) = s*temp + ctemp*b( i-1, jj )
                       end do
                       ! annihilate b( jj+1, jj ).
                       if( jj<ihi ) then
                          temp = b( jj+1, jj+1 )
                          call stdlib_clartg( temp, b( jj+1, jj ), c, s,b( jj+1, jj+1 ) )
                          b( jj+1, jj ) = czero
                          call stdlib_crot( jj-top, b( top+1, jj+1 ), 1,b( top+1, jj ), 1, c, s )
                                    
                          a( jj+1, j ) = cmplx( c,KIND=sp)
                          b( jj+1, j ) = -conjg( s )
                       end if
                    end do
                    ! update a by transformations from right.
                    jj = mod( ihi-j-1, 3 )
                    do i = ihi-j-3, jj+1, -3
                       ctemp = a( j+1+i, j )
                       s = -b( j+1+i, j )
                       c1 = a( j+2+i, j )
                       s1 = -b( j+2+i, j )
                       c2 = a( j+3+i, j )
                       s2 = -b( j+3+i, j )
                       do k = top+1, ihi
                          temp = a( k, j+i  )
                          temp1 = a( k, j+i+1 )
                          temp2 = a( k, j+i+2 )
                          temp3 = a( k, j+i+3 )
                          a( k, j+i+3 ) = c2*temp3 + conjg( s2 )*temp2
                          temp2 = -s2*temp3 + c2*temp2
                          a( k, j+i+2 ) = c1*temp2 + conjg( s1 )*temp1
                          temp1 = -s1*temp2 + c1*temp1
                          a( k, j+i+1 ) = ctemp*temp1 + conjg( s )*temp
                          a( k, j+i ) = -s*temp1 + ctemp*temp
                       end do
                    end do
                    if( jj>0 ) then
                       do i = jj, 1, -1
                          c = real( a( j+1+i, j ),KIND=sp)
                          call stdlib_crot( ihi-top, a( top+1, j+i+1 ), 1,a( top+1, j+i ), 1, c,-&
                                    conjg( b( j+1+i, j ) ) )
                       end do
                    end if
                    ! update (j+1)th column of a by transformations from left.
                    if ( j < jcol + nnb - 1 ) then
                       len  = 1 + j - jcol
                       ! multiply with the trailing accumulated unitary
                       ! matrix, which takes the form
                              ! [  u11  u12  ]
                          ! u = [            ],
                              ! [  u21  u22  ]
                       ! where u21 is a len-by-len matrix and u12 is lower
                       ! triangular.
                       jrow = ihi - nblst + 1
                       call stdlib_cgemv( 'CONJUGATE', nblst, len, cone, work,nblst, a( jrow, j+1 &
                                 ), 1, czero,work( pw ), 1 )
                       ppw = pw + len
                       do i = jrow, jrow+nblst-len-1
                          work( ppw ) = a( i, j+1 )
                          ppw = ppw + 1
                       end do
                       call stdlib_ctrmv( 'LOWER', 'CONJUGATE', 'NON-UNIT',nblst-len, work( &
                                 len*nblst + 1 ), nblst,work( pw+len ), 1 )
                       call stdlib_cgemv( 'CONJUGATE', len, nblst-len, cone,work( (len+1)*nblst - &
                       len + 1 ), nblst,a( jrow+nblst-len, j+1 ), 1, cone,work( pw+len ), 1 )
                                 
                       ppw = pw
                       do i = jrow, jrow+nblst-1
                          a( i, j+1 ) = work( ppw )
                          ppw = ppw + 1
                       end do
                       ! multiply with the other accumulated unitary
                       ! matrices, which take the form
                              ! [  u11  u12   0  ]
                              ! [                ]
                          ! u = [  u21  u22   0  ],
                              ! [                ]
                              ! [   0    0    i  ]
                       ! where i denotes the (nnb-len)-by-(nnb-len) identity
                       ! matrix, u21 is a len-by-len upper triangular matrix
                       ! and u12 is an nnb-by-nnb lower triangular matrix.
                       ppwo = 1 + nblst*nblst
                       j0 = jrow - nnb
                       do jrow = j0, jcol+1, -nnb
                          ppw = pw + len
                          do i = jrow, jrow+nnb-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          ppw = pw
                          do i = jrow+nnb, jrow+nnb+len-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          call stdlib_ctrmv( 'UPPER', 'CONJUGATE', 'NON-UNIT', len,work( ppwo + &
                                    nnb ), 2*nnb, work( pw ),1 )
                          call stdlib_ctrmv( 'LOWER', 'CONJUGATE', 'NON-UNIT', nnb,work( ppwo + &
                                    2*len*nnb ),2*nnb, work( pw + len ), 1 )
                          call stdlib_cgemv( 'CONJUGATE', nnb, len, cone,work( ppwo ), 2*nnb, a( &
                                    jrow, j+1 ), 1,cone, work( pw ), 1 )
                          call stdlib_cgemv( 'CONJUGATE', len, nnb, cone,work( ppwo + 2*len*nnb + &
                                    nnb ), 2*nnb,a( jrow+nnb, j+1 ), 1, cone,work( pw+len ), 1 )
                          ppw = pw
                          do i = jrow, jrow+len+nnb-1
                             a( i, j+1 ) = work( ppw )
                             ppw = ppw + 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end if
                 end do
                 ! apply accumulated unitary matrices to a.
                 cola = n - jcol - nnb + 1
                 j = ihi - nblst + 1
                 call stdlib_cgemm( 'CONJUGATE', 'NO TRANSPOSE', nblst,cola, nblst, cone, work, &
                           nblst,a( j, jcol+nnb ), lda, czero, work( pw ),nblst )
                 call stdlib_clacpy( 'ALL', nblst, cola, work( pw ), nblst,a( j, jcol+nnb ), lda )
                           
                 ppwo = nblst*nblst + 1
                 j0 = j - nnb
                 do j = j0, jcol+1, -nnb
                    if ( blk22 ) then
                       ! exploit the structure of
                              ! [  u11  u12  ]
                          ! u = [            ]
                              ! [  u21  u22  ],
                       ! where all blocks are nnb-by-nnb, u21 is upper
                       ! triangular and u12 is lower triangular.
                       call stdlib_cunm22( 'LEFT', 'CONJUGATE', 2*nnb, cola, nnb,nnb, work( ppwo )&
                                 , 2*nnb,a( j, jcol+nnb ), lda, work( pw ),lwork-pw+1, ierr )
                    else
                       ! ignore the structure of u.
                       call stdlib_cgemm( 'CONJUGATE', 'NO TRANSPOSE', 2*nnb,cola, 2*nnb, cone, &
                       work( ppwo ), 2*nnb,a( j, jcol+nnb ), lda, czero, work( pw ),2*nnb )
                                 
                       call stdlib_clacpy( 'ALL', 2*nnb, cola, work( pw ), 2*nnb,a( j, jcol+nnb ),&
                                  lda )
                    end if
                    ppwo = ppwo + 4*nnb*nnb
                 end do
                 ! apply accumulated unitary matrices to q.
                 if( wantq ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, cone, q( &
                              topq, j ), ldq,work, nblst, czero, work( pw ), nh )
                    call stdlib_clacpy( 'ALL', nh, nblst, work( pw ), nh,q( topq, j ), ldq )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_cunm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,q( topq, j ), ldq, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, &
                          cone, q( topq, j ), ldq,work( ppwo ), 2*nnb, czero, work( pw ),nh )
                                    
                          call stdlib_clacpy( 'ALL', nh, 2*nnb, work( pw ), nh,q( topq, j ), ldq )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! accumulate right givens rotations if required.
                 if ( wantz .or. top>0 ) then
                    ! initialize small unitary factors that will hold the
                    ! accumulated givens rotations in workspace.
                    call stdlib_claset( 'ALL', nblst, nblst, czero, cone, work,nblst )
                    pw = nblst * nblst + 1
                    do i = 1, n2nb
                       call stdlib_claset( 'ALL', 2*nnb, 2*nnb, czero, cone,work( pw ), 2*nnb )
                                 
                       pw = pw + 4*nnb*nnb
                    end do
                    ! accumulate givens rotations into workspace array.
                    do j = jcol, jcol+nnb-1
                       ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                       len  = 2 + j - jcol
                       jrow = j + n2nb*nnb + 2
                       do i = ihi, jrow, -1
                          ctemp = a( i, j )
                          a( i, j ) = czero
                          s = b( i, j )
                          b( i, j ) = czero
                          do jj = ppw, ppw+len-1
                             temp = work( jj + nblst )
                             work( jj + nblst ) = ctemp*temp -conjg( s )*work( jj )
                             work( jj ) = s*temp + ctemp*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - nblst - 1
                       end do
                       ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                       j0 = jrow - nnb
                       do jrow = j0, j+2, -nnb
                          ppw = ppwo
                          len  = 2 + j - jcol
                          do i = jrow+nnb-1, jrow, -1
                             ctemp = a( i, j )
                             a( i, j ) = czero
                             s = b( i, j )
                             b( i, j ) = czero
                             do jj = ppw, ppw+len-1
                                temp = work( jj + 2*nnb )
                                work( jj + 2*nnb ) = ctemp*temp -conjg( s )*work( jj )
                                work( jj ) = s*temp + ctemp*work( jj )
                             end do
                             len = len + 1
                             ppw = ppw - 2*nnb - 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end do
                 else
                    call stdlib_claset( 'LOWER', ihi - jcol - 1, nnb, czero, czero,a( jcol + 2, &
                              jcol ), lda )
                    call stdlib_claset( 'LOWER', ihi - jcol - 1, nnb, czero, czero,b( jcol + 2, &
                              jcol ), ldb )
                 end if
                 ! apply accumulated unitary matrices to a and b.
                 if ( top>0 ) then
                    j = ihi - nblst + 1
                    call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, cone, a( &
                              1, j ), lda,work, nblst, czero, work( pw ), top )
                    call stdlib_clacpy( 'ALL', top, nblst, work( pw ), top,a( 1, j ), lda )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_cunm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,a( 1, j ), lda, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                          cone, a( 1, j ), lda,work( ppwo ), 2*nnb, czero,work( pw ), top )
                                    
                          call stdlib_clacpy( 'ALL', top, 2*nnb, work( pw ), top,a( 1, j ), lda )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    j = ihi - nblst + 1
                    call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, cone, b( &
                              1, j ), ldb,work, nblst, czero, work( pw ), top )
                    call stdlib_clacpy( 'ALL', top, nblst, work( pw ), top,b( 1, j ), ldb )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_cunm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,b( 1, j ), ldb, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                          cone, b( 1, j ), ldb,work( ppwo ), 2*nnb, czero,work( pw ), top )
                                    
                          call stdlib_clacpy( 'ALL', top, 2*nnb, work( pw ), top,b( 1, j ), ldb )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! apply accumulated unitary matrices to z.
                 if( wantz ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, cone, z( &
                              topq, j ), ldz,work, nblst, czero, work( pw ), nh )
                    call stdlib_clacpy( 'ALL', nh, nblst, work( pw ), nh,z( topq, j ), ldz )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                          if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_cunm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,z( topq, j ), ldz, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, &
                          cone, z( topq, j ), ldz,work( ppwo ), 2*nnb, czero, work( pw ),nh )
                                    
                          call stdlib_clacpy( 'ALL', nh, 2*nnb, work( pw ), nh,z( topq, j ), ldz )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           ! avoid re-initialization of modified q and z.
           compq2 = compq
           compz2 = compz
           if ( jcol/=ilo ) then
              if ( wantq )compq2 = 'V'
              if ( wantz )compz2 = 'V'
           end if
           if ( jcol<ihi )call stdlib_cgghrd( compq2, compz2, n, jcol, ihi, a, lda, b, ldb, q,ldq,&
                      z, ldz, ierr )
           work( 1 ) = cmplx( lwkopt,KIND=sp)
           return
     end subroutine stdlib_cgghd3

     module pure subroutine stdlib_zgghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! ZGGHD3 reduces a pair of complex matrices (A,B) to generalized upper
     !! Hessenberg form using unitary transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the unitary matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**H*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**H*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**H*x.
     !! The unitary matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H
     !! Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H
     !! If Q1 is the unitary matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then ZGGHD3 reduces the original
     !! problem to generalized Hessenberg form.
     !! This is a blocked variant of CGGHRD, using matrix-matrix
     !! multiplications for parts of the computation to enhance performance.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: blk22, initq, initz, lquery, wantq, wantz
           character :: compq2, compz2
           integer(ilp) :: cola, i, ierr, j, j0, jcol, jj, jrow, k, kacc22, len, lwkopt, n2nb, nb,&
                      nblst, nbmin, nh, nnb, nx, ppw, ppwo, pw, top, topq
           real(dp) :: c
           complex(dp) :: c1, c2, ctemp, s, s1, s2, temp, temp1, temp2, temp3
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           info = 0
           nb = stdlib_ilaenv( 1, 'ZGGHD3', ' ', n, ilo, ihi, -1 )
           lwkopt = max( 6*n*nb, 1 )
           work( 1 ) = cmplx( lwkopt,KIND=dp)
           initq = stdlib_lsame( compq, 'I' )
           wantq = initq .or. stdlib_lsame( compq, 'V' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( wantq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( wantz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           else if( lwork<1 .and. .not.lquery ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGHD3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! initialize q and z if desired.
           if( initq )call stdlib_zlaset( 'ALL', n, n, czero, cone, q, ldq )
           if( initz )call stdlib_zlaset( 'ALL', n, n, czero, cone, z, ldz )
           ! zero out lower triangle of b.
           if( n>1 )call stdlib_zlaset( 'LOWER', n-1, n-1, czero, czero, b(2, 1), ldb )
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = cone
              return
           end if
           ! determine the blocksize.
           nbmin = stdlib_ilaenv( 2, 'ZGGHD3', ' ', n, ilo, ihi, -1 )
           if( nb>1 .and. nb<nh ) then
              ! determine when to use unblocked instead of blocked code.
              nx = max( nb, stdlib_ilaenv( 3, 'ZGGHD3', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code.
                 if( lwork<lwkopt ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code.
                    nbmin = max( 2, stdlib_ilaenv( 2, 'ZGGHD3', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=6*n*nbmin ) then
                       nb = lwork / ( 6*n )
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              jcol = ilo
           else
              ! use blocked code
              kacc22 = stdlib_ilaenv( 16, 'ZGGHD3', ' ', n, ilo, ihi, -1 )
              blk22 = kacc22==2
              do jcol = ilo, ihi-2, nb
                 nnb = min( nb, ihi-jcol-1 )
                 ! initialize small unitary factors that will hold the
                 ! accumulated givens rotations in workspace.
                 ! n2nb   denotes the number of 2*nnb-by-2*nnb factors
                 ! nblst  denotes the (possibly smaller) order of the last
                        ! factor.
                 n2nb = ( ihi-jcol-1 ) / nnb - 1
                 nblst = ihi - jcol - n2nb*nnb
                 call stdlib_zlaset( 'ALL', nblst, nblst, czero, cone, work, nblst )
                 pw = nblst * nblst + 1
                 do i = 1, n2nb
                    call stdlib_zlaset( 'ALL', 2*nnb, 2*nnb, czero, cone,work( pw ), 2*nnb )
                              
                    pw = pw + 4*nnb*nnb
                 end do
                 ! reduce columns jcol:jcol+nnb-1 of a to hessenberg form.
                 do j = jcol, jcol+nnb-1
                    ! reduce jth column of a. store cosines and sines in jth
                    ! column of a and b, respectively.
                    do i = ihi, j+2, -1
                       temp = a( i-1, j )
                       call stdlib_zlartg( temp, a( i, j ), c, s, a( i-1, j ) )
                       a( i, j ) = cmplx( c,KIND=dp)
                       b( i, j ) = s
                    end do
                    ! accumulate givens rotations into workspace array.
                    ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                    len  = 2 + j - jcol
                    jrow = j + n2nb*nnb + 2
                    do i = ihi, jrow, -1
                       ctemp = a( i, j )
                       s = b( i, j )
                       do jj = ppw, ppw+len-1
                          temp = work( jj + nblst )
                          work( jj + nblst ) = ctemp*temp - s*work( jj )
                          work( jj ) = conjg( s )*temp + ctemp*work( jj )
                       end do
                       len = len + 1
                       ppw = ppw - nblst - 1
                    end do
                    ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                    j0 = jrow - nnb
                    do jrow = j0, j+2, -nnb
                       ppw = ppwo
                       len  = 2 + j - jcol
                       do i = jrow+nnb-1, jrow, -1
                          ctemp = a( i, j )
                          s = b( i, j )
                          do jj = ppw, ppw+len-1
                             temp = work( jj + 2*nnb )
                             work( jj + 2*nnb ) = ctemp*temp - s*work( jj )
                             work( jj ) = conjg( s )*temp + ctemp*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - 2*nnb - 1
                       end do
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    ! top denotes the number of top rows in a and b that will
                    ! not be updated during the next steps.
                    if( jcol<=2 ) then
                       top = 0
                    else
                       top = jcol
                    end if
                    ! propagate transformations through b and replace stored
                    ! left sines/cosines by right sines/cosines.
                    do jj = n, j+1, -1
                       ! update jjth column of b.
                       do i = min( jj+1, ihi ), j+2, -1
                          ctemp = a( i, j )
                          s = b( i, j )
                          temp = b( i, jj )
                          b( i, jj ) = ctemp*temp - conjg( s )*b( i-1, jj )
                          b( i-1, jj ) = s*temp + ctemp*b( i-1, jj )
                       end do
                       ! annihilate b( jj+1, jj ).
                       if( jj<ihi ) then
                          temp = b( jj+1, jj+1 )
                          call stdlib_zlartg( temp, b( jj+1, jj ), c, s,b( jj+1, jj+1 ) )
                          b( jj+1, jj ) = czero
                          call stdlib_zrot( jj-top, b( top+1, jj+1 ), 1,b( top+1, jj ), 1, c, s )
                                    
                          a( jj+1, j ) = cmplx( c,KIND=dp)
                          b( jj+1, j ) = -conjg( s )
                       end if
                    end do
                    ! update a by transformations from right.
                    jj = mod( ihi-j-1, 3 )
                    do i = ihi-j-3, jj+1, -3
                       ctemp = a( j+1+i, j )
                       s = -b( j+1+i, j )
                       c1 = a( j+2+i, j )
                       s1 = -b( j+2+i, j )
                       c2 = a( j+3+i, j )
                       s2 = -b( j+3+i, j )
                       do k = top+1, ihi
                          temp = a( k, j+i  )
                          temp1 = a( k, j+i+1 )
                          temp2 = a( k, j+i+2 )
                          temp3 = a( k, j+i+3 )
                          a( k, j+i+3 ) = c2*temp3 + conjg( s2 )*temp2
                          temp2 = -s2*temp3 + c2*temp2
                          a( k, j+i+2 ) = c1*temp2 + conjg( s1 )*temp1
                          temp1 = -s1*temp2 + c1*temp1
                          a( k, j+i+1 ) = ctemp*temp1 + conjg( s )*temp
                          a( k, j+i ) = -s*temp1 + ctemp*temp
                       end do
                    end do
                    if( jj>0 ) then
                       do i = jj, 1, -1
                          c = real( a( j+1+i, j ),KIND=dp)
                          call stdlib_zrot( ihi-top, a( top+1, j+i+1 ), 1,a( top+1, j+i ), 1, c,-&
                                    conjg( b( j+1+i, j ) ) )
                       end do
                    end if
                    ! update (j+1)th column of a by transformations from left.
                    if ( j < jcol + nnb - 1 ) then
                       len  = 1 + j - jcol
                       ! multiply with the trailing accumulated unitary
                       ! matrix, which takes the form
                              ! [  u11  u12  ]
                          ! u = [            ],
                              ! [  u21  u22  ]
                       ! where u21 is a len-by-len matrix and u12 is lower
                       ! triangular.
                       jrow = ihi - nblst + 1
                       call stdlib_zgemv( 'CONJUGATE', nblst, len, cone, work,nblst, a( jrow, j+1 &
                                 ), 1, czero,work( pw ), 1 )
                       ppw = pw + len
                       do i = jrow, jrow+nblst-len-1
                          work( ppw ) = a( i, j+1 )
                          ppw = ppw + 1
                       end do
                       call stdlib_ztrmv( 'LOWER', 'CONJUGATE', 'NON-UNIT',nblst-len, work( &
                                 len*nblst + 1 ), nblst,work( pw+len ), 1 )
                       call stdlib_zgemv( 'CONJUGATE', len, nblst-len, cone,work( (len+1)*nblst - &
                       len + 1 ), nblst,a( jrow+nblst-len, j+1 ), 1, cone,work( pw+len ), 1 )
                                 
                       ppw = pw
                       do i = jrow, jrow+nblst-1
                          a( i, j+1 ) = work( ppw )
                          ppw = ppw + 1
                       end do
                       ! multiply with the other accumulated unitary
                       ! matrices, which take the form
                              ! [  u11  u12   0  ]
                              ! [                ]
                          ! u = [  u21  u22   0  ],
                              ! [                ]
                              ! [   0    0    i  ]
                       ! where i denotes the (nnb-len)-by-(nnb-len) identity
                       ! matrix, u21 is a len-by-len upper triangular matrix
                       ! and u12 is an nnb-by-nnb lower triangular matrix.
                       ppwo = 1 + nblst*nblst
                       j0 = jrow - nnb
                       do jrow = j0, jcol+1, -nnb
                          ppw = pw + len
                          do i = jrow, jrow+nnb-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          ppw = pw
                          do i = jrow+nnb, jrow+nnb+len-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          call stdlib_ztrmv( 'UPPER', 'CONJUGATE', 'NON-UNIT', len,work( ppwo + &
                                    nnb ), 2*nnb, work( pw ),1 )
                          call stdlib_ztrmv( 'LOWER', 'CONJUGATE', 'NON-UNIT', nnb,work( ppwo + &
                                    2*len*nnb ),2*nnb, work( pw + len ), 1 )
                          call stdlib_zgemv( 'CONJUGATE', nnb, len, cone,work( ppwo ), 2*nnb, a( &
                                    jrow, j+1 ), 1,cone, work( pw ), 1 )
                          call stdlib_zgemv( 'CONJUGATE', len, nnb, cone,work( ppwo + 2*len*nnb + &
                                    nnb ), 2*nnb,a( jrow+nnb, j+1 ), 1, cone,work( pw+len ), 1 )
                          ppw = pw
                          do i = jrow, jrow+len+nnb-1
                             a( i, j+1 ) = work( ppw )
                             ppw = ppw + 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end if
                 end do
                 ! apply accumulated unitary matrices to a.
                 cola = n - jcol - nnb + 1
                 j = ihi - nblst + 1
                 call stdlib_zgemm( 'CONJUGATE', 'NO TRANSPOSE', nblst,cola, nblst, cone, work, &
                           nblst,a( j, jcol+nnb ), lda, czero, work( pw ),nblst )
                 call stdlib_zlacpy( 'ALL', nblst, cola, work( pw ), nblst,a( j, jcol+nnb ), lda )
                           
                 ppwo = nblst*nblst + 1
                 j0 = j - nnb
                 do j = j0, jcol+1, -nnb
                    if ( blk22 ) then
                       ! exploit the structure of
                              ! [  u11  u12  ]
                          ! u = [            ]
                              ! [  u21  u22  ],
                       ! where all blocks are nnb-by-nnb, u21 is upper
                       ! triangular and u12 is lower triangular.
                       call stdlib_zunm22( 'LEFT', 'CONJUGATE', 2*nnb, cola, nnb,nnb, work( ppwo )&
                                 , 2*nnb,a( j, jcol+nnb ), lda, work( pw ),lwork-pw+1, ierr )
                    else
                       ! ignore the structure of u.
                       call stdlib_zgemm( 'CONJUGATE', 'NO TRANSPOSE', 2*nnb,cola, 2*nnb, cone, &
                       work( ppwo ), 2*nnb,a( j, jcol+nnb ), lda, czero, work( pw ),2*nnb )
                                 
                       call stdlib_zlacpy( 'ALL', 2*nnb, cola, work( pw ), 2*nnb,a( j, jcol+nnb ),&
                                  lda )
                    end if
                    ppwo = ppwo + 4*nnb*nnb
                 end do
                 ! apply accumulated unitary matrices to q.
                 if( wantq ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_zgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, cone, q( &
                              topq, j ), ldq,work, nblst, czero, work( pw ), nh )
                    call stdlib_zlacpy( 'ALL', nh, nblst, work( pw ), nh,q( topq, j ), ldq )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_zunm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,q( topq, j ), ldq, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_zgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, &
                          cone, q( topq, j ), ldq,work( ppwo ), 2*nnb, czero, work( pw ),nh )
                                    
                          call stdlib_zlacpy( 'ALL', nh, 2*nnb, work( pw ), nh,q( topq, j ), ldq )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! accumulate right givens rotations if required.
                 if ( wantz .or. top>0 ) then
                    ! initialize small unitary factors that will hold the
                    ! accumulated givens rotations in workspace.
                    call stdlib_zlaset( 'ALL', nblst, nblst, czero, cone, work,nblst )
                    pw = nblst * nblst + 1
                    do i = 1, n2nb
                       call stdlib_zlaset( 'ALL', 2*nnb, 2*nnb, czero, cone,work( pw ), 2*nnb )
                                 
                       pw = pw + 4*nnb*nnb
                    end do
                    ! accumulate givens rotations into workspace array.
                    do j = jcol, jcol+nnb-1
                       ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                       len  = 2 + j - jcol
                       jrow = j + n2nb*nnb + 2
                       do i = ihi, jrow, -1
                          ctemp = a( i, j )
                          a( i, j ) = czero
                          s = b( i, j )
                          b( i, j ) = czero
                          do jj = ppw, ppw+len-1
                             temp = work( jj + nblst )
                             work( jj + nblst ) = ctemp*temp -conjg( s )*work( jj )
                             work( jj ) = s*temp + ctemp*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - nblst - 1
                       end do
                       ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                       j0 = jrow - nnb
                       do jrow = j0, j+2, -nnb
                          ppw = ppwo
                          len  = 2 + j - jcol
                          do i = jrow+nnb-1, jrow, -1
                             ctemp = a( i, j )
                             a( i, j ) = czero
                             s = b( i, j )
                             b( i, j ) = czero
                             do jj = ppw, ppw+len-1
                                temp = work( jj + 2*nnb )
                                work( jj + 2*nnb ) = ctemp*temp -conjg( s )*work( jj )
                                work( jj ) = s*temp + ctemp*work( jj )
                             end do
                             len = len + 1
                             ppw = ppw - 2*nnb - 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end do
                 else
                    call stdlib_zlaset( 'LOWER', ihi - jcol - 1, nnb, czero, czero,a( jcol + 2, &
                              jcol ), lda )
                    call stdlib_zlaset( 'LOWER', ihi - jcol - 1, nnb, czero, czero,b( jcol + 2, &
                              jcol ), ldb )
                 end if
                 ! apply accumulated unitary matrices to a and b.
                 if ( top>0 ) then
                    j = ihi - nblst + 1
                    call stdlib_zgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, cone, a( &
                              1, j ), lda,work, nblst, czero, work( pw ), top )
                    call stdlib_zlacpy( 'ALL', top, nblst, work( pw ), top,a( 1, j ), lda )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_zunm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,a( 1, j ), lda, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_zgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                          cone, a( 1, j ), lda,work( ppwo ), 2*nnb, czero,work( pw ), top )
                                    
                          call stdlib_zlacpy( 'ALL', top, 2*nnb, work( pw ), top,a( 1, j ), lda )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    j = ihi - nblst + 1
                    call stdlib_zgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, cone, b( &
                              1, j ), ldb,work, nblst, czero, work( pw ), top )
                    call stdlib_zlacpy( 'ALL', top, nblst, work( pw ), top,b( 1, j ), ldb )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_zunm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,b( 1, j ), ldb, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_zgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                          cone, b( 1, j ), ldb,work( ppwo ), 2*nnb, czero,work( pw ), top )
                                    
                          call stdlib_zlacpy( 'ALL', top, 2*nnb, work( pw ), top,b( 1, j ), ldb )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! apply accumulated unitary matrices to z.
                 if( wantz ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_zgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, cone, z( &
                              topq, j ), ldz,work, nblst, czero, work( pw ), nh )
                    call stdlib_zlacpy( 'ALL', nh, nblst, work( pw ), nh,z( topq, j ), ldz )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                          if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_zunm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,z( topq, j ), ldz, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_zgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, &
                          cone, z( topq, j ), ldz,work( ppwo ), 2*nnb, czero, work( pw ),nh )
                                    
                          call stdlib_zlacpy( 'ALL', nh, 2*nnb, work( pw ), nh,z( topq, j ), ldz )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           ! avoid re-initialization of modified q and z.
           compq2 = compq
           compz2 = compz
           if ( jcol/=ilo ) then
              if ( wantq )compq2 = 'V'
              if ( wantz )compz2 = 'V'
           end if
           if ( jcol<ihi )call stdlib_zgghrd( compq2, compz2, n, jcol, ihi, a, lda, b, ldb, q,ldq,&
                      z, ldz, ierr )
           work( 1 ) = cmplx( lwkopt,KIND=dp)
           return
     end subroutine stdlib_zgghd3

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$gghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! ZGGHD3: reduces a pair of complex matrices (A,B) to generalized upper
     !! Hessenberg form using unitary transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the unitary matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**H*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**H*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**H*x.
     !! The unitary matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H
     !! Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H
     !! If Q1 is the unitary matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then ZGGHD3 reduces the original
     !! problem to generalized Hessenberg form.
     !! This is a blocked variant of CGGHRD, using matrix-matrix
     !! multiplications for parts of the computation to enhance performance.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: blk22, initq, initz, lquery, wantq, wantz
           character :: compq2, compz2
           integer(ilp) :: cola, i, ierr, j, j0, jcol, jj, jrow, k, kacc22, len, lwkopt, n2nb, nb,&
                      nblst, nbmin, nh, nnb, nx, ppw, ppwo, pw, top, topq
           real(${ck}$) :: c
           complex(${ck}$) :: c1, c2, ctemp, s, s1, s2, temp, temp1, temp2, temp3
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           info = 0
           nb = stdlib_ilaenv( 1, 'ZGGHD3', ' ', n, ilo, ihi, -1 )
           lwkopt = max( 6*n*nb, 1 )
           work( 1 ) = cmplx( lwkopt,KIND=${ck}$)
           initq = stdlib_lsame( compq, 'I' )
           wantq = initq .or. stdlib_lsame( compq, 'V' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( wantq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( wantz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           else if( lwork<1 .and. .not.lquery ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGHD3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! initialize q and z if desired.
           if( initq )call stdlib_${ci}$laset( 'ALL', n, n, czero, cone, q, ldq )
           if( initz )call stdlib_${ci}$laset( 'ALL', n, n, czero, cone, z, ldz )
           ! zero out lower triangle of b.
           if( n>1 )call stdlib_${ci}$laset( 'LOWER', n-1, n-1, czero, czero, b(2, 1), ldb )
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = cone
              return
           end if
           ! determine the blocksize.
           nbmin = stdlib_ilaenv( 2, 'ZGGHD3', ' ', n, ilo, ihi, -1 )
           if( nb>1 .and. nb<nh ) then
              ! determine when to use unblocked instead of blocked code.
              nx = max( nb, stdlib_ilaenv( 3, 'ZGGHD3', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code.
                 if( lwork<lwkopt ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code.
                    nbmin = max( 2, stdlib_ilaenv( 2, 'ZGGHD3', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=6*n*nbmin ) then
                       nb = lwork / ( 6*n )
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              jcol = ilo
           else
              ! use blocked code
              kacc22 = stdlib_ilaenv( 16, 'ZGGHD3', ' ', n, ilo, ihi, -1 )
              blk22 = kacc22==2
              do jcol = ilo, ihi-2, nb
                 nnb = min( nb, ihi-jcol-1 )
                 ! initialize small unitary factors that will hold the
                 ! accumulated givens rotations in workspace.
                 ! n2nb   denotes the number of 2*nnb-by-2*nnb factors
                 ! nblst  denotes the (possibly smaller) order of the last
                        ! factor.
                 n2nb = ( ihi-jcol-1 ) / nnb - 1
                 nblst = ihi - jcol - n2nb*nnb
                 call stdlib_${ci}$laset( 'ALL', nblst, nblst, czero, cone, work, nblst )
                 pw = nblst * nblst + 1
                 do i = 1, n2nb
                    call stdlib_${ci}$laset( 'ALL', 2*nnb, 2*nnb, czero, cone,work( pw ), 2*nnb )
                              
                    pw = pw + 4*nnb*nnb
                 end do
                 ! reduce columns jcol:jcol+nnb-1 of a to hessenberg form.
                 do j = jcol, jcol+nnb-1
                    ! reduce jth column of a. store cosines and sines in jth
                    ! column of a and b, respectively.
                    do i = ihi, j+2, -1
                       temp = a( i-1, j )
                       call stdlib_${ci}$lartg( temp, a( i, j ), c, s, a( i-1, j ) )
                       a( i, j ) = cmplx( c,KIND=${ck}$)
                       b( i, j ) = s
                    end do
                    ! accumulate givens rotations into workspace array.
                    ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                    len  = 2 + j - jcol
                    jrow = j + n2nb*nnb + 2
                    do i = ihi, jrow, -1
                       ctemp = a( i, j )
                       s = b( i, j )
                       do jj = ppw, ppw+len-1
                          temp = work( jj + nblst )
                          work( jj + nblst ) = ctemp*temp - s*work( jj )
                          work( jj ) = conjg( s )*temp + ctemp*work( jj )
                       end do
                       len = len + 1
                       ppw = ppw - nblst - 1
                    end do
                    ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                    j0 = jrow - nnb
                    do jrow = j0, j+2, -nnb
                       ppw = ppwo
                       len  = 2 + j - jcol
                       do i = jrow+nnb-1, jrow, -1
                          ctemp = a( i, j )
                          s = b( i, j )
                          do jj = ppw, ppw+len-1
                             temp = work( jj + 2*nnb )
                             work( jj + 2*nnb ) = ctemp*temp - s*work( jj )
                             work( jj ) = conjg( s )*temp + ctemp*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - 2*nnb - 1
                       end do
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    ! top denotes the number of top rows in a and b that will
                    ! not be updated during the next steps.
                    if( jcol<=2 ) then
                       top = 0
                    else
                       top = jcol
                    end if
                    ! propagate transformations through b and replace stored
                    ! left sines/cosines by right sines/cosines.
                    do jj = n, j+1, -1
                       ! update jjth column of b.
                       do i = min( jj+1, ihi ), j+2, -1
                          ctemp = a( i, j )
                          s = b( i, j )
                          temp = b( i, jj )
                          b( i, jj ) = ctemp*temp - conjg( s )*b( i-1, jj )
                          b( i-1, jj ) = s*temp + ctemp*b( i-1, jj )
                       end do
                       ! annihilate b( jj+1, jj ).
                       if( jj<ihi ) then
                          temp = b( jj+1, jj+1 )
                          call stdlib_${ci}$lartg( temp, b( jj+1, jj ), c, s,b( jj+1, jj+1 ) )
                          b( jj+1, jj ) = czero
                          call stdlib_${ci}$rot( jj-top, b( top+1, jj+1 ), 1,b( top+1, jj ), 1, c, s )
                                    
                          a( jj+1, j ) = cmplx( c,KIND=${ck}$)
                          b( jj+1, j ) = -conjg( s )
                       end if
                    end do
                    ! update a by transformations from right.
                    jj = mod( ihi-j-1, 3 )
                    do i = ihi-j-3, jj+1, -3
                       ctemp = a( j+1+i, j )
                       s = -b( j+1+i, j )
                       c1 = a( j+2+i, j )
                       s1 = -b( j+2+i, j )
                       c2 = a( j+3+i, j )
                       s2 = -b( j+3+i, j )
                       do k = top+1, ihi
                          temp = a( k, j+i  )
                          temp1 = a( k, j+i+1 )
                          temp2 = a( k, j+i+2 )
                          temp3 = a( k, j+i+3 )
                          a( k, j+i+3 ) = c2*temp3 + conjg( s2 )*temp2
                          temp2 = -s2*temp3 + c2*temp2
                          a( k, j+i+2 ) = c1*temp2 + conjg( s1 )*temp1
                          temp1 = -s1*temp2 + c1*temp1
                          a( k, j+i+1 ) = ctemp*temp1 + conjg( s )*temp
                          a( k, j+i ) = -s*temp1 + ctemp*temp
                       end do
                    end do
                    if( jj>0 ) then
                       do i = jj, 1, -1
                          c = real( a( j+1+i, j ),KIND=${ck}$)
                          call stdlib_${ci}$rot( ihi-top, a( top+1, j+i+1 ), 1,a( top+1, j+i ), 1, c,-&
                                    conjg( b( j+1+i, j ) ) )
                       end do
                    end if
                    ! update (j+1)th column of a by transformations from left.
                    if ( j < jcol + nnb - 1 ) then
                       len  = 1 + j - jcol
                       ! multiply with the trailing accumulated unitary
                       ! matrix, which takes the form
                              ! [  u11  u12  ]
                          ! u = [            ],
                              ! [  u21  u22  ]
                       ! where u21 is a len-by-len matrix and u12 is lower
                       ! triangular.
                       jrow = ihi - nblst + 1
                       call stdlib_${ci}$gemv( 'CONJUGATE', nblst, len, cone, work,nblst, a( jrow, j+1 &
                                 ), 1, czero,work( pw ), 1 )
                       ppw = pw + len
                       do i = jrow, jrow+nblst-len-1
                          work( ppw ) = a( i, j+1 )
                          ppw = ppw + 1
                       end do
                       call stdlib_${ci}$trmv( 'LOWER', 'CONJUGATE', 'NON-UNIT',nblst-len, work( &
                                 len*nblst + 1 ), nblst,work( pw+len ), 1 )
                       call stdlib_${ci}$gemv( 'CONJUGATE', len, nblst-len, cone,work( (len+1)*nblst - &
                       len + 1 ), nblst,a( jrow+nblst-len, j+1 ), 1, cone,work( pw+len ), 1 )
                                 
                       ppw = pw
                       do i = jrow, jrow+nblst-1
                          a( i, j+1 ) = work( ppw )
                          ppw = ppw + 1
                       end do
                       ! multiply with the other accumulated unitary
                       ! matrices, which take the form
                              ! [  u11  u12   0  ]
                              ! [                ]
                          ! u = [  u21  u22   0  ],
                              ! [                ]
                              ! [   0    0    i  ]
                       ! where i denotes the (nnb-len)-by-(nnb-len) identity
                       ! matrix, u21 is a len-by-len upper triangular matrix
                       ! and u12 is an nnb-by-nnb lower triangular matrix.
                       ppwo = 1 + nblst*nblst
                       j0 = jrow - nnb
                       do jrow = j0, jcol+1, -nnb
                          ppw = pw + len
                          do i = jrow, jrow+nnb-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          ppw = pw
                          do i = jrow+nnb, jrow+nnb+len-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          call stdlib_${ci}$trmv( 'UPPER', 'CONJUGATE', 'NON-UNIT', len,work( ppwo + &
                                    nnb ), 2*nnb, work( pw ),1 )
                          call stdlib_${ci}$trmv( 'LOWER', 'CONJUGATE', 'NON-UNIT', nnb,work( ppwo + &
                                    2*len*nnb ),2*nnb, work( pw + len ), 1 )
                          call stdlib_${ci}$gemv( 'CONJUGATE', nnb, len, cone,work( ppwo ), 2*nnb, a( &
                                    jrow, j+1 ), 1,cone, work( pw ), 1 )
                          call stdlib_${ci}$gemv( 'CONJUGATE', len, nnb, cone,work( ppwo + 2*len*nnb + &
                                    nnb ), 2*nnb,a( jrow+nnb, j+1 ), 1, cone,work( pw+len ), 1 )
                          ppw = pw
                          do i = jrow, jrow+len+nnb-1
                             a( i, j+1 ) = work( ppw )
                             ppw = ppw + 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end if
                 end do
                 ! apply accumulated unitary matrices to a.
                 cola = n - jcol - nnb + 1
                 j = ihi - nblst + 1
                 call stdlib_${ci}$gemm( 'CONJUGATE', 'NO TRANSPOSE', nblst,cola, nblst, cone, work, &
                           nblst,a( j, jcol+nnb ), lda, czero, work( pw ),nblst )
                 call stdlib_${ci}$lacpy( 'ALL', nblst, cola, work( pw ), nblst,a( j, jcol+nnb ), lda )
                           
                 ppwo = nblst*nblst + 1
                 j0 = j - nnb
                 do j = j0, jcol+1, -nnb
                    if ( blk22 ) then
                       ! exploit the structure of
                              ! [  u11  u12  ]
                          ! u = [            ]
                              ! [  u21  u22  ],
                       ! where all blocks are nnb-by-nnb, u21 is upper
                       ! triangular and u12 is lower triangular.
                       call stdlib_${ci}$unm22( 'LEFT', 'CONJUGATE', 2*nnb, cola, nnb,nnb, work( ppwo )&
                                 , 2*nnb,a( j, jcol+nnb ), lda, work( pw ),lwork-pw+1, ierr )
                    else
                       ! ignore the structure of u.
                       call stdlib_${ci}$gemm( 'CONJUGATE', 'NO TRANSPOSE', 2*nnb,cola, 2*nnb, cone, &
                       work( ppwo ), 2*nnb,a( j, jcol+nnb ), lda, czero, work( pw ),2*nnb )
                                 
                       call stdlib_${ci}$lacpy( 'ALL', 2*nnb, cola, work( pw ), 2*nnb,a( j, jcol+nnb ),&
                                  lda )
                    end if
                    ppwo = ppwo + 4*nnb*nnb
                 end do
                 ! apply accumulated unitary matrices to q.
                 if( wantq ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, cone, q( &
                              topq, j ), ldq,work, nblst, czero, work( pw ), nh )
                    call stdlib_${ci}$lacpy( 'ALL', nh, nblst, work( pw ), nh,q( topq, j ), ldq )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_${ci}$unm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,q( topq, j ), ldq, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, &
                          cone, q( topq, j ), ldq,work( ppwo ), 2*nnb, czero, work( pw ),nh )
                                    
                          call stdlib_${ci}$lacpy( 'ALL', nh, 2*nnb, work( pw ), nh,q( topq, j ), ldq )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! accumulate right givens rotations if required.
                 if ( wantz .or. top>0 ) then
                    ! initialize small unitary factors that will hold the
                    ! accumulated givens rotations in workspace.
                    call stdlib_${ci}$laset( 'ALL', nblst, nblst, czero, cone, work,nblst )
                    pw = nblst * nblst + 1
                    do i = 1, n2nb
                       call stdlib_${ci}$laset( 'ALL', 2*nnb, 2*nnb, czero, cone,work( pw ), 2*nnb )
                                 
                       pw = pw + 4*nnb*nnb
                    end do
                    ! accumulate givens rotations into workspace array.
                    do j = jcol, jcol+nnb-1
                       ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                       len  = 2 + j - jcol
                       jrow = j + n2nb*nnb + 2
                       do i = ihi, jrow, -1
                          ctemp = a( i, j )
                          a( i, j ) = czero
                          s = b( i, j )
                          b( i, j ) = czero
                          do jj = ppw, ppw+len-1
                             temp = work( jj + nblst )
                             work( jj + nblst ) = ctemp*temp -conjg( s )*work( jj )
                             work( jj ) = s*temp + ctemp*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - nblst - 1
                       end do
                       ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                       j0 = jrow - nnb
                       do jrow = j0, j+2, -nnb
                          ppw = ppwo
                          len  = 2 + j - jcol
                          do i = jrow+nnb-1, jrow, -1
                             ctemp = a( i, j )
                             a( i, j ) = czero
                             s = b( i, j )
                             b( i, j ) = czero
                             do jj = ppw, ppw+len-1
                                temp = work( jj + 2*nnb )
                                work( jj + 2*nnb ) = ctemp*temp -conjg( s )*work( jj )
                                work( jj ) = s*temp + ctemp*work( jj )
                             end do
                             len = len + 1
                             ppw = ppw - 2*nnb - 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end do
                 else
                    call stdlib_${ci}$laset( 'LOWER', ihi - jcol - 1, nnb, czero, czero,a( jcol + 2, &
                              jcol ), lda )
                    call stdlib_${ci}$laset( 'LOWER', ihi - jcol - 1, nnb, czero, czero,b( jcol + 2, &
                              jcol ), ldb )
                 end if
                 ! apply accumulated unitary matrices to a and b.
                 if ( top>0 ) then
                    j = ihi - nblst + 1
                    call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, cone, a( &
                              1, j ), lda,work, nblst, czero, work( pw ), top )
                    call stdlib_${ci}$lacpy( 'ALL', top, nblst, work( pw ), top,a( 1, j ), lda )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_${ci}$unm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,a( 1, j ), lda, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                          cone, a( 1, j ), lda,work( ppwo ), 2*nnb, czero,work( pw ), top )
                                    
                          call stdlib_${ci}$lacpy( 'ALL', top, 2*nnb, work( pw ), top,a( 1, j ), lda )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    j = ihi - nblst + 1
                    call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, cone, b( &
                              1, j ), ldb,work, nblst, czero, work( pw ), top )
                    call stdlib_${ci}$lacpy( 'ALL', top, nblst, work( pw ), top,b( 1, j ), ldb )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_${ci}$unm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,b( 1, j ), ldb, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                          cone, b( 1, j ), ldb,work( ppwo ), 2*nnb, czero,work( pw ), top )
                                    
                          call stdlib_${ci}$lacpy( 'ALL', top, 2*nnb, work( pw ), top,b( 1, j ), ldb )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! apply accumulated unitary matrices to z.
                 if( wantz ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, cone, z( &
                              topq, j ), ldz,work, nblst, czero, work( pw ), nh )
                    call stdlib_${ci}$lacpy( 'ALL', nh, nblst, work( pw ), nh,z( topq, j ), ldz )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                          if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_${ci}$unm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,z( topq, j ), ldz, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, &
                          cone, z( topq, j ), ldz,work( ppwo ), 2*nnb, czero, work( pw ),nh )
                                    
                          call stdlib_${ci}$lacpy( 'ALL', nh, 2*nnb, work( pw ), nh,z( topq, j ), ldz )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           ! avoid re-initialization of modified q and z.
           compq2 = compq
           compz2 = compz
           if ( jcol/=ilo ) then
              if ( wantq )compq2 = 'V'
              if ( wantz )compz2 = 'V'
           end if
           if ( jcol<ihi )call stdlib_${ci}$gghrd( compq2, compz2, n, jcol, ihi, a, lda, b, ldb, q,ldq,&
                      z, ldz, ierr )
           work( 1 ) = cmplx( lwkopt,KIND=${ck}$)
           return
     end subroutine stdlib_${ci}$gghd3

#:endif
#:endfor



     module pure subroutine stdlib_slaqz4( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_desired, sr, &
     !! SLAQZ4 Executes a single multishift QZ sweep
               si, ss, a, lda, b, ldb, q,ldq, z, ldz, qc, ldqc, zc, ldzc, work, lwork,info )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! function arguments
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(ilp), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,nshifts, &
                     nblock_desired, ldqc, ldzc
           real(sp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq, * ),z( ldz, * ), qc( &
                     ldqc, * ), zc( ldzc, * ), work( * ), sr( * ),si( * ), ss( * )
           integer(ilp), intent( out ) :: info
           ! ================================================================
           ! local scalars
           integer(ilp) :: i, j, ns, istartm, istopm, sheight, swidth, k, np, istartb, istopb, &
                     ishift, nblock, npos
           real(sp) :: temp, v(3), c1, s1, c2, s2, swap
           info = 0
           if ( nblock_desired < nshifts+1 ) then
              info = -8
           end if
           if ( lwork ==-1 ) then
              ! workspace query, quick return
              work( 1 ) = n*nblock_desired
              return
           else if ( lwork < n*nblock_desired ) then
              info = -25
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SLAQZ4', -info )
              return
           end if
           ! executable statements
           if ( nshifts < 2 ) then
              return
           end if
           if ( ilo >= ihi ) then
              return
           end if
           if ( ilschur ) then
              istartm = 1
              istopm = n
           else
              istartm = ilo
              istopm = ihi
           end if
           ! shuffle shifts into pairs of real shifts and pairs
           ! of complex conjugate shifts assuming complex
           ! conjugate shifts are already adjacent to one
           ! another
           do i = 1, nshifts-2, 2
              if( si( i )/=-si( i+1 ) ) then
                 swap = sr( i )
                 sr( i ) = sr( i+1 )
                 sr( i+1 ) = sr( i+2 )
                 sr( i+2 ) = swap
                 swap = si( i )
                 si( i ) = si( i+1 )
                 si( i+1 ) = si( i+2 )
                 si( i+2 ) = swap
                 swap = ss( i )
                 ss( i ) = ss( i+1 )
                 ss( i+1 ) = ss( i+2 )
                 ss( i+2 ) = swap
              end if
           end do
           ! nshfts is supposed to be even, but if it is odd,
           ! then simply reduce it by one.  the shuffle above
           ! ensures that the dropped shift is real and that
           ! the remaining shifts are paired.
           ns = nshifts-mod( nshifts, 2 )
           npos = max( nblock_desired-ns, 1 )
           ! the following block introduces the shifts and chases
           ! them down one by one just enough to make space for
           ! the other shifts. the near-the-diagonal block is
           ! of size (ns+1) x ns.
           call stdlib_slaset( 'FULL', ns+1, ns+1, zero, one, qc, ldqc )
           call stdlib_slaset( 'FULL', ns, ns, zero, one, zc, ldzc )
           do i = 1, ns, 2
              ! introduce the shift
              call stdlib_slaqz1( a( ilo, ilo ), lda, b( ilo, ilo ), ldb, sr( i ),sr( i+1 ), si( &
                        i ), ss( i ), ss( i+1 ), v )
              temp = v( 2 )
              call stdlib_slartg( temp, v( 3 ), c1, s1, v( 2 ) )
              call stdlib_slartg( v( 1 ), v( 2 ), c2, s2, temp )
              call stdlib_srot( ns, a( ilo+1, ilo ), lda, a( ilo+2, ilo ), lda, c1,s1 )
              call stdlib_srot( ns, a( ilo, ilo ), lda, a( ilo+1, ilo ), lda, c2,s2 )
              call stdlib_srot( ns, b( ilo+1, ilo ), ldb, b( ilo+2, ilo ), ldb, c1,s1 )
              call stdlib_srot( ns, b( ilo, ilo ), ldb, b( ilo+1, ilo ), ldb, c2,s2 )
              call stdlib_srot( ns+1, qc( 1, 2 ), 1, qc( 1, 3 ), 1, c1, s1 )
              call stdlib_srot( ns+1, qc( 1, 1 ), 1, qc( 1, 2 ), 1, c2, s2 )
              ! chase the shift down
              do j = 1, ns-1-i
                 call stdlib_slaqz2( .true., .true., j, 1, ns, ihi-ilo+1, a( ilo,ilo ), lda, b( &
                           ilo, ilo ), ldb, ns+1, 1, qc,ldqc, ns, 1, zc, ldzc )
              end do
           end do
           ! update the rest of the pencil
           ! update a(ilo:ilo+ns,ilo+ns:istopm) and b(ilo:ilo+ns,ilo+ns:istopm)
           ! from the left with qc(1:ns+1,1:ns+1)'
           sheight = ns+1
           swidth = istopm-( ilo+ns )+1
           if ( swidth > 0 ) then
              call stdlib_sgemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,a( ilo, ilo+ns &
                        ), lda, zero, work, sheight )
              call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight, a( ilo,ilo+ns ), lda )
                        
              call stdlib_sgemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,b( ilo, ilo+ns &
                        ), ldb, zero, work, sheight )
              call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight, b( ilo,ilo+ns ), ldb )
                        
           end if
           if ( ilq ) then
              call stdlib_sgemm( 'N', 'N', n, sheight, sheight, one, q( 1, ilo ),ldq, qc, ldqc, &
                        zero, work, n )
              call stdlib_slacpy( 'ALL', n, sheight, work, n, q( 1, ilo ), ldq )
           end if
           ! update a(istartm:ilo-1,ilo:ilo+ns-1) and b(istartm:ilo-1,ilo:ilo+ns-1)
           ! from the right with zc(1:ns,1:ns)
           sheight = ilo-1-istartm+1
           swidth = ns
           if ( sheight > 0 ) then
              call stdlib_sgemm( 'N', 'N', sheight, swidth, swidth, one, a( istartm,ilo ), lda, &
                        zc, ldzc, zero, work, sheight )
              call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ilo ), lda )
                        
              call stdlib_sgemm( 'N', 'N', sheight, swidth, swidth, one, b( istartm,ilo ), ldb, &
                        zc, ldzc, zero, work, sheight )
              call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ilo ), ldb )
                        
           end if
           if ( ilz ) then
              call stdlib_sgemm( 'N', 'N', n, swidth, swidth, one, z( 1, ilo ), ldz,zc, ldzc, &
                        zero, work, n )
              call stdlib_slacpy( 'ALL', n, swidth, work, n, z( 1, ilo ), ldz )
           end if
           ! the following block chases the shifts down to the bottom
           ! right block. if possible, a shift is moved down npos
           ! positions at a time
           k = ilo
           do while ( k < ihi-ns )
              np = min( ihi-ns-k, npos )
              ! size of the near-the-diagonal block
              nblock = ns+np
              ! istartb points to the first row we will be updating
              istartb = k+1
              ! istopb points to the last column we will be updating
              istopb = k+nblock-1
              call stdlib_slaset( 'FULL', ns+np, ns+np, zero, one, qc, ldqc )
              call stdlib_slaset( 'FULL', ns+np, ns+np, zero, one, zc, ldzc )
              ! near the diagonal shift chase
              do i = ns-1, 0, -2
                 do j = 0, np-1
                    ! move down the block with index k+i+j-1, updating
                    ! the (ns+np x ns+np) block:
                    ! (k:k+ns+np,k:k+ns+np-1)
                    call stdlib_slaqz2( .true., .true., k+i+j-1, istartb, istopb,ihi, a, lda, b, &
                              ldb, nblock, k+1, qc, ldqc,nblock, k, zc, ldzc )
                 end do
              end do
              ! update rest of the pencil
              ! update a(k+1:k+ns+np, k+ns+np:istopm) and
              ! b(k+1:k+ns+np, k+ns+np:istopm)
              ! from the left with qc(1:ns+np,1:ns+np)'
              sheight = ns+np
              swidth = istopm-( k+ns+np )+1
              if ( swidth > 0 ) then
                 call stdlib_sgemm( 'T', 'N', sheight, swidth, sheight, one, qc,ldqc, a( k+1, k+&
                           ns+np ), lda, zero, work,sheight )
                 call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight, a( k+1,k+ns+np ), lda &
                           )
                 call stdlib_sgemm( 'T', 'N', sheight, swidth, sheight, one, qc,ldqc, b( k+1, k+&
                           ns+np ), ldb, zero, work,sheight )
                 call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight, b( k+1,k+ns+np ), ldb &
                           )
              end if
              if ( ilq ) then
                 call stdlib_sgemm( 'N', 'N', n, nblock, nblock, one, q( 1, k+1 ),ldq, qc, ldqc, &
                           zero, work, n )
                 call stdlib_slacpy( 'ALL', n, nblock, work, n, q( 1, k+1 ), ldq )
              end if
              ! update a(istartm:k,k:k+ns+npos-1) and b(istartm:k,k:k+ns+npos-1)
              ! from the right with zc(1:ns+np,1:ns+np)
              sheight = k-istartm+1
              swidth = nblock
              if ( sheight > 0 ) then
                 call stdlib_sgemm( 'N', 'N', sheight, swidth, swidth, one,a( istartm, k ), lda, &
                           zc, ldzc, zero, work,sheight )
                 call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight,a( istartm, k ), lda )
                           
                 call stdlib_sgemm( 'N', 'N', sheight, swidth, swidth, one,b( istartm, k ), ldb, &
                           zc, ldzc, zero, work,sheight )
                 call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight,b( istartm, k ), ldb )
                           
              end if
              if ( ilz ) then
                 call stdlib_sgemm( 'N', 'N', n, nblock, nblock, one, z( 1, k ),ldz, zc, ldzc, &
                           zero, work, n )
                 call stdlib_slacpy( 'ALL', n, nblock, work, n, z( 1, k ), ldz )
              end if
              k = k+np
           end do
           ! the following block removes the shifts from the bottom right corner
           ! one by one. updates are initially applied to a(ihi-ns+1:ihi,ihi-ns:ihi).
           call stdlib_slaset( 'FULL', ns, ns, zero, one, qc, ldqc )
           call stdlib_slaset( 'FULL', ns+1, ns+1, zero, one, zc, ldzc )
           ! istartb points to the first row we will be updating
           istartb = ihi-ns+1
           ! istopb points to the last column we will be updating
           istopb = ihi
           do i = 1, ns, 2
              ! chase the shift down to the bottom right corner
              do ishift = ihi-i-1, ihi-2
                 call stdlib_slaqz2( .true., .true., ishift, istartb, istopb, ihi,a, lda, b, ldb, &
                           ns, ihi-ns+1, qc, ldqc, ns+1,ihi-ns, zc, ldzc )
              end do
           end do
           ! update rest of the pencil
           ! update a(ihi-ns+1:ihi, ihi+1:istopm)
           ! from the left with qc(1:ns,1:ns)'
           sheight = ns
           swidth = istopm-( ihi+1 )+1
           if ( swidth > 0 ) then
              call stdlib_sgemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,a( ihi-ns+1, &
                        ihi+1 ), lda, zero, work, sheight )
              call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight,a( ihi-ns+1, ihi+1 ), lda &
                        )
              call stdlib_sgemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,b( ihi-ns+1, &
                        ihi+1 ), ldb, zero, work, sheight )
              call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight,b( ihi-ns+1, ihi+1 ), ldb &
                        )
           end if
           if ( ilq ) then
              call stdlib_sgemm( 'N', 'N', n, ns, ns, one, q( 1, ihi-ns+1 ), ldq,qc, ldqc, zero, &
                        work, n )
              call stdlib_slacpy( 'ALL', n, ns, work, n, q( 1, ihi-ns+1 ), ldq )
           end if
           ! update a(istartm:ihi-ns,ihi-ns:ihi)
           ! from the right with zc(1:ns+1,1:ns+1)
           sheight = ihi-ns-istartm+1
           swidth = ns+1
           if ( sheight > 0 ) then
              call stdlib_sgemm( 'N', 'N', sheight, swidth, swidth, one, a( istartm,ihi-ns ), lda,&
                         zc, ldzc, zero, work, sheight )
              call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ihi-ns ), lda &
                        )
              call stdlib_sgemm( 'N', 'N', sheight, swidth, swidth, one, b( istartm,ihi-ns ), ldb,&
                         zc, ldzc, zero, work, sheight )
              call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ihi-ns ), ldb &
                        )
           end if
           if ( ilz ) then
           call stdlib_sgemm( 'N', 'N', n, ns+1, ns+1, one, z( 1, ihi-ns ), ldz, zc,ldzc, zero, &
                     work, n )
              call stdlib_slacpy( 'ALL', n, ns+1, work, n, z( 1, ihi-ns ), ldz )
           end if
     end subroutine stdlib_slaqz4

     module pure subroutine stdlib_dlaqz4( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_desired, sr, &
     !! DLAQZ4 Executes a single multishift QZ sweep
               si, ss, a, lda, b, ldb, q,ldq, z, ldz, qc, ldqc, zc, ldzc, work, lwork,info )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! function arguments
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(ilp), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,nshifts, &
                     nblock_desired, ldqc, ldzc
           real(dp), intent( inout ) :: a( lda, * ), b( ldb, * ),q( ldq, * ), z( ldz, * ), qc( &
                     ldqc, * ),zc( ldzc, * ), work( * ), sr( * ), si( * ),ss( * )
           integer(ilp), intent( out ) :: info
           ! ================================================================
           ! local scalars
           integer(ilp) :: i, j, ns, istartm, istopm, sheight, swidth, k, np, istartb, istopb, &
                     ishift, nblock, npos
           real(dp) :: temp, v(3), c1, s1, c2, s2, swap
           info = 0
           if ( nblock_desired < nshifts+1 ) then
              info = -8
           end if
           if ( lwork ==-1 ) then
              ! workspace query, quick return
              work( 1 ) = n*nblock_desired
              return
           else if ( lwork < n*nblock_desired ) then
              info = -25
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAQZ4', -info )
              return
           end if
           ! executable statements
           if ( nshifts < 2 ) then
              return
           end if
           if ( ilo >= ihi ) then
              return
           end if
           if ( ilschur ) then
              istartm = 1
              istopm = n
           else
              istartm = ilo
              istopm = ihi
           end if
           ! shuffle shifts into pairs of real shifts and pairs
           ! of complex conjugate shifts assuming complex
           ! conjugate shifts are already adjacent to one
           ! another
           do i = 1, nshifts-2, 2
              if( si( i )/=-si( i+1 ) ) then
                 swap = sr( i )
                 sr( i ) = sr( i+1 )
                 sr( i+1 ) = sr( i+2 )
                 sr( i+2 ) = swap
                 swap = si( i )
                 si( i ) = si( i+1 )
                 si( i+1 ) = si( i+2 )
                 si( i+2 ) = swap
                 swap = ss( i )
                 ss( i ) = ss( i+1 )
                 ss( i+1 ) = ss( i+2 )
                 ss( i+2 ) = swap
              end if
           end do
           ! nshfts is supposed to be even, but if it is odd,
           ! then simply reduce it by one.  the shuffle above
           ! ensures that the dropped shift is real and that
           ! the remaining shifts are paired.
           ns = nshifts-mod( nshifts, 2 )
           npos = max( nblock_desired-ns, 1 )
           ! the following block introduces the shifts and chases
           ! them down one by one just enough to make space for
           ! the other shifts. the near-the-diagonal block is
           ! of size (ns+1) x ns.
           call stdlib_dlaset( 'FULL', ns+1, ns+1, zero, one, qc, ldqc )
           call stdlib_dlaset( 'FULL', ns, ns, zero, one, zc, ldzc )
           do i = 1, ns, 2
              ! introduce the shift
              call stdlib_dlaqz1( a( ilo, ilo ), lda, b( ilo, ilo ), ldb, sr( i ),sr( i+1 ), si( &
                        i ), ss( i ), ss( i+1 ), v )
              temp = v( 2 )
              call stdlib_dlartg( temp, v( 3 ), c1, s1, v( 2 ) )
              call stdlib_dlartg( v( 1 ), v( 2 ), c2, s2, temp )
              call stdlib_drot( ns, a( ilo+1, ilo ), lda, a( ilo+2, ilo ), lda, c1,s1 )
              call stdlib_drot( ns, a( ilo, ilo ), lda, a( ilo+1, ilo ), lda, c2,s2 )
              call stdlib_drot( ns, b( ilo+1, ilo ), ldb, b( ilo+2, ilo ), ldb, c1,s1 )
              call stdlib_drot( ns, b( ilo, ilo ), ldb, b( ilo+1, ilo ), ldb, c2,s2 )
              call stdlib_drot( ns+1, qc( 1, 2 ), 1, qc( 1, 3 ), 1, c1, s1 )
              call stdlib_drot( ns+1, qc( 1, 1 ), 1, qc( 1, 2 ), 1, c2, s2 )
              ! chase the shift down
              do j = 1, ns-1-i
                 call stdlib_dlaqz2( .true., .true., j, 1, ns, ihi-ilo+1, a( ilo,ilo ), lda, b( &
                           ilo, ilo ), ldb, ns+1, 1, qc,ldqc, ns, 1, zc, ldzc )
              end do
           end do
           ! update the rest of the pencil
           ! update a(ilo:ilo+ns,ilo+ns:istopm) and b(ilo:ilo+ns,ilo+ns:istopm)
           ! from the left with qc(1:ns+1,1:ns+1)'
           sheight = ns+1
           swidth = istopm-( ilo+ns )+1
           if ( swidth > 0 ) then
              call stdlib_dgemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,a( ilo, ilo+ns &
                        ), lda, zero, work, sheight )
              call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight, a( ilo,ilo+ns ), lda )
                        
              call stdlib_dgemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,b( ilo, ilo+ns &
                        ), ldb, zero, work, sheight )
              call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight, b( ilo,ilo+ns ), ldb )
                        
           end if
           if ( ilq ) then
              call stdlib_dgemm( 'N', 'N', n, sheight, sheight, one, q( 1, ilo ),ldq, qc, ldqc, &
                        zero, work, n )
              call stdlib_dlacpy( 'ALL', n, sheight, work, n, q( 1, ilo ), ldq )
           end if
           ! update a(istartm:ilo-1,ilo:ilo+ns-1) and b(istartm:ilo-1,ilo:ilo+ns-1)
           ! from the right with zc(1:ns,1:ns)
           sheight = ilo-1-istartm+1
           swidth = ns
           if ( sheight > 0 ) then
              call stdlib_dgemm( 'N', 'N', sheight, swidth, swidth, one, a( istartm,ilo ), lda, &
                        zc, ldzc, zero, work, sheight )
              call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ilo ), lda )
                        
              call stdlib_dgemm( 'N', 'N', sheight, swidth, swidth, one, b( istartm,ilo ), ldb, &
                        zc, ldzc, zero, work, sheight )
              call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ilo ), ldb )
                        
           end if
           if ( ilz ) then
              call stdlib_dgemm( 'N', 'N', n, swidth, swidth, one, z( 1, ilo ), ldz,zc, ldzc, &
                        zero, work, n )
              call stdlib_dlacpy( 'ALL', n, swidth, work, n, z( 1, ilo ), ldz )
           end if
           ! the following block chases the shifts down to the bottom
           ! right block. if possible, a shift is moved down npos
           ! positions at a time
           k = ilo
           do while ( k < ihi-ns )
              np = min( ihi-ns-k, npos )
              ! size of the near-the-diagonal block
              nblock = ns+np
              ! istartb points to the first row we will be updating
              istartb = k+1
              ! istopb points to the last column we will be updating
              istopb = k+nblock-1
              call stdlib_dlaset( 'FULL', ns+np, ns+np, zero, one, qc, ldqc )
              call stdlib_dlaset( 'FULL', ns+np, ns+np, zero, one, zc, ldzc )
              ! near the diagonal shift chase
              do i = ns-1, 0, -2
                 do j = 0, np-1
                    ! move down the block with index k+i+j-1, updating
                    ! the (ns+np x ns+np) block:
                    ! (k:k+ns+np,k:k+ns+np-1)
                    call stdlib_dlaqz2( .true., .true., k+i+j-1, istartb, istopb,ihi, a, lda, b, &
                              ldb, nblock, k+1, qc, ldqc,nblock, k, zc, ldzc )
                 end do
              end do
              ! update rest of the pencil
              ! update a(k+1:k+ns+np, k+ns+np:istopm) and
              ! b(k+1:k+ns+np, k+ns+np:istopm)
              ! from the left with qc(1:ns+np,1:ns+np)'
              sheight = ns+np
              swidth = istopm-( k+ns+np )+1
              if ( swidth > 0 ) then
                 call stdlib_dgemm( 'T', 'N', sheight, swidth, sheight, one, qc,ldqc, a( k+1, k+&
                           ns+np ), lda, zero, work,sheight )
                 call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight, a( k+1,k+ns+np ), lda &
                           )
                 call stdlib_dgemm( 'T', 'N', sheight, swidth, sheight, one, qc,ldqc, b( k+1, k+&
                           ns+np ), ldb, zero, work,sheight )
                 call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight, b( k+1,k+ns+np ), ldb &
                           )
              end if
              if ( ilq ) then
                 call stdlib_dgemm( 'N', 'N', n, nblock, nblock, one, q( 1, k+1 ),ldq, qc, ldqc, &
                           zero, work, n )
                 call stdlib_dlacpy( 'ALL', n, nblock, work, n, q( 1, k+1 ), ldq )
              end if
              ! update a(istartm:k,k:k+ns+npos-1) and b(istartm:k,k:k+ns+npos-1)
              ! from the right with zc(1:ns+np,1:ns+np)
              sheight = k-istartm+1
              swidth = nblock
              if ( sheight > 0 ) then
                 call stdlib_dgemm( 'N', 'N', sheight, swidth, swidth, one,a( istartm, k ), lda, &
                           zc, ldzc, zero, work,sheight )
                 call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight,a( istartm, k ), lda )
                           
                 call stdlib_dgemm( 'N', 'N', sheight, swidth, swidth, one,b( istartm, k ), ldb, &
                           zc, ldzc, zero, work,sheight )
                 call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight,b( istartm, k ), ldb )
                           
              end if
              if ( ilz ) then
                 call stdlib_dgemm( 'N', 'N', n, nblock, nblock, one, z( 1, k ),ldz, zc, ldzc, &
                           zero, work, n )
                 call stdlib_dlacpy( 'ALL', n, nblock, work, n, z( 1, k ), ldz )
              end if
              k = k+np
           end do
           ! the following block removes the shifts from the bottom right corner
           ! one by one. updates are initially applied to a(ihi-ns+1:ihi,ihi-ns:ihi).
           call stdlib_dlaset( 'FULL', ns, ns, zero, one, qc, ldqc )
           call stdlib_dlaset( 'FULL', ns+1, ns+1, zero, one, zc, ldzc )
           ! istartb points to the first row we will be updating
           istartb = ihi-ns+1
           ! istopb points to the last column we will be updating
           istopb = ihi
           do i = 1, ns, 2
              ! chase the shift down to the bottom right corner
              do ishift = ihi-i-1, ihi-2
                 call stdlib_dlaqz2( .true., .true., ishift, istartb, istopb, ihi,a, lda, b, ldb, &
                           ns, ihi-ns+1, qc, ldqc, ns+1,ihi-ns, zc, ldzc )
              end do
           end do
           ! update rest of the pencil
           ! update a(ihi-ns+1:ihi, ihi+1:istopm)
           ! from the left with qc(1:ns,1:ns)'
           sheight = ns
           swidth = istopm-( ihi+1 )+1
           if ( swidth > 0 ) then
              call stdlib_dgemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,a( ihi-ns+1, &
                        ihi+1 ), lda, zero, work, sheight )
              call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight,a( ihi-ns+1, ihi+1 ), lda &
                        )
              call stdlib_dgemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,b( ihi-ns+1, &
                        ihi+1 ), ldb, zero, work, sheight )
              call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight,b( ihi-ns+1, ihi+1 ), ldb &
                        )
           end if
           if ( ilq ) then
              call stdlib_dgemm( 'N', 'N', n, ns, ns, one, q( 1, ihi-ns+1 ), ldq,qc, ldqc, zero, &
                        work, n )
              call stdlib_dlacpy( 'ALL', n, ns, work, n, q( 1, ihi-ns+1 ), ldq )
           end if
           ! update a(istartm:ihi-ns,ihi-ns:ihi)
           ! from the right with zc(1:ns+1,1:ns+1)
           sheight = ihi-ns-istartm+1
           swidth = ns+1
           if ( sheight > 0 ) then
              call stdlib_dgemm( 'N', 'N', sheight, swidth, swidth, one, a( istartm,ihi-ns ), lda,&
                         zc, ldzc, zero, work, sheight )
              call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ihi-ns ), lda &
                        )
              call stdlib_dgemm( 'N', 'N', sheight, swidth, swidth, one, b( istartm,ihi-ns ), ldb,&
                         zc, ldzc, zero, work, sheight )
              call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ihi-ns ), ldb &
                        )
           end if
           if ( ilz ) then
              call stdlib_dgemm( 'N', 'N', n, ns+1, ns+1, one, z( 1, ihi-ns ), ldz,zc, ldzc, zero,&
                         work, n )
              call stdlib_dlacpy( 'ALL', n, ns+1, work, n, z( 1, ihi-ns ), ldz )
           end if
     end subroutine stdlib_dlaqz4

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$laqz4( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_qesired, sr, &
     !! DLAQZ4: Executes a single multishift QZ sweep
               si, ss, a, lda, b, ldb, q,ldq, z, ldz, qc, ldqc, zc, ldzc, work, lwork,info )
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! function arguments
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(ilp), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,nshifts, &
                     nblock_qesired, ldqc, ldzc
           real(${rk}$), intent( inout ) :: a( lda, * ), b( ldb, * ),q( ldq, * ), z( ldz, * ), qc( &
                     ldqc, * ),zc( ldzc, * ), work( * ), sr( * ), si( * ),ss( * )
           integer(ilp), intent( out ) :: info
           ! ================================================================
           ! local scalars
           integer(ilp) :: i, j, ns, istartm, istopm, sheight, swidth, k, np, istartb, istopb, &
                     ishift, nblock, npos
           real(${rk}$) :: temp, v(3), c1, s1, c2, s2, swap
           info = 0
           if ( nblock_qesired < nshifts+1 ) then
              info = -8
           end if
           if ( lwork ==-1 ) then
              ! workspace query, quick return
              work( 1 ) = n*nblock_qesired
              return
           else if ( lwork < n*nblock_qesired ) then
              info = -25
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAQZ4', -info )
              return
           end if
           ! executable statements
           if ( nshifts < 2 ) then
              return
           end if
           if ( ilo >= ihi ) then
              return
           end if
           if ( ilschur ) then
              istartm = 1
              istopm = n
           else
              istartm = ilo
              istopm = ihi
           end if
           ! shuffle shifts into pairs of real shifts and pairs
           ! of complex conjugate shifts assuming complex
           ! conjugate shifts are already adjacent to one
           ! another
           do i = 1, nshifts-2, 2
              if( si( i )/=-si( i+1 ) ) then
                 swap = sr( i )
                 sr( i ) = sr( i+1 )
                 sr( i+1 ) = sr( i+2 )
                 sr( i+2 ) = swap
                 swap = si( i )
                 si( i ) = si( i+1 )
                 si( i+1 ) = si( i+2 )
                 si( i+2 ) = swap
                 swap = ss( i )
                 ss( i ) = ss( i+1 )
                 ss( i+1 ) = ss( i+2 )
                 ss( i+2 ) = swap
              end if
           end do
           ! nshfts is supposed to be even, but if it is odd,
           ! then simply reduce it by one.  the shuffle above
           ! ensures that the dropped shift is real and that
           ! the remaining shifts are paired.
           ns = nshifts-mod( nshifts, 2 )
           npos = max( nblock_qesired-ns, 1 )
           ! the following block introduces the shifts and chases
           ! them down one by one just enough to make space for
           ! the other shifts. the near-the-diagonal block is
           ! of size (ns+1) x ns.
           call stdlib_${ri}$laset( 'FULL', ns+1, ns+1, zero, one, qc, ldqc )
           call stdlib_${ri}$laset( 'FULL', ns, ns, zero, one, zc, ldzc )
           do i = 1, ns, 2
              ! introduce the shift
              call stdlib_${ri}$laqz1( a( ilo, ilo ), lda, b( ilo, ilo ), ldb, sr( i ),sr( i+1 ), si( &
                        i ), ss( i ), ss( i+1 ), v )
              temp = v( 2 )
              call stdlib_${ri}$lartg( temp, v( 3 ), c1, s1, v( 2 ) )
              call stdlib_${ri}$lartg( v( 1 ), v( 2 ), c2, s2, temp )
              call stdlib_${ri}$rot( ns, a( ilo+1, ilo ), lda, a( ilo+2, ilo ), lda, c1,s1 )
              call stdlib_${ri}$rot( ns, a( ilo, ilo ), lda, a( ilo+1, ilo ), lda, c2,s2 )
              call stdlib_${ri}$rot( ns, b( ilo+1, ilo ), ldb, b( ilo+2, ilo ), ldb, c1,s1 )
              call stdlib_${ri}$rot( ns, b( ilo, ilo ), ldb, b( ilo+1, ilo ), ldb, c2,s2 )
              call stdlib_${ri}$rot( ns+1, qc( 1, 2 ), 1, qc( 1, 3 ), 1, c1, s1 )
              call stdlib_${ri}$rot( ns+1, qc( 1, 1 ), 1, qc( 1, 2 ), 1, c2, s2 )
              ! chase the shift down
              do j = 1, ns-1-i
                 call stdlib_${ri}$laqz2( .true., .true., j, 1, ns, ihi-ilo+1, a( ilo,ilo ), lda, b( &
                           ilo, ilo ), ldb, ns+1, 1, qc,ldqc, ns, 1, zc, ldzc )
              end do
           end do
           ! update the rest of the pencil
           ! update a(ilo:ilo+ns,ilo+ns:istopm) and b(ilo:ilo+ns,ilo+ns:istopm)
           ! from the left with qc(1:ns+1,1:ns+1)'
           sheight = ns+1
           swidth = istopm-( ilo+ns )+1
           if ( swidth > 0 ) then
              call stdlib_${ri}$gemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,a( ilo, ilo+ns &
                        ), lda, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, a( ilo,ilo+ns ), lda )
                        
              call stdlib_${ri}$gemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,b( ilo, ilo+ns &
                        ), ldb, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, b( ilo,ilo+ns ), ldb )
                        
           end if
           if ( ilq ) then
              call stdlib_${ri}$gemm( 'N', 'N', n, sheight, sheight, one, q( 1, ilo ),ldq, qc, ldqc, &
                        zero, work, n )
              call stdlib_${ri}$lacpy( 'ALL', n, sheight, work, n, q( 1, ilo ), ldq )
           end if
           ! update a(istartm:ilo-1,ilo:ilo+ns-1) and b(istartm:ilo-1,ilo:ilo+ns-1)
           ! from the right with zc(1:ns,1:ns)
           sheight = ilo-1-istartm+1
           swidth = ns
           if ( sheight > 0 ) then
              call stdlib_${ri}$gemm( 'N', 'N', sheight, swidth, swidth, one, a( istartm,ilo ), lda, &
                        zc, ldzc, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ilo ), lda )
                        
              call stdlib_${ri}$gemm( 'N', 'N', sheight, swidth, swidth, one, b( istartm,ilo ), ldb, &
                        zc, ldzc, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ilo ), ldb )
                        
           end if
           if ( ilz ) then
              call stdlib_${ri}$gemm( 'N', 'N', n, swidth, swidth, one, z( 1, ilo ), ldz,zc, ldzc, &
                        zero, work, n )
              call stdlib_${ri}$lacpy( 'ALL', n, swidth, work, n, z( 1, ilo ), ldz )
           end if
           ! the following block chases the shifts down to the bottom
           ! right block. if possible, a shift is moved down npos
           ! positions at a time
           k = ilo
           do while ( k < ihi-ns )
              np = min( ihi-ns-k, npos )
              ! size of the near-the-diagonal block
              nblock = ns+np
              ! istartb points to the first row we will be updating
              istartb = k+1
              ! istopb points to the last column we will be updating
              istopb = k+nblock-1
              call stdlib_${ri}$laset( 'FULL', ns+np, ns+np, zero, one, qc, ldqc )
              call stdlib_${ri}$laset( 'FULL', ns+np, ns+np, zero, one, zc, ldzc )
              ! near the diagonal shift chase
              do i = ns-1, 0, -2
                 do j = 0, np-1
                    ! move down the block with index k+i+j-1, updating
                    ! the (ns+np x ns+np) block:
                    ! (k:k+ns+np,k:k+ns+np-1)
                    call stdlib_${ri}$laqz2( .true., .true., k+i+j-1, istartb, istopb,ihi, a, lda, b, &
                              ldb, nblock, k+1, qc, ldqc,nblock, k, zc, ldzc )
                 end do
              end do
              ! update rest of the pencil
              ! update a(k+1:k+ns+np, k+ns+np:istopm) and
              ! b(k+1:k+ns+np, k+ns+np:istopm)
              ! from the left with qc(1:ns+np,1:ns+np)'
              sheight = ns+np
              swidth = istopm-( k+ns+np )+1
              if ( swidth > 0 ) then
                 call stdlib_${ri}$gemm( 'T', 'N', sheight, swidth, sheight, one, qc,ldqc, a( k+1, k+&
                           ns+np ), lda, zero, work,sheight )
                 call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, a( k+1,k+ns+np ), lda &
                           )
                 call stdlib_${ri}$gemm( 'T', 'N', sheight, swidth, sheight, one, qc,ldqc, b( k+1, k+&
                           ns+np ), ldb, zero, work,sheight )
                 call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, b( k+1,k+ns+np ), ldb &
                           )
              end if
              if ( ilq ) then
                 call stdlib_${ri}$gemm( 'N', 'N', n, nblock, nblock, one, q( 1, k+1 ),ldq, qc, ldqc, &
                           zero, work, n )
                 call stdlib_${ri}$lacpy( 'ALL', n, nblock, work, n, q( 1, k+1 ), ldq )
              end if
              ! update a(istartm:k,k:k+ns+npos-1) and b(istartm:k,k:k+ns+npos-1)
              ! from the right with zc(1:ns+np,1:ns+np)
              sheight = k-istartm+1
              swidth = nblock
              if ( sheight > 0 ) then
                 call stdlib_${ri}$gemm( 'N', 'N', sheight, swidth, swidth, one,a( istartm, k ), lda, &
                           zc, ldzc, zero, work,sheight )
                 call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight,a( istartm, k ), lda )
                           
                 call stdlib_${ri}$gemm( 'N', 'N', sheight, swidth, swidth, one,b( istartm, k ), ldb, &
                           zc, ldzc, zero, work,sheight )
                 call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight,b( istartm, k ), ldb )
                           
              end if
              if ( ilz ) then
                 call stdlib_${ri}$gemm( 'N', 'N', n, nblock, nblock, one, z( 1, k ),ldz, zc, ldzc, &
                           zero, work, n )
                 call stdlib_${ri}$lacpy( 'ALL', n, nblock, work, n, z( 1, k ), ldz )
              end if
              k = k+np
           end do
           ! the following block removes the shifts from the bottom right corner
           ! one by one. updates are initially applied to a(ihi-ns+1:ihi,ihi-ns:ihi).
           call stdlib_${ri}$laset( 'FULL', ns, ns, zero, one, qc, ldqc )
           call stdlib_${ri}$laset( 'FULL', ns+1, ns+1, zero, one, zc, ldzc )
           ! istartb points to the first row we will be updating
           istartb = ihi-ns+1
           ! istopb points to the last column we will be updating
           istopb = ihi
           do i = 1, ns, 2
              ! chase the shift down to the bottom right corner
              do ishift = ihi-i-1, ihi-2
                 call stdlib_${ri}$laqz2( .true., .true., ishift, istartb, istopb, ihi,a, lda, b, ldb, &
                           ns, ihi-ns+1, qc, ldqc, ns+1,ihi-ns, zc, ldzc )
              end do
           end do
           ! update rest of the pencil
           ! update a(ihi-ns+1:ihi, ihi+1:istopm)
           ! from the left with qc(1:ns,1:ns)'
           sheight = ns
           swidth = istopm-( ihi+1 )+1
           if ( swidth > 0 ) then
              call stdlib_${ri}$gemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,a( ihi-ns+1, &
                        ihi+1 ), lda, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight,a( ihi-ns+1, ihi+1 ), lda &
                        )
              call stdlib_${ri}$gemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,b( ihi-ns+1, &
                        ihi+1 ), ldb, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight,b( ihi-ns+1, ihi+1 ), ldb &
                        )
           end if
           if ( ilq ) then
              call stdlib_${ri}$gemm( 'N', 'N', n, ns, ns, one, q( 1, ihi-ns+1 ), ldq,qc, ldqc, zero, &
                        work, n )
              call stdlib_${ri}$lacpy( 'ALL', n, ns, work, n, q( 1, ihi-ns+1 ), ldq )
           end if
           ! update a(istartm:ihi-ns,ihi-ns:ihi)
           ! from the right with zc(1:ns+1,1:ns+1)
           sheight = ihi-ns-istartm+1
           swidth = ns+1
           if ( sheight > 0 ) then
              call stdlib_${ri}$gemm( 'N', 'N', sheight, swidth, swidth, one, a( istartm,ihi-ns ), lda,&
                         zc, ldzc, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ihi-ns ), lda &
                        )
              call stdlib_${ri}$gemm( 'N', 'N', sheight, swidth, swidth, one, b( istartm,ihi-ns ), ldb,&
                         zc, ldzc, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ihi-ns ), ldb &
                        )
           end if
           if ( ilz ) then
              call stdlib_${ri}$gemm( 'N', 'N', n, ns+1, ns+1, one, z( 1, ihi-ns ), ldz,zc, ldzc, zero,&
                         work, n )
              call stdlib_${ri}$lacpy( 'ALL', n, ns+1, work, n, z( 1, ihi-ns ), ldz )
           end if
     end subroutine stdlib_${ri}$laqz4

#:endif
#:endfor



     module pure subroutine stdlib_slagv2( a, lda, b, ldb, alphar, alphai, beta, csl, snl,csr, snr )
     !! SLAGV2 computes the Generalized Schur factorization of a real 2-by-2
     !! matrix pencil (A,B) where B is upper triangular. This routine
     !! computes orthogonal (rotation) matrices given by CSL, SNL and CSR,
     !! SNR such that
     !! 1) if the pencil (A,B) has two real eigenvalues (include 0/0 or 1/0
     !! types), then
     !! [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
     !! [  0  a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]
     !! [ b11 b12 ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
     !! [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ],
     !! 2) if the pencil (A,B) has a pair of complex conjugate eigenvalues,
     !! then
     !! [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
     !! [ a21 a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]
     !! [ b11  0  ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
     !! [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ]
     !! where b11 >= b22 > 0.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: lda, ldb
           real(sp), intent(out) :: csl, csr, snl, snr
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: alphai(2), alphar(2), beta(2)
        ! =====================================================================
           
           ! Local Scalars 
           real(sp) :: anorm, ascale, bnorm, bscale, h1, h2, h3, qq, r, rr, safmin, scale1, &
                     scale2, t, ulp, wi, wr1, wr2
           ! Intrinsic Functions 
           ! Executable Statements 
           safmin = stdlib_slamch( 'S' )
           ulp = stdlib_slamch( 'P' )
           ! scale a
           anorm = max( abs( a( 1, 1 ) )+abs( a( 2, 1 ) ),abs( a( 1, 2 ) )+abs( a( 2, 2 ) ), &
                     safmin )
           ascale = one / anorm
           a( 1, 1 ) = ascale*a( 1, 1 )
           a( 1, 2 ) = ascale*a( 1, 2 )
           a( 2, 1 ) = ascale*a( 2, 1 )
           a( 2, 2 ) = ascale*a( 2, 2 )
           ! scale b
           bnorm = max( abs( b( 1, 1 ) ), abs( b( 1, 2 ) )+abs( b( 2, 2 ) ),safmin )
           bscale = one / bnorm
           b( 1, 1 ) = bscale*b( 1, 1 )
           b( 1, 2 ) = bscale*b( 1, 2 )
           b( 2, 2 ) = bscale*b( 2, 2 )
           ! check if a can be deflated
           if( abs( a( 2, 1 ) )<=ulp ) then
              csl = one
              snl = zero
              csr = one
              snr = zero
              a( 2, 1 ) = zero
              b( 2, 1 ) = zero
              wi = zero
           ! check if b is singular
           else if( abs( b( 1, 1 ) )<=ulp ) then
              call stdlib_slartg( a( 1, 1 ), a( 2, 1 ), csl, snl, r )
              csr = one
              snr = zero
              call stdlib_srot( 2, a( 1, 1 ), lda, a( 2, 1 ), lda, csl, snl )
              call stdlib_srot( 2, b( 1, 1 ), ldb, b( 2, 1 ), ldb, csl, snl )
              a( 2, 1 ) = zero
              b( 1, 1 ) = zero
              b( 2, 1 ) = zero
              wi = zero
           else if( abs( b( 2, 2 ) )<=ulp ) then
              call stdlib_slartg( a( 2, 2 ), a( 2, 1 ), csr, snr, t )
              snr = -snr
              call stdlib_srot( 2, a( 1, 1 ), 1, a( 1, 2 ), 1, csr, snr )
              call stdlib_srot( 2, b( 1, 1 ), 1, b( 1, 2 ), 1, csr, snr )
              csl = one
              snl = zero
              a( 2, 1 ) = zero
              b( 2, 1 ) = zero
              b( 2, 2 ) = zero
              wi = zero
           else
              ! b is nonsingular, first compute the eigenvalues of (a,b)
              call stdlib_slag2( a, lda, b, ldb, safmin, scale1, scale2, wr1, wr2,wi )
              if( wi==zero ) then
                 ! two real eigenvalues, compute s*a-w*b
                 h1 = scale1*a( 1, 1 ) - wr1*b( 1, 1 )
                 h2 = scale1*a( 1, 2 ) - wr1*b( 1, 2 )
                 h3 = scale1*a( 2, 2 ) - wr1*b( 2, 2 )
                 rr = stdlib_slapy2( h1, h2 )
                 qq = stdlib_slapy2( scale1*a( 2, 1 ), h3 )
                 if( rr>qq ) then
                    ! find right rotation matrix to zero 1,1 element of
                    ! (sa - wb)
                    call stdlib_slartg( h2, h1, csr, snr, t )
                 else
                    ! find right rotation matrix to zero 2,1 element of
                    ! (sa - wb)
                    call stdlib_slartg( h3, scale1*a( 2, 1 ), csr, snr, t )
                 end if
                 snr = -snr
                 call stdlib_srot( 2, a( 1, 1 ), 1, a( 1, 2 ), 1, csr, snr )
                 call stdlib_srot( 2, b( 1, 1 ), 1, b( 1, 2 ), 1, csr, snr )
                 ! compute inf norms of a and b
                 h1 = max( abs( a( 1, 1 ) )+abs( a( 1, 2 ) ),abs( a( 2, 1 ) )+abs( a( 2, 2 ) ) )
                           
                 h2 = max( abs( b( 1, 1 ) )+abs( b( 1, 2 ) ),abs( b( 2, 1 ) )+abs( b( 2, 2 ) ) )
                           
                 if( ( scale1*h1 )>=abs( wr1 )*h2 ) then
                    ! find left rotation matrix q to zero out b(2,1)
                    call stdlib_slartg( b( 1, 1 ), b( 2, 1 ), csl, snl, r )
                 else
                    ! find left rotation matrix q to zero out a(2,1)
                    call stdlib_slartg( a( 1, 1 ), a( 2, 1 ), csl, snl, r )
                 end if
                 call stdlib_srot( 2, a( 1, 1 ), lda, a( 2, 1 ), lda, csl, snl )
                 call stdlib_srot( 2, b( 1, 1 ), ldb, b( 2, 1 ), ldb, csl, snl )
                 a( 2, 1 ) = zero
                 b( 2, 1 ) = zero
              else
                 ! a pair of complex conjugate eigenvalues
                 ! first compute the svd of the matrix b
                 call stdlib_slasv2( b( 1, 1 ), b( 1, 2 ), b( 2, 2 ), r, t, snr,csr, snl, csl )
                           
                 ! form (a,b) := q(a,b)z**t where q is left rotation matrix and
                 ! z is right rotation matrix computed from stdlib_slasv2
                 call stdlib_srot( 2, a( 1, 1 ), lda, a( 2, 1 ), lda, csl, snl )
                 call stdlib_srot( 2, b( 1, 1 ), ldb, b( 2, 1 ), ldb, csl, snl )
                 call stdlib_srot( 2, a( 1, 1 ), 1, a( 1, 2 ), 1, csr, snr )
                 call stdlib_srot( 2, b( 1, 1 ), 1, b( 1, 2 ), 1, csr, snr )
                 b( 2, 1 ) = zero
                 b( 1, 2 ) = zero
              end if
           end if
           ! unscaling
           a( 1, 1 ) = anorm*a( 1, 1 )
           a( 2, 1 ) = anorm*a( 2, 1 )
           a( 1, 2 ) = anorm*a( 1, 2 )
           a( 2, 2 ) = anorm*a( 2, 2 )
           b( 1, 1 ) = bnorm*b( 1, 1 )
           b( 2, 1 ) = bnorm*b( 2, 1 )
           b( 1, 2 ) = bnorm*b( 1, 2 )
           b( 2, 2 ) = bnorm*b( 2, 2 )
           if( wi==zero ) then
              alphar( 1 ) = a( 1, 1 )
              alphar( 2 ) = a( 2, 2 )
              alphai( 1 ) = zero
              alphai( 2 ) = zero
              beta( 1 ) = b( 1, 1 )
              beta( 2 ) = b( 2, 2 )
           else
              alphar( 1 ) = anorm*wr1 / scale1 / bnorm
              alphai( 1 ) = anorm*wi / scale1 / bnorm
              alphar( 2 ) = alphar( 1 )
              alphai( 2 ) = -alphai( 1 )
              beta( 1 ) = one
              beta( 2 ) = one
           end if
           return
     end subroutine stdlib_slagv2

     module pure subroutine stdlib_dlagv2( a, lda, b, ldb, alphar, alphai, beta, csl, snl,csr, snr )
     !! DLAGV2 computes the Generalized Schur factorization of a real 2-by-2
     !! matrix pencil (A,B) where B is upper triangular. This routine
     !! computes orthogonal (rotation) matrices given by CSL, SNL and CSR,
     !! SNR such that
     !! 1) if the pencil (A,B) has two real eigenvalues (include 0/0 or 1/0
     !! types), then
     !! [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
     !! [  0  a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]
     !! [ b11 b12 ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
     !! [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ],
     !! 2) if the pencil (A,B) has a pair of complex conjugate eigenvalues,
     !! then
     !! [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
     !! [ a21 a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]
     !! [ b11  0  ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
     !! [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ]
     !! where b11 >= b22 > 0.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: lda, ldb
           real(dp), intent(out) :: csl, csr, snl, snr
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: alphai(2), alphar(2), beta(2)
        ! =====================================================================
           
           ! Local Scalars 
           real(dp) :: anorm, ascale, bnorm, bscale, h1, h2, h3, qq, r, rr, safmin, scale1, &
                     scale2, t, ulp, wi, wr1, wr2
           ! Intrinsic Functions 
           ! Executable Statements 
           safmin = stdlib_dlamch( 'S' )
           ulp = stdlib_dlamch( 'P' )
           ! scale a
           anorm = max( abs( a( 1, 1 ) )+abs( a( 2, 1 ) ),abs( a( 1, 2 ) )+abs( a( 2, 2 ) ), &
                     safmin )
           ascale = one / anorm
           a( 1, 1 ) = ascale*a( 1, 1 )
           a( 1, 2 ) = ascale*a( 1, 2 )
           a( 2, 1 ) = ascale*a( 2, 1 )
           a( 2, 2 ) = ascale*a( 2, 2 )
           ! scale b
           bnorm = max( abs( b( 1, 1 ) ), abs( b( 1, 2 ) )+abs( b( 2, 2 ) ),safmin )
           bscale = one / bnorm
           b( 1, 1 ) = bscale*b( 1, 1 )
           b( 1, 2 ) = bscale*b( 1, 2 )
           b( 2, 2 ) = bscale*b( 2, 2 )
           ! check if a can be deflated
           if( abs( a( 2, 1 ) )<=ulp ) then
              csl = one
              snl = zero
              csr = one
              snr = zero
              a( 2, 1 ) = zero
              b( 2, 1 ) = zero
              wi = zero
           ! check if b is singular
           else if( abs( b( 1, 1 ) )<=ulp ) then
              call stdlib_dlartg( a( 1, 1 ), a( 2, 1 ), csl, snl, r )
              csr = one
              snr = zero
              call stdlib_drot( 2, a( 1, 1 ), lda, a( 2, 1 ), lda, csl, snl )
              call stdlib_drot( 2, b( 1, 1 ), ldb, b( 2, 1 ), ldb, csl, snl )
              a( 2, 1 ) = zero
              b( 1, 1 ) = zero
              b( 2, 1 ) = zero
              wi = zero
           else if( abs( b( 2, 2 ) )<=ulp ) then
              call stdlib_dlartg( a( 2, 2 ), a( 2, 1 ), csr, snr, t )
              snr = -snr
              call stdlib_drot( 2, a( 1, 1 ), 1, a( 1, 2 ), 1, csr, snr )
              call stdlib_drot( 2, b( 1, 1 ), 1, b( 1, 2 ), 1, csr, snr )
              csl = one
              snl = zero
              a( 2, 1 ) = zero
              b( 2, 1 ) = zero
              b( 2, 2 ) = zero
              wi = zero
           else
              ! b is nonsingular, first compute the eigenvalues of (a,b)
              call stdlib_dlag2( a, lda, b, ldb, safmin, scale1, scale2, wr1, wr2,wi )
              if( wi==zero ) then
                 ! two real eigenvalues, compute s*a-w*b
                 h1 = scale1*a( 1, 1 ) - wr1*b( 1, 1 )
                 h2 = scale1*a( 1, 2 ) - wr1*b( 1, 2 )
                 h3 = scale1*a( 2, 2 ) - wr1*b( 2, 2 )
                 rr = stdlib_dlapy2( h1, h2 )
                 qq = stdlib_dlapy2( scale1*a( 2, 1 ), h3 )
                 if( rr>qq ) then
                    ! find right rotation matrix to zero 1,1 element of
                    ! (sa - wb)
                    call stdlib_dlartg( h2, h1, csr, snr, t )
                 else
                    ! find right rotation matrix to zero 2,1 element of
                    ! (sa - wb)
                    call stdlib_dlartg( h3, scale1*a( 2, 1 ), csr, snr, t )
                 end if
                 snr = -snr
                 call stdlib_drot( 2, a( 1, 1 ), 1, a( 1, 2 ), 1, csr, snr )
                 call stdlib_drot( 2, b( 1, 1 ), 1, b( 1, 2 ), 1, csr, snr )
                 ! compute inf norms of a and b
                 h1 = max( abs( a( 1, 1 ) )+abs( a( 1, 2 ) ),abs( a( 2, 1 ) )+abs( a( 2, 2 ) ) )
                           
                 h2 = max( abs( b( 1, 1 ) )+abs( b( 1, 2 ) ),abs( b( 2, 1 ) )+abs( b( 2, 2 ) ) )
                           
                 if( ( scale1*h1 )>=abs( wr1 )*h2 ) then
                    ! find left rotation matrix q to zero out b(2,1)
                    call stdlib_dlartg( b( 1, 1 ), b( 2, 1 ), csl, snl, r )
                 else
                    ! find left rotation matrix q to zero out a(2,1)
                    call stdlib_dlartg( a( 1, 1 ), a( 2, 1 ), csl, snl, r )
                 end if
                 call stdlib_drot( 2, a( 1, 1 ), lda, a( 2, 1 ), lda, csl, snl )
                 call stdlib_drot( 2, b( 1, 1 ), ldb, b( 2, 1 ), ldb, csl, snl )
                 a( 2, 1 ) = zero
                 b( 2, 1 ) = zero
              else
                 ! a pair of complex conjugate eigenvalues
                 ! first compute the svd of the matrix b
                 call stdlib_dlasv2( b( 1, 1 ), b( 1, 2 ), b( 2, 2 ), r, t, snr,csr, snl, csl )
                           
                 ! form (a,b) := q(a,b)z**t where q is left rotation matrix and
                 ! z is right rotation matrix computed from stdlib_dlasv2
                 call stdlib_drot( 2, a( 1, 1 ), lda, a( 2, 1 ), lda, csl, snl )
                 call stdlib_drot( 2, b( 1, 1 ), ldb, b( 2, 1 ), ldb, csl, snl )
                 call stdlib_drot( 2, a( 1, 1 ), 1, a( 1, 2 ), 1, csr, snr )
                 call stdlib_drot( 2, b( 1, 1 ), 1, b( 1, 2 ), 1, csr, snr )
                 b( 2, 1 ) = zero
                 b( 1, 2 ) = zero
              end if
           end if
           ! unscaling
           a( 1, 1 ) = anorm*a( 1, 1 )
           a( 2, 1 ) = anorm*a( 2, 1 )
           a( 1, 2 ) = anorm*a( 1, 2 )
           a( 2, 2 ) = anorm*a( 2, 2 )
           b( 1, 1 ) = bnorm*b( 1, 1 )
           b( 2, 1 ) = bnorm*b( 2, 1 )
           b( 1, 2 ) = bnorm*b( 1, 2 )
           b( 2, 2 ) = bnorm*b( 2, 2 )
           if( wi==zero ) then
              alphar( 1 ) = a( 1, 1 )
              alphar( 2 ) = a( 2, 2 )
              alphai( 1 ) = zero
              alphai( 2 ) = zero
              beta( 1 ) = b( 1, 1 )
              beta( 2 ) = b( 2, 2 )
           else
              alphar( 1 ) = anorm*wr1 / scale1 / bnorm
              alphai( 1 ) = anorm*wi / scale1 / bnorm
              alphar( 2 ) = alphar( 1 )
              alphai( 2 ) = -alphai( 1 )
              beta( 1 ) = one
              beta( 2 ) = one
           end if
           return
     end subroutine stdlib_dlagv2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$lagv2( a, lda, b, ldb, alphar, alphai, beta, csl, snl,csr, snr )
     !! DLAGV2: computes the Generalized Schur factorization of a real 2-by-2
     !! matrix pencil (A,B) where B is upper triangular. This routine
     !! computes orthogonal (rotation) matrices given by CSL, SNL and CSR,
     !! SNR such that
     !! 1) if the pencil (A,B) has two real eigenvalues (include 0/0 or 1/0
     !! types), then
     !! [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
     !! [  0  a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]
     !! [ b11 b12 ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
     !! [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ],
     !! 2) if the pencil (A,B) has a pair of complex conjugate eigenvalues,
     !! then
     !! [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
     !! [ a21 a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]
     !! [ b11  0  ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
     !! [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ]
     !! where b11 >= b22 > 0.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: lda, ldb
           real(${rk}$), intent(out) :: csl, csr, snl, snr
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: alphai(2), alphar(2), beta(2)
        ! =====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: anorm, ascale, bnorm, bscale, h1, h2, h3, qq, r, rr, safmin, scale1, &
                     scale2, t, ulp, wi, wr1, wr2
           ! Intrinsic Functions 
           ! Executable Statements 
           safmin = stdlib_${ri}$lamch( 'S' )
           ulp = stdlib_${ri}$lamch( 'P' )
           ! scale a
           anorm = max( abs( a( 1, 1 ) )+abs( a( 2, 1 ) ),abs( a( 1, 2 ) )+abs( a( 2, 2 ) ), &
                     safmin )
           ascale = one / anorm
           a( 1, 1 ) = ascale*a( 1, 1 )
           a( 1, 2 ) = ascale*a( 1, 2 )
           a( 2, 1 ) = ascale*a( 2, 1 )
           a( 2, 2 ) = ascale*a( 2, 2 )
           ! scale b
           bnorm = max( abs( b( 1, 1 ) ), abs( b( 1, 2 ) )+abs( b( 2, 2 ) ),safmin )
           bscale = one / bnorm
           b( 1, 1 ) = bscale*b( 1, 1 )
           b( 1, 2 ) = bscale*b( 1, 2 )
           b( 2, 2 ) = bscale*b( 2, 2 )
           ! check if a can be deflated
           if( abs( a( 2, 1 ) )<=ulp ) then
              csl = one
              snl = zero
              csr = one
              snr = zero
              a( 2, 1 ) = zero
              b( 2, 1 ) = zero
              wi = zero
           ! check if b is singular
           else if( abs( b( 1, 1 ) )<=ulp ) then
              call stdlib_${ri}$lartg( a( 1, 1 ), a( 2, 1 ), csl, snl, r )
              csr = one
              snr = zero
              call stdlib_${ri}$rot( 2, a( 1, 1 ), lda, a( 2, 1 ), lda, csl, snl )
              call stdlib_${ri}$rot( 2, b( 1, 1 ), ldb, b( 2, 1 ), ldb, csl, snl )
              a( 2, 1 ) = zero
              b( 1, 1 ) = zero
              b( 2, 1 ) = zero
              wi = zero
           else if( abs( b( 2, 2 ) )<=ulp ) then
              call stdlib_${ri}$lartg( a( 2, 2 ), a( 2, 1 ), csr, snr, t )
              snr = -snr
              call stdlib_${ri}$rot( 2, a( 1, 1 ), 1, a( 1, 2 ), 1, csr, snr )
              call stdlib_${ri}$rot( 2, b( 1, 1 ), 1, b( 1, 2 ), 1, csr, snr )
              csl = one
              snl = zero
              a( 2, 1 ) = zero
              b( 2, 1 ) = zero
              b( 2, 2 ) = zero
              wi = zero
           else
              ! b is nonsingular, first compute the eigenvalues of (a,b)
              call stdlib_${ri}$lag2( a, lda, b, ldb, safmin, scale1, scale2, wr1, wr2,wi )
              if( wi==zero ) then
                 ! two real eigenvalues, compute s*a-w*b
                 h1 = scale1*a( 1, 1 ) - wr1*b( 1, 1 )
                 h2 = scale1*a( 1, 2 ) - wr1*b( 1, 2 )
                 h3 = scale1*a( 2, 2 ) - wr1*b( 2, 2 )
                 rr = stdlib_${ri}$lapy2( h1, h2 )
                 qq = stdlib_${ri}$lapy2( scale1*a( 2, 1 ), h3 )
                 if( rr>qq ) then
                    ! find right rotation matrix to zero 1,1 element of
                    ! (sa - wb)
                    call stdlib_${ri}$lartg( h2, h1, csr, snr, t )
                 else
                    ! find right rotation matrix to zero 2,1 element of
                    ! (sa - wb)
                    call stdlib_${ri}$lartg( h3, scale1*a( 2, 1 ), csr, snr, t )
                 end if
                 snr = -snr
                 call stdlib_${ri}$rot( 2, a( 1, 1 ), 1, a( 1, 2 ), 1, csr, snr )
                 call stdlib_${ri}$rot( 2, b( 1, 1 ), 1, b( 1, 2 ), 1, csr, snr )
                 ! compute inf norms of a and b
                 h1 = max( abs( a( 1, 1 ) )+abs( a( 1, 2 ) ),abs( a( 2, 1 ) )+abs( a( 2, 2 ) ) )
                           
                 h2 = max( abs( b( 1, 1 ) )+abs( b( 1, 2 ) ),abs( b( 2, 1 ) )+abs( b( 2, 2 ) ) )
                           
                 if( ( scale1*h1 )>=abs( wr1 )*h2 ) then
                    ! find left rotation matrix q to zero out b(2,1)
                    call stdlib_${ri}$lartg( b( 1, 1 ), b( 2, 1 ), csl, snl, r )
                 else
                    ! find left rotation matrix q to zero out a(2,1)
                    call stdlib_${ri}$lartg( a( 1, 1 ), a( 2, 1 ), csl, snl, r )
                 end if
                 call stdlib_${ri}$rot( 2, a( 1, 1 ), lda, a( 2, 1 ), lda, csl, snl )
                 call stdlib_${ri}$rot( 2, b( 1, 1 ), ldb, b( 2, 1 ), ldb, csl, snl )
                 a( 2, 1 ) = zero
                 b( 2, 1 ) = zero
              else
                 ! a pair of complex conjugate eigenvalues
                 ! first compute the svd of the matrix b
                 call stdlib_${ri}$lasv2( b( 1, 1 ), b( 1, 2 ), b( 2, 2 ), r, t, snr,csr, snl, csl )
                           
                 ! form (a,b) := q(a,b)z**t where q is left rotation matrix and
                 ! z is right rotation matrix computed from stdlib_${ri}$lasv2
                 call stdlib_${ri}$rot( 2, a( 1, 1 ), lda, a( 2, 1 ), lda, csl, snl )
                 call stdlib_${ri}$rot( 2, b( 1, 1 ), ldb, b( 2, 1 ), ldb, csl, snl )
                 call stdlib_${ri}$rot( 2, a( 1, 1 ), 1, a( 1, 2 ), 1, csr, snr )
                 call stdlib_${ri}$rot( 2, b( 1, 1 ), 1, b( 1, 2 ), 1, csr, snr )
                 b( 2, 1 ) = zero
                 b( 1, 2 ) = zero
              end if
           end if
           ! unscaling
           a( 1, 1 ) = anorm*a( 1, 1 )
           a( 2, 1 ) = anorm*a( 2, 1 )
           a( 1, 2 ) = anorm*a( 1, 2 )
           a( 2, 2 ) = anorm*a( 2, 2 )
           b( 1, 1 ) = bnorm*b( 1, 1 )
           b( 2, 1 ) = bnorm*b( 2, 1 )
           b( 1, 2 ) = bnorm*b( 1, 2 )
           b( 2, 2 ) = bnorm*b( 2, 2 )
           if( wi==zero ) then
              alphar( 1 ) = a( 1, 1 )
              alphar( 2 ) = a( 2, 2 )
              alphai( 1 ) = zero
              alphai( 2 ) = zero
              beta( 1 ) = b( 1, 1 )
              beta( 2 ) = b( 2, 2 )
           else
              alphar( 1 ) = anorm*wr1 / scale1 / bnorm
              alphai( 1 ) = anorm*wi / scale1 / bnorm
              alphar( 2 ) = alphar( 1 )
              alphai( 2 ) = -alphai( 1 )
              beta( 1 ) = one
              beta( 2 ) = one
           end if
           return
     end subroutine stdlib_${ri}$lagv2

#:endif
#:endfor



     module pure subroutine stdlib_sggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
     !! SGGBAK forms the right or left eigenvectors of a real generalized
     !! eigenvalue problem A*x = lambda*B*x, by backward transformation on
     !! the computed eigenvectors of the balanced pair of matrices output by
     !! SGGBAL.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(in) :: lscale(*), rscale(*)
           real(sp), intent(inout) :: v(ldv,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, k
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( n==0 .and. ihi==0 .and. ilo/=1 ) then
              info = -4
           else if( n>0 .and. ( ihi<ilo .or. ihi>max( 1, n ) ) )then
              info = -5
           else if( n==0 .and. ilo==1 .and. ihi/=0 ) then
              info = -5
           else if( m<0 ) then
              info = -8
           else if( ldv<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGGBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward transformation on right eigenvectors
              if( rightv ) then
                 do i = ilo, ihi
                    call stdlib_sscal( m, rscale( i ), v( i, 1 ), ldv )
                 end do
              end if
              ! backward transformation on left eigenvectors
              if( leftv ) then
                 do i = ilo, ihi
                    call stdlib_sscal( m, lscale( i ), v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward permutation on right eigenvectors
              if( rightv ) then
                 if( ilo==1 )go to 50
                 loop_40: do i = ilo - 1, 1, -1
                    k = rscale( i )
                    if( k==i )cycle loop_40
                    call stdlib_sswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
                 50 continue
                 if( ihi==n )go to 70
                 loop_60: do i = ihi + 1, n
                    k = rscale( i )
                    if( k==i )cycle loop_60
                    call stdlib_sswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_60
              end if
              ! backward permutation on left eigenvectors
              70 continue
              if( leftv ) then
                 if( ilo==1 )go to 90
                 loop_80: do i = ilo - 1, 1, -1
                    k = lscale( i )
                    if( k==i )cycle loop_80
                    call stdlib_sswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_80
                 90 continue
                 if( ihi==n )go to 110
                 loop_100: do i = ihi + 1, n
                    k = lscale( i )
                    if( k==i )cycle loop_100
                    call stdlib_sswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_100
              end if
           end if
           110 continue
           return
     end subroutine stdlib_sggbak

     module pure subroutine stdlib_dggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
     !! DGGBAK forms the right or left eigenvectors of a real generalized
     !! eigenvalue problem A*x = lambda*B*x, by backward transformation on
     !! the computed eigenvectors of the balanced pair of matrices output by
     !! DGGBAL.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(in) :: lscale(*), rscale(*)
           real(dp), intent(inout) :: v(ldv,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, k
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( n==0 .and. ihi==0 .and. ilo/=1 ) then
              info = -4
           else if( n>0 .and. ( ihi<ilo .or. ihi>max( 1, n ) ) )then
              info = -5
           else if( n==0 .and. ilo==1 .and. ihi/=0 ) then
              info = -5
           else if( m<0 ) then
              info = -8
           else if( ldv<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward transformation on right eigenvectors
              if( rightv ) then
                 do i = ilo, ihi
                    call stdlib_dscal( m, rscale( i ), v( i, 1 ), ldv )
                 end do
              end if
              ! backward transformation on left eigenvectors
              if( leftv ) then
                 do i = ilo, ihi
                    call stdlib_dscal( m, lscale( i ), v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward permutation on right eigenvectors
              if( rightv ) then
                 if( ilo==1 )go to 50
                 loop_40: do i = ilo - 1, 1, -1
                    k = int(rscale( i ),KIND=ilp)
                    if( k==i )cycle loop_40
                    call stdlib_dswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
                 50 continue
                 if( ihi==n )go to 70
                 loop_60: do i = ihi + 1, n
                    k = int(rscale( i ),KIND=ilp)
                    if( k==i )cycle loop_60
                    call stdlib_dswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_60
              end if
              ! backward permutation on left eigenvectors
              70 continue
              if( leftv ) then
                 if( ilo==1 )go to 90
                 loop_80: do i = ilo - 1, 1, -1
                    k = int(lscale( i ),KIND=ilp)
                    if( k==i )cycle loop_80
                    call stdlib_dswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_80
                 90 continue
                 if( ihi==n )go to 110
                 loop_100: do i = ihi + 1, n
                    k = int(lscale( i ),KIND=ilp)
                    if( k==i )cycle loop_100
                    call stdlib_dswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_100
              end if
           end if
           110 continue
           return
     end subroutine stdlib_dggbak

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$ggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
     !! DGGBAK: forms the right or left eigenvectors of a real generalized
     !! eigenvalue problem A*x = lambda*B*x, by backward transformation on
     !! the computed eigenvectors of the balanced pair of matrices output by
     !! DGGBAL.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(in) :: lscale(*), rscale(*)
           real(${rk}$), intent(inout) :: v(ldv,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, k
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( n==0 .and. ihi==0 .and. ilo/=1 ) then
              info = -4
           else if( n>0 .and. ( ihi<ilo .or. ihi>max( 1, n ) ) )then
              info = -5
           else if( n==0 .and. ilo==1 .and. ihi/=0 ) then
              info = -5
           else if( m<0 ) then
              info = -8
           else if( ldv<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward transformation on right eigenvectors
              if( rightv ) then
                 do i = ilo, ihi
                    call stdlib_${ri}$scal( m, rscale( i ), v( i, 1 ), ldv )
                 end do
              end if
              ! backward transformation on left eigenvectors
              if( leftv ) then
                 do i = ilo, ihi
                    call stdlib_${ri}$scal( m, lscale( i ), v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward permutation on right eigenvectors
              if( rightv ) then
                 if( ilo==1 )go to 50
                 loop_40: do i = ilo - 1, 1, -1
                    k = int(rscale( i ),KIND=ilp)
                    if( k==i )cycle loop_40
                    call stdlib_${ri}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
                 50 continue
                 if( ihi==n )go to 70
                 loop_60: do i = ihi + 1, n
                    k = int(rscale( i ),KIND=ilp)
                    if( k==i )cycle loop_60
                    call stdlib_${ri}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_60
              end if
              ! backward permutation on left eigenvectors
              70 continue
              if( leftv ) then
                 if( ilo==1 )go to 90
                 loop_80: do i = ilo - 1, 1, -1
                    k = int(lscale( i ),KIND=ilp)
                    if( k==i )cycle loop_80
                    call stdlib_${ri}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_80
                 90 continue
                 if( ihi==n )go to 110
                 loop_100: do i = ihi + 1, n
                    k = int(lscale( i ),KIND=ilp)
                    if( k==i )cycle loop_100
                    call stdlib_${ri}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_100
              end if
           end if
           110 continue
           return
     end subroutine stdlib_${ri}$ggbak

#:endif
#:endfor

     module pure subroutine stdlib_cggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
     !! CGGBAK forms the right or left eigenvectors of a complex generalized
     !! eigenvalue problem A*x = lambda*B*x, by backward transformation on
     !! the computed eigenvectors of the balanced pair of matrices output by
     !! CGGBAL.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(in) :: lscale(*), rscale(*)
           complex(sp), intent(inout) :: v(ldv,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, k
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( n==0 .and. ihi==0 .and. ilo/=1 ) then
              info = -4
           else if( n>0 .and. ( ihi<ilo .or. ihi>max( 1, n ) ) )then
              info = -5
           else if( n==0 .and. ilo==1 .and. ihi/=0 ) then
              info = -5
           else if( m<0 ) then
              info = -8
           else if( ldv<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward transformation on right eigenvectors
              if( rightv ) then
                 do i = ilo, ihi
                    call stdlib_csscal( m, rscale( i ), v( i, 1 ), ldv )
                 end do
              end if
              ! backward transformation on left eigenvectors
              if( leftv ) then
                 do i = ilo, ihi
                    call stdlib_csscal( m, lscale( i ), v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward permutation on right eigenvectors
              if( rightv ) then
                 if( ilo==1 )go to 50
                 loop_40: do i = ilo - 1, 1, -1
                    k = rscale( i )
                    if( k==i )cycle loop_40
                    call stdlib_cswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
                 50 continue
                 if( ihi==n )go to 70
                 loop_60: do i = ihi + 1, n
                    k = rscale( i )
                    if( k==i )cycle loop_60
                    call stdlib_cswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_60
              end if
              ! backward permutation on left eigenvectors
              70 continue
              if( leftv ) then
                 if( ilo==1 )go to 90
                 loop_80: do i = ilo - 1, 1, -1
                    k = lscale( i )
                    if( k==i )cycle loop_80
                    call stdlib_cswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_80
                 90 continue
                 if( ihi==n )go to 110
                 loop_100: do i = ihi + 1, n
                    k = lscale( i )
                    if( k==i )cycle loop_100
                    call stdlib_cswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_100
              end if
           end if
           110 continue
           return
     end subroutine stdlib_cggbak

     module pure subroutine stdlib_zggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
     !! ZGGBAK forms the right or left eigenvectors of a complex generalized
     !! eigenvalue problem A*x = lambda*B*x, by backward transformation on
     !! the computed eigenvectors of the balanced pair of matrices output by
     !! ZGGBAL.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(in) :: lscale(*), rscale(*)
           complex(dp), intent(inout) :: v(ldv,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, k
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( n==0 .and. ihi==0 .and. ilo/=1 ) then
              info = -4
           else if( n>0 .and. ( ihi<ilo .or. ihi>max( 1, n ) ) )then
              info = -5
           else if( n==0 .and. ilo==1 .and. ihi/=0 ) then
              info = -5
           else if( m<0 ) then
              info = -8
           else if( ldv<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward transformation on right eigenvectors
              if( rightv ) then
                 do i = ilo, ihi
                    call stdlib_zdscal( m, rscale( i ), v( i, 1 ), ldv )
                 end do
              end if
              ! backward transformation on left eigenvectors
              if( leftv ) then
                 do i = ilo, ihi
                    call stdlib_zdscal( m, lscale( i ), v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward permutation on right eigenvectors
              if( rightv ) then
                 if( ilo==1 )go to 50
                 loop_40: do i = ilo - 1, 1, -1
                    k = int(rscale( i ),KIND=ilp)
                    if( k==i )cycle loop_40
                    call stdlib_zswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
                 50 continue
                 if( ihi==n )go to 70
                 loop_60: do i = ihi + 1, n
                    k = int(rscale( i ),KIND=ilp)
                    if( k==i )cycle loop_60
                    call stdlib_zswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_60
              end if
              ! backward permutation on left eigenvectors
              70 continue
              if( leftv ) then
                 if( ilo==1 )go to 90
                 loop_80: do i = ilo - 1, 1, -1
                    k = int(lscale( i ),KIND=ilp)
                    if( k==i )cycle loop_80
                    call stdlib_zswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_80
                 90 continue
                 if( ihi==n )go to 110
                 loop_100: do i = ihi + 1, n
                    k = int(lscale( i ),KIND=ilp)
                    if( k==i )cycle loop_100
                    call stdlib_zswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_100
              end if
           end if
           110 continue
           return
     end subroutine stdlib_zggbak

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$ggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
     !! ZGGBAK: forms the right or left eigenvectors of a complex generalized
     !! eigenvalue problem A*x = lambda*B*x, by backward transformation on
     !! the computed eigenvectors of the balanced pair of matrices output by
     !! ZGGBAL.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${ck}$), intent(in) :: lscale(*), rscale(*)
           complex(${ck}$), intent(inout) :: v(ldv,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, k
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( n==0 .and. ihi==0 .and. ilo/=1 ) then
              info = -4
           else if( n>0 .and. ( ihi<ilo .or. ihi>max( 1, n ) ) )then
              info = -5
           else if( n==0 .and. ilo==1 .and. ihi/=0 ) then
              info = -5
           else if( m<0 ) then
              info = -8
           else if( ldv<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward transformation on right eigenvectors
              if( rightv ) then
                 do i = ilo, ihi
                    call stdlib_${ci}$dscal( m, rscale( i ), v( i, 1 ), ldv )
                 end do
              end if
              ! backward transformation on left eigenvectors
              if( leftv ) then
                 do i = ilo, ihi
                    call stdlib_${ci}$dscal( m, lscale( i ), v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward permutation on right eigenvectors
              if( rightv ) then
                 if( ilo==1 )go to 50
                 loop_40: do i = ilo - 1, 1, -1
                    k = int(rscale( i ),KIND=ilp)
                    if( k==i )cycle loop_40
                    call stdlib_${ci}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
                 50 continue
                 if( ihi==n )go to 70
                 loop_60: do i = ihi + 1, n
                    k = int(rscale( i ),KIND=ilp)
                    if( k==i )cycle loop_60
                    call stdlib_${ci}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_60
              end if
              ! backward permutation on left eigenvectors
              70 continue
              if( leftv ) then
                 if( ilo==1 )go to 90
                 loop_80: do i = ilo - 1, 1, -1
                    k = int(lscale( i ),KIND=ilp)
                    if( k==i )cycle loop_80
                    call stdlib_${ci}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_80
                 90 continue
                 if( ihi==n )go to 110
                 loop_100: do i = ihi + 1, n
                    k = int(lscale( i ),KIND=ilp)
                    if( k==i )cycle loop_100
                    call stdlib_${ci}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_100
              end if
           end if
           110 continue
           return
     end subroutine stdlib_${ci}$ggbak

#:endif
#:endfor





     module pure subroutine stdlib_slahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
     !! SLAHR2 reduces the first NB columns of A real general n-BY-(n-k+1)
     !! matrix A so that elements below the k-th subdiagonal are zero. The
     !! reduction is performed by an orthogonal similarity transformation
     !! Q**T * A * Q. The routine returns the matrices V and T which determine
     !! Q as a block reflector I - V*T*V**T, and also the matrix Y = A * V * T.
     !! This is an auxiliary routine called by SGEHRD.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: k, lda, ldt, ldy, n, nb
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: t(ldt,nb), tau(nb), y(ldy,nb)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(sp) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=1 )return
           loop_10: do i = 1, nb
              if( i>1 ) then
                 ! update a(k+1:n,i)
                 ! update i-th column of a - y * v**t
                 call stdlib_sgemv( 'NO TRANSPOSE', n-k, i-1, -one, y(k+1,1), ldy,a( k+i-1, 1 ), &
                           lda, one, a( k+1, i ), 1 )
                 ! apply i - v * t**t * v**t to this column (call it b) from the
                 ! left, using the last column of t as workspace
                 ! let  v = ( v1 )   and   b = ( b1 )   (first i-1 rows)
                          ! ( v2 )             ( b2 )
                 ! where v1 is unit lower triangular
                 ! w := v1**t * b1
                 call stdlib_scopy( i-1, a( k+1, i ), 1, t( 1, nb ), 1 )
                 call stdlib_strmv( 'LOWER', 'TRANSPOSE', 'UNIT',i-1, a( k+1, 1 ),lda, t( 1, nb ),&
                            1 )
                 ! w := w + v2**t * b2
                 call stdlib_sgemv( 'TRANSPOSE', n-k-i+1, i-1,one, a( k+i, 1 ),lda, a( k+i, i ), &
                           1, one, t( 1, nb ), 1 )
                 ! w := t**t * w
                 call stdlib_strmv( 'UPPER', 'TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, nb ), 1 )
                           
                 ! b2 := b2 - v2*w
                 call stdlib_sgemv( 'NO TRANSPOSE', n-k-i+1, i-1, -one,a( k+i, 1 ),lda, t( 1, nb )&
                           , 1, one, a( k+i, i ), 1 )
                 ! b1 := b1 - v1*w
                 call stdlib_strmv( 'LOWER', 'NO TRANSPOSE','UNIT', i-1,a( k+1, 1 ), lda, t( 1, &
                           nb ), 1 )
                 call stdlib_saxpy( i-1, -one, t( 1, nb ), 1, a( k+1, i ), 1 )
                 a( k+i-1, i-1 ) = ei
              end if
              ! generate the elementary reflector h(i) to annihilate
              ! a(k+i+1:n,i)
              call stdlib_slarfg( n-k-i+1, a( k+i, i ), a( min( k+i+1, n ), i ), 1,tau( i ) )
                        
              ei = a( k+i, i )
              a( k+i, i ) = one
              ! compute  y(k+1:n,i)
              call stdlib_sgemv( 'NO TRANSPOSE', n-k, n-k-i+1,one, a( k+1, i+1 ),lda, a( k+i, i ),&
                         1, zero, y( k+1, i ), 1 )
              call stdlib_sgemv( 'TRANSPOSE', n-k-i+1, i-1,one, a( k+i, 1 ), lda,a( k+i, i ), 1, &
                        zero, t( 1, i ), 1 )
              call stdlib_sgemv( 'NO TRANSPOSE', n-k, i-1, -one,y( k+1, 1 ), ldy,t( 1, i ), 1, &
                        one, y( k+1, i ), 1 )
              call stdlib_sscal( n-k, tau( i ), y( k+1, i ), 1 )
              ! compute t(1:i,i)
              call stdlib_sscal( i-1, -tau( i ), t( 1, i ), 1 )
              call stdlib_strmv( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, i ), 1 )
                        
              t( i, i ) = tau( i )
           end do loop_10
           a( k+nb, nb ) = ei
           ! compute y(1:k,1:nb)
           call stdlib_slacpy( 'ALL', k, nb, a( 1, 2 ), lda, y, ldy )
           call stdlib_strmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE','UNIT', k, nb,one, a( k+1, 1 ), &
                     lda, y, ldy )
           if( n>k+nb )call stdlib_sgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', k,nb, n-k-nb, one,a( 1, &
                     2+nb ), lda, a( k+1+nb, 1 ), lda, one, y,ldy )
           call stdlib_strmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE','NON-UNIT', k, nb,one, t, ldt, y, &
                     ldy )
           return
     end subroutine stdlib_slahr2

     module pure subroutine stdlib_dlahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
     !! DLAHR2 reduces the first NB columns of A real general n-BY-(n-k+1)
     !! matrix A so that elements below the k-th subdiagonal are zero. The
     !! reduction is performed by an orthogonal similarity transformation
     !! Q**T * A * Q. The routine returns the matrices V and T which determine
     !! Q as a block reflector I - V*T*V**T, and also the matrix Y = A * V * T.
     !! This is an auxiliary routine called by DGEHRD.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: k, lda, ldt, ldy, n, nb
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: t(ldt,nb), tau(nb), y(ldy,nb)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(dp) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=1 )return
           loop_10: do i = 1, nb
              if( i>1 ) then
                 ! update a(k+1:n,i)
                 ! update i-th column of a - y * v**t
                 call stdlib_dgemv( 'NO TRANSPOSE', n-k, i-1, -one, y(k+1,1), ldy,a( k+i-1, 1 ), &
                           lda, one, a( k+1, i ), 1 )
                 ! apply i - v * t**t * v**t to this column (call it b) from the
                 ! left, using the last column of t as workspace
                 ! let  v = ( v1 )   and   b = ( b1 )   (first i-1 rows)
                          ! ( v2 )             ( b2 )
                 ! where v1 is unit lower triangular
                 ! w := v1**t * b1
                 call stdlib_dcopy( i-1, a( k+1, i ), 1, t( 1, nb ), 1 )
                 call stdlib_dtrmv( 'LOWER', 'TRANSPOSE', 'UNIT',i-1, a( k+1, 1 ),lda, t( 1, nb ),&
                            1 )
                 ! w := w + v2**t * b2
                 call stdlib_dgemv( 'TRANSPOSE', n-k-i+1, i-1,one, a( k+i, 1 ),lda, a( k+i, i ), &
                           1, one, t( 1, nb ), 1 )
                 ! w := t**t * w
                 call stdlib_dtrmv( 'UPPER', 'TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, nb ), 1 )
                           
                 ! b2 := b2 - v2*w
                 call stdlib_dgemv( 'NO TRANSPOSE', n-k-i+1, i-1, -one,a( k+i, 1 ),lda, t( 1, nb )&
                           , 1, one, a( k+i, i ), 1 )
                 ! b1 := b1 - v1*w
                 call stdlib_dtrmv( 'LOWER', 'NO TRANSPOSE','UNIT', i-1,a( k+1, 1 ), lda, t( 1, &
                           nb ), 1 )
                 call stdlib_daxpy( i-1, -one, t( 1, nb ), 1, a( k+1, i ), 1 )
                 a( k+i-1, i-1 ) = ei
              end if
              ! generate the elementary reflector h(i) to annihilate
              ! a(k+i+1:n,i)
              call stdlib_dlarfg( n-k-i+1, a( k+i, i ), a( min( k+i+1, n ), i ), 1,tau( i ) )
                        
              ei = a( k+i, i )
              a( k+i, i ) = one
              ! compute  y(k+1:n,i)
              call stdlib_dgemv( 'NO TRANSPOSE', n-k, n-k-i+1,one, a( k+1, i+1 ),lda, a( k+i, i ),&
                         1, zero, y( k+1, i ), 1 )
              call stdlib_dgemv( 'TRANSPOSE', n-k-i+1, i-1,one, a( k+i, 1 ), lda,a( k+i, i ), 1, &
                        zero, t( 1, i ), 1 )
              call stdlib_dgemv( 'NO TRANSPOSE', n-k, i-1, -one,y( k+1, 1 ), ldy,t( 1, i ), 1, &
                        one, y( k+1, i ), 1 )
              call stdlib_dscal( n-k, tau( i ), y( k+1, i ), 1 )
              ! compute t(1:i,i)
              call stdlib_dscal( i-1, -tau( i ), t( 1, i ), 1 )
              call stdlib_dtrmv( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, i ), 1 )
                        
              t( i, i ) = tau( i )
           end do loop_10
           a( k+nb, nb ) = ei
           ! compute y(1:k,1:nb)
           call stdlib_dlacpy( 'ALL', k, nb, a( 1, 2 ), lda, y, ldy )
           call stdlib_dtrmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE','UNIT', k, nb,one, a( k+1, 1 ), &
                     lda, y, ldy )
           if( n>k+nb )call stdlib_dgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', k,nb, n-k-nb, one,a( 1, &
                     2+nb ), lda, a( k+1+nb, 1 ), lda, one, y,ldy )
           call stdlib_dtrmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE','NON-UNIT', k, nb,one, t, ldt, y, &
                     ldy )
           return
     end subroutine stdlib_dlahr2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$lahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
     !! DLAHR2: reduces the first NB columns of A real general n-BY-(n-k+1)
     !! matrix A so that elements below the k-th subdiagonal are zero. The
     !! reduction is performed by an orthogonal similarity transformation
     !! Q**T * A * Q. The routine returns the matrices V and T which determine
     !! Q as a block reflector I - V*T*V**T, and also the matrix Y = A * V * T.
     !! This is an auxiliary routine called by DGEHRD.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: k, lda, ldt, ldy, n, nb
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: t(ldt,nb), tau(nb), y(ldy,nb)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(${rk}$) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=1 )return
           loop_10: do i = 1, nb
              if( i>1 ) then
                 ! update a(k+1:n,i)
                 ! update i-th column of a - y * v**t
                 call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k, i-1, -one, y(k+1,1), ldy,a( k+i-1, 1 ), &
                           lda, one, a( k+1, i ), 1 )
                 ! apply i - v * t**t * v**t to this column (call it b) from the
                 ! left, using the last column of t as workspace
                 ! let  v = ( v1 )   and   b = ( b1 )   (first i-1 rows)
                          ! ( v2 )             ( b2 )
                 ! where v1 is unit lower triangular
                 ! w := v1**t * b1
                 call stdlib_${ri}$copy( i-1, a( k+1, i ), 1, t( 1, nb ), 1 )
                 call stdlib_${ri}$trmv( 'LOWER', 'TRANSPOSE', 'UNIT',i-1, a( k+1, 1 ),lda, t( 1, nb ),&
                            1 )
                 ! w := w + v2**t * b2
                 call stdlib_${ri}$gemv( 'TRANSPOSE', n-k-i+1, i-1,one, a( k+i, 1 ),lda, a( k+i, i ), &
                           1, one, t( 1, nb ), 1 )
                 ! w := t**t * w
                 call stdlib_${ri}$trmv( 'UPPER', 'TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, nb ), 1 )
                           
                 ! b2 := b2 - v2*w
                 call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k-i+1, i-1, -one,a( k+i, 1 ),lda, t( 1, nb )&
                           , 1, one, a( k+i, i ), 1 )
                 ! b1 := b1 - v1*w
                 call stdlib_${ri}$trmv( 'LOWER', 'NO TRANSPOSE','UNIT', i-1,a( k+1, 1 ), lda, t( 1, &
                           nb ), 1 )
                 call stdlib_${ri}$axpy( i-1, -one, t( 1, nb ), 1, a( k+1, i ), 1 )
                 a( k+i-1, i-1 ) = ei
              end if
              ! generate the elementary reflector h(i) to annihilate
              ! a(k+i+1:n,i)
              call stdlib_${ri}$larfg( n-k-i+1, a( k+i, i ), a( min( k+i+1, n ), i ), 1,tau( i ) )
                        
              ei = a( k+i, i )
              a( k+i, i ) = one
              ! compute  y(k+1:n,i)
              call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k, n-k-i+1,one, a( k+1, i+1 ),lda, a( k+i, i ),&
                         1, zero, y( k+1, i ), 1 )
              call stdlib_${ri}$gemv( 'TRANSPOSE', n-k-i+1, i-1,one, a( k+i, 1 ), lda,a( k+i, i ), 1, &
                        zero, t( 1, i ), 1 )
              call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k, i-1, -one,y( k+1, 1 ), ldy,t( 1, i ), 1, &
                        one, y( k+1, i ), 1 )
              call stdlib_${ri}$scal( n-k, tau( i ), y( k+1, i ), 1 )
              ! compute t(1:i,i)
              call stdlib_${ri}$scal( i-1, -tau( i ), t( 1, i ), 1 )
              call stdlib_${ri}$trmv( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, i ), 1 )
                        
              t( i, i ) = tau( i )
           end do loop_10
           a( k+nb, nb ) = ei
           ! compute y(1:k,1:nb)
           call stdlib_${ri}$lacpy( 'ALL', k, nb, a( 1, 2 ), lda, y, ldy )
           call stdlib_${ri}$trmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE','UNIT', k, nb,one, a( k+1, 1 ), &
                     lda, y, ldy )
           if( n>k+nb )call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', k,nb, n-k-nb, one,a( 1, &
                     2+nb ), lda, a( k+1+nb, 1 ), lda, one, y,ldy )
           call stdlib_${ri}$trmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE','NON-UNIT', k, nb,one, t, ldt, y, &
                     ldy )
           return
     end subroutine stdlib_${ri}$lahr2

#:endif
#:endfor

     module pure subroutine stdlib_clahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
     !! CLAHR2 reduces the first NB columns of A complex general n-BY-(n-k+1)
     !! matrix A so that elements below the k-th subdiagonal are zero. The
     !! reduction is performed by an unitary similarity transformation
     !! Q**H * A * Q. The routine returns the matrices V and T which determine
     !! Q as a block reflector I - V*T*v**H, and also the matrix Y = A * V * T.
     !! This is an auxiliary routine called by CGEHRD.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: k, lda, ldt, ldy, n, nb
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: t(ldt,nb), tau(nb), y(ldy,nb)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           complex(sp) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=1 )return
           loop_10: do i = 1, nb
              if( i>1 ) then
                 ! update a(k+1:n,i)
                 ! update i-th column of a - y * v**h
                 call stdlib_clacgv( i-1, a( k+i-1, 1 ), lda )
                 call stdlib_cgemv( 'NO TRANSPOSE', n-k, i-1, -cone, y(k+1,1), ldy,a( k+i-1, 1 ), &
                           lda, cone, a( k+1, i ), 1 )
                 call stdlib_clacgv( i-1, a( k+i-1, 1 ), lda )
                 ! apply i - v * t**h * v**h to this column (call it b) from the
                 ! left, using the last column of t as workspace
                 ! let  v = ( v1 )   and   b = ( b1 )   (first i-1 rows)
                          ! ( v2 )             ( b2 )
                 ! where v1 is unit lower triangular
                 ! w := v1**h * b1
                 call stdlib_ccopy( i-1, a( k+1, i ), 1, t( 1, nb ), 1 )
                 call stdlib_ctrmv( 'LOWER', 'CONJUGATE TRANSPOSE', 'UNIT',i-1, a( k+1, 1 ),lda, &
                           t( 1, nb ), 1 )
                 ! w := w + v2**h * b2
                 call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k-i+1, i-1,cone, a( k+i, 1 ),lda, a( &
                           k+i, i ), 1, cone, t( 1, nb ), 1 )
                 ! w := t**h * w
                 call stdlib_ctrmv( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, &
                           nb ), 1 )
                 ! b2 := b2 - v2*w
                 call stdlib_cgemv( 'NO TRANSPOSE', n-k-i+1, i-1, -cone,a( k+i, 1 ),lda, t( 1, nb &
                           ), 1, cone, a( k+i, i ), 1 )
                 ! b1 := b1 - v1*w
                 call stdlib_ctrmv( 'LOWER', 'NO TRANSPOSE','UNIT', i-1,a( k+1, 1 ), lda, t( 1, &
                           nb ), 1 )
                 call stdlib_caxpy( i-1, -cone, t( 1, nb ), 1, a( k+1, i ), 1 )
                 a( k+i-1, i-1 ) = ei
              end if
              ! generate the elementary reflector h(i) to annihilate
              ! a(k+i+1:n,i)
              call stdlib_clarfg( n-k-i+1, a( k+i, i ), a( min( k+i+1, n ), i ), 1,tau( i ) )
                        
              ei = a( k+i, i )
              a( k+i, i ) = cone
              ! compute  y(k+1:n,i)
              call stdlib_cgemv( 'NO TRANSPOSE', n-k, n-k-i+1,cone, a( k+1, i+1 ),lda, a( k+i, i )&
                        , 1, czero, y( k+1, i ), 1 )
              call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k-i+1, i-1,cone, a( k+i, 1 ), lda,a( k+&
                        i, i ), 1, czero, t( 1, i ), 1 )
              call stdlib_cgemv( 'NO TRANSPOSE', n-k, i-1, -cone,y( k+1, 1 ), ldy,t( 1, i ), 1, &
                        cone, y( k+1, i ), 1 )
              call stdlib_cscal( n-k, tau( i ), y( k+1, i ), 1 )
              ! compute t(1:i,i)
              call stdlib_cscal( i-1, -tau( i ), t( 1, i ), 1 )
              call stdlib_ctrmv( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, i ), 1 )
                        
              t( i, i ) = tau( i )
           end do loop_10
           a( k+nb, nb ) = ei
           ! compute y(1:k,1:nb)
           call stdlib_clacpy( 'ALL', k, nb, a( 1, 2 ), lda, y, ldy )
           call stdlib_ctrmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE','UNIT', k, nb,cone, a( k+1, 1 ), &
                     lda, y, ldy )
           if( n>k+nb )call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', k,nb, n-k-nb, cone,a( 1,&
                      2+nb ), lda, a( k+1+nb, 1 ), lda, cone, y,ldy )
           call stdlib_ctrmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE','NON-UNIT', k, nb,cone, t, ldt, y, &
                     ldy )
           return
     end subroutine stdlib_clahr2

     module pure subroutine stdlib_zlahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
     !! ZLAHR2 reduces the first NB columns of A complex general n-BY-(n-k+1)
     !! matrix A so that elements below the k-th subdiagonal are zero. The
     !! reduction is performed by an unitary similarity transformation
     !! Q**H * A * Q. The routine returns the matrices V and T which determine
     !! Q as a block reflector I - V*T*V**H, and also the matrix Y = A * V * T.
     !! This is an auxiliary routine called by ZGEHRD.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: k, lda, ldt, ldy, n, nb
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: t(ldt,nb), tau(nb), y(ldy,nb)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           complex(dp) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=1 )return
           loop_10: do i = 1, nb
              if( i>1 ) then
                 ! update a(k+1:n,i)
                 ! update i-th column of a - y * v**h
                 call stdlib_zlacgv( i-1, a( k+i-1, 1 ), lda )
                 call stdlib_zgemv( 'NO TRANSPOSE', n-k, i-1, -cone, y(k+1,1), ldy,a( k+i-1, 1 ), &
                           lda, cone, a( k+1, i ), 1 )
                 call stdlib_zlacgv( i-1, a( k+i-1, 1 ), lda )
                 ! apply i - v * t**h * v**h to this column (call it b) from the
                 ! left, using the last column of t as workspace
                 ! let  v = ( v1 )   and   b = ( b1 )   (first i-1 rows)
                          ! ( v2 )             ( b2 )
                 ! where v1 is unit lower triangular
                 ! w := v1**h * b1
                 call stdlib_zcopy( i-1, a( k+1, i ), 1, t( 1, nb ), 1 )
                 call stdlib_ztrmv( 'LOWER', 'CONJUGATE TRANSPOSE', 'UNIT',i-1, a( k+1, 1 ),lda, &
                           t( 1, nb ), 1 )
                 ! w := w + v2**h * b2
                 call stdlib_zgemv( 'CONJUGATE TRANSPOSE', n-k-i+1, i-1,cone, a( k+i, 1 ),lda, a( &
                           k+i, i ), 1, cone, t( 1, nb ), 1 )
                 ! w := t**h * w
                 call stdlib_ztrmv( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, &
                           nb ), 1 )
                 ! b2 := b2 - v2*w
                 call stdlib_zgemv( 'NO TRANSPOSE', n-k-i+1, i-1, -cone,a( k+i, 1 ),lda, t( 1, nb &
                           ), 1, cone, a( k+i, i ), 1 )
                 ! b1 := b1 - v1*w
                 call stdlib_ztrmv( 'LOWER', 'NO TRANSPOSE','UNIT', i-1,a( k+1, 1 ), lda, t( 1, &
                           nb ), 1 )
                 call stdlib_zaxpy( i-1, -cone, t( 1, nb ), 1, a( k+1, i ), 1 )
                 a( k+i-1, i-1 ) = ei
              end if
              ! generate the elementary reflector h(i) to annihilate
              ! a(k+i+1:n,i)
              call stdlib_zlarfg( n-k-i+1, a( k+i, i ), a( min( k+i+1, n ), i ), 1,tau( i ) )
                        
              ei = a( k+i, i )
              a( k+i, i ) = cone
              ! compute  y(k+1:n,i)
              call stdlib_zgemv( 'NO TRANSPOSE', n-k, n-k-i+1,cone, a( k+1, i+1 ),lda, a( k+i, i )&
                        , 1, czero, y( k+1, i ), 1 )
              call stdlib_zgemv( 'CONJUGATE TRANSPOSE', n-k-i+1, i-1,cone, a( k+i, 1 ), lda,a( k+&
                        i, i ), 1, czero, t( 1, i ), 1 )
              call stdlib_zgemv( 'NO TRANSPOSE', n-k, i-1, -cone,y( k+1, 1 ), ldy,t( 1, i ), 1, &
                        cone, y( k+1, i ), 1 )
              call stdlib_zscal( n-k, tau( i ), y( k+1, i ), 1 )
              ! compute t(1:i,i)
              call stdlib_zscal( i-1, -tau( i ), t( 1, i ), 1 )
              call stdlib_ztrmv( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, i ), 1 )
                        
              t( i, i ) = tau( i )
           end do loop_10
           a( k+nb, nb ) = ei
           ! compute y(1:k,1:nb)
           call stdlib_zlacpy( 'ALL', k, nb, a( 1, 2 ), lda, y, ldy )
           call stdlib_ztrmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE','UNIT', k, nb,cone, a( k+1, 1 ), &
                     lda, y, ldy )
           if( n>k+nb )call stdlib_zgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', k,nb, n-k-nb, cone,a( 1,&
                      2+nb ), lda, a( k+1+nb, 1 ), lda, cone, y,ldy )
           call stdlib_ztrmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE','NON-UNIT', k, nb,cone, t, ldt, y, &
                     ldy )
           return
     end subroutine stdlib_zlahr2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$lahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
     !! ZLAHR2: reduces the first NB columns of A complex general n-BY-(n-k+1)
     !! matrix A so that elements below the k-th subdiagonal are zero. The
     !! reduction is performed by an unitary similarity transformation
     !! Q**H * A * Q. The routine returns the matrices V and T which determine
     !! Q as a block reflector I - V*T*V**H, and also the matrix Y = A * V * T.
     !! This is an auxiliary routine called by ZGEHRD.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: k, lda, ldt, ldy, n, nb
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: t(ldt,nb), tau(nb), y(ldy,nb)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           complex(${ck}$) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=1 )return
           loop_10: do i = 1, nb
              if( i>1 ) then
                 ! update a(k+1:n,i)
                 ! update i-th column of a - y * v**h
                 call stdlib_${ci}$lacgv( i-1, a( k+i-1, 1 ), lda )
                 call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-k, i-1, -cone, y(k+1,1), ldy,a( k+i-1, 1 ), &
                           lda, cone, a( k+1, i ), 1 )
                 call stdlib_${ci}$lacgv( i-1, a( k+i-1, 1 ), lda )
                 ! apply i - v * t**h * v**h to this column (call it b) from the
                 ! left, using the last column of t as workspace
                 ! let  v = ( v1 )   and   b = ( b1 )   (first i-1 rows)
                          ! ( v2 )             ( b2 )
                 ! where v1 is unit lower triangular
                 ! w := v1**h * b1
                 call stdlib_${ci}$copy( i-1, a( k+1, i ), 1, t( 1, nb ), 1 )
                 call stdlib_${ci}$trmv( 'LOWER', 'CONJUGATE TRANSPOSE', 'UNIT',i-1, a( k+1, 1 ),lda, &
                           t( 1, nb ), 1 )
                 ! w := w + v2**h * b2
                 call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', n-k-i+1, i-1,cone, a( k+i, 1 ),lda, a( &
                           k+i, i ), 1, cone, t( 1, nb ), 1 )
                 ! w := t**h * w
                 call stdlib_${ci}$trmv( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, &
                           nb ), 1 )
                 ! b2 := b2 - v2*w
                 call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-k-i+1, i-1, -cone,a( k+i, 1 ),lda, t( 1, nb &
                           ), 1, cone, a( k+i, i ), 1 )
                 ! b1 := b1 - v1*w
                 call stdlib_${ci}$trmv( 'LOWER', 'NO TRANSPOSE','UNIT', i-1,a( k+1, 1 ), lda, t( 1, &
                           nb ), 1 )
                 call stdlib_${ci}$axpy( i-1, -cone, t( 1, nb ), 1, a( k+1, i ), 1 )
                 a( k+i-1, i-1 ) = ei
              end if
              ! generate the elementary reflector h(i) to annihilate
              ! a(k+i+1:n,i)
              call stdlib_${ci}$larfg( n-k-i+1, a( k+i, i ), a( min( k+i+1, n ), i ), 1,tau( i ) )
                        
              ei = a( k+i, i )
              a( k+i, i ) = cone
              ! compute  y(k+1:n,i)
              call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-k, n-k-i+1,cone, a( k+1, i+1 ),lda, a( k+i, i )&
                        , 1, czero, y( k+1, i ), 1 )
              call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', n-k-i+1, i-1,cone, a( k+i, 1 ), lda,a( k+&
                        i, i ), 1, czero, t( 1, i ), 1 )
              call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-k, i-1, -cone,y( k+1, 1 ), ldy,t( 1, i ), 1, &
                        cone, y( k+1, i ), 1 )
              call stdlib_${ci}$scal( n-k, tau( i ), y( k+1, i ), 1 )
              ! compute t(1:i,i)
              call stdlib_${ci}$scal( i-1, -tau( i ), t( 1, i ), 1 )
              call stdlib_${ci}$trmv( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, i ), 1 )
                        
              t( i, i ) = tau( i )
           end do loop_10
           a( k+nb, nb ) = ei
           ! compute y(1:k,1:nb)
           call stdlib_${ci}$lacpy( 'ALL', k, nb, a( 1, 2 ), lda, y, ldy )
           call stdlib_${ci}$trmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE','UNIT', k, nb,cone, a( k+1, 1 ), &
                     lda, y, ldy )
           if( n>k+nb )call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', k,nb, n-k-nb, cone,a( 1,&
                      2+nb ), lda, a( k+1+nb, 1 ), lda, cone, y,ldy )
           call stdlib_${ci}$trmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE','NON-UNIT', k, nb,cone, t, ldt, y, &
                     ldy )
           return
     end subroutine stdlib_${ci}$lahr2

#:endif
#:endfor



     module pure subroutine stdlib_slahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, &
     !! SLAHQR is an auxiliary routine called by SHSEQR to update the
     !! eigenvalues and Schur decomposition already computed by SHSEQR, by
     !! dealing with the Hessenberg submatrix in rows and columns ILO to
     !! IHI.
               info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(sp), intent(out) :: wi(*), wr(*)
        ! =========================================================
           ! Parameters 
           real(sp), parameter :: dat1 = 3.0_sp/4.0_sp
           real(sp), parameter :: dat2 = -0.4375_sp
           integer(ilp), parameter :: kexsh = 10
           
           
           
           ! Local Scalars 
           real(sp) :: aa, ab, ba, bb, cs, det, h11, h12, h21, h21s, h22, rt1i, rt1r, rt2i, rt2r, &
                     rtdisc, s, safmax, safmin, smlnum, sn, sum, t1, t2, t3, tr, tst, ulp, v2, v3
           integer(ilp) :: i, i1, i2, its, itmax, j, k, l, m, nh, nr, nz, kdefl
           ! Local Arrays 
           real(sp) :: v(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n==0 )return
           if( ilo==ihi ) then
              wr( ilo ) = h( ilo, ilo )
              wi( ilo ) = zero
              return
           end if
           ! ==== clear out the trash ====
           do j = ilo, ihi - 3
              h( j+2, j ) = zero
              h( j+3, j ) = zero
           end do
           if( ilo<=ihi-2 )h( ihi, ihi-2 ) = zero
           nh = ihi - ilo + 1
           nz = ihiz - iloz + 1
           ! set machine-dependent constants for the stopping criterion.
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = one / safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( nh,KIND=sp) / ulp )
           ! i1 and i2 are the indices of the first row and last column of h
           ! to which transformations must be applied. if eigenvalues only are
           ! being computed, i1 and i2 are set inside the main loop.
           if( wantt ) then
              i1 = 1
              i2 = n
           end if
           ! itmax is the total number of qr iterations allowed.
           itmax = 30 * max( 10, nh )
           ! kdefl counts the number of iterations since a deflation
           kdefl = 0
           ! the main loop begins here. i is the loop index and decreases from
           ! ihi to ilo in steps of 1 or 2. each iteration of the loop works
           ! with the active submatrix in rows and columns l to i.
           ! eigenvalues i+1 to ihi have already converged. either l = ilo or
           ! h(l,l-1) is negligible so that the matrix splits.
           i = ihi
           20 continue
           l = ilo
           if( i<ilo )go to 160
           ! perform qr iterations on rows and columns ilo to i until a
           ! submatrix of order 1 or 2 splits off at the bottom because a
           ! subdiagonal element has become negligible.
           loop_140: do its = 0, itmax
              ! look for a single small subdiagonal element.
              do k = i, l + 1, -1
                 if( abs( h( k, k-1 ) )<=smlnum )go to 40
                 tst = abs( h( k-1, k-1 ) ) + abs( h( k, k ) )
                 if( tst==zero ) then
                    if( k-2>=ilo )tst = tst + abs( h( k-1, k-2 ) )
                    if( k+1<=ihi )tst = tst + abs( h( k+1, k ) )
                 end if
                 ! ==== the following is a conservative small subdiagonal
                 ! .    deflation  criterion due to ahues
                 ! .    1997). it has better mathematical foundation and
                 ! .    improves accuracy in some cases.  ====
                 if( abs( h( k, k-1 ) )<=ulp*tst ) then
                    ab = max( abs( h( k, k-1 ) ), abs( h( k-1, k ) ) )
                    ba = min( abs( h( k, k-1 ) ), abs( h( k-1, k ) ) )
                    aa = max( abs( h( k, k ) ),abs( h( k-1, k-1 )-h( k, k ) ) )
                    bb = min( abs( h( k, k ) ),abs( h( k-1, k-1 )-h( k, k ) ) )
                    s = aa + ab
                    if( ba*( ab / s )<=max( smlnum,ulp*( bb*( aa / s ) ) ) )go to 40
                 end if
              end do
              40 continue
              l = k
              if( l>ilo ) then
                 ! h(l,l-1) is negligible
                 h( l, l-1 ) = zero
              end if
              ! exit from loop if a submatrix of order 1 or 2 has split off.
              if( l>=i-1 )go to 150
              kdefl = kdefl + 1
              ! now the active submatrix is in rows and columns l to i. if
              ! eigenvalues only are being computed, only the active submatrix
              ! need be transformed.
              if( .not.wantt ) then
                 i1 = l
                 i2 = i
              end if
              if( mod(kdefl,2*kexsh)==0 ) then
                 ! exceptional shift.
                 s = abs( h( i, i-1 ) ) + abs( h( i-1, i-2 ) )
                 h11 = dat1*s + h( i, i )
                 h12 = dat2*s
                 h21 = s
                 h22 = h11
              else if( mod(kdefl,kexsh)==0 ) then
                 ! exceptional shift.
                 s = abs( h( l+1, l ) ) + abs( h( l+2, l+1 ) )
                 h11 = dat1*s + h( l, l )
                 h12 = dat2*s
                 h21 = s
                 h22 = h11
              else
                 ! prepare to use francis' double shift
                 ! (i.e. 2nd degree generalized rayleigh quotient)
                 h11 = h( i-1, i-1 )
                 h21 = h( i, i-1 )
                 h12 = h( i-1, i )
                 h22 = h( i, i )
              end if
              s = abs( h11 ) + abs( h12 ) + abs( h21 ) + abs( h22 )
              if( s==zero ) then
                 rt1r = zero
                 rt1i = zero
                 rt2r = zero
                 rt2i = zero
              else
                 h11 = h11 / s
                 h21 = h21 / s
                 h12 = h12 / s
                 h22 = h22 / s
                 tr = ( h11+h22 ) / two
                 det = ( h11-tr )*( h22-tr ) - h12*h21
                 rtdisc = sqrt( abs( det ) )
                 if( det>=zero ) then
                    ! ==== complex conjugate shifts ====
                    rt1r = tr*s
                    rt2r = rt1r
                    rt1i = rtdisc*s
                    rt2i = -rt1i
                 else
                    ! ==== realshifts (use only one of them,KIND=sp)  ====
                    rt1r = tr + rtdisc
                    rt2r = tr - rtdisc
                    if( abs( rt1r-h22 )<=abs( rt2r-h22 ) ) then
                       rt1r = rt1r*s
                       rt2r = rt1r
                    else
                       rt2r = rt2r*s
                       rt1r = rt2r
                    end if
                    rt1i = zero
                    rt2i = zero
                 end if
              end if
              ! look for two consecutive small subdiagonal elements.
              do m = i - 2, l, -1
                 ! determine the effect of starting the double-shift qr
                 ! iteration at row m, and see if this would make h(m,m-1)
                 ! negligible.  (the following uses scaling to avoid
                 ! overflows and most underflows.)
                 h21s = h( m+1, m )
                 s = abs( h( m, m )-rt2r ) + abs( rt2i ) + abs( h21s )
                 h21s = h( m+1, m ) / s
                 v( 1 ) = h21s*h( m, m+1 ) + ( h( m, m )-rt1r )*( ( h( m, m )-rt2r ) / s ) - &
                           rt1i*( rt2i / s )
                 v( 2 ) = h21s*( h( m, m )+h( m+1, m+1 )-rt1r-rt2r )
                 v( 3 ) = h21s*h( m+2, m+1 )
                 s = abs( v( 1 ) ) + abs( v( 2 ) ) + abs( v( 3 ) )
                 v( 1 ) = v( 1 ) / s
                 v( 2 ) = v( 2 ) / s
                 v( 3 ) = v( 3 ) / s
                 if( m==l )go to 60
                 if( abs( h( m, m-1 ) )*( abs( v( 2 ) )+abs( v( 3 ) ) )<=ulp*abs( v( 1 ) )*( abs( &
                           h( m-1, m-1 ) )+abs( h( m,m ) )+abs( h( m+1, m+1 ) ) ) )go to 60
              end do
              60 continue
              ! double-shift qr step
              loop_130: do k = m, i - 1
                 ! the first iteration of this loop determines a reflection g
                 ! from the vector v and applies it from left and right to h,
                 ! thus creating a nonzero bulge below the subdiagonal.
                 ! each subsequent iteration determines a reflection g to
                 ! restore the hessenberg form in the (k-1)th column, and thus
                 ! chases the bulge one step toward the bottom of the active
                 ! submatrix. nr is the order of g.
                 nr = min( 3, i-k+1 )
                 if( k>m )call stdlib_scopy( nr, h( k, k-1 ), 1, v, 1 )
                 call stdlib_slarfg( nr, v( 1 ), v( 2 ), 1, t1 )
                 if( k>m ) then
                    h( k, k-1 ) = v( 1 )
                    h( k+1, k-1 ) = zero
                    if( k<i-1 )h( k+2, k-1 ) = zero
                 else if( m>l ) then
                     ! ==== use the following instead of
                     ! .    h( k, k-1 ) = -h( k, k-1 ) to
                     ! .    avoid a bug when v(2) and v(3)
                     ! .    underflow. ====
                    h( k, k-1 ) = h( k, k-1 )*( one-t1 )
                 end if
                 v2 = v( 2 )
                 t2 = t1*v2
                 if( nr==3 ) then
                    v3 = v( 3 )
                    t3 = t1*v3
                    ! apply g from the left to transform the rows of the matrix
                    ! in columns k to i2.
                    do j = k, i2
                       sum = h( k, j ) + v2*h( k+1, j ) + v3*h( k+2, j )
                       h( k, j ) = h( k, j ) - sum*t1
                       h( k+1, j ) = h( k+1, j ) - sum*t2
                       h( k+2, j ) = h( k+2, j ) - sum*t3
                    end do
                    ! apply g from the right to transform the columns of the
                    ! matrix in rows i1 to min(k+3,i).
                    do j = i1, min( k+3, i )
                       sum = h( j, k ) + v2*h( j, k+1 ) + v3*h( j, k+2 )
                       h( j, k ) = h( j, k ) - sum*t1
                       h( j, k+1 ) = h( j, k+1 ) - sum*t2
                       h( j, k+2 ) = h( j, k+2 ) - sum*t3
                    end do
                    if( wantz ) then
                       ! accumulate transformations in the matrix z
                       do j = iloz, ihiz
                          sum = z( j, k ) + v2*z( j, k+1 ) + v3*z( j, k+2 )
                          z( j, k ) = z( j, k ) - sum*t1
                          z( j, k+1 ) = z( j, k+1 ) - sum*t2
                          z( j, k+2 ) = z( j, k+2 ) - sum*t3
                       end do
                    end if
                 else if( nr==2 ) then
                    ! apply g from the left to transform the rows of the matrix
                    ! in columns k to i2.
                    do j = k, i2
                       sum = h( k, j ) + v2*h( k+1, j )
                       h( k, j ) = h( k, j ) - sum*t1
                       h( k+1, j ) = h( k+1, j ) - sum*t2
                    end do
                    ! apply g from the right to transform the columns of the
                    ! matrix in rows i1 to min(k+3,i).
                    do j = i1, i
                       sum = h( j, k ) + v2*h( j, k+1 )
                       h( j, k ) = h( j, k ) - sum*t1
                       h( j, k+1 ) = h( j, k+1 ) - sum*t2
                    end do
                    if( wantz ) then
                       ! accumulate transformations in the matrix z
                       do j = iloz, ihiz
                          sum = z( j, k ) + v2*z( j, k+1 )
                          z( j, k ) = z( j, k ) - sum*t1
                          z( j, k+1 ) = z( j, k+1 ) - sum*t2
                       end do
                    end if
                 end if
              end do loop_130
           end do loop_140
           ! failure to converge in remaining number of iterations
           info = i
           return
           150 continue
           if( l==i ) then
              ! h(i,i-1) is negligible: one eigenvalue has converged.
              wr( i ) = h( i, i )
              wi( i ) = zero
           else if( l==i-1 ) then
              ! h(i-1,i-2) is negligible: a pair of eigenvalues have converged.
              ! transform the 2-by-2 submatrix to standard schur form,
              ! and compute and store the eigenvalues.
              call stdlib_slanv2( h( i-1, i-1 ), h( i-1, i ), h( i, i-1 ),h( i, i ), wr( i-1 ), &
                        wi( i-1 ), wr( i ), wi( i ),cs, sn )
              if( wantt ) then
                 ! apply the transformation to the rest of h.
                 if( i2>i )call stdlib_srot( i2-i, h( i-1, i+1 ), ldh, h( i, i+1 ), ldh,cs, sn )
                           
                 call stdlib_srot( i-i1-1, h( i1, i-1 ), 1, h( i1, i ), 1, cs, sn )
              end if
              if( wantz ) then
                 ! apply the transformation to z.
                 call stdlib_srot( nz, z( iloz, i-1 ), 1, z( iloz, i ), 1, cs, sn )
              end if
           end if
           ! reset deflation counter
           kdefl = 0
           ! return to start of the main loop with new value of i.
           i = l - 1
           go to 20
           160 continue
           return
     end subroutine stdlib_slahqr

     module pure subroutine stdlib_dlahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, &
     !! DLAHQR is an auxiliary routine called by DHSEQR to update the
     !! eigenvalues and Schur decomposition already computed by DHSEQR, by
     !! dealing with the Hessenberg submatrix in rows and columns ILO to
     !! IHI.
               info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(dp), intent(out) :: wi(*), wr(*)
        ! =========================================================
           ! Parameters 
           real(dp), parameter :: dat1 = 3.0_dp/4.0_dp
           real(dp), parameter :: dat2 = -0.4375_dp
           integer(ilp), parameter :: kexsh = 10
           
           
           
           ! Local Scalars 
           real(dp) :: aa, ab, ba, bb, cs, det, h11, h12, h21, h21s, h22, rt1i, rt1r, rt2i, rt2r, &
                     rtdisc, s, safmax, safmin, smlnum, sn, sum, t1, t2, t3, tr, tst, ulp, v2, v3
           integer(ilp) :: i, i1, i2, its, itmax, j, k, l, m, nh, nr, nz, kdefl
           ! Local Arrays 
           real(dp) :: v(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n==0 )return
           if( ilo==ihi ) then
              wr( ilo ) = h( ilo, ilo )
              wi( ilo ) = zero
              return
           end if
           ! ==== clear out the trash ====
           do j = ilo, ihi - 3
              h( j+2, j ) = zero
              h( j+3, j ) = zero
           end do
           if( ilo<=ihi-2 )h( ihi, ihi-2 ) = zero
           nh = ihi - ilo + 1
           nz = ihiz - iloz + 1
           ! set machine-dependent constants for the stopping criterion.
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safmax = one / safmin
           call stdlib_dlabad( safmin, safmax )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin*( real( nh,KIND=dp) / ulp )
           ! i1 and i2 are the indices of the first row and last column of h
           ! to which transformations must be applied. if eigenvalues only are
           ! being computed, i1 and i2 are set inside the main loop.
           if( wantt ) then
              i1 = 1
              i2 = n
           end if
           ! itmax is the total number of qr iterations allowed.
           itmax = 30 * max( 10, nh )
           ! kdefl counts the number of iterations since a deflation
           kdefl = 0
           ! the main loop begins here. i is the loop index and decreases from
           ! ihi to ilo in steps of 1 or 2. each iteration of the loop works
           ! with the active submatrix in rows and columns l to i.
           ! eigenvalues i+1 to ihi have already converged. either l = ilo or
           ! h(l,l-1) is negligible so that the matrix splits.
           i = ihi
           20 continue
           l = ilo
           if( i<ilo )go to 160
           ! perform qr iterations on rows and columns ilo to i until a
           ! submatrix of order 1 or 2 splits off at the bottom because a
           ! subdiagonal element has become negligible.
           loop_140: do its = 0, itmax
              ! look for a single small subdiagonal element.
              do k = i, l + 1, -1
                 if( abs( h( k, k-1 ) )<=smlnum )go to 40
                 tst = abs( h( k-1, k-1 ) ) + abs( h( k, k ) )
                 if( tst==zero ) then
                    if( k-2>=ilo )tst = tst + abs( h( k-1, k-2 ) )
                    if( k+1<=ihi )tst = tst + abs( h( k+1, k ) )
                 end if
                 ! ==== the following is a conservative small subdiagonal
                 ! .    deflation  criterion due to ahues
                 ! .    1997). it has better mathematical foundation and
                 ! .    improves accuracy in some cases.  ====
                 if( abs( h( k, k-1 ) )<=ulp*tst ) then
                    ab = max( abs( h( k, k-1 ) ), abs( h( k-1, k ) ) )
                    ba = min( abs( h( k, k-1 ) ), abs( h( k-1, k ) ) )
                    aa = max( abs( h( k, k ) ),abs( h( k-1, k-1 )-h( k, k ) ) )
                    bb = min( abs( h( k, k ) ),abs( h( k-1, k-1 )-h( k, k ) ) )
                    s = aa + ab
                    if( ba*( ab / s )<=max( smlnum,ulp*( bb*( aa / s ) ) ) )go to 40
                 end if
              end do
              40 continue
              l = k
              if( l>ilo ) then
                 ! h(l,l-1) is negligible
                 h( l, l-1 ) = zero
              end if
              ! exit from loop if a submatrix of order 1 or 2 has split off.
              if( l>=i-1 )go to 150
              kdefl = kdefl + 1
              ! now the active submatrix is in rows and columns l to i. if
              ! eigenvalues only are being computed, only the active submatrix
              ! need be transformed.
              if( .not.wantt ) then
                 i1 = l
                 i2 = i
              end if
              if( mod(kdefl,2*kexsh)==0 ) then
                 ! exceptional shift.
                 s = abs( h( i, i-1 ) ) + abs( h( i-1, i-2 ) )
                 h11 = dat1*s + h( i, i )
                 h12 = dat2*s
                 h21 = s
                 h22 = h11
              else if( mod(kdefl,kexsh)==0 ) then
                 ! exceptional shift.
                 s = abs( h( l+1, l ) ) + abs( h( l+2, l+1 ) )
                 h11 = dat1*s + h( l, l )
                 h12 = dat2*s
                 h21 = s
                 h22 = h11
              else
                 ! prepare to use francis' double shift
                 ! (i.e. 2nd degree generalized rayleigh quotient)
                 h11 = h( i-1, i-1 )
                 h21 = h( i, i-1 )
                 h12 = h( i-1, i )
                 h22 = h( i, i )
              end if
              s = abs( h11 ) + abs( h12 ) + abs( h21 ) + abs( h22 )
              if( s==zero ) then
                 rt1r = zero
                 rt1i = zero
                 rt2r = zero
                 rt2i = zero
              else
                 h11 = h11 / s
                 h21 = h21 / s
                 h12 = h12 / s
                 h22 = h22 / s
                 tr = ( h11+h22 ) / two
                 det = ( h11-tr )*( h22-tr ) - h12*h21
                 rtdisc = sqrt( abs( det ) )
                 if( det>=zero ) then
                    ! ==== complex conjugate shifts ====
                    rt1r = tr*s
                    rt2r = rt1r
                    rt1i = rtdisc*s
                    rt2i = -rt1i
                 else
                    ! ==== realshifts (use only one of them,KIND=dp)  ====
                    rt1r = tr + rtdisc
                    rt2r = tr - rtdisc
                    if( abs( rt1r-h22 )<=abs( rt2r-h22 ) ) then
                       rt1r = rt1r*s
                       rt2r = rt1r
                    else
                       rt2r = rt2r*s
                       rt1r = rt2r
                    end if
                    rt1i = zero
                    rt2i = zero
                 end if
              end if
              ! look for two consecutive small subdiagonal elements.
              do m = i - 2, l, -1
                 ! determine the effect of starting the double-shift qr
                 ! iteration at row m, and see if this would make h(m,m-1)
                 ! negligible.  (the following uses scaling to avoid
                 ! overflows and most underflows.)
                 h21s = h( m+1, m )
                 s = abs( h( m, m )-rt2r ) + abs( rt2i ) + abs( h21s )
                 h21s = h( m+1, m ) / s
                 v( 1 ) = h21s*h( m, m+1 ) + ( h( m, m )-rt1r )*( ( h( m, m )-rt2r ) / s ) - &
                           rt1i*( rt2i / s )
                 v( 2 ) = h21s*( h( m, m )+h( m+1, m+1 )-rt1r-rt2r )
                 v( 3 ) = h21s*h( m+2, m+1 )
                 s = abs( v( 1 ) ) + abs( v( 2 ) ) + abs( v( 3 ) )
                 v( 1 ) = v( 1 ) / s
                 v( 2 ) = v( 2 ) / s
                 v( 3 ) = v( 3 ) / s
                 if( m==l )go to 60
                 if( abs( h( m, m-1 ) )*( abs( v( 2 ) )+abs( v( 3 ) ) )<=ulp*abs( v( 1 ) )*( abs( &
                           h( m-1, m-1 ) )+abs( h( m,m ) )+abs( h( m+1, m+1 ) ) ) )go to 60
              end do
              60 continue
              ! double-shift qr step
              loop_130: do k = m, i - 1
                 ! the first iteration of this loop determines a reflection g
                 ! from the vector v and applies it from left and right to h,
                 ! thus creating a nonzero bulge below the subdiagonal.
                 ! each subsequent iteration determines a reflection g to
                 ! restore the hessenberg form in the (k-1)th column, and thus
                 ! chases the bulge one step toward the bottom of the active
                 ! submatrix. nr is the order of g.
                 nr = min( 3, i-k+1 )
                 if( k>m )call stdlib_dcopy( nr, h( k, k-1 ), 1, v, 1 )
                 call stdlib_dlarfg( nr, v( 1 ), v( 2 ), 1, t1 )
                 if( k>m ) then
                    h( k, k-1 ) = v( 1 )
                    h( k+1, k-1 ) = zero
                    if( k<i-1 )h( k+2, k-1 ) = zero
                 else if( m>l ) then
                     ! ==== use the following instead of
                     ! .    h( k, k-1 ) = -h( k, k-1 ) to
                     ! .    avoid a bug when v(2) and v(3)
                     ! .    underflow. ====
                    h( k, k-1 ) = h( k, k-1 )*( one-t1 )
                 end if
                 v2 = v( 2 )
                 t2 = t1*v2
                 if( nr==3 ) then
                    v3 = v( 3 )
                    t3 = t1*v3
                    ! apply g from the left to transform the rows of the matrix
                    ! in columns k to i2.
                    do j = k, i2
                       sum = h( k, j ) + v2*h( k+1, j ) + v3*h( k+2, j )
                       h( k, j ) = h( k, j ) - sum*t1
                       h( k+1, j ) = h( k+1, j ) - sum*t2
                       h( k+2, j ) = h( k+2, j ) - sum*t3
                    end do
                    ! apply g from the right to transform the columns of the
                    ! matrix in rows i1 to min(k+3,i).
                    do j = i1, min( k+3, i )
                       sum = h( j, k ) + v2*h( j, k+1 ) + v3*h( j, k+2 )
                       h( j, k ) = h( j, k ) - sum*t1
                       h( j, k+1 ) = h( j, k+1 ) - sum*t2
                       h( j, k+2 ) = h( j, k+2 ) - sum*t3
                    end do
                    if( wantz ) then
                       ! accumulate transformations in the matrix z
                       do j = iloz, ihiz
                          sum = z( j, k ) + v2*z( j, k+1 ) + v3*z( j, k+2 )
                          z( j, k ) = z( j, k ) - sum*t1
                          z( j, k+1 ) = z( j, k+1 ) - sum*t2
                          z( j, k+2 ) = z( j, k+2 ) - sum*t3
                       end do
                    end if
                 else if( nr==2 ) then
                    ! apply g from the left to transform the rows of the matrix
                    ! in columns k to i2.
                    do j = k, i2
                       sum = h( k, j ) + v2*h( k+1, j )
                       h( k, j ) = h( k, j ) - sum*t1
                       h( k+1, j ) = h( k+1, j ) - sum*t2
                    end do
                    ! apply g from the right to transform the columns of the
                    ! matrix in rows i1 to min(k+3,i).
                    do j = i1, i
                       sum = h( j, k ) + v2*h( j, k+1 )
                       h( j, k ) = h( j, k ) - sum*t1
                       h( j, k+1 ) = h( j, k+1 ) - sum*t2
                    end do
                    if( wantz ) then
                       ! accumulate transformations in the matrix z
                       do j = iloz, ihiz
                          sum = z( j, k ) + v2*z( j, k+1 )
                          z( j, k ) = z( j, k ) - sum*t1
                          z( j, k+1 ) = z( j, k+1 ) - sum*t2
                       end do
                    end if
                 end if
              end do loop_130
           end do loop_140
           ! failure to converge in remaining number of iterations
           info = i
           return
           150 continue
           if( l==i ) then
              ! h(i,i-1) is negligible: one eigenvalue has converged.
              wr( i ) = h( i, i )
              wi( i ) = zero
           else if( l==i-1 ) then
              ! h(i-1,i-2) is negligible: a pair of eigenvalues have converged.
              ! transform the 2-by-2 submatrix to standard schur form,
              ! and compute and store the eigenvalues.
              call stdlib_dlanv2( h( i-1, i-1 ), h( i-1, i ), h( i, i-1 ),h( i, i ), wr( i-1 ), &
                        wi( i-1 ), wr( i ), wi( i ),cs, sn )
              if( wantt ) then
                 ! apply the transformation to the rest of h.
                 if( i2>i )call stdlib_drot( i2-i, h( i-1, i+1 ), ldh, h( i, i+1 ), ldh,cs, sn )
                           
                 call stdlib_drot( i-i1-1, h( i1, i-1 ), 1, h( i1, i ), 1, cs, sn )
              end if
              if( wantz ) then
                 ! apply the transformation to z.
                 call stdlib_drot( nz, z( iloz, i-1 ), 1, z( iloz, i ), 1, cs, sn )
              end if
           end if
           ! reset deflation counter
           kdefl = 0
           ! return to start of the main loop with new value of i.
           i = l - 1
           go to 20
           160 continue
           return
     end subroutine stdlib_dlahqr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$lahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, &
     !! DLAHQR: is an auxiliary routine called by DHSEQR to update the
     !! eigenvalues and Schur decomposition already computed by DHSEQR, by
     !! dealing with the Hessenberg submatrix in rows and columns ILO to
     !! IHI.
               info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(${rk}$), intent(inout) :: h(ldh,*), z(ldz,*)
           real(${rk}$), intent(out) :: wi(*), wr(*)
        ! =========================================================
           ! Parameters 
           real(${rk}$), parameter :: dat1 = 3.0_${rk}$/4.0_${rk}$
           real(${rk}$), parameter :: dat2 = -0.4375_${rk}$
           integer(ilp), parameter :: kexsh = 10
           
           
           
           ! Local Scalars 
           real(${rk}$) :: aa, ab, ba, bb, cs, det, h11, h12, h21, h21s, h22, rt1i, rt1r, rt2i, rt2r, &
                     rtdisc, s, safmax, safmin, smlnum, sn, sum, t1, t2, t3, tr, tst, ulp, v2, v3
           integer(ilp) :: i, i1, i2, its, itmax, j, k, l, m, nh, nr, nz, kdefl
           ! Local Arrays 
           real(${rk}$) :: v(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n==0 )return
           if( ilo==ihi ) then
              wr( ilo ) = h( ilo, ilo )
              wi( ilo ) = zero
              return
           end if
           ! ==== clear out the trash ====
           do j = ilo, ihi - 3
              h( j+2, j ) = zero
              h( j+3, j ) = zero
           end do
           if( ilo<=ihi-2 )h( ihi, ihi-2 ) = zero
           nh = ihi - ilo + 1
           nz = ihiz - iloz + 1
           ! set machine-dependent constants for the stopping criterion.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safmax = one / safmin
           call stdlib_${ri}$labad( safmin, safmax )
           ulp = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin*( real( nh,KIND=${rk}$) / ulp )
           ! i1 and i2 are the indices of the first row and last column of h
           ! to which transformations must be applied. if eigenvalues only are
           ! being computed, i1 and i2 are set inside the main loop.
           if( wantt ) then
              i1 = 1
              i2 = n
           end if
           ! itmax is the total number of qr iterations allowed.
           itmax = 30 * max( 10, nh )
           ! kdefl counts the number of iterations since a deflation
           kdefl = 0
           ! the main loop begins here. i is the loop index and decreases from
           ! ihi to ilo in steps of 1 or 2. each iteration of the loop works
           ! with the active submatrix in rows and columns l to i.
           ! eigenvalues i+1 to ihi have already converged. either l = ilo or
           ! h(l,l-1) is negligible so that the matrix splits.
           i = ihi
           20 continue
           l = ilo
           if( i<ilo )go to 160
           ! perform qr iterations on rows and columns ilo to i until a
           ! submatrix of order 1 or 2 splits off at the bottom because a
           ! subdiagonal element has become negligible.
           loop_140: do its = 0, itmax
              ! look for a single small subdiagonal element.
              do k = i, l + 1, -1
                 if( abs( h( k, k-1 ) )<=smlnum )go to 40
                 tst = abs( h( k-1, k-1 ) ) + abs( h( k, k ) )
                 if( tst==zero ) then
                    if( k-2>=ilo )tst = tst + abs( h( k-1, k-2 ) )
                    if( k+1<=ihi )tst = tst + abs( h( k+1, k ) )
                 end if
                 ! ==== the following is a conservative small subdiagonal
                 ! .    deflation  criterion due to ahues
                 ! .    1997). it has better mathematical foundation and
                 ! .    improves accuracy in some cases.  ====
                 if( abs( h( k, k-1 ) )<=ulp*tst ) then
                    ab = max( abs( h( k, k-1 ) ), abs( h( k-1, k ) ) )
                    ba = min( abs( h( k, k-1 ) ), abs( h( k-1, k ) ) )
                    aa = max( abs( h( k, k ) ),abs( h( k-1, k-1 )-h( k, k ) ) )
                    bb = min( abs( h( k, k ) ),abs( h( k-1, k-1 )-h( k, k ) ) )
                    s = aa + ab
                    if( ba*( ab / s )<=max( smlnum,ulp*( bb*( aa / s ) ) ) )go to 40
                 end if
              end do
              40 continue
              l = k
              if( l>ilo ) then
                 ! h(l,l-1) is negligible
                 h( l, l-1 ) = zero
              end if
              ! exit from loop if a submatrix of order 1 or 2 has split off.
              if( l>=i-1 )go to 150
              kdefl = kdefl + 1
              ! now the active submatrix is in rows and columns l to i. if
              ! eigenvalues only are being computed, only the active submatrix
              ! need be transformed.
              if( .not.wantt ) then
                 i1 = l
                 i2 = i
              end if
              if( mod(kdefl,2*kexsh)==0 ) then
                 ! exceptional shift.
                 s = abs( h( i, i-1 ) ) + abs( h( i-1, i-2 ) )
                 h11 = dat1*s + h( i, i )
                 h12 = dat2*s
                 h21 = s
                 h22 = h11
              else if( mod(kdefl,kexsh)==0 ) then
                 ! exceptional shift.
                 s = abs( h( l+1, l ) ) + abs( h( l+2, l+1 ) )
                 h11 = dat1*s + h( l, l )
                 h12 = dat2*s
                 h21 = s
                 h22 = h11
              else
                 ! prepare to use francis' double shift
                 ! (i.e. 2nd degree generalized rayleigh quotient)
                 h11 = h( i-1, i-1 )
                 h21 = h( i, i-1 )
                 h12 = h( i-1, i )
                 h22 = h( i, i )
              end if
              s = abs( h11 ) + abs( h12 ) + abs( h21 ) + abs( h22 )
              if( s==zero ) then
                 rt1r = zero
                 rt1i = zero
                 rt2r = zero
                 rt2i = zero
              else
                 h11 = h11 / s
                 h21 = h21 / s
                 h12 = h12 / s
                 h22 = h22 / s
                 tr = ( h11+h22 ) / two
                 det = ( h11-tr )*( h22-tr ) - h12*h21
                 rtdisc = sqrt( abs( det ) )
                 if( det>=zero ) then
                    ! ==== complex conjugate shifts ====
                    rt1r = tr*s
                    rt2r = rt1r
                    rt1i = rtdisc*s
                    rt2i = -rt1i
                 else
                    ! ==== realshifts (use only one of them,KIND=${rk}$)  ====
                    rt1r = tr + rtdisc
                    rt2r = tr - rtdisc
                    if( abs( rt1r-h22 )<=abs( rt2r-h22 ) ) then
                       rt1r = rt1r*s
                       rt2r = rt1r
                    else
                       rt2r = rt2r*s
                       rt1r = rt2r
                    end if
                    rt1i = zero
                    rt2i = zero
                 end if
              end if
              ! look for two consecutive small subdiagonal elements.
              do m = i - 2, l, -1
                 ! determine the effect of starting the double-shift qr
                 ! iteration at row m, and see if this would make h(m,m-1)
                 ! negligible.  (the following uses scaling to avoid
                 ! overflows and most underflows.)
                 h21s = h( m+1, m )
                 s = abs( h( m, m )-rt2r ) + abs( rt2i ) + abs( h21s )
                 h21s = h( m+1, m ) / s
                 v( 1 ) = h21s*h( m, m+1 ) + ( h( m, m )-rt1r )*( ( h( m, m )-rt2r ) / s ) - &
                           rt1i*( rt2i / s )
                 v( 2 ) = h21s*( h( m, m )+h( m+1, m+1 )-rt1r-rt2r )
                 v( 3 ) = h21s*h( m+2, m+1 )
                 s = abs( v( 1 ) ) + abs( v( 2 ) ) + abs( v( 3 ) )
                 v( 1 ) = v( 1 ) / s
                 v( 2 ) = v( 2 ) / s
                 v( 3 ) = v( 3 ) / s
                 if( m==l )go to 60
                 if( abs( h( m, m-1 ) )*( abs( v( 2 ) )+abs( v( 3 ) ) )<=ulp*abs( v( 1 ) )*( abs( &
                           h( m-1, m-1 ) )+abs( h( m,m ) )+abs( h( m+1, m+1 ) ) ) )go to 60
              end do
              60 continue
              ! double-shift qr step
              loop_130: do k = m, i - 1
                 ! the first iteration of this loop determines a reflection g
                 ! from the vector v and applies it from left and right to h,
                 ! thus creating a nonzero bulge below the subdiagonal.
                 ! each subsequent iteration determines a reflection g to
                 ! restore the hessenberg form in the (k-1)th column, and thus
                 ! chases the bulge one step toward the bottom of the active
                 ! submatrix. nr is the order of g.
                 nr = min( 3, i-k+1 )
                 if( k>m )call stdlib_${ri}$copy( nr, h( k, k-1 ), 1, v, 1 )
                 call stdlib_${ri}$larfg( nr, v( 1 ), v( 2 ), 1, t1 )
                 if( k>m ) then
                    h( k, k-1 ) = v( 1 )
                    h( k+1, k-1 ) = zero
                    if( k<i-1 )h( k+2, k-1 ) = zero
                 else if( m>l ) then
                     ! ==== use the following instead of
                     ! .    h( k, k-1 ) = -h( k, k-1 ) to
                     ! .    avoid a bug when v(2) and v(3)
                     ! .    underflow. ====
                    h( k, k-1 ) = h( k, k-1 )*( one-t1 )
                 end if
                 v2 = v( 2 )
                 t2 = t1*v2
                 if( nr==3 ) then
                    v3 = v( 3 )
                    t3 = t1*v3
                    ! apply g from the left to transform the rows of the matrix
                    ! in columns k to i2.
                    do j = k, i2
                       sum = h( k, j ) + v2*h( k+1, j ) + v3*h( k+2, j )
                       h( k, j ) = h( k, j ) - sum*t1
                       h( k+1, j ) = h( k+1, j ) - sum*t2
                       h( k+2, j ) = h( k+2, j ) - sum*t3
                    end do
                    ! apply g from the right to transform the columns of the
                    ! matrix in rows i1 to min(k+3,i).
                    do j = i1, min( k+3, i )
                       sum = h( j, k ) + v2*h( j, k+1 ) + v3*h( j, k+2 )
                       h( j, k ) = h( j, k ) - sum*t1
                       h( j, k+1 ) = h( j, k+1 ) - sum*t2
                       h( j, k+2 ) = h( j, k+2 ) - sum*t3
                    end do
                    if( wantz ) then
                       ! accumulate transformations in the matrix z
                       do j = iloz, ihiz
                          sum = z( j, k ) + v2*z( j, k+1 ) + v3*z( j, k+2 )
                          z( j, k ) = z( j, k ) - sum*t1
                          z( j, k+1 ) = z( j, k+1 ) - sum*t2
                          z( j, k+2 ) = z( j, k+2 ) - sum*t3
                       end do
                    end if
                 else if( nr==2 ) then
                    ! apply g from the left to transform the rows of the matrix
                    ! in columns k to i2.
                    do j = k, i2
                       sum = h( k, j ) + v2*h( k+1, j )
                       h( k, j ) = h( k, j ) - sum*t1
                       h( k+1, j ) = h( k+1, j ) - sum*t2
                    end do
                    ! apply g from the right to transform the columns of the
                    ! matrix in rows i1 to min(k+3,i).
                    do j = i1, i
                       sum = h( j, k ) + v2*h( j, k+1 )
                       h( j, k ) = h( j, k ) - sum*t1
                       h( j, k+1 ) = h( j, k+1 ) - sum*t2
                    end do
                    if( wantz ) then
                       ! accumulate transformations in the matrix z
                       do j = iloz, ihiz
                          sum = z( j, k ) + v2*z( j, k+1 )
                          z( j, k ) = z( j, k ) - sum*t1
                          z( j, k+1 ) = z( j, k+1 ) - sum*t2
                       end do
                    end if
                 end if
              end do loop_130
           end do loop_140
           ! failure to converge in remaining number of iterations
           info = i
           return
           150 continue
           if( l==i ) then
              ! h(i,i-1) is negligible: one eigenvalue has converged.
              wr( i ) = h( i, i )
              wi( i ) = zero
           else if( l==i-1 ) then
              ! h(i-1,i-2) is negligible: a pair of eigenvalues have converged.
              ! transform the 2-by-2 submatrix to standard schur form,
              ! and compute and store the eigenvalues.
              call stdlib_${ri}$lanv2( h( i-1, i-1 ), h( i-1, i ), h( i, i-1 ),h( i, i ), wr( i-1 ), &
                        wi( i-1 ), wr( i ), wi( i ),cs, sn )
              if( wantt ) then
                 ! apply the transformation to the rest of h.
                 if( i2>i )call stdlib_${ri}$rot( i2-i, h( i-1, i+1 ), ldh, h( i, i+1 ), ldh,cs, sn )
                           
                 call stdlib_${ri}$rot( i-i1-1, h( i1, i-1 ), 1, h( i1, i ), 1, cs, sn )
              end if
              if( wantz ) then
                 ! apply the transformation to z.
                 call stdlib_${ri}$rot( nz, z( iloz, i-1 ), 1, z( iloz, i ), 1, cs, sn )
              end if
           end if
           ! reset deflation counter
           kdefl = 0
           ! return to start of the main loop with new value of i.
           i = l - 1
           go to 20
           160 continue
           return
     end subroutine stdlib_${ri}$lahqr

#:endif
#:endfor

     module pure subroutine stdlib_clahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, info &
     !! CLAHQR is an auxiliary routine called by CHSEQR to update the
     !! eigenvalues and Schur decomposition already computed by CHSEQR, by
     !! dealing with the Hessenberg submatrix in rows and columns ILO to
     !! IHI.
               )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: w(*)
        ! =========================================================
           ! Parameters 
           real(sp), parameter :: rzero = 0.0_sp
           real(sp), parameter :: rone = 1.0_sp
           real(sp), parameter :: dat1 = 3.0_sp/4.0_sp
           integer(ilp), parameter :: kexsh = 10
           
           
           
           
           ! Local Scalars 
           complex(sp) :: cdum, h11, h11s, h22, sc, sum, t, t1, temp, u, v2, x, y
           real(sp) :: aa, ab, ba, bb, h10, h21, rtemp, s, safmax, safmin, smlnum, sx, t2, tst, &
                     ulp
           integer(ilp) :: i, i1, i2, its, itmax, j, jhi, jlo, k, l, m, nh, nz, kdefl
           ! Local Arrays 
           complex(sp) :: v(2)
           ! Statement Functions 
           real(sp) :: cabs1
           ! Intrinsic Functions 
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n==0 )return
           if( ilo==ihi ) then
              w( ilo ) = h( ilo, ilo )
              return
           end if
           ! ==== clear out the trash ====
           do j = ilo, ihi - 3
              h( j+2, j ) = czero
              h( j+3, j ) = czero
           end do
           if( ilo<=ihi-2 )h( ihi, ihi-2 ) = czero
           ! ==== ensure that subdiagonal entries are real ====
           if( wantt ) then
              jlo = 1
              jhi = n
           else
              jlo = ilo
              jhi = ihi
           end if
           do i = ilo + 1, ihi
              if( aimag( h( i, i-1 ) )/=rzero ) then
                 ! ==== the following redundant normalization
                 ! .    avoids problems with both gradual and
                 ! .    sudden underflow in abs(h(i,i-1)) ====
                 sc = h( i, i-1 ) / cabs1( h( i, i-1 ) )
                 sc = conjg( sc ) / abs( sc )
                 h( i, i-1 ) = abs( h( i, i-1 ) )
                 call stdlib_cscal( jhi-i+1, sc, h( i, i ), ldh )
                 call stdlib_cscal( min( jhi, i+1 )-jlo+1, conjg( sc ), h( jlo, i ),1 )
                 if( wantz )call stdlib_cscal( ihiz-iloz+1, conjg( sc ), z( iloz, i ), 1 )
              end if
           end do
           nh = ihi - ilo + 1
           nz = ihiz - iloz + 1
           ! set machine-dependent constants for the stopping criterion.
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( nh,KIND=sp) / ulp )
           ! i1 and i2 are the indices of the first row and last column of h
           ! to which transformations must be applied. if eigenvalues only are
           ! being computed, i1 and i2 are set inside the main loop.
           if( wantt ) then
              i1 = 1
              i2 = n
           end if
           ! itmax is the total number of qr iterations allowed.
           itmax = 30 * max( 10, nh )
           ! kdefl counts the number of iterations since a deflation
           kdefl = 0
           ! the main loop begins here. i is the loop index and decreases from
           ! ihi to ilo in steps of 1. each iteration of the loop works
           ! with the active submatrix in rows and columns l to i.
           ! eigenvalues i+1 to ihi have already converged. either l = ilo, or
           ! h(l,l-1) is negligible so that the matrix splits.
           i = ihi
           30 continue
           if( i<ilo )go to 150
           ! perform qr iterations on rows and columns ilo to i until a
           ! submatrix of order 1 splits off at the bottom because a
           ! subdiagonal element has become negligible.
           l = ilo
           loop_130: do its = 0, itmax
              ! look for a single small subdiagonal element.
              do k = i, l + 1, -1
                 if( cabs1( h( k, k-1 ) )<=smlnum )go to 50
                 tst = cabs1( h( k-1, k-1 ) ) + cabs1( h( k, k ) )
                 if( tst==czero ) then
                    if( k-2>=ilo )tst = tst + abs( real( h( k-1, k-2 ),KIND=sp) )
                    if( k+1<=ihi )tst = tst + abs( real( h( k+1, k ),KIND=sp) )
                 end if
                 ! ==== the following is a conservative small subdiagonal
                 ! .    deflation criterion due to ahues
                 ! .    1997). it has better mathematical foundation and
                 ! .    improves accuracy in some examples.  ====
                 if( abs( real( h( k, k-1 ),KIND=sp) )<=ulp*tst ) then
                    ab = max( cabs1( h( k, k-1 ) ), cabs1( h( k-1, k ) ) )
                    ba = min( cabs1( h( k, k-1 ) ), cabs1( h( k-1, k ) ) )
                    aa = max( cabs1( h( k, k ) ),cabs1( h( k-1, k-1 )-h( k, k ) ) )
                    bb = min( cabs1( h( k, k ) ),cabs1( h( k-1, k-1 )-h( k, k ) ) )
                    s = aa + ab
                    if( ba*( ab / s )<=max( smlnum,ulp*( bb*( aa / s ) ) ) )go to 50
                 end if
              end do
              50 continue
              l = k
              if( l>ilo ) then
                 ! h(l,l-1) is negligible
                 h( l, l-1 ) = czero
              end if
              ! exit from loop if a submatrix of order 1 has split off.
              if( l>=i )go to 140
              kdefl = kdefl + 1
              ! now the active submatrix is in rows and columns l to i. if
              ! eigenvalues only are being computed, only the active submatrix
              ! need be transformed.
              if( .not.wantt ) then
                 i1 = l
                 i2 = i
              end if
              if( mod(kdefl,2*kexsh)==0 ) then
                 ! exceptional shift.
                 s = dat1*abs( real( h( i, i-1 ),KIND=sp) )
                 t = s + h( i, i )
              else if( mod(kdefl,kexsh)==0 ) then
                 ! exceptional shift.
                 s = dat1*abs( real( h( l+1, l ),KIND=sp) )
                 t = s + h( l, l )
              else
                 ! wilkinson's shift.
                 t = h( i, i )
                 u = sqrt( h( i-1, i ) )*sqrt( h( i, i-1 ) )
                 s = cabs1( u )
                 if( s/=rzero ) then
                    x = half*( h( i-1, i-1 )-t )
                    sx = cabs1( x )
                    s = max( s, cabs1( x ) )
                    y = s*sqrt( ( x / s )**2+( u / s )**2 )
                    if( sx>rzero ) then
                       if( real( x / sx,KIND=sp)*real( y,KIND=sp)+aimag( x / sx )*aimag( y )&
                                 <rzero )y = -y
                    end if
                    t = t - u*stdlib_cladiv( u, ( x+y ) )
                 end if
              end if
              ! look for two consecutive small subdiagonal elements.
              do m = i - 1, l + 1, -1
                 ! determine the effect of starting the single-shift qr
                 ! iteration at row m, and see if this would make h(m,m-1)
                 ! negligible.
                 h11 = h( m, m )
                 h22 = h( m+1, m+1 )
                 h11s = h11 - t
                 h21 = real( h( m+1, m ),KIND=sp)
                 s = cabs1( h11s ) + abs( h21 )
                 h11s = h11s / s
                 h21 = h21 / s
                 v( 1 ) = h11s
                 v( 2 ) = h21
                 h10 = real( h( m, m-1 ),KIND=sp)
                 if( abs( h10 )*abs( h21 )<=ulp*( cabs1( h11s )*( cabs1( h11 )+cabs1( h22 ) ) ) )&
                           go to 70
              end do
              h11 = h( l, l )
              h22 = h( l+1, l+1 )
              h11s = h11 - t
              h21 = real( h( l+1, l ),KIND=sp)
              s = cabs1( h11s ) + abs( h21 )
              h11s = h11s / s
              h21 = h21 / s
              v( 1 ) = h11s
              v( 2 ) = h21
              70 continue
              ! single-shift qr step
              loop_120: do k = m, i - 1
                 ! the first iteration of this loop determines a reflection g
                 ! from the vector v and applies it from left and right to h,
                 ! thus creating a nonzero bulge below the subdiagonal.
                 ! each subsequent iteration determines a reflection g to
                 ! restore the hessenberg form in the (k-1)th column, and thus
                 ! chases the bulge cone step toward the bottom of the active
                 ! submatrix.
                 ! v(2) is always real before the call to stdlib_clarfg, and hence
                 ! after the call t2 ( = t1*v(2) ) is also real.
                 if( k>m )call stdlib_ccopy( 2, h( k, k-1 ), 1, v, 1 )
                 call stdlib_clarfg( 2, v( 1 ), v( 2 ), 1, t1 )
                 if( k>m ) then
                    h( k, k-1 ) = v( 1 )
                    h( k+1, k-1 ) = czero
                 end if
                 v2 = v( 2 )
                 t2 = real( t1*v2,KIND=sp)
                 ! apply g from the left to transform the rows of the matrix
                 ! in columns k to i2.
                 do j = k, i2
                    sum = conjg( t1 )*h( k, j ) + t2*h( k+1, j )
                    h( k, j ) = h( k, j ) - sum
                    h( k+1, j ) = h( k+1, j ) - sum*v2
                 end do
                 ! apply g from the right to transform the columns of the
                 ! matrix in rows i1 to min(k+2,i).
                 do j = i1, min( k+2, i )
                    sum = t1*h( j, k ) + t2*h( j, k+1 )
                    h( j, k ) = h( j, k ) - sum
                    h( j, k+1 ) = h( j, k+1 ) - sum*conjg( v2 )
                 end do
                 if( wantz ) then
                    ! accumulate transformations in the matrix z
                    do j = iloz, ihiz
                       sum = t1*z( j, k ) + t2*z( j, k+1 )
                       z( j, k ) = z( j, k ) - sum
                       z( j, k+1 ) = z( j, k+1 ) - sum*conjg( v2 )
                    end do
                 end if
                 if( k==m .and. m>l ) then
                    ! if the qr step was started at row m > l because two
                    ! consecutive small subdiagonals were found, then extra
                    ! scaling must be performed to ensure that h(m,m-1) remains
                    ! real.
                    temp = cone - t1
                    temp = temp / abs( temp )
                    h( m+1, m ) = h( m+1, m )*conjg( temp )
                    if( m+2<=i )h( m+2, m+1 ) = h( m+2, m+1 )*temp
                    do j = m, i
                       if( j/=m+1 ) then
                          if( i2>j )call stdlib_cscal( i2-j, temp, h( j, j+1 ), ldh )
                          call stdlib_cscal( j-i1, conjg( temp ), h( i1, j ), 1 )
                          if( wantz ) then
                             call stdlib_cscal( nz, conjg( temp ), z( iloz, j ), 1 )
                          end if
                       end if
                    end do
                 end if
              end do loop_120
              ! ensure that h(i,i-1) is real.
              temp = h( i, i-1 )
              if( aimag( temp )/=rzero ) then
                 rtemp = abs( temp )
                 h( i, i-1 ) = rtemp
                 temp = temp / rtemp
                 if( i2>i )call stdlib_cscal( i2-i, conjg( temp ), h( i, i+1 ), ldh )
                 call stdlib_cscal( i-i1, temp, h( i1, i ), 1 )
                 if( wantz ) then
                    call stdlib_cscal( nz, temp, z( iloz, i ), 1 )
                 end if
              end if
           end do loop_130
           ! failure to converge in remaining number of iterations
           info = i
           return
           140 continue
           ! h(i,i-1) is negligible: cone eigenvalue has converged.
           w( i ) = h( i, i )
           ! reset deflation counter
           kdefl = 0
           ! return to start of the main loop with new value of i.
           i = l - 1
           go to 30
           150 continue
           return
     end subroutine stdlib_clahqr

     module pure subroutine stdlib_zlahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, info &
     !! ZLAHQR is an auxiliary routine called by CHSEQR to update the
     !! eigenvalues and Schur decomposition already computed by CHSEQR, by
     !! dealing with the Hessenberg submatrix in rows and columns ILO to
     !! IHI.
               )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(dp), intent(out) :: w(*)
        ! =========================================================
           ! Parameters 
           real(dp), parameter :: rzero = 0.0_dp
           real(dp), parameter :: rone = 1.0_dp
           real(dp), parameter :: dat1 = 3.0_dp/4.0_dp
           integer(ilp), parameter :: kexsh = 10
           
           
           
           
           ! Local Scalars 
           complex(dp) :: cdum, h11, h11s, h22, sc, sum, t, t1, temp, u, v2, x, y
           real(dp) :: aa, ab, ba, bb, h10, h21, rtemp, s, safmax, safmin, smlnum, sx, t2, tst, &
                     ulp
           integer(ilp) :: i, i1, i2, its, itmax, j, jhi, jlo, k, l, m, nh, nz, kdefl
           ! Local Arrays 
           complex(dp) :: v(2)
           ! Statement Functions 
           real(dp) :: cabs1
           ! Intrinsic Functions 
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n==0 )return
           if( ilo==ihi ) then
              w( ilo ) = h( ilo, ilo )
              return
           end if
           ! ==== clear out the trash ====
           do j = ilo, ihi - 3
              h( j+2, j ) = czero
              h( j+3, j ) = czero
           end do
           if( ilo<=ihi-2 )h( ihi, ihi-2 ) = czero
           ! ==== ensure that subdiagonal entries are real ====
           if( wantt ) then
              jlo = 1
              jhi = n
           else
              jlo = ilo
              jhi = ihi
           end if
           do i = ilo + 1, ihi
              if( aimag( h( i, i-1 ) )/=rzero ) then
                 ! ==== the following redundant normalization
                 ! .    avoids problems with both gradual and
                 ! .    sudden underflow in abs(h(i,i-1)) ====
                 sc = h( i, i-1 ) / cabs1( h( i, i-1 ) )
                 sc = conjg( sc ) / abs( sc )
                 h( i, i-1 ) = abs( h( i, i-1 ) )
                 call stdlib_zscal( jhi-i+1, sc, h( i, i ), ldh )
                 call stdlib_zscal( min( jhi, i+1 )-jlo+1, conjg( sc ),h( jlo, i ), 1 )
                 if( wantz )call stdlib_zscal( ihiz-iloz+1, conjg( sc ), z( iloz, i ), 1 )
              end if
           end do
           nh = ihi - ilo + 1
           nz = ihiz - iloz + 1
           ! set machine-dependent constants for the stopping criterion.
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_dlabad( safmin, safmax )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin*( real( nh,KIND=dp) / ulp )
           ! i1 and i2 are the indices of the first row and last column of h
           ! to which transformations must be applied. if eigenvalues only are
           ! being computed, i1 and i2 are set inside the main loop.
           if( wantt ) then
              i1 = 1
              i2 = n
           end if
           ! itmax is the total number of qr iterations allowed.
           itmax = 30 * max( 10, nh )
           ! kdefl counts the number of iterations since a deflation
           kdefl = 0
           ! the main loop begins here. i is the loop index and decreases from
           ! ihi to ilo in steps of 1. each iteration of the loop works
           ! with the active submatrix in rows and columns l to i.
           ! eigenvalues i+1 to ihi have already converged. either l = ilo, or
           ! h(l,l-1) is negligible so that the matrix splits.
           i = ihi
           30 continue
           if( i<ilo )go to 150
           ! perform qr iterations on rows and columns ilo to i until a
           ! submatrix of order 1 splits off at the bottom because a
           ! subdiagonal element has become negligible.
           l = ilo
           loop_130: do its = 0, itmax
              ! look for a single small subdiagonal element.
              do k = i, l + 1, -1
                 if( cabs1( h( k, k-1 ) )<=smlnum )go to 50
                 tst = cabs1( h( k-1, k-1 ) ) + cabs1( h( k, k ) )
                 if( tst==czero ) then
                    if( k-2>=ilo )tst = tst + abs( real( h( k-1, k-2 ),KIND=dp) )
                    if( k+1<=ihi )tst = tst + abs( real( h( k+1, k ),KIND=dp) )
                 end if
                 ! ==== the following is a conservative small subdiagonal
                 ! .    deflation criterion due to ahues
                 ! .    1997). it has better mathematical foundation and
                 ! .    improves accuracy in some examples.  ====
                 if( abs( real( h( k, k-1 ),KIND=dp) )<=ulp*tst ) then
                    ab = max( cabs1( h( k, k-1 ) ), cabs1( h( k-1, k ) ) )
                    ba = min( cabs1( h( k, k-1 ) ), cabs1( h( k-1, k ) ) )
                    aa = max( cabs1( h( k, k ) ),cabs1( h( k-1, k-1 )-h( k, k ) ) )
                    bb = min( cabs1( h( k, k ) ),cabs1( h( k-1, k-1 )-h( k, k ) ) )
                    s = aa + ab
                    if( ba*( ab / s )<=max( smlnum,ulp*( bb*( aa / s ) ) ) )go to 50
                 end if
              end do
              50 continue
              l = k
              if( l>ilo ) then
                 ! h(l,l-1) is negligible
                 h( l, l-1 ) = czero
              end if
              ! exit from loop if a submatrix of order 1 has split off.
              if( l>=i )go to 140
              kdefl = kdefl + 1
              ! now the active submatrix is in rows and columns l to i. if
              ! eigenvalues only are being computed, only the active submatrix
              ! need be transformed.
              if( .not.wantt ) then
                 i1 = l
                 i2 = i
              end if
              if( mod(kdefl,2*kexsh)==0 ) then
                 ! exceptional shift.
                 s = dat1*abs( real( h( i, i-1 ),KIND=dp) )
                 t = s + h( i, i )
              else if( mod(kdefl,kexsh)==0 ) then
                 ! exceptional shift.
                 s = dat1*abs( real( h( l+1, l ),KIND=dp) )
                 t = s + h( l, l )
              else
                 ! wilkinson's shift.
                 t = h( i, i )
                 u = sqrt( h( i-1, i ) )*sqrt( h( i, i-1 ) )
                 s = cabs1( u )
                 if( s/=rzero ) then
                    x = half*( h( i-1, i-1 )-t )
                    sx = cabs1( x )
                    s = max( s, cabs1( x ) )
                    y = s*sqrt( ( x / s )**2+( u / s )**2 )
                    if( sx>rzero ) then
                       if( real( x / sx,KIND=dp)*real( y,KIND=dp)+aimag( x / sx )*aimag( y )&
                                 <rzero )y = -y
                    end if
                    t = t - u*stdlib_zladiv( u, ( x+y ) )
                 end if
              end if
              ! look for two consecutive small subdiagonal elements.
              do m = i - 1, l + 1, -1
                 ! determine the effect of starting the single-shift qr
                 ! iteration at row m, and see if this would make h(m,m-1)
                 ! negligible.
                 h11 = h( m, m )
                 h22 = h( m+1, m+1 )
                 h11s = h11 - t
                 h21 = real( h( m+1, m ),KIND=dp)
                 s = cabs1( h11s ) + abs( h21 )
                 h11s = h11s / s
                 h21 = h21 / s
                 v( 1 ) = h11s
                 v( 2 ) = h21
                 h10 = real( h( m, m-1 ),KIND=dp)
                 if( abs( h10 )*abs( h21 )<=ulp*( cabs1( h11s )*( cabs1( h11 )+cabs1( h22 ) ) ) )&
                           go to 70
              end do
              h11 = h( l, l )
              h22 = h( l+1, l+1 )
              h11s = h11 - t
              h21 = real( h( l+1, l ),KIND=dp)
              s = cabs1( h11s ) + abs( h21 )
              h11s = h11s / s
              h21 = h21 / s
              v( 1 ) = h11s
              v( 2 ) = h21
              70 continue
              ! single-shift qr step
              loop_120: do k = m, i - 1
                 ! the first iteration of this loop determines a reflection g
                 ! from the vector v and applies it from left and right to h,
                 ! thus creating a nonzero bulge below the subdiagonal.
                 ! each subsequent iteration determines a reflection g to
                 ! restore the hessenberg form in the (k-1)th column, and thus
                 ! chases the bulge cone step toward the bottom of the active
                 ! submatrix.
                 ! v(2) is always real before the call to stdlib_zlarfg, and hence
                 ! after the call t2 ( = t1*v(2) ) is also real.
                 if( k>m )call stdlib_zcopy( 2, h( k, k-1 ), 1, v, 1 )
                 call stdlib_zlarfg( 2, v( 1 ), v( 2 ), 1, t1 )
                 if( k>m ) then
                    h( k, k-1 ) = v( 1 )
                    h( k+1, k-1 ) = czero
                 end if
                 v2 = v( 2 )
                 t2 = real( t1*v2,KIND=dp)
                 ! apply g from the left to transform the rows of the matrix
                 ! in columns k to i2.
                 do j = k, i2
                    sum = conjg( t1 )*h( k, j ) + t2*h( k+1, j )
                    h( k, j ) = h( k, j ) - sum
                    h( k+1, j ) = h( k+1, j ) - sum*v2
                 end do
                 ! apply g from the right to transform the columns of the
                 ! matrix in rows i1 to min(k+2,i).
                 do j = i1, min( k+2, i )
                    sum = t1*h( j, k ) + t2*h( j, k+1 )
                    h( j, k ) = h( j, k ) - sum
                    h( j, k+1 ) = h( j, k+1 ) - sum*conjg( v2 )
                 end do
                 if( wantz ) then
                    ! accumulate transformations in the matrix z
                    do j = iloz, ihiz
                       sum = t1*z( j, k ) + t2*z( j, k+1 )
                       z( j, k ) = z( j, k ) - sum
                       z( j, k+1 ) = z( j, k+1 ) - sum*conjg( v2 )
                    end do
                 end if
                 if( k==m .and. m>l ) then
                    ! if the qr step was started at row m > l because two
                    ! consecutive small subdiagonals were found, then extra
                    ! scaling must be performed to ensure that h(m,m-1) remains
                    ! real.
                    temp = cone - t1
                    temp = temp / abs( temp )
                    h( m+1, m ) = h( m+1, m )*conjg( temp )
                    if( m+2<=i )h( m+2, m+1 ) = h( m+2, m+1 )*temp
                    do j = m, i
                       if( j/=m+1 ) then
                          if( i2>j )call stdlib_zscal( i2-j, temp, h( j, j+1 ), ldh )
                          call stdlib_zscal( j-i1, conjg( temp ), h( i1, j ), 1 )
                          if( wantz ) then
                             call stdlib_zscal( nz, conjg( temp ), z( iloz, j ),1 )
                          end if
                       end if
                    end do
                 end if
              end do loop_120
              ! ensure that h(i,i-1) is real.
              temp = h( i, i-1 )
              if( aimag( temp )/=rzero ) then
                 rtemp = abs( temp )
                 h( i, i-1 ) = rtemp
                 temp = temp / rtemp
                 if( i2>i )call stdlib_zscal( i2-i, conjg( temp ), h( i, i+1 ), ldh )
                 call stdlib_zscal( i-i1, temp, h( i1, i ), 1 )
                 if( wantz ) then
                    call stdlib_zscal( nz, temp, z( iloz, i ), 1 )
                 end if
              end if
           end do loop_130
           ! failure to converge in remaining number of iterations
           info = i
           return
           140 continue
           ! h(i,i-1) is negligible: cone eigenvalue has converged.
           w( i ) = h( i, i )
           ! reset deflation counter
           kdefl = 0
           ! return to start of the main loop with new value of i.
           i = l - 1
           go to 30
           150 continue
           return
     end subroutine stdlib_zlahqr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$lahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, info &
     !! ZLAHQR: is an auxiliary routine called by CHSEQR to update the
     !! eigenvalues and Schur decomposition already computed by CHSEQR, by
     !! dealing with the Hessenberg submatrix in rows and columns ILO to
     !! IHI.
               )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(${ck}$), intent(out) :: w(*)
        ! =========================================================
           ! Parameters 
           real(${ck}$), parameter :: rzero = 0.0_${ck}$
           real(${ck}$), parameter :: rone = 1.0_${ck}$
           real(${ck}$), parameter :: dat1 = 3.0_${ck}$/4.0_${ck}$
           integer(ilp), parameter :: kexsh = 10
           
           
           
           
           ! Local Scalars 
           complex(${ck}$) :: cdum, h11, h11s, h22, sc, sum, t, t1, temp, u, v2, x, y
           real(${ck}$) :: aa, ab, ba, bb, h10, h21, rtemp, s, safmax, safmin, smlnum, sx, t2, tst, &
                     ulp
           integer(ilp) :: i, i1, i2, its, itmax, j, jhi, jlo, k, l, m, nh, nz, kdefl
           ! Local Arrays 
           complex(${ck}$) :: v(2)
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Intrinsic Functions 
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n==0 )return
           if( ilo==ihi ) then
              w( ilo ) = h( ilo, ilo )
              return
           end if
           ! ==== clear out the trash ====
           do j = ilo, ihi - 3
              h( j+2, j ) = czero
              h( j+3, j ) = czero
           end do
           if( ilo<=ihi-2 )h( ihi, ihi-2 ) = czero
           ! ==== ensure that subdiagonal entries are real ====
           if( wantt ) then
              jlo = 1
              jhi = n
           else
              jlo = ilo
              jhi = ihi
           end if
           do i = ilo + 1, ihi
              if( aimag( h( i, i-1 ) )/=rzero ) then
                 ! ==== the following redundant normalization
                 ! .    avoids problems with both gradual and
                 ! .    sudden underflow in abs(h(i,i-1)) ====
                 sc = h( i, i-1 ) / cabs1( h( i, i-1 ) )
                 sc = conjg( sc ) / abs( sc )
                 h( i, i-1 ) = abs( h( i, i-1 ) )
                 call stdlib_${ci}$scal( jhi-i+1, sc, h( i, i ), ldh )
                 call stdlib_${ci}$scal( min( jhi, i+1 )-jlo+1, conjg( sc ),h( jlo, i ), 1 )
                 if( wantz )call stdlib_${ci}$scal( ihiz-iloz+1, conjg( sc ), z( iloz, i ), 1 )
              end if
           end do
           nh = ihi - ilo + 1
           nz = ihiz - iloz + 1
           ! set machine-dependent constants for the stopping criterion.
           safmin = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_${c2ri(ci)}$labad( safmin, safmax )
           ulp = stdlib_${c2ri(ci)}$lamch( 'PRECISION' )
           smlnum = safmin*( real( nh,KIND=${ck}$) / ulp )
           ! i1 and i2 are the indices of the first row and last column of h
           ! to which transformations must be applied. if eigenvalues only are
           ! being computed, i1 and i2 are set inside the main loop.
           if( wantt ) then
              i1 = 1
              i2 = n
           end if
           ! itmax is the total number of qr iterations allowed.
           itmax = 30 * max( 10, nh )
           ! kdefl counts the number of iterations since a deflation
           kdefl = 0
           ! the main loop begins here. i is the loop index and decreases from
           ! ihi to ilo in steps of 1. each iteration of the loop works
           ! with the active submatrix in rows and columns l to i.
           ! eigenvalues i+1 to ihi have already converged. either l = ilo, or
           ! h(l,l-1) is negligible so that the matrix splits.
           i = ihi
           30 continue
           if( i<ilo )go to 150
           ! perform qr iterations on rows and columns ilo to i until a
           ! submatrix of order 1 splits off at the bottom because a
           ! subdiagonal element has become negligible.
           l = ilo
           loop_130: do its = 0, itmax
              ! look for a single small subdiagonal element.
              do k = i, l + 1, -1
                 if( cabs1( h( k, k-1 ) )<=smlnum )go to 50
                 tst = cabs1( h( k-1, k-1 ) ) + cabs1( h( k, k ) )
                 if( tst==czero ) then
                    if( k-2>=ilo )tst = tst + abs( real( h( k-1, k-2 ),KIND=${ck}$) )
                    if( k+1<=ihi )tst = tst + abs( real( h( k+1, k ),KIND=${ck}$) )
                 end if
                 ! ==== the following is a conservative small subdiagonal
                 ! .    deflation criterion due to ahues
                 ! .    1997). it has better mathematical foundation and
                 ! .    improves accuracy in some examples.  ====
                 if( abs( real( h( k, k-1 ),KIND=${ck}$) )<=ulp*tst ) then
                    ab = max( cabs1( h( k, k-1 ) ), cabs1( h( k-1, k ) ) )
                    ba = min( cabs1( h( k, k-1 ) ), cabs1( h( k-1, k ) ) )
                    aa = max( cabs1( h( k, k ) ),cabs1( h( k-1, k-1 )-h( k, k ) ) )
                    bb = min( cabs1( h( k, k ) ),cabs1( h( k-1, k-1 )-h( k, k ) ) )
                    s = aa + ab
                    if( ba*( ab / s )<=max( smlnum,ulp*( bb*( aa / s ) ) ) )go to 50
                 end if
              end do
              50 continue
              l = k
              if( l>ilo ) then
                 ! h(l,l-1) is negligible
                 h( l, l-1 ) = czero
              end if
              ! exit from loop if a submatrix of order 1 has split off.
              if( l>=i )go to 140
              kdefl = kdefl + 1
              ! now the active submatrix is in rows and columns l to i. if
              ! eigenvalues only are being computed, only the active submatrix
              ! need be transformed.
              if( .not.wantt ) then
                 i1 = l
                 i2 = i
              end if
              if( mod(kdefl,2*kexsh)==0 ) then
                 ! exceptional shift.
                 s = dat1*abs( real( h( i, i-1 ),KIND=${ck}$) )
                 t = s + h( i, i )
              else if( mod(kdefl,kexsh)==0 ) then
                 ! exceptional shift.
                 s = dat1*abs( real( h( l+1, l ),KIND=${ck}$) )
                 t = s + h( l, l )
              else
                 ! wilkinson's shift.
                 t = h( i, i )
                 u = sqrt( h( i-1, i ) )*sqrt( h( i, i-1 ) )
                 s = cabs1( u )
                 if( s/=rzero ) then
                    x = half*( h( i-1, i-1 )-t )
                    sx = cabs1( x )
                    s = max( s, cabs1( x ) )
                    y = s*sqrt( ( x / s )**2+( u / s )**2 )
                    if( sx>rzero ) then
                       if( real( x / sx,KIND=${ck}$)*real( y,KIND=${ck}$)+aimag( x / sx )*aimag( y )&
                                 <rzero )y = -y
                    end if
                    t = t - u*stdlib_${ci}$ladiv( u, ( x+y ) )
                 end if
              end if
              ! look for two consecutive small subdiagonal elements.
              do m = i - 1, l + 1, -1
                 ! determine the effect of starting the single-shift qr
                 ! iteration at row m, and see if this would make h(m,m-1)
                 ! negligible.
                 h11 = h( m, m )
                 h22 = h( m+1, m+1 )
                 h11s = h11 - t
                 h21 = real( h( m+1, m ),KIND=${ck}$)
                 s = cabs1( h11s ) + abs( h21 )
                 h11s = h11s / s
                 h21 = h21 / s
                 v( 1 ) = h11s
                 v( 2 ) = h21
                 h10 = real( h( m, m-1 ),KIND=${ck}$)
                 if( abs( h10 )*abs( h21 )<=ulp*( cabs1( h11s )*( cabs1( h11 )+cabs1( h22 ) ) ) )&
                           go to 70
              end do
              h11 = h( l, l )
              h22 = h( l+1, l+1 )
              h11s = h11 - t
              h21 = real( h( l+1, l ),KIND=${ck}$)
              s = cabs1( h11s ) + abs( h21 )
              h11s = h11s / s
              h21 = h21 / s
              v( 1 ) = h11s
              v( 2 ) = h21
              70 continue
              ! single-shift qr step
              loop_120: do k = m, i - 1
                 ! the first iteration of this loop determines a reflection g
                 ! from the vector v and applies it from left and right to h,
                 ! thus creating a nonzero bulge below the subdiagonal.
                 ! each subsequent iteration determines a reflection g to
                 ! restore the hessenberg form in the (k-1)th column, and thus
                 ! chases the bulge cone step toward the bottom of the active
                 ! submatrix.
                 ! v(2) is always real before the call to stdlib_${ci}$larfg, and hence
                 ! after the call t2 ( = t1*v(2) ) is also real.
                 if( k>m )call stdlib_${ci}$copy( 2, h( k, k-1 ), 1, v, 1 )
                 call stdlib_${ci}$larfg( 2, v( 1 ), v( 2 ), 1, t1 )
                 if( k>m ) then
                    h( k, k-1 ) = v( 1 )
                    h( k+1, k-1 ) = czero
                 end if
                 v2 = v( 2 )
                 t2 = real( t1*v2,KIND=${ck}$)
                 ! apply g from the left to transform the rows of the matrix
                 ! in columns k to i2.
                 do j = k, i2
                    sum = conjg( t1 )*h( k, j ) + t2*h( k+1, j )
                    h( k, j ) = h( k, j ) - sum
                    h( k+1, j ) = h( k+1, j ) - sum*v2
                 end do
                 ! apply g from the right to transform the columns of the
                 ! matrix in rows i1 to min(k+2,i).
                 do j = i1, min( k+2, i )
                    sum = t1*h( j, k ) + t2*h( j, k+1 )
                    h( j, k ) = h( j, k ) - sum
                    h( j, k+1 ) = h( j, k+1 ) - sum*conjg( v2 )
                 end do
                 if( wantz ) then
                    ! accumulate transformations in the matrix z
                    do j = iloz, ihiz
                       sum = t1*z( j, k ) + t2*z( j, k+1 )
                       z( j, k ) = z( j, k ) - sum
                       z( j, k+1 ) = z( j, k+1 ) - sum*conjg( v2 )
                    end do
                 end if
                 if( k==m .and. m>l ) then
                    ! if the qr step was started at row m > l because two
                    ! consecutive small subdiagonals were found, then extra
                    ! scaling must be performed to ensure that h(m,m-1) remains
                    ! real.
                    temp = cone - t1
                    temp = temp / abs( temp )
                    h( m+1, m ) = h( m+1, m )*conjg( temp )
                    if( m+2<=i )h( m+2, m+1 ) = h( m+2, m+1 )*temp
                    do j = m, i
                       if( j/=m+1 ) then
                          if( i2>j )call stdlib_${ci}$scal( i2-j, temp, h( j, j+1 ), ldh )
                          call stdlib_${ci}$scal( j-i1, conjg( temp ), h( i1, j ), 1 )
                          if( wantz ) then
                             call stdlib_${ci}$scal( nz, conjg( temp ), z( iloz, j ),1 )
                          end if
                       end if
                    end do
                 end if
              end do loop_120
              ! ensure that h(i,i-1) is real.
              temp = h( i, i-1 )
              if( aimag( temp )/=rzero ) then
                 rtemp = abs( temp )
                 h( i, i-1 ) = rtemp
                 temp = temp / rtemp
                 if( i2>i )call stdlib_${ci}$scal( i2-i, conjg( temp ), h( i, i+1 ), ldh )
                 call stdlib_${ci}$scal( i-i1, temp, h( i1, i ), 1 )
                 if( wantz ) then
                    call stdlib_${ci}$scal( nz, temp, z( iloz, i ), 1 )
                 end if
              end if
           end do loop_130
           ! failure to converge in remaining number of iterations
           info = i
           return
           140 continue
           ! h(i,i-1) is negligible: cone eigenvalue has converged.
           w( i ) = h( i, i )
           ! reset deflation counter
           kdefl = 0
           ! return to start of the main loop with new value of i.
           i = l - 1
           go to 30
           150 continue
           return
     end subroutine stdlib_${ci}$lahqr

#:endif
#:endfor



     module pure subroutine stdlib_sorghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! SORGHR generates a real orthogonal matrix Q which is defined as the
     !! product of IHI-ILO elementary reflectors of order N, as returned by
     !! SGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(in) :: tau(*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, iinfo, j, lwkopt, nb, nh
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, nh ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              nb = stdlib_ilaenv( 1, 'SORGQR', ' ', nh, nh, nh, -1 )
              lwkopt = max( 1, nh )*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SORGHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           ! shift the vectors which define the elementary reflectors one
           ! column to the right, and set the first ilo and the last n-ihi
           ! rows and columns to those of the unit matrix
           do j = ihi, ilo + 1, -1
              do i = 1, j - 1
                 a( i, j ) = zero
              end do
              do i = j + 1, ihi
                 a( i, j ) = a( i, j-1 )
              end do
              do i = ihi + 1, n
                 a( i, j ) = zero
              end do
           end do
           do j = 1, ilo
              do i = 1, n
                 a( i, j ) = zero
              end do
              a( j, j ) = one
           end do
           do j = ihi + 1, n
              do i = 1, n
                 a( i, j ) = zero
              end do
              a( j, j ) = one
           end do
           if( nh>0 ) then
              ! generate q(ilo+1:ihi,ilo+1:ihi)
              call stdlib_sorgqr( nh, nh, nh, a( ilo+1, ilo+1 ), lda, tau( ilo ),work, lwork, &
                        iinfo )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_sorghr

     module pure subroutine stdlib_dorghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! DORGHR generates a real orthogonal matrix Q which is defined as the
     !! product of IHI-ILO elementary reflectors of order N, as returned by
     !! DGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(in) :: tau(*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, iinfo, j, lwkopt, nb, nh
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, nh ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              nb = stdlib_ilaenv( 1, 'DORGQR', ' ', nh, nh, nh, -1 )
              lwkopt = max( 1, nh )*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORGHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           ! shift the vectors which define the elementary reflectors one
           ! column to the right, and set the first ilo and the last n-ihi
           ! rows and columns to those of the unit matrix
           do j = ihi, ilo + 1, -1
              do i = 1, j - 1
                 a( i, j ) = zero
              end do
              do i = j + 1, ihi
                 a( i, j ) = a( i, j-1 )
              end do
              do i = ihi + 1, n
                 a( i, j ) = zero
              end do
           end do
           do j = 1, ilo
              do i = 1, n
                 a( i, j ) = zero
              end do
              a( j, j ) = one
           end do
           do j = ihi + 1, n
              do i = 1, n
                 a( i, j ) = zero
              end do
              a( j, j ) = one
           end do
           if( nh>0 ) then
              ! generate q(ilo+1:ihi,ilo+1:ihi)
              call stdlib_dorgqr( nh, nh, nh, a( ilo+1, ilo+1 ), lda, tau( ilo ),work, lwork, &
                        iinfo )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dorghr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$orghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! DORGHR: generates a real orthogonal matrix Q which is defined as the
     !! product of IHI-ILO elementary reflectors of order N, as returned by
     !! DGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, iinfo, j, lwkopt, nb, nh
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, nh ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              nb = stdlib_ilaenv( 1, 'DORGQR', ' ', nh, nh, nh, -1 )
              lwkopt = max( 1, nh )*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORGHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           ! shift the vectors which define the elementary reflectors one
           ! column to the right, and set the first ilo and the last n-ihi
           ! rows and columns to those of the unit matrix
           do j = ihi, ilo + 1, -1
              do i = 1, j - 1
                 a( i, j ) = zero
              end do
              do i = j + 1, ihi
                 a( i, j ) = a( i, j-1 )
              end do
              do i = ihi + 1, n
                 a( i, j ) = zero
              end do
           end do
           do j = 1, ilo
              do i = 1, n
                 a( i, j ) = zero
              end do
              a( j, j ) = one
           end do
           do j = ihi + 1, n
              do i = 1, n
                 a( i, j ) = zero
              end do
              a( j, j ) = one
           end do
           if( nh>0 ) then
              ! generate q(ilo+1:ihi,ilo+1:ihi)
              call stdlib_${ri}$orgqr( nh, nh, nh, a( ilo+1, ilo+1 ), lda, tau( ilo ),work, lwork, &
                        iinfo )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$orghr

#:endif
#:endfor



     module subroutine stdlib_sggevx( balanc, jobvl, jobvr, sense, n, a, lda, b, ldb,alphar, alphai, &
     !! SGGEVX computes for a pair of N-by-N real nonsymmetric matrices (A,B)
     !! the generalized eigenvalues, and optionally, the left and/or right
     !! generalized eigenvectors.
     !! Optionally also, it computes a balancing transformation to improve
     !! the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
     !! LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
     !! the eigenvalues (RCONDE), and reciprocal condition numbers for the
     !! right eigenvectors (RCONDV).
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j) .
     !! The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! u(j)**H * A  = lambda(j) * u(j)**H * B.
     !! where u(j)**H is the conjugate-transpose of u(j).
     beta, vl, ldvl, vr, ldvr, ilo,ihi, lscale, rscale, abnrm, bbnrm, rconde,rcondv, work, lwork, &
               iwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(sp), intent(out) :: abnrm, bbnrm
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: alphai(*), alphar(*), beta(*), lscale(*), rconde(*), rcondv(*)&
                     , rscale(*), vl(ldvl,*), vr(ldvr,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery, noscl, pair, wantsb, wantse, &
                     wantsn, wantsv
           character :: chtemp
           integer(ilp) :: i, icols, ierr, ijobvl, ijobvr, in, irows, itau, iwrk, iwrk1, j, jc, &
                     jr, m, maxwrk, minwrk, mm
           real(sp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           noscl  = stdlib_lsame( balanc, 'N' ) .or. stdlib_lsame( balanc, 'P' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( .not.( noscl .or. stdlib_lsame( balanc, 'S' ) .or.stdlib_lsame( balanc, 'B' ) ) ) &
                     then
              info = -1
           else if( ijobvl<=0 ) then
              info = -2
           else if( ijobvr<=0 ) then
              info = -3
           else if( .not.( wantsn .or. wantse .or. wantsb .or. wantsv ) )then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -14
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -16
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv. the workspace is
             ! computed assuming ilo = 1 and ihi = n, the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 if( noscl .and. .not.ilv ) then
                    minwrk = 2*n
                 else
                    minwrk = 6*n
                 end if
                 if( wantse ) then
                    minwrk = 10*n
                 else if( wantsv .or. wantsb ) then
                    minwrk = 2*n*( n + 4 ) + 16
                 end if
                 maxwrk = minwrk
                 maxwrk = max( maxwrk,n + n*stdlib_ilaenv( 1, 'SGEQRF', ' ', n, 1, n, 0 ) )
                           
                 maxwrk = max( maxwrk,n + n*stdlib_ilaenv( 1, 'SORMQR', ' ', n, 1, n, 0 ) )
                           
                 if( ilvl ) then
                    maxwrk = max( maxwrk, n +n*stdlib_ilaenv( 1, 'SORGQR', ' ', n, 1, n, 0 ) )
                              
                 end if
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -26
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGGEVX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_slange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_slascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_slange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_slascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute and/or balance the matrix pair (a,b)
           ! (workspace: need 6*n if balanc = 's' or 'b', 1 otherwise)
           call stdlib_sggbal( balanc, n, a, lda, b, ldb, ilo, ihi, lscale, rscale,work, ierr )
                     
           ! compute abnrm and bbnrm
           abnrm = stdlib_slange( '1', n, n, a, lda, work( 1 ) )
           if( ilascl ) then
              work( 1 ) = abnrm
              call stdlib_slascl( 'G', 0, 0, anrmto, anrm, 1, 1, work( 1 ), 1,ierr )
              abnrm = work( 1 )
           end if
           bbnrm = stdlib_slange( '1', n, n, b, ldb, work( 1 ) )
           if( ilbscl ) then
              work( 1 ) = bbnrm
              call stdlib_slascl( 'G', 0, 0, bnrmto, bnrm, 1, 1, work( 1 ), 1,ierr )
              bbnrm = work( 1 )
           end if
           ! reduce b to triangular form (qr decomposition of b)
           ! (workspace: need n, prefer n*nb )
           irows = ihi + 1 - ilo
           if( ilv .or. .not.wantsn ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = 1
           iwrk = itau + irows
           call stdlib_sgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to a
           ! (workspace: need n, prefer n*nb)
           call stdlib_sormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl and/or vr
           ! (workspace: need n, prefer n*nb)
           if( ilvl ) then
              call stdlib_slaset( 'FULL', n, n, zero, one, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_slacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_sorgqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           if( ilvr )call stdlib_slaset( 'FULL', n, n, zero, one, vr, ldvr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           if( ilv .or. .not.wantsn ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_sgghrd( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        ierr )
           else
              call stdlib_sgghrd( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur forms and schur vectors)
           ! (workspace: need n)
           if( ilv .or. .not.wantsn ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_shgeqz( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vl, ldvl, vr, ldvr, work,lwork, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 130
           end if
           ! compute eigenvectors and estimate condition numbers if desired
           ! (workspace: stdlib_stgevc: need 6*n
                       ! stdlib_stgsna: need 2*n*(n+2)+16 if sense = 'v' or 'b',
                               ! need n otherwise )
           if( ilv .or. .not.wantsn ) then
              if( ilv ) then
                 if( ilvl ) then
                    if( ilvr ) then
                       chtemp = 'B'
                    else
                       chtemp = 'L'
                    end if
                 else
                    chtemp = 'R'
                 end if
                 call stdlib_stgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, n,&
                            in, work, ierr )
                 if( ierr/=0 ) then
                    info = n + 2
                    go to 130
                 end if
              end if
              if( .not.wantsn ) then
                 ! compute eigenvectors (stdlib_stgevc) and estimate condition
                 ! numbers (stdlib_stgsna). note that the definition of the condition
                 ! number is not invariant under transformation (u,v) to
                 ! (q*u, z*v), where (u,v) are eigenvectors of the generalized
                 ! schur form (s,t), q and z are orthogonal matrices. in order
                 ! to avoid using extra 2*n*n workspace, we have to recalculate
                 ! eigenvectors and estimate one condition numbers at a time.
                 pair = .false.
                 loop_20: do i = 1, n
                    if( pair ) then
                       pair = .false.
                       cycle loop_20
                    end if
                    mm = 1
                    if( i<n ) then
                       if( a( i+1, i )/=zero ) then
                          pair = .true.
                          mm = 2
                       end if
                    end if
                    do j = 1, n
                       bwork( j ) = .false.
                    end do
                    if( mm==1 ) then
                       bwork( i ) = .true.
                    else if( mm==2 ) then
                       bwork( i ) = .true.
                       bwork( i+1 ) = .true.
                    end if
                    iwrk = mm*n + 1
                    iwrk1 = iwrk + mm*n
                    ! compute a pair of left and right eigenvectors.
                    ! (compute workspace: need up to 4*n + 6*n)
                    if( wantse .or. wantsb ) then
                       call stdlib_stgevc( 'B', 'S', bwork, n, a, lda, b, ldb,work( 1 ), n, work( &
                                 iwrk ), n, mm, m,work( iwrk1 ), ierr )
                       if( ierr/=0 ) then
                          info = n + 2
                          go to 130
                       end if
                    end if
                    call stdlib_stgsna( sense, 'S', bwork, n, a, lda, b, ldb,work( 1 ), n, work( &
                    iwrk ), n, rconde( i ),rcondv( i ), mm, m, work( iwrk1 ),lwork-iwrk1+1, iwork,&
                               ierr )
                 end do loop_20
              end if
           end if
           ! undo balancing on vl and vr and normalization
           ! (workspace: none needed)
           if( ilvl ) then
              call stdlib_sggbak( balanc, 'L', n, ilo, ihi, lscale, rscale, n, vl,ldvl, ierr )
                        
              loop_70: do jc = 1, n
                 if( alphai( jc )<zero )cycle loop_70
                 temp = zero
                 if( alphai( jc )==zero ) then
                    do jr = 1, n
                       temp = max( temp, abs( vl( jr, jc ) ) )
                    end do
                 else
                    do jr = 1, n
                       temp = max( temp, abs( vl( jr, jc ) )+abs( vl( jr, jc+1 ) ) )
                    end do
                 end if
                 if( temp<smlnum )cycle loop_70
                 temp = one / temp
                 if( alphai( jc )==zero ) then
                    do jr = 1, n
                       vl( jr, jc ) = vl( jr, jc )*temp
                    end do
                 else
                    do jr = 1, n
                       vl( jr, jc ) = vl( jr, jc )*temp
                       vl( jr, jc+1 ) = vl( jr, jc+1 )*temp
                    end do
                 end if
              end do loop_70
           end if
           if( ilvr ) then
              call stdlib_sggbak( balanc, 'R', n, ilo, ihi, lscale, rscale, n, vr,ldvr, ierr )
                        
              loop_120: do jc = 1, n
                 if( alphai( jc )<zero )cycle loop_120
                 temp = zero
                 if( alphai( jc )==zero ) then
                    do jr = 1, n
                       temp = max( temp, abs( vr( jr, jc ) ) )
                    end do
                 else
                    do jr = 1, n
                       temp = max( temp, abs( vr( jr, jc ) )+abs( vr( jr, jc+1 ) ) )
                    end do
                 end if
                 if( temp<smlnum )cycle loop_120
                 temp = one / temp
                 if( alphai( jc )==zero ) then
                    do jr = 1, n
                       vr( jr, jc ) = vr( jr, jc )*temp
                    end do
                 else
                    do jr = 1, n
                       vr( jr, jc ) = vr( jr, jc )*temp
                       vr( jr, jc+1 ) = vr( jr, jc+1 )*temp
                    end do
                 end if
              end do loop_120
           end if
           ! undo scaling if necessary
           130 continue
           if( ilascl ) then
              call stdlib_slascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_slascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_slascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_sggevx

     module subroutine stdlib_dggevx( balanc, jobvl, jobvr, sense, n, a, lda, b, ldb,alphar, alphai, &
     !! DGGEVX computes for a pair of N-by-N real nonsymmetric matrices (A,B)
     !! the generalized eigenvalues, and optionally, the left and/or right
     !! generalized eigenvectors.
     !! Optionally also, it computes a balancing transformation to improve
     !! the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
     !! LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
     !! the eigenvalues (RCONDE), and reciprocal condition numbers for the
     !! right eigenvectors (RCONDV).
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j) .
     !! The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! u(j)**H * A  = lambda(j) * u(j)**H * B.
     !! where u(j)**H is the conjugate-transpose of u(j).
     beta, vl, ldvl, vr, ldvr, ilo,ihi, lscale, rscale, abnrm, bbnrm, rconde,rcondv, work, lwork, &
               iwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(dp), intent(out) :: abnrm, bbnrm
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: alphai(*), alphar(*), beta(*), lscale(*), rconde(*), rcondv(*)&
                     , rscale(*), vl(ldvl,*), vr(ldvr,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery, noscl, pair, wantsb, wantse, &
                     wantsn, wantsv
           character :: chtemp
           integer(ilp) :: i, icols, ierr, ijobvl, ijobvr, in, irows, itau, iwrk, iwrk1, j, jc, &
                     jr, m, maxwrk, minwrk, mm
           real(dp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           noscl  = stdlib_lsame( balanc, 'N' ) .or. stdlib_lsame( balanc, 'P' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( .not.( stdlib_lsame( balanc, 'N' ) .or. stdlib_lsame( balanc,'S' ) .or. &
                     stdlib_lsame( balanc, 'P' ) .or. stdlib_lsame( balanc, 'B' ) ) )then
              info = -1
           else if( ijobvl<=0 ) then
              info = -2
           else if( ijobvr<=0 ) then
              info = -3
           else if( .not.( wantsn .or. wantse .or. wantsb .or. wantsv ) )then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -14
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -16
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv. the workspace is
             ! computed assuming ilo = 1 and ihi = n, the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 if( noscl .and. .not.ilv ) then
                    minwrk = 2*n
                 else
                    minwrk = 6*n
                 end if
                 if( wantse .or. wantsb ) then
                    minwrk = 10*n
                 end if
                 if( wantsv .or. wantsb ) then
                    minwrk = max( minwrk, 2*n*( n + 4 ) + 16 )
                 end if
                 maxwrk = minwrk
                 maxwrk = max( maxwrk,n + n*stdlib_ilaenv( 1, 'DGEQRF', ' ', n, 1, n, 0 ) )
                           
                 maxwrk = max( maxwrk,n + n*stdlib_ilaenv( 1, 'DORMQR', ' ', n, 1, n, 0 ) )
                           
                 if( ilvl ) then
                    maxwrk = max( maxwrk, n +n*stdlib_ilaenv( 1, 'DORGQR', ' ', n, 1, n, 0 ) )
                              
                 end if
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -26
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGEVX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' )
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_dlange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_dlascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_dlange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_dlascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute and/or balance the matrix pair (a,b)
           ! (workspace: need 6*n if balanc = 's' or 'b', 1 otherwise)
           call stdlib_dggbal( balanc, n, a, lda, b, ldb, ilo, ihi, lscale, rscale,work, ierr )
                     
           ! compute abnrm and bbnrm
           abnrm = stdlib_dlange( '1', n, n, a, lda, work( 1 ) )
           if( ilascl ) then
              work( 1 ) = abnrm
              call stdlib_dlascl( 'G', 0, 0, anrmto, anrm, 1, 1, work( 1 ), 1,ierr )
              abnrm = work( 1 )
           end if
           bbnrm = stdlib_dlange( '1', n, n, b, ldb, work( 1 ) )
           if( ilbscl ) then
              work( 1 ) = bbnrm
              call stdlib_dlascl( 'G', 0, 0, bnrmto, bnrm, 1, 1, work( 1 ), 1,ierr )
              bbnrm = work( 1 )
           end if
           ! reduce b to triangular form (qr decomposition of b)
           ! (workspace: need n, prefer n*nb )
           irows = ihi + 1 - ilo
           if( ilv .or. .not.wantsn ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = 1
           iwrk = itau + irows
           call stdlib_dgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to a
           ! (workspace: need n, prefer n*nb)
           call stdlib_dormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl and/or vr
           ! (workspace: need n, prefer n*nb)
           if( ilvl ) then
              call stdlib_dlaset( 'FULL', n, n, zero, one, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_dlacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_dorgqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           if( ilvr )call stdlib_dlaset( 'FULL', n, n, zero, one, vr, ldvr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           if( ilv .or. .not.wantsn ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_dgghrd( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        ierr )
           else
              call stdlib_dgghrd( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur forms and schur vectors)
           ! (workspace: need n)
           if( ilv .or. .not.wantsn ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_dhgeqz( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vl, ldvl, vr, ldvr, work,lwork, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 130
           end if
           ! compute eigenvectors and estimate condition numbers if desired
           ! (workspace: stdlib_dtgevc: need 6*n
                       ! stdlib_dtgsna: need 2*n*(n+2)+16 if sense = 'v' or 'b',
                               ! need n otherwise )
           if( ilv .or. .not.wantsn ) then
              if( ilv ) then
                 if( ilvl ) then
                    if( ilvr ) then
                       chtemp = 'B'
                    else
                       chtemp = 'L'
                    end if
                 else
                    chtemp = 'R'
                 end if
                 call stdlib_dtgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, n,&
                            in, work, ierr )
                 if( ierr/=0 ) then
                    info = n + 2
                    go to 130
                 end if
              end if
              if( .not.wantsn ) then
                 ! compute eigenvectors (stdlib_dtgevc) and estimate condition
                 ! numbers (stdlib_dtgsna). note that the definition of the condition
                 ! number is not invariant under transformation (u,v) to
                 ! (q*u, z*v), where (u,v) are eigenvectors of the generalized
                 ! schur form (s,t), q and z are orthogonal matrices. in order
                 ! to avoid using extra 2*n*n workspace, we have to recalculate
                 ! eigenvectors and estimate one condition numbers at a time.
                 pair = .false.
                 loop_20: do i = 1, n
                    if( pair ) then
                       pair = .false.
                       cycle loop_20
                    end if
                    mm = 1
                    if( i<n ) then
                       if( a( i+1, i )/=zero ) then
                          pair = .true.
                          mm = 2
                       end if
                    end if
                    do j = 1, n
                       bwork( j ) = .false.
                    end do
                    if( mm==1 ) then
                       bwork( i ) = .true.
                    else if( mm==2 ) then
                       bwork( i ) = .true.
                       bwork( i+1 ) = .true.
                    end if
                    iwrk = mm*n + 1
                    iwrk1 = iwrk + mm*n
                    ! compute a pair of left and right eigenvectors.
                    ! (compute workspace: need up to 4*n + 6*n)
                    if( wantse .or. wantsb ) then
                       call stdlib_dtgevc( 'B', 'S', bwork, n, a, lda, b, ldb,work( 1 ), n, work( &
                                 iwrk ), n, mm, m,work( iwrk1 ), ierr )
                       if( ierr/=0 ) then
                          info = n + 2
                          go to 130
                       end if
                    end if
                    call stdlib_dtgsna( sense, 'S', bwork, n, a, lda, b, ldb,work( 1 ), n, work( &
                    iwrk ), n, rconde( i ),rcondv( i ), mm, m, work( iwrk1 ),lwork-iwrk1+1, iwork,&
                               ierr )
                 end do loop_20
              end if
           end if
           ! undo balancing on vl and vr and normalization
           ! (workspace: none needed)
           if( ilvl ) then
              call stdlib_dggbak( balanc, 'L', n, ilo, ihi, lscale, rscale, n, vl,ldvl, ierr )
                        
              loop_70: do jc = 1, n
                 if( alphai( jc )<zero )cycle loop_70
                 temp = zero
                 if( alphai( jc )==zero ) then
                    do jr = 1, n
                       temp = max( temp, abs( vl( jr, jc ) ) )
                    end do
                 else
                    do jr = 1, n
                       temp = max( temp, abs( vl( jr, jc ) )+abs( vl( jr, jc+1 ) ) )
                    end do
                 end if
                 if( temp<smlnum )cycle loop_70
                 temp = one / temp
                 if( alphai( jc )==zero ) then
                    do jr = 1, n
                       vl( jr, jc ) = vl( jr, jc )*temp
                    end do
                 else
                    do jr = 1, n
                       vl( jr, jc ) = vl( jr, jc )*temp
                       vl( jr, jc+1 ) = vl( jr, jc+1 )*temp
                    end do
                 end if
              end do loop_70
           end if
           if( ilvr ) then
              call stdlib_dggbak( balanc, 'R', n, ilo, ihi, lscale, rscale, n, vr,ldvr, ierr )
                        
              loop_120: do jc = 1, n
                 if( alphai( jc )<zero )cycle loop_120
                 temp = zero
                 if( alphai( jc )==zero ) then
                    do jr = 1, n
                       temp = max( temp, abs( vr( jr, jc ) ) )
                    end do
                 else
                    do jr = 1, n
                       temp = max( temp, abs( vr( jr, jc ) )+abs( vr( jr, jc+1 ) ) )
                    end do
                 end if
                 if( temp<smlnum )cycle loop_120
                 temp = one / temp
                 if( alphai( jc )==zero ) then
                    do jr = 1, n
                       vr( jr, jc ) = vr( jr, jc )*temp
                    end do
                 else
                    do jr = 1, n
                       vr( jr, jc ) = vr( jr, jc )*temp
                       vr( jr, jc+1 ) = vr( jr, jc+1 )*temp
                    end do
                 end if
              end do loop_120
           end if
           ! undo scaling if necessary
           130 continue
           if( ilascl ) then
              call stdlib_dlascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_dlascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_dlascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_dggevx

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$ggevx( balanc, jobvl, jobvr, sense, n, a, lda, b, ldb,alphar, alphai, &
     !! DGGEVX: computes for a pair of N-by-N real nonsymmetric matrices (A,B)
     !! the generalized eigenvalues, and optionally, the left and/or right
     !! generalized eigenvectors.
     !! Optionally also, it computes a balancing transformation to improve
     !! the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
     !! LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
     !! the eigenvalues (RCONDE), and reciprocal condition numbers for the
     !! right eigenvectors (RCONDV).
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j) .
     !! The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! u(j)**H * A  = lambda(j) * u(j)**H * B.
     !! where u(j)**H is the conjugate-transpose of u(j).
     beta, vl, ldvl, vr, ldvr, ilo,ihi, lscale, rscale, abnrm, bbnrm, rconde,rcondv, work, lwork, &
               iwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(${rk}$), intent(out) :: abnrm, bbnrm
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), lscale(*), rconde(*), rcondv(*)&
                     , rscale(*), vl(ldvl,*), vr(ldvr,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery, noscl, pair, wantsb, wantse, &
                     wantsn, wantsv
           character :: chtemp
           integer(ilp) :: i, icols, ierr, ijobvl, ijobvr, in, irows, itau, iwrk, iwrk1, j, jc, &
                     jr, m, maxwrk, minwrk, mm
           real(${rk}$) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           noscl  = stdlib_lsame( balanc, 'N' ) .or. stdlib_lsame( balanc, 'P' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( .not.( stdlib_lsame( balanc, 'N' ) .or. stdlib_lsame( balanc,'S' ) .or. &
                     stdlib_lsame( balanc, 'P' ) .or. stdlib_lsame( balanc, 'B' ) ) )then
              info = -1
           else if( ijobvl<=0 ) then
              info = -2
           else if( ijobvr<=0 ) then
              info = -3
           else if( .not.( wantsn .or. wantse .or. wantsb .or. wantsv ) )then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -14
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -16
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv. the workspace is
             ! computed assuming ilo = 1 and ihi = n, the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 if( noscl .and. .not.ilv ) then
                    minwrk = 2*n
                 else
                    minwrk = 6*n
                 end if
                 if( wantse .or. wantsb ) then
                    minwrk = 10*n
                 end if
                 if( wantsv .or. wantsb ) then
                    minwrk = max( minwrk, 2*n*( n + 4 ) + 16 )
                 end if
                 maxwrk = minwrk
                 maxwrk = max( maxwrk,n + n*stdlib_ilaenv( 1, 'DGEQRF', ' ', n, 1, n, 0 ) )
                           
                 maxwrk = max( maxwrk,n + n*stdlib_ilaenv( 1, 'DORMQR', ' ', n, 1, n, 0 ) )
                           
                 if( ilvl ) then
                    maxwrk = max( maxwrk, n +n*stdlib_ilaenv( 1, 'DORGQR', ' ', n, 1, n, 0 ) )
                              
                 end if
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -26
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGEVX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_${ri}$lascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_${ri}$lange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_${ri}$lascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute and/or balance the matrix pair (a,b)
           ! (workspace: need 6*n if balanc = 's' or 'b', 1 otherwise)
           call stdlib_${ri}$ggbal( balanc, n, a, lda, b, ldb, ilo, ihi, lscale, rscale,work, ierr )
                     
           ! compute abnrm and bbnrm
           abnrm = stdlib_${ri}$lange( '1', n, n, a, lda, work( 1 ) )
           if( ilascl ) then
              work( 1 ) = abnrm
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, 1, 1, work( 1 ), 1,ierr )
              abnrm = work( 1 )
           end if
           bbnrm = stdlib_${ri}$lange( '1', n, n, b, ldb, work( 1 ) )
           if( ilbscl ) then
              work( 1 ) = bbnrm
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrmto, bnrm, 1, 1, work( 1 ), 1,ierr )
              bbnrm = work( 1 )
           end if
           ! reduce b to triangular form (qr decomposition of b)
           ! (workspace: need n, prefer n*nb )
           irows = ihi + 1 - ilo
           if( ilv .or. .not.wantsn ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = 1
           iwrk = itau + irows
           call stdlib_${ri}$geqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to a
           ! (workspace: need n, prefer n*nb)
           call stdlib_${ri}$ormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl and/or vr
           ! (workspace: need n, prefer n*nb)
           if( ilvl ) then
              call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_${ri}$lacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_${ri}$orgqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           if( ilvr )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vr, ldvr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           if( ilv .or. .not.wantsn ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_${ri}$gghrd( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        ierr )
           else
              call stdlib_${ri}$gghrd( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur forms and schur vectors)
           ! (workspace: need n)
           if( ilv .or. .not.wantsn ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_${ri}$hgeqz( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vl, ldvl, vr, ldvr, work,lwork, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 130
           end if
           ! compute eigenvectors and estimate condition numbers if desired
           ! (workspace: stdlib_${ri}$tgevc: need 6*n
                       ! stdlib_${ri}$tgsna: need 2*n*(n+2)+16 if sense = 'v' or 'b',
                               ! need n otherwise )
           if( ilv .or. .not.wantsn ) then
              if( ilv ) then
                 if( ilvl ) then
                    if( ilvr ) then
                       chtemp = 'B'
                    else
                       chtemp = 'L'
                    end if
                 else
                    chtemp = 'R'
                 end if
                 call stdlib_${ri}$tgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, n,&
                            in, work, ierr )
                 if( ierr/=0 ) then
                    info = n + 2
                    go to 130
                 end if
              end if
              if( .not.wantsn ) then
                 ! compute eigenvectors (stdlib_${ri}$tgevc) and estimate condition
                 ! numbers (stdlib_${ri}$tgsna). note that the definition of the condition
                 ! number is not invariant under transformation (u,v) to
                 ! (q*u, z*v), where (u,v) are eigenvectors of the generalized
                 ! schur form (s,t), q and z are orthogonal matrices. in order
                 ! to avoid using extra 2*n*n workspace, we have to recalculate
                 ! eigenvectors and estimate one condition numbers at a time.
                 pair = .false.
                 loop_20: do i = 1, n
                    if( pair ) then
                       pair = .false.
                       cycle loop_20
                    end if
                    mm = 1
                    if( i<n ) then
                       if( a( i+1, i )/=zero ) then
                          pair = .true.
                          mm = 2
                       end if
                    end if
                    do j = 1, n
                       bwork( j ) = .false.
                    end do
                    if( mm==1 ) then
                       bwork( i ) = .true.
                    else if( mm==2 ) then
                       bwork( i ) = .true.
                       bwork( i+1 ) = .true.
                    end if
                    iwrk = mm*n + 1
                    iwrk1 = iwrk + mm*n
                    ! compute a pair of left and right eigenvectors.
                    ! (compute workspace: need up to 4*n + 6*n)
                    if( wantse .or. wantsb ) then
                       call stdlib_${ri}$tgevc( 'B', 'S', bwork, n, a, lda, b, ldb,work( 1 ), n, work( &
                                 iwrk ), n, mm, m,work( iwrk1 ), ierr )
                       if( ierr/=0 ) then
                          info = n + 2
                          go to 130
                       end if
                    end if
                    call stdlib_${ri}$tgsna( sense, 'S', bwork, n, a, lda, b, ldb,work( 1 ), n, work( &
                    iwrk ), n, rconde( i ),rcondv( i ), mm, m, work( iwrk1 ),lwork-iwrk1+1, iwork,&
                               ierr )
                 end do loop_20
              end if
           end if
           ! undo balancing on vl and vr and normalization
           ! (workspace: none needed)
           if( ilvl ) then
              call stdlib_${ri}$ggbak( balanc, 'L', n, ilo, ihi, lscale, rscale, n, vl,ldvl, ierr )
                        
              loop_70: do jc = 1, n
                 if( alphai( jc )<zero )cycle loop_70
                 temp = zero
                 if( alphai( jc )==zero ) then
                    do jr = 1, n
                       temp = max( temp, abs( vl( jr, jc ) ) )
                    end do
                 else
                    do jr = 1, n
                       temp = max( temp, abs( vl( jr, jc ) )+abs( vl( jr, jc+1 ) ) )
                    end do
                 end if
                 if( temp<smlnum )cycle loop_70
                 temp = one / temp
                 if( alphai( jc )==zero ) then
                    do jr = 1, n
                       vl( jr, jc ) = vl( jr, jc )*temp
                    end do
                 else
                    do jr = 1, n
                       vl( jr, jc ) = vl( jr, jc )*temp
                       vl( jr, jc+1 ) = vl( jr, jc+1 )*temp
                    end do
                 end if
              end do loop_70
           end if
           if( ilvr ) then
              call stdlib_${ri}$ggbak( balanc, 'R', n, ilo, ihi, lscale, rscale, n, vr,ldvr, ierr )
                        
              loop_120: do jc = 1, n
                 if( alphai( jc )<zero )cycle loop_120
                 temp = zero
                 if( alphai( jc )==zero ) then
                    do jr = 1, n
                       temp = max( temp, abs( vr( jr, jc ) ) )
                    end do
                 else
                    do jr = 1, n
                       temp = max( temp, abs( vr( jr, jc ) )+abs( vr( jr, jc+1 ) ) )
                    end do
                 end if
                 if( temp<smlnum )cycle loop_120
                 temp = one / temp
                 if( alphai( jc )==zero ) then
                    do jr = 1, n
                       vr( jr, jc ) = vr( jr, jc )*temp
                    end do
                 else
                    do jr = 1, n
                       vr( jr, jc ) = vr( jr, jc )*temp
                       vr( jr, jc+1 ) = vr( jr, jc+1 )*temp
                    end do
                 end if
              end do loop_120
           end if
           ! undo scaling if necessary
           130 continue
           if( ilascl ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_${ri}$ggevx

#:endif
#:endfor

     module subroutine stdlib_cggevx( balanc, jobvl, jobvr, sense, n, a, lda, b, ldb,alpha, beta, vl, &
     !! CGGEVX computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B) the generalized eigenvalues, and optionally, the left and/or
     !! right generalized eigenvectors.
     !! Optionally, it also computes a balancing transformation to improve
     !! the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
     !! LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
     !! the eigenvalues (RCONDE), and reciprocal condition numbers for the
     !! right eigenvectors (RCONDV).
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j) .
     !! The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! u(j)**H * A  = lambda(j) * u(j)**H * B.
     !! where u(j)**H is the conjugate-transpose of u(j).
     ldvl, vr, ldvr, ilo, ihi,lscale, rscale, abnrm, bbnrm, rconde, rcondv,work, lwork, rwork, &
               iwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(sp), intent(out) :: abnrm, bbnrm
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(out) :: lscale(*), rconde(*), rcondv(*), rscale(*), rwork(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: alpha(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery, noscl, wantsb, wantse, wantsn, &
                     wantsv
           character :: chtemp
           integer(ilp) :: i, icols, ierr, ijobvl, ijobvr, in, irows, itau, iwrk, iwrk1, j, jc, &
                     jr, m, maxwrk, minwrk
           real(sp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           complex(sp) :: x
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=sp) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           noscl  = stdlib_lsame( balanc, 'N' ) .or. stdlib_lsame( balanc, 'P' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( .not.( noscl .or. stdlib_lsame( balanc,'S' ) .or.stdlib_lsame( balanc, 'B' ) ) ) &
                     then
              info = -1
           else if( ijobvl<=0 ) then
              info = -2
           else if( ijobvr<=0 ) then
              info = -3
           else if( .not.( wantsn .or. wantse .or. wantsb .or. wantsv ) )then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -13
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -15
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv. the workspace is
             ! computed assuming ilo = 1 and ihi = n, the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 minwrk = 2*n
                 if( wantse ) then
                    minwrk = 4*n
                 else if( wantsv .or. wantsb ) then
                    minwrk = 2*n*( n + 1)
                 end if
                 maxwrk = minwrk
                 maxwrk = max( maxwrk,n + n*stdlib_ilaenv( 1, 'CGEQRF', ' ', n, 1, n, 0 ) )
                           
                 maxwrk = max( maxwrk,n + n*stdlib_ilaenv( 1, 'CUNMQR', ' ', n, 1, n, 0 ) )
                           
                 if( ilvl ) then
                    maxwrk = max( maxwrk, n +n*stdlib_ilaenv( 1, 'CUNGQR', ' ', n, 1, n, 0 ) )
                              
                 end if
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -25
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGEVX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_clascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_clange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute and/or balance the matrix pair (a,b)
           ! (real workspace: need 6*n if balanc = 's' or 'b', 1 otherwise)
           call stdlib_cggbal( balanc, n, a, lda, b, ldb, ilo, ihi, lscale, rscale,rwork, ierr )
                     
           ! compute abnrm and bbnrm
           abnrm = stdlib_clange( '1', n, n, a, lda, rwork( 1 ) )
           if( ilascl ) then
              rwork( 1 ) = abnrm
              call stdlib_slascl( 'G', 0, 0, anrmto, anrm, 1, 1, rwork( 1 ), 1,ierr )
              abnrm = rwork( 1 )
           end if
           bbnrm = stdlib_clange( '1', n, n, b, ldb, rwork( 1 ) )
           if( ilbscl ) then
              rwork( 1 ) = bbnrm
              call stdlib_slascl( 'G', 0, 0, bnrmto, bnrm, 1, 1, rwork( 1 ), 1,ierr )
              bbnrm = rwork( 1 )
           end if
           ! reduce b to triangular form (qr decomposition of b)
           ! (complex workspace: need n, prefer n*nb )
           irows = ihi + 1 - ilo
           if( ilv .or. .not.wantsn ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = 1
           iwrk = itau + irows
           call stdlib_cgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the unitary transformation to a
           ! (complex workspace: need n, prefer n*nb)
           call stdlib_cunmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl and/or vr
           ! (workspace: need n, prefer n*nb)
           if( ilvl ) then
              call stdlib_claset( 'FULL', n, n, czero, cone, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_clacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_cungqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           if( ilvr )call stdlib_claset( 'FULL', n, n, czero, cone, vr, ldvr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           if( ilv .or. .not.wantsn ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_cgghrd( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        ierr )
           else
              call stdlib_cgghrd( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur forms and schur vectors)
           ! (complex workspace: need n)
           ! (real workspace: need n)
           iwrk = itau
           if( ilv .or. .not.wantsn ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_chgeqz( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vl, &
                     ldvl, vr, ldvr, work( iwrk ),lwork+1-iwrk, rwork, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 90
           end if
           ! compute eigenvectors and estimate condition numbers if desired
           ! stdlib_ctgevc: (complex workspace: need 2*n )
                   ! (real workspace:    need 2*n )
           ! stdlib_ctgsna: (complex workspace: need 2*n*n if sense='v' or 'b')
                   ! (integer workspace: need n+2 )
           if( ilv .or. .not.wantsn ) then
              if( ilv ) then
                 if( ilvl ) then
                    if( ilvr ) then
                       chtemp = 'B'
                    else
                       chtemp = 'L'
                    end if
                 else
                    chtemp = 'R'
                 end if
                 call stdlib_ctgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, n,&
                            in, work( iwrk ), rwork,ierr )
                 if( ierr/=0 ) then
                    info = n + 2
                    go to 90
                 end if
              end if
              if( .not.wantsn ) then
                 ! compute eigenvectors (stdlib_ctgevc) and estimate condition
                 ! numbers (stdlib_ctgsna). note that the definition of the condition
                 ! number is not invariant under transformation (u,v) to
                 ! (q*u, z*v), where (u,v) are eigenvectors of the generalized
                 ! schur form (s,t), q and z are orthogonal matrices. in order
                 ! to avoid using extra 2*n*n workspace, we have to
                 ! re-calculate eigenvectors and estimate the condition numbers
                 ! one at a time.
                 do i = 1, n
                    do j = 1, n
                       bwork( j ) = .false.
                    end do
                    bwork( i ) = .true.
                    iwrk = n + 1
                    iwrk1 = iwrk + n
                    if( wantse .or. wantsb ) then
                       call stdlib_ctgevc( 'B', 'S', bwork, n, a, lda, b, ldb,work( 1 ), n, work( &
                                 iwrk ), n, 1, m,work( iwrk1 ), rwork, ierr )
                       if( ierr/=0 ) then
                          info = n + 2
                          go to 90
                       end if
                    end if
                    call stdlib_ctgsna( sense, 'S', bwork, n, a, lda, b, ldb,work( 1 ), n, work( &
                    iwrk ), n, rconde( i ),rcondv( i ), 1, m, work( iwrk1 ),lwork-iwrk1+1, iwork, &
                              ierr )
                 end do
              end if
           end if
           ! undo balancing on vl and vr and normalization
           ! (workspace: none needed)
           if( ilvl ) then
              call stdlib_cggbak( balanc, 'L', n, ilo, ihi, lscale, rscale, n, vl,ldvl, ierr )
                        
              loop_50: do jc = 1, n
                 temp = zero
                 do jr = 1, n
                    temp = max( temp, abs1( vl( jr, jc ) ) )
                 end do
                 if( temp<smlnum )cycle loop_50
                 temp = one / temp
                 do jr = 1, n
                    vl( jr, jc ) = vl( jr, jc )*temp
                 end do
              end do loop_50
           end if
           if( ilvr ) then
              call stdlib_cggbak( balanc, 'R', n, ilo, ihi, lscale, rscale, n, vr,ldvr, ierr )
                        
              loop_80: do jc = 1, n
                 temp = zero
                 do jr = 1, n
                    temp = max( temp, abs1( vr( jr, jc ) ) )
                 end do
                 if( temp<smlnum )cycle loop_80
                 temp = one / temp
                 do jr = 1, n
                    vr( jr, jc ) = vr( jr, jc )*temp
                 end do
              end do loop_80
           end if
           ! undo scaling if necessary
           90 continue
           if( ilascl )call stdlib_clascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_cggevx

     module subroutine stdlib_zggevx( balanc, jobvl, jobvr, sense, n, a, lda, b, ldb,alpha, beta, vl, &
     !! ZGGEVX computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B) the generalized eigenvalues, and optionally, the left and/or
     !! right generalized eigenvectors.
     !! Optionally, it also computes a balancing transformation to improve
     !! the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
     !! LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
     !! the eigenvalues (RCONDE), and reciprocal condition numbers for the
     !! right eigenvectors (RCONDV).
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j) .
     !! The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! u(j)**H * A  = lambda(j) * u(j)**H * B.
     !! where u(j)**H is the conjugate-transpose of u(j).
     ldvl, vr, ldvr, ilo, ihi,lscale, rscale, abnrm, bbnrm, rconde, rcondv,work, lwork, rwork, &
               iwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(dp), intent(out) :: abnrm, bbnrm
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(out) :: lscale(*), rconde(*), rcondv(*), rscale(*), rwork(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: alpha(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery, noscl, wantsb, wantse, wantsn, &
                     wantsv
           character :: chtemp
           integer(ilp) :: i, icols, ierr, ijobvl, ijobvr, in, irows, itau, iwrk, iwrk1, j, jc, &
                     jr, m, maxwrk, minwrk
           real(dp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           complex(dp) :: x
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=dp) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           noscl  = stdlib_lsame( balanc, 'N' ) .or. stdlib_lsame( balanc, 'P' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( .not.( noscl .or. stdlib_lsame( balanc,'S' ) .or.stdlib_lsame( balanc, 'B' ) ) ) &
                     then
              info = -1
           else if( ijobvl<=0 ) then
              info = -2
           else if( ijobvr<=0 ) then
              info = -3
           else if( .not.( wantsn .or. wantse .or. wantsb .or. wantsv ) )then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -13
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -15
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv. the workspace is
             ! computed assuming ilo = 1 and ihi = n, the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 minwrk = 2*n
                 if( wantse ) then
                    minwrk = 4*n
                 else if( wantsv .or. wantsb ) then
                    minwrk = 2*n*( n + 1)
                 end if
                 maxwrk = minwrk
                 maxwrk = max( maxwrk,n + n*stdlib_ilaenv( 1, 'ZGEQRF', ' ', n, 1, n, 0 ) )
                           
                 maxwrk = max( maxwrk,n + n*stdlib_ilaenv( 1, 'ZUNMQR', ' ', n, 1, n, 0 ) )
                           
                 if( ilvl ) then
                    maxwrk = max( maxwrk, n +n*stdlib_ilaenv( 1, 'ZUNGQR', ' ', n, 1, n, 0 ) )
                              
                 end if
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -25
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGEVX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' )
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_zlange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_zlascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_zlange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_zlascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute and/or balance the matrix pair (a,b)
           ! (real workspace: need 6*n if balanc = 's' or 'b', 1 otherwise)
           call stdlib_zggbal( balanc, n, a, lda, b, ldb, ilo, ihi, lscale, rscale,rwork, ierr )
                     
           ! compute abnrm and bbnrm
           abnrm = stdlib_zlange( '1', n, n, a, lda, rwork( 1 ) )
           if( ilascl ) then
              rwork( 1 ) = abnrm
              call stdlib_dlascl( 'G', 0, 0, anrmto, anrm, 1, 1, rwork( 1 ), 1,ierr )
              abnrm = rwork( 1 )
           end if
           bbnrm = stdlib_zlange( '1', n, n, b, ldb, rwork( 1 ) )
           if( ilbscl ) then
              rwork( 1 ) = bbnrm
              call stdlib_dlascl( 'G', 0, 0, bnrmto, bnrm, 1, 1, rwork( 1 ), 1,ierr )
              bbnrm = rwork( 1 )
           end if
           ! reduce b to triangular form (qr decomposition of b)
           ! (complex workspace: need n, prefer n*nb )
           irows = ihi + 1 - ilo
           if( ilv .or. .not.wantsn ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = 1
           iwrk = itau + irows
           call stdlib_zgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the unitary transformation to a
           ! (complex workspace: need n, prefer n*nb)
           call stdlib_zunmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl and/or vr
           ! (workspace: need n, prefer n*nb)
           if( ilvl ) then
              call stdlib_zlaset( 'FULL', n, n, czero, cone, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_zlacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_zungqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           if( ilvr )call stdlib_zlaset( 'FULL', n, n, czero, cone, vr, ldvr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           if( ilv .or. .not.wantsn ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_zgghrd( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        ierr )
           else
              call stdlib_zgghrd( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur forms and schur vectors)
           ! (complex workspace: need n)
           ! (real workspace: need n)
           iwrk = itau
           if( ilv .or. .not.wantsn ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_zhgeqz( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vl, &
                     ldvl, vr, ldvr, work( iwrk ),lwork+1-iwrk, rwork, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 90
           end if
           ! compute eigenvectors and estimate condition numbers if desired
           ! stdlib_ztgevc: (complex workspace: need 2*n )
                   ! (real workspace:    need 2*n )
           ! stdlib_ztgsna: (complex workspace: need 2*n*n if sense='v' or 'b')
                   ! (integer workspace: need n+2 )
           if( ilv .or. .not.wantsn ) then
              if( ilv ) then
                 if( ilvl ) then
                    if( ilvr ) then
                       chtemp = 'B'
                    else
                       chtemp = 'L'
                    end if
                 else
                    chtemp = 'R'
                 end if
                 call stdlib_ztgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, n,&
                            in, work( iwrk ), rwork,ierr )
                 if( ierr/=0 ) then
                    info = n + 2
                    go to 90
                 end if
              end if
              if( .not.wantsn ) then
                 ! compute eigenvectors (stdlib_ztgevc) and estimate condition
                 ! numbers (stdlib_ztgsna). note that the definition of the condition
                 ! number is not invariant under transformation (u,v) to
                 ! (q*u, z*v), where (u,v) are eigenvectors of the generalized
                 ! schur form (s,t), q and z are orthogonal matrices. in order
                 ! to avoid using extra 2*n*n workspace, we have to
                 ! re-calculate eigenvectors and estimate the condition numbers
                 ! one at a time.
                 do i = 1, n
                    do j = 1, n
                       bwork( j ) = .false.
                    end do
                    bwork( i ) = .true.
                    iwrk = n + 1
                    iwrk1 = iwrk + n
                    if( wantse .or. wantsb ) then
                       call stdlib_ztgevc( 'B', 'S', bwork, n, a, lda, b, ldb,work( 1 ), n, work( &
                                 iwrk ), n, 1, m,work( iwrk1 ), rwork, ierr )
                       if( ierr/=0 ) then
                          info = n + 2
                          go to 90
                       end if
                    end if
                    call stdlib_ztgsna( sense, 'S', bwork, n, a, lda, b, ldb,work( 1 ), n, work( &
                    iwrk ), n, rconde( i ),rcondv( i ), 1, m, work( iwrk1 ),lwork-iwrk1+1, iwork, &
                              ierr )
                 end do
              end if
           end if
           ! undo balancing on vl and vr and normalization
           ! (workspace: none needed)
           if( ilvl ) then
              call stdlib_zggbak( balanc, 'L', n, ilo, ihi, lscale, rscale, n, vl,ldvl, ierr )
                        
              loop_50: do jc = 1, n
                 temp = zero
                 do jr = 1, n
                    temp = max( temp, abs1( vl( jr, jc ) ) )
                 end do
                 if( temp<smlnum )cycle loop_50
                 temp = one / temp
                 do jr = 1, n
                    vl( jr, jc ) = vl( jr, jc )*temp
                 end do
              end do loop_50
           end if
           if( ilvr ) then
              call stdlib_zggbak( balanc, 'R', n, ilo, ihi, lscale, rscale, n, vr,ldvr, ierr )
                        
              loop_80: do jc = 1, n
                 temp = zero
                 do jr = 1, n
                    temp = max( temp, abs1( vr( jr, jc ) ) )
                 end do
                 if( temp<smlnum )cycle loop_80
                 temp = one / temp
                 do jr = 1, n
                    vr( jr, jc ) = vr( jr, jc )*temp
                 end do
              end do loop_80
           end if
           ! undo scaling if necessary
           90 continue
           if( ilascl )call stdlib_zlascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           if( ilbscl )call stdlib_zlascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_zggevx

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$ggevx( balanc, jobvl, jobvr, sense, n, a, lda, b, ldb,alpha, beta, vl, &
     !! ZGGEVX: computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B) the generalized eigenvalues, and optionally, the left and/or
     !! right generalized eigenvectors.
     !! Optionally, it also computes a balancing transformation to improve
     !! the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
     !! LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
     !! the eigenvalues (RCONDE), and reciprocal condition numbers for the
     !! right eigenvectors (RCONDV).
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j) .
     !! The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! u(j)**H * A  = lambda(j) * u(j)**H * B.
     !! where u(j)**H is the conjugate-transpose of u(j).
     ldvl, vr, ldvr, ilo, ihi,lscale, rscale, abnrm, bbnrm, rconde, rcondv,work, lwork, rwork, &
               iwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           real(${ck}$), intent(out) :: abnrm, bbnrm
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${ck}$), intent(out) :: lscale(*), rconde(*), rcondv(*), rscale(*), rwork(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: alpha(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery, noscl, wantsb, wantse, wantsn, &
                     wantsv
           character :: chtemp
           integer(ilp) :: i, icols, ierr, ijobvl, ijobvr, in, irows, itau, iwrk, iwrk1, j, jc, &
                     jr, m, maxwrk, minwrk
           real(${ck}$) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           complex(${ck}$) :: x
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=${ck}$) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           noscl  = stdlib_lsame( balanc, 'N' ) .or. stdlib_lsame( balanc, 'P' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( .not.( noscl .or. stdlib_lsame( balanc,'S' ) .or.stdlib_lsame( balanc, 'B' ) ) ) &
                     then
              info = -1
           else if( ijobvl<=0 ) then
              info = -2
           else if( ijobvr<=0 ) then
              info = -3
           else if( .not.( wantsn .or. wantse .or. wantsb .or. wantsv ) )then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -13
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -15
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv. the workspace is
             ! computed assuming ilo = 1 and ihi = n, the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 minwrk = 2*n
                 if( wantse ) then
                    minwrk = 4*n
                 else if( wantsv .or. wantsb ) then
                    minwrk = 2*n*( n + 1)
                 end if
                 maxwrk = minwrk
                 maxwrk = max( maxwrk,n + n*stdlib_ilaenv( 1, 'ZGEQRF', ' ', n, 1, n, 0 ) )
                           
                 maxwrk = max( maxwrk,n + n*stdlib_ilaenv( 1, 'ZUNMQR', ' ', n, 1, n, 0 ) )
                           
                 if( ilvl ) then
                    maxwrk = max( maxwrk, n +n*stdlib_ilaenv( 1, 'ZUNGQR', ' ', n, 1, n, 0 ) )
                              
                 end if
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -25
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGEVX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_${c2ri(ci)}$lamch( 'P' )
           smlnum = stdlib_${c2ri(ci)}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${c2ri(ci)}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ci}$lange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_${ci}$lascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_${ci}$lange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_${ci}$lascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute and/or balance the matrix pair (a,b)
           ! (real workspace: need 6*n if balanc = 's' or 'b', 1 otherwise)
           call stdlib_${ci}$ggbal( balanc, n, a, lda, b, ldb, ilo, ihi, lscale, rscale,rwork, ierr )
                     
           ! compute abnrm and bbnrm
           abnrm = stdlib_${ci}$lange( '1', n, n, a, lda, rwork( 1 ) )
           if( ilascl ) then
              rwork( 1 ) = abnrm
              call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, anrmto, anrm, 1, 1, rwork( 1 ), 1,ierr )
              abnrm = rwork( 1 )
           end if
           bbnrm = stdlib_${ci}$lange( '1', n, n, b, ldb, rwork( 1 ) )
           if( ilbscl ) then
              rwork( 1 ) = bbnrm
              call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, bnrmto, bnrm, 1, 1, rwork( 1 ), 1,ierr )
              bbnrm = rwork( 1 )
           end if
           ! reduce b to triangular form (qr decomposition of b)
           ! (complex workspace: need n, prefer n*nb )
           irows = ihi + 1 - ilo
           if( ilv .or. .not.wantsn ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = 1
           iwrk = itau + irows
           call stdlib_${ci}$geqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the unitary transformation to a
           ! (complex workspace: need n, prefer n*nb)
           call stdlib_${ci}$unmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl and/or vr
           ! (workspace: need n, prefer n*nb)
           if( ilvl ) then
              call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_${ci}$lacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_${ci}$ungqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           if( ilvr )call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, vr, ldvr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           if( ilv .or. .not.wantsn ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_${ci}$gghrd( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        ierr )
           else
              call stdlib_${ci}$gghrd( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur forms and schur vectors)
           ! (complex workspace: need n)
           ! (real workspace: need n)
           iwrk = itau
           if( ilv .or. .not.wantsn ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_${ci}$hgeqz( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vl, &
                     ldvl, vr, ldvr, work( iwrk ),lwork+1-iwrk, rwork, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 90
           end if
           ! compute eigenvectors and estimate condition numbers if desired
           ! stdlib_${ci}$tgevc: (complex workspace: need 2*n )
                   ! (real workspace:    need 2*n )
           ! stdlib_${ci}$tgsna: (complex workspace: need 2*n*n if sense='v' or 'b')
                   ! (integer workspace: need n+2 )
           if( ilv .or. .not.wantsn ) then
              if( ilv ) then
                 if( ilvl ) then
                    if( ilvr ) then
                       chtemp = 'B'
                    else
                       chtemp = 'L'
                    end if
                 else
                    chtemp = 'R'
                 end if
                 call stdlib_${ci}$tgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, n,&
                            in, work( iwrk ), rwork,ierr )
                 if( ierr/=0 ) then
                    info = n + 2
                    go to 90
                 end if
              end if
              if( .not.wantsn ) then
                 ! compute eigenvectors (stdlib_${ci}$tgevc) and estimate condition
                 ! numbers (stdlib_${ci}$tgsna). note that the definition of the condition
                 ! number is not invariant under transformation (u,v) to
                 ! (q*u, z*v), where (u,v) are eigenvectors of the generalized
                 ! schur form (s,t), q and z are orthogonal matrices. in order
                 ! to avoid using extra 2*n*n workspace, we have to
                 ! re-calculate eigenvectors and estimate the condition numbers
                 ! one at a time.
                 do i = 1, n
                    do j = 1, n
                       bwork( j ) = .false.
                    end do
                    bwork( i ) = .true.
                    iwrk = n + 1
                    iwrk1 = iwrk + n
                    if( wantse .or. wantsb ) then
                       call stdlib_${ci}$tgevc( 'B', 'S', bwork, n, a, lda, b, ldb,work( 1 ), n, work( &
                                 iwrk ), n, 1, m,work( iwrk1 ), rwork, ierr )
                       if( ierr/=0 ) then
                          info = n + 2
                          go to 90
                       end if
                    end if
                    call stdlib_${ci}$tgsna( sense, 'S', bwork, n, a, lda, b, ldb,work( 1 ), n, work( &
                    iwrk ), n, rconde( i ),rcondv( i ), 1, m, work( iwrk1 ),lwork-iwrk1+1, iwork, &
                              ierr )
                 end do
              end if
           end if
           ! undo balancing on vl and vr and normalization
           ! (workspace: none needed)
           if( ilvl ) then
              call stdlib_${ci}$ggbak( balanc, 'L', n, ilo, ihi, lscale, rscale, n, vl,ldvl, ierr )
                        
              loop_50: do jc = 1, n
                 temp = zero
                 do jr = 1, n
                    temp = max( temp, abs1( vl( jr, jc ) ) )
                 end do
                 if( temp<smlnum )cycle loop_50
                 temp = one / temp
                 do jr = 1, n
                    vl( jr, jc ) = vl( jr, jc )*temp
                 end do
              end do loop_50
           end if
           if( ilvr ) then
              call stdlib_${ci}$ggbak( balanc, 'R', n, ilo, ihi, lscale, rscale, n, vr,ldvr, ierr )
                        
              loop_80: do jc = 1, n
                 temp = zero
                 do jr = 1, n
                    temp = max( temp, abs1( vr( jr, jc ) ) )
                 end do
                 if( temp<smlnum )cycle loop_80
                 temp = one / temp
                 do jr = 1, n
                    vr( jr, jc ) = vr( jr, jc )*temp
                 end do
              end do loop_80
           end if
           ! undo scaling if necessary
           90 continue
           if( ilascl )call stdlib_${ci}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           if( ilbscl )call stdlib_${ci}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_${ci}$ggevx

#:endif
#:endfor



     module pure subroutine stdlib_slasy2( ltranl, ltranr, isgn, n1, n2, tl, ldtl, tr,ldtr, b, ldb, &
     !! SLASY2 solves for the N1 by N2 matrix X, 1 <= N1,N2 <= 2, in
     !! op(TL)*X + ISGN*X*op(TR) = SCALE*B,
     !! where TL is N1 by N1, TR is N2 by N2, B is N1 by N2, and ISGN = 1 or
     !! -1.  op(T) = T or T**T, where T**T denotes the transpose of T.
               scale, x, ldx, xnorm, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: ltranl, ltranr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: isgn, ldb, ldtl, ldtr, ldx, n1, n2
           real(sp), intent(out) :: scale, xnorm
           ! Array Arguments 
           real(sp), intent(in) :: b(ldb,*), tl(ldtl,*), tr(ldtr,*)
           real(sp), intent(out) :: x(ldx,*)
       ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: bswap, xswap
           integer(ilp) :: i, ip, ipiv, ipsv, j, jp, jpsv, k
           real(sp) :: bet, eps, gam, l21, sgn, smin, smlnum, tau1, temp, u11, u12, u22, &
                     xmax
           ! Local Arrays 
           logical(lk) :: bswpiv(4), xswpiv(4)
           integer(ilp) :: jpiv(4), locl21(4), locu12(4), locu22(4)
           real(sp) :: btmp(4), t16(4,4), tmp(4), x2(2)
           ! Intrinsic Functions 
           ! Data Statements 
           locu12 = [3,4,1,2]
           locl21 = [2,1,4,3]
           locu22 = [4,3,2,1]
           xswpiv = [.false.,.false.,.true.,.true.]
           bswpiv = [.false.,.true.,.false.,.true.]
           ! Executable Statements 
           ! do not check the input parameters for errors
           info = 0
           ! quick return if possible
           if( n1==0 .or. n2==0 )return
           ! set constants to control overflow
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' ) / eps
           sgn = isgn
           k = n1 + n1 + n2 - 2
           go to ( 10, 20, 30, 50 )k
           ! 1 by 1: tl11*x + sgn*x*tr11 = b11
           10 continue
           tau1 = tl( 1, 1 ) + sgn*tr( 1, 1 )
           bet = abs( tau1 )
           if( bet<=smlnum ) then
              tau1 = smlnum
              bet = smlnum
              info = 1
           end if
           scale = one
           gam = abs( b( 1, 1 ) )
           if( smlnum*gam>bet )scale = one / gam
           x( 1, 1 ) = ( b( 1, 1 )*scale ) / tau1
           xnorm = abs( x( 1, 1 ) )
           return
           ! 1 by 2:
           ! tl11*[x11 x12] + isgn*[x11 x12]*op[tr11 tr12]  = [b11 b12]
                                             ! [tr21 tr22]
                                             20 continue
           smin = max( eps*max( abs( tl( 1, 1 ) ), abs( tr( 1, 1 ) ),abs( tr( 1, 2 ) ), abs( tr( &
                     2, 1 ) ), abs( tr( 2, 2 ) ) ),smlnum )
           tmp( 1 ) = tl( 1, 1 ) + sgn*tr( 1, 1 )
           tmp( 4 ) = tl( 1, 1 ) + sgn*tr( 2, 2 )
           if( ltranr ) then
              tmp( 2 ) = sgn*tr( 2, 1 )
              tmp( 3 ) = sgn*tr( 1, 2 )
           else
              tmp( 2 ) = sgn*tr( 1, 2 )
              tmp( 3 ) = sgn*tr( 2, 1 )
           end if
           btmp( 1 ) = b( 1, 1 )
           btmp( 2 ) = b( 1, 2 )
           go to 40
           ! 2 by 1:
                ! op[tl11 tl12]*[x11] + isgn* [x11]*tr11  = [b11]
                  ! [tl21 tl22] [x21]         [x21]         [b21]
                  30 continue
           smin = max( eps*max( abs( tr( 1, 1 ) ), abs( tl( 1, 1 ) ),abs( tl( 1, 2 ) ), abs( tl( &
                     2, 1 ) ), abs( tl( 2, 2 ) ) ),smlnum )
           tmp( 1 ) = tl( 1, 1 ) + sgn*tr( 1, 1 )
           tmp( 4 ) = tl( 2, 2 ) + sgn*tr( 1, 1 )
           if( ltranl ) then
              tmp( 2 ) = tl( 1, 2 )
              tmp( 3 ) = tl( 2, 1 )
           else
              tmp( 2 ) = tl( 2, 1 )
              tmp( 3 ) = tl( 1, 2 )
           end if
           btmp( 1 ) = b( 1, 1 )
           btmp( 2 ) = b( 2, 1 )
           40 continue
           ! solve 2 by 2 system using complete pivoting.
           ! set pivots less than smin to smin.
           ipiv = stdlib_isamax( 4, tmp, 1 )
           u11 = tmp( ipiv )
           if( abs( u11 )<=smin ) then
              info = 1
              u11 = smin
           end if
           u12 = tmp( locu12( ipiv ) )
           l21 = tmp( locl21( ipiv ) ) / u11
           u22 = tmp( locu22( ipiv ) ) - u12*l21
           xswap = xswpiv( ipiv )
           bswap = bswpiv( ipiv )
           if( abs( u22 )<=smin ) then
              info = 1
              u22 = smin
           end if
           if( bswap ) then
              temp = btmp( 2 )
              btmp( 2 ) = btmp( 1 ) - l21*temp
              btmp( 1 ) = temp
           else
              btmp( 2 ) = btmp( 2 ) - l21*btmp( 1 )
           end if
           scale = one
           if( ( two*smlnum )*abs( btmp( 2 ) )>abs( u22 ) .or.( two*smlnum )*abs( btmp( 1 ) )>abs(&
                      u11 ) ) then
              scale = half / max( abs( btmp( 1 ) ), abs( btmp( 2 ) ) )
              btmp( 1 ) = btmp( 1 )*scale
              btmp( 2 ) = btmp( 2 )*scale
           end if
           x2( 2 ) = btmp( 2 ) / u22
           x2( 1 ) = btmp( 1 ) / u11 - ( u12 / u11 )*x2( 2 )
           if( xswap ) then
              temp = x2( 2 )
              x2( 2 ) = x2( 1 )
              x2( 1 ) = temp
           end if
           x( 1, 1 ) = x2( 1 )
           if( n1==1 ) then
              x( 1, 2 ) = x2( 2 )
              xnorm = abs( x( 1, 1 ) ) + abs( x( 1, 2 ) )
           else
              x( 2, 1 ) = x2( 2 )
              xnorm = max( abs( x( 1, 1 ) ), abs( x( 2, 1 ) ) )
           end if
           return
           ! 2 by 2:
           ! op[tl11 tl12]*[x11 x12] +isgn* [x11 x12]*op[tr11 tr12] = [b11 b12]
             ! [tl21 tl22] [x21 x22]        [x21 x22]   [tr21 tr22]   [b21 b22]
           ! solve equivalent 4 by 4 system using complete pivoting.
           ! set pivots less than smin to smin.
           50 continue
           smin = max( abs( tr( 1, 1 ) ), abs( tr( 1, 2 ) ),abs( tr( 2, 1 ) ), abs( tr( 2, 2 ) ) )
                     
           smin = max( smin, abs( tl( 1, 1 ) ), abs( tl( 1, 2 ) ),abs( tl( 2, 1 ) ), abs( tl( 2, &
                     2 ) ) )
           smin = max( eps*smin, smlnum )
           btmp( 1 ) = zero
           call stdlib_scopy( 16, btmp, 0, t16, 1 )
           t16( 1, 1 ) = tl( 1, 1 ) + sgn*tr( 1, 1 )
           t16( 2, 2 ) = tl( 2, 2 ) + sgn*tr( 1, 1 )
           t16( 3, 3 ) = tl( 1, 1 ) + sgn*tr( 2, 2 )
           t16( 4, 4 ) = tl( 2, 2 ) + sgn*tr( 2, 2 )
           if( ltranl ) then
              t16( 1, 2 ) = tl( 2, 1 )
              t16( 2, 1 ) = tl( 1, 2 )
              t16( 3, 4 ) = tl( 2, 1 )
              t16( 4, 3 ) = tl( 1, 2 )
           else
              t16( 1, 2 ) = tl( 1, 2 )
              t16( 2, 1 ) = tl( 2, 1 )
              t16( 3, 4 ) = tl( 1, 2 )
              t16( 4, 3 ) = tl( 2, 1 )
           end if
           if( ltranr ) then
              t16( 1, 3 ) = sgn*tr( 1, 2 )
              t16( 2, 4 ) = sgn*tr( 1, 2 )
              t16( 3, 1 ) = sgn*tr( 2, 1 )
              t16( 4, 2 ) = sgn*tr( 2, 1 )
           else
              t16( 1, 3 ) = sgn*tr( 2, 1 )
              t16( 2, 4 ) = sgn*tr( 2, 1 )
              t16( 3, 1 ) = sgn*tr( 1, 2 )
              t16( 4, 2 ) = sgn*tr( 1, 2 )
           end if
           btmp( 1 ) = b( 1, 1 )
           btmp( 2 ) = b( 2, 1 )
           btmp( 3 ) = b( 1, 2 )
           btmp( 4 ) = b( 2, 2 )
           ! perform elimination
           loop_100: do i = 1, 3
              xmax = zero
              do ip = i, 4
                 do jp = i, 4
                    if( abs( t16( ip, jp ) )>=xmax ) then
                       xmax = abs( t16( ip, jp ) )
                       ipsv = ip
                       jpsv = jp
                    end if
                 end do
              end do
              if( ipsv/=i ) then
                 call stdlib_sswap( 4, t16( ipsv, 1 ), 4, t16( i, 1 ), 4 )
                 temp = btmp( i )
                 btmp( i ) = btmp( ipsv )
                 btmp( ipsv ) = temp
              end if
              if( jpsv/=i )call stdlib_sswap( 4, t16( 1, jpsv ), 1, t16( 1, i ), 1 )
              jpiv( i ) = jpsv
              if( abs( t16( i, i ) )<smin ) then
                 info = 1
                 t16( i, i ) = smin
              end if
              do j = i + 1, 4
                 t16( j, i ) = t16( j, i ) / t16( i, i )
                 btmp( j ) = btmp( j ) - t16( j, i )*btmp( i )
                 do k = i + 1, 4
                    t16( j, k ) = t16( j, k ) - t16( j, i )*t16( i, k )
                 end do
              end do
           end do loop_100
           if( abs( t16( 4, 4 ) )<smin ) then
              info = 1
              t16( 4, 4 ) = smin
           end if
           scale = one
           if( ( eight*smlnum )*abs( btmp( 1 ) )>abs( t16( 1, 1 ) ) .or.( eight*smlnum )*abs( &
           btmp( 2 ) )>abs( t16( 2, 2 ) ) .or.( eight*smlnum )*abs( btmp( 3 ) )>abs( t16( 3, 3 ) )&
                      .or.( eight*smlnum )*abs( btmp( 4 ) )>abs( t16( 4, 4 ) ) ) then
              scale = ( one / eight ) / max( abs( btmp( 1 ) ),abs( btmp( 2 ) ), abs( btmp( 3 ) ), &
                        abs( btmp( 4 ) ) )
              btmp( 1 ) = btmp( 1 )*scale
              btmp( 2 ) = btmp( 2 )*scale
              btmp( 3 ) = btmp( 3 )*scale
              btmp( 4 ) = btmp( 4 )*scale
           end if
           do i = 1, 4
              k = 5 - i
              temp = one / t16( k, k )
              tmp( k ) = btmp( k )*temp
              do j = k + 1, 4
                 tmp( k ) = tmp( k ) - ( temp*t16( k, j ) )*tmp( j )
              end do
           end do
           do i = 1, 3
              if( jpiv( 4-i )/=4-i ) then
                 temp = tmp( 4-i )
                 tmp( 4-i ) = tmp( jpiv( 4-i ) )
                 tmp( jpiv( 4-i ) ) = temp
              end if
           end do
           x( 1, 1 ) = tmp( 1 )
           x( 2, 1 ) = tmp( 2 )
           x( 1, 2 ) = tmp( 3 )
           x( 2, 2 ) = tmp( 4 )
           xnorm = max( abs( tmp( 1 ) )+abs( tmp( 3 ) ),abs( tmp( 2 ) )+abs( tmp( 4 ) ) )
           return
     end subroutine stdlib_slasy2

     module pure subroutine stdlib_dlasy2( ltranl, ltranr, isgn, n1, n2, tl, ldtl, tr,ldtr, b, ldb, &
     !! DLASY2 solves for the N1 by N2 matrix X, 1 <= N1,N2 <= 2, in
     !! op(TL)*X + ISGN*X*op(TR) = SCALE*B,
     !! where TL is N1 by N1, TR is N2 by N2, B is N1 by N2, and ISGN = 1 or
     !! -1.  op(T) = T or T**T, where T**T denotes the transpose of T.
               scale, x, ldx, xnorm, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: ltranl, ltranr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: isgn, ldb, ldtl, ldtr, ldx, n1, n2
           real(dp), intent(out) :: scale, xnorm
           ! Array Arguments 
           real(dp), intent(in) :: b(ldb,*), tl(ldtl,*), tr(ldtr,*)
           real(dp), intent(out) :: x(ldx,*)
       ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: bswap, xswap
           integer(ilp) :: i, ip, ipiv, ipsv, j, jp, jpsv, k
           real(dp) :: bet, eps, gam, l21, sgn, smin, smlnum, tau1, temp, u11, u12, u22, &
                     xmax
           ! Local Arrays 
           logical(lk) :: bswpiv(4), xswpiv(4)
           integer(ilp) :: jpiv(4), locl21(4), locu12(4), locu22(4)
           real(dp) :: btmp(4), t16(4,4), tmp(4), x2(2)
           ! Intrinsic Functions 
           ! Data Statements 
           locu12 = [3,4,1,2]
           locl21 = [2,1,4,3]
           locu22 = [4,3,2,1]
           xswpiv = [.false.,.false.,.true.,.true.]
           bswpiv = [.false.,.true.,.false.,.true.]
           ! Executable Statements 
           ! do not check the input parameters for errors
           info = 0
           ! quick return if possible
           if( n1==0 .or. n2==0 )return
           ! set constants to control overflow
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' ) / eps
           sgn = isgn
           k = n1 + n1 + n2 - 2
           go to ( 10, 20, 30, 50 )k
           ! 1 by 1: tl11*x + sgn*x*tr11 = b11
           10 continue
           tau1 = tl( 1, 1 ) + sgn*tr( 1, 1 )
           bet = abs( tau1 )
           if( bet<=smlnum ) then
              tau1 = smlnum
              bet = smlnum
              info = 1
           end if
           scale = one
           gam = abs( b( 1, 1 ) )
           if( smlnum*gam>bet )scale = one / gam
           x( 1, 1 ) = ( b( 1, 1 )*scale ) / tau1
           xnorm = abs( x( 1, 1 ) )
           return
           ! 1 by 2:
           ! tl11*[x11 x12] + isgn*[x11 x12]*op[tr11 tr12]  = [b11 b12]
                                             ! [tr21 tr22]
                                             20 continue
           smin = max( eps*max( abs( tl( 1, 1 ) ), abs( tr( 1, 1 ) ),abs( tr( 1, 2 ) ), abs( tr( &
                     2, 1 ) ), abs( tr( 2, 2 ) ) ),smlnum )
           tmp( 1 ) = tl( 1, 1 ) + sgn*tr( 1, 1 )
           tmp( 4 ) = tl( 1, 1 ) + sgn*tr( 2, 2 )
           if( ltranr ) then
              tmp( 2 ) = sgn*tr( 2, 1 )
              tmp( 3 ) = sgn*tr( 1, 2 )
           else
              tmp( 2 ) = sgn*tr( 1, 2 )
              tmp( 3 ) = sgn*tr( 2, 1 )
           end if
           btmp( 1 ) = b( 1, 1 )
           btmp( 2 ) = b( 1, 2 )
           go to 40
           ! 2 by 1:
                ! op[tl11 tl12]*[x11] + isgn* [x11]*tr11  = [b11]
                  ! [tl21 tl22] [x21]         [x21]         [b21]
                  30 continue
           smin = max( eps*max( abs( tr( 1, 1 ) ), abs( tl( 1, 1 ) ),abs( tl( 1, 2 ) ), abs( tl( &
                     2, 1 ) ), abs( tl( 2, 2 ) ) ),smlnum )
           tmp( 1 ) = tl( 1, 1 ) + sgn*tr( 1, 1 )
           tmp( 4 ) = tl( 2, 2 ) + sgn*tr( 1, 1 )
           if( ltranl ) then
              tmp( 2 ) = tl( 1, 2 )
              tmp( 3 ) = tl( 2, 1 )
           else
              tmp( 2 ) = tl( 2, 1 )
              tmp( 3 ) = tl( 1, 2 )
           end if
           btmp( 1 ) = b( 1, 1 )
           btmp( 2 ) = b( 2, 1 )
           40 continue
           ! solve 2 by 2 system using complete pivoting.
           ! set pivots less than smin to smin.
           ipiv = stdlib_idamax( 4, tmp, 1 )
           u11 = tmp( ipiv )
           if( abs( u11 )<=smin ) then
              info = 1
              u11 = smin
           end if
           u12 = tmp( locu12( ipiv ) )
           l21 = tmp( locl21( ipiv ) ) / u11
           u22 = tmp( locu22( ipiv ) ) - u12*l21
           xswap = xswpiv( ipiv )
           bswap = bswpiv( ipiv )
           if( abs( u22 )<=smin ) then
              info = 1
              u22 = smin
           end if
           if( bswap ) then
              temp = btmp( 2 )
              btmp( 2 ) = btmp( 1 ) - l21*temp
              btmp( 1 ) = temp
           else
              btmp( 2 ) = btmp( 2 ) - l21*btmp( 1 )
           end if
           scale = one
           if( ( two*smlnum )*abs( btmp( 2 ) )>abs( u22 ) .or.( two*smlnum )*abs( btmp( 1 ) )>abs(&
                      u11 ) ) then
              scale = half / max( abs( btmp( 1 ) ), abs( btmp( 2 ) ) )
              btmp( 1 ) = btmp( 1 )*scale
              btmp( 2 ) = btmp( 2 )*scale
           end if
           x2( 2 ) = btmp( 2 ) / u22
           x2( 1 ) = btmp( 1 ) / u11 - ( u12 / u11 )*x2( 2 )
           if( xswap ) then
              temp = x2( 2 )
              x2( 2 ) = x2( 1 )
              x2( 1 ) = temp
           end if
           x( 1, 1 ) = x2( 1 )
           if( n1==1 ) then
              x( 1, 2 ) = x2( 2 )
              xnorm = abs( x( 1, 1 ) ) + abs( x( 1, 2 ) )
           else
              x( 2, 1 ) = x2( 2 )
              xnorm = max( abs( x( 1, 1 ) ), abs( x( 2, 1 ) ) )
           end if
           return
           ! 2 by 2:
           ! op[tl11 tl12]*[x11 x12] +isgn* [x11 x12]*op[tr11 tr12] = [b11 b12]
             ! [tl21 tl22] [x21 x22]        [x21 x22]   [tr21 tr22]   [b21 b22]
           ! solve equivalent 4 by 4 system using complete pivoting.
           ! set pivots less than smin to smin.
           50 continue
           smin = max( abs( tr( 1, 1 ) ), abs( tr( 1, 2 ) ),abs( tr( 2, 1 ) ), abs( tr( 2, 2 ) ) )
                     
           smin = max( smin, abs( tl( 1, 1 ) ), abs( tl( 1, 2 ) ),abs( tl( 2, 1 ) ), abs( tl( 2, &
                     2 ) ) )
           smin = max( eps*smin, smlnum )
           btmp( 1 ) = zero
           call stdlib_dcopy( 16, btmp, 0, t16, 1 )
           t16( 1, 1 ) = tl( 1, 1 ) + sgn*tr( 1, 1 )
           t16( 2, 2 ) = tl( 2, 2 ) + sgn*tr( 1, 1 )
           t16( 3, 3 ) = tl( 1, 1 ) + sgn*tr( 2, 2 )
           t16( 4, 4 ) = tl( 2, 2 ) + sgn*tr( 2, 2 )
           if( ltranl ) then
              t16( 1, 2 ) = tl( 2, 1 )
              t16( 2, 1 ) = tl( 1, 2 )
              t16( 3, 4 ) = tl( 2, 1 )
              t16( 4, 3 ) = tl( 1, 2 )
           else
              t16( 1, 2 ) = tl( 1, 2 )
              t16( 2, 1 ) = tl( 2, 1 )
              t16( 3, 4 ) = tl( 1, 2 )
              t16( 4, 3 ) = tl( 2, 1 )
           end if
           if( ltranr ) then
              t16( 1, 3 ) = sgn*tr( 1, 2 )
              t16( 2, 4 ) = sgn*tr( 1, 2 )
              t16( 3, 1 ) = sgn*tr( 2, 1 )
              t16( 4, 2 ) = sgn*tr( 2, 1 )
           else
              t16( 1, 3 ) = sgn*tr( 2, 1 )
              t16( 2, 4 ) = sgn*tr( 2, 1 )
              t16( 3, 1 ) = sgn*tr( 1, 2 )
              t16( 4, 2 ) = sgn*tr( 1, 2 )
           end if
           btmp( 1 ) = b( 1, 1 )
           btmp( 2 ) = b( 2, 1 )
           btmp( 3 ) = b( 1, 2 )
           btmp( 4 ) = b( 2, 2 )
           ! perform elimination
           loop_100: do i = 1, 3
              xmax = zero
              do ip = i, 4
                 do jp = i, 4
                    if( abs( t16( ip, jp ) )>=xmax ) then
                       xmax = abs( t16( ip, jp ) )
                       ipsv = ip
                       jpsv = jp
                    end if
                 end do
              end do
              if( ipsv/=i ) then
                 call stdlib_dswap( 4, t16( ipsv, 1 ), 4, t16( i, 1 ), 4 )
                 temp = btmp( i )
                 btmp( i ) = btmp( ipsv )
                 btmp( ipsv ) = temp
              end if
              if( jpsv/=i )call stdlib_dswap( 4, t16( 1, jpsv ), 1, t16( 1, i ), 1 )
              jpiv( i ) = jpsv
              if( abs( t16( i, i ) )<smin ) then
                 info = 1
                 t16( i, i ) = smin
              end if
              do j = i + 1, 4
                 t16( j, i ) = t16( j, i ) / t16( i, i )
                 btmp( j ) = btmp( j ) - t16( j, i )*btmp( i )
                 do k = i + 1, 4
                    t16( j, k ) = t16( j, k ) - t16( j, i )*t16( i, k )
                 end do
              end do
           end do loop_100
           if( abs( t16( 4, 4 ) )<smin ) then
              info = 1
              t16( 4, 4 ) = smin
           end if
           scale = one
           if( ( eight*smlnum )*abs( btmp( 1 ) )>abs( t16( 1, 1 ) ) .or.( eight*smlnum )*abs( &
           btmp( 2 ) )>abs( t16( 2, 2 ) ) .or.( eight*smlnum )*abs( btmp( 3 ) )>abs( t16( 3, 3 ) )&
                      .or.( eight*smlnum )*abs( btmp( 4 ) )>abs( t16( 4, 4 ) ) ) then
              scale = ( one / eight ) / max( abs( btmp( 1 ) ),abs( btmp( 2 ) ), abs( btmp( 3 ) ), &
                        abs( btmp( 4 ) ) )
              btmp( 1 ) = btmp( 1 )*scale
              btmp( 2 ) = btmp( 2 )*scale
              btmp( 3 ) = btmp( 3 )*scale
              btmp( 4 ) = btmp( 4 )*scale
           end if
           do i = 1, 4
              k = 5 - i
              temp = one / t16( k, k )
              tmp( k ) = btmp( k )*temp
              do j = k + 1, 4
                 tmp( k ) = tmp( k ) - ( temp*t16( k, j ) )*tmp( j )
              end do
           end do
           do i = 1, 3
              if( jpiv( 4-i )/=4-i ) then
                 temp = tmp( 4-i )
                 tmp( 4-i ) = tmp( jpiv( 4-i ) )
                 tmp( jpiv( 4-i ) ) = temp
              end if
           end do
           x( 1, 1 ) = tmp( 1 )
           x( 2, 1 ) = tmp( 2 )
           x( 1, 2 ) = tmp( 3 )
           x( 2, 2 ) = tmp( 4 )
           xnorm = max( abs( tmp( 1 ) )+abs( tmp( 3 ) ),abs( tmp( 2 ) )+abs( tmp( 4 ) ) )
           return
     end subroutine stdlib_dlasy2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$lasy2( ltranl, ltranr, isgn, n1, n2, tl, ldtl, tr,ldtr, b, ldb, &
     !! DLASY2: solves for the N1 by N2 matrix X, 1 <= N1,N2 <= 2, in
     !! op(TL)*X + ISGN*X*op(TR) = SCALE*B,
     !! where TL is N1 by N1, TR is N2 by N2, B is N1 by N2, and ISGN = 1 or
     !! -1.  op(T) = T or T**T, where T**T denotes the transpose of T.
               scale, x, ldx, xnorm, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: ltranl, ltranr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: isgn, ldb, ldtl, ldtr, ldx, n1, n2
           real(${rk}$), intent(out) :: scale, xnorm
           ! Array Arguments 
           real(${rk}$), intent(in) :: b(ldb,*), tl(ldtl,*), tr(ldtr,*)
           real(${rk}$), intent(out) :: x(ldx,*)
       ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: bswap, xswap
           integer(ilp) :: i, ip, ipiv, ipsv, j, jp, jpsv, k
           real(${rk}$) :: bet, eps, gam, l21, sgn, smin, smlnum, tau1, temp, u11, u12, u22, &
                     xmax
           ! Local Arrays 
           logical(lk) :: bswpiv(4), xswpiv(4)
           integer(ilp) :: jpiv(4), locl21(4), locu12(4), locu22(4)
           real(${rk}$) :: btmp(4), t16(4,4), tmp(4), x2(2)
           ! Intrinsic Functions 
           ! Data Statements 
           locu12 = [3,4,1,2]
           locl21 = [2,1,4,3]
           locu22 = [4,3,2,1]
           xswpiv = [.false.,.false.,.true.,.true.]
           bswpiv = [.false.,.true.,.false.,.true.]
           ! Executable Statements 
           ! do not check the input parameters for errors
           info = 0
           ! quick return if possible
           if( n1==0 .or. n2==0 )return
           ! set constants to control overflow
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' ) / eps
           sgn = isgn
           k = n1 + n1 + n2 - 2
           go to ( 10, 20, 30, 50 )k
           ! 1 by 1: tl11*x + sgn*x*tr11 = b11
           10 continue
           tau1 = tl( 1, 1 ) + sgn*tr( 1, 1 )
           bet = abs( tau1 )
           if( bet<=smlnum ) then
              tau1 = smlnum
              bet = smlnum
              info = 1
           end if
           scale = one
           gam = abs( b( 1, 1 ) )
           if( smlnum*gam>bet )scale = one / gam
           x( 1, 1 ) = ( b( 1, 1 )*scale ) / tau1
           xnorm = abs( x( 1, 1 ) )
           return
           ! 1 by 2:
           ! tl11*[x11 x12] + isgn*[x11 x12]*op[tr11 tr12]  = [b11 b12]
                                             ! [tr21 tr22]
                                             20 continue
           smin = max( eps*max( abs( tl( 1, 1 ) ), abs( tr( 1, 1 ) ),abs( tr( 1, 2 ) ), abs( tr( &
                     2, 1 ) ), abs( tr( 2, 2 ) ) ),smlnum )
           tmp( 1 ) = tl( 1, 1 ) + sgn*tr( 1, 1 )
           tmp( 4 ) = tl( 1, 1 ) + sgn*tr( 2, 2 )
           if( ltranr ) then
              tmp( 2 ) = sgn*tr( 2, 1 )
              tmp( 3 ) = sgn*tr( 1, 2 )
           else
              tmp( 2 ) = sgn*tr( 1, 2 )
              tmp( 3 ) = sgn*tr( 2, 1 )
           end if
           btmp( 1 ) = b( 1, 1 )
           btmp( 2 ) = b( 1, 2 )
           go to 40
           ! 2 by 1:
                ! op[tl11 tl12]*[x11] + isgn* [x11]*tr11  = [b11]
                  ! [tl21 tl22] [x21]         [x21]         [b21]
                  30 continue
           smin = max( eps*max( abs( tr( 1, 1 ) ), abs( tl( 1, 1 ) ),abs( tl( 1, 2 ) ), abs( tl( &
                     2, 1 ) ), abs( tl( 2, 2 ) ) ),smlnum )
           tmp( 1 ) = tl( 1, 1 ) + sgn*tr( 1, 1 )
           tmp( 4 ) = tl( 2, 2 ) + sgn*tr( 1, 1 )
           if( ltranl ) then
              tmp( 2 ) = tl( 1, 2 )
              tmp( 3 ) = tl( 2, 1 )
           else
              tmp( 2 ) = tl( 2, 1 )
              tmp( 3 ) = tl( 1, 2 )
           end if
           btmp( 1 ) = b( 1, 1 )
           btmp( 2 ) = b( 2, 1 )
           40 continue
           ! solve 2 by 2 system using complete pivoting.
           ! set pivots less than smin to smin.
           ipiv = stdlib_i${ri}$amax( 4, tmp, 1 )
           u11 = tmp( ipiv )
           if( abs( u11 )<=smin ) then
              info = 1
              u11 = smin
           end if
           u12 = tmp( locu12( ipiv ) )
           l21 = tmp( locl21( ipiv ) ) / u11
           u22 = tmp( locu22( ipiv ) ) - u12*l21
           xswap = xswpiv( ipiv )
           bswap = bswpiv( ipiv )
           if( abs( u22 )<=smin ) then
              info = 1
              u22 = smin
           end if
           if( bswap ) then
              temp = btmp( 2 )
              btmp( 2 ) = btmp( 1 ) - l21*temp
              btmp( 1 ) = temp
           else
              btmp( 2 ) = btmp( 2 ) - l21*btmp( 1 )
           end if
           scale = one
           if( ( two*smlnum )*abs( btmp( 2 ) )>abs( u22 ) .or.( two*smlnum )*abs( btmp( 1 ) )>abs(&
                      u11 ) ) then
              scale = half / max( abs( btmp( 1 ) ), abs( btmp( 2 ) ) )
              btmp( 1 ) = btmp( 1 )*scale
              btmp( 2 ) = btmp( 2 )*scale
           end if
           x2( 2 ) = btmp( 2 ) / u22
           x2( 1 ) = btmp( 1 ) / u11 - ( u12 / u11 )*x2( 2 )
           if( xswap ) then
              temp = x2( 2 )
              x2( 2 ) = x2( 1 )
              x2( 1 ) = temp
           end if
           x( 1, 1 ) = x2( 1 )
           if( n1==1 ) then
              x( 1, 2 ) = x2( 2 )
              xnorm = abs( x( 1, 1 ) ) + abs( x( 1, 2 ) )
           else
              x( 2, 1 ) = x2( 2 )
              xnorm = max( abs( x( 1, 1 ) ), abs( x( 2, 1 ) ) )
           end if
           return
           ! 2 by 2:
           ! op[tl11 tl12]*[x11 x12] +isgn* [x11 x12]*op[tr11 tr12] = [b11 b12]
             ! [tl21 tl22] [x21 x22]        [x21 x22]   [tr21 tr22]   [b21 b22]
           ! solve equivalent 4 by 4 system using complete pivoting.
           ! set pivots less than smin to smin.
           50 continue
           smin = max( abs( tr( 1, 1 ) ), abs( tr( 1, 2 ) ),abs( tr( 2, 1 ) ), abs( tr( 2, 2 ) ) )
                     
           smin = max( smin, abs( tl( 1, 1 ) ), abs( tl( 1, 2 ) ),abs( tl( 2, 1 ) ), abs( tl( 2, &
                     2 ) ) )
           smin = max( eps*smin, smlnum )
           btmp( 1 ) = zero
           call stdlib_${ri}$copy( 16, btmp, 0, t16, 1 )
           t16( 1, 1 ) = tl( 1, 1 ) + sgn*tr( 1, 1 )
           t16( 2, 2 ) = tl( 2, 2 ) + sgn*tr( 1, 1 )
           t16( 3, 3 ) = tl( 1, 1 ) + sgn*tr( 2, 2 )
           t16( 4, 4 ) = tl( 2, 2 ) + sgn*tr( 2, 2 )
           if( ltranl ) then
              t16( 1, 2 ) = tl( 2, 1 )
              t16( 2, 1 ) = tl( 1, 2 )
              t16( 3, 4 ) = tl( 2, 1 )
              t16( 4, 3 ) = tl( 1, 2 )
           else
              t16( 1, 2 ) = tl( 1, 2 )
              t16( 2, 1 ) = tl( 2, 1 )
              t16( 3, 4 ) = tl( 1, 2 )
              t16( 4, 3 ) = tl( 2, 1 )
           end if
           if( ltranr ) then
              t16( 1, 3 ) = sgn*tr( 1, 2 )
              t16( 2, 4 ) = sgn*tr( 1, 2 )
              t16( 3, 1 ) = sgn*tr( 2, 1 )
              t16( 4, 2 ) = sgn*tr( 2, 1 )
           else
              t16( 1, 3 ) = sgn*tr( 2, 1 )
              t16( 2, 4 ) = sgn*tr( 2, 1 )
              t16( 3, 1 ) = sgn*tr( 1, 2 )
              t16( 4, 2 ) = sgn*tr( 1, 2 )
           end if
           btmp( 1 ) = b( 1, 1 )
           btmp( 2 ) = b( 2, 1 )
           btmp( 3 ) = b( 1, 2 )
           btmp( 4 ) = b( 2, 2 )
           ! perform elimination
           loop_100: do i = 1, 3
              xmax = zero
              do ip = i, 4
                 do jp = i, 4
                    if( abs( t16( ip, jp ) )>=xmax ) then
                       xmax = abs( t16( ip, jp ) )
                       ipsv = ip
                       jpsv = jp
                    end if
                 end do
              end do
              if( ipsv/=i ) then
                 call stdlib_${ri}$swap( 4, t16( ipsv, 1 ), 4, t16( i, 1 ), 4 )
                 temp = btmp( i )
                 btmp( i ) = btmp( ipsv )
                 btmp( ipsv ) = temp
              end if
              if( jpsv/=i )call stdlib_${ri}$swap( 4, t16( 1, jpsv ), 1, t16( 1, i ), 1 )
              jpiv( i ) = jpsv
              if( abs( t16( i, i ) )<smin ) then
                 info = 1
                 t16( i, i ) = smin
              end if
              do j = i + 1, 4
                 t16( j, i ) = t16( j, i ) / t16( i, i )
                 btmp( j ) = btmp( j ) - t16( j, i )*btmp( i )
                 do k = i + 1, 4
                    t16( j, k ) = t16( j, k ) - t16( j, i )*t16( i, k )
                 end do
              end do
           end do loop_100
           if( abs( t16( 4, 4 ) )<smin ) then
              info = 1
              t16( 4, 4 ) = smin
           end if
           scale = one
           if( ( eight*smlnum )*abs( btmp( 1 ) )>abs( t16( 1, 1 ) ) .or.( eight*smlnum )*abs( &
           btmp( 2 ) )>abs( t16( 2, 2 ) ) .or.( eight*smlnum )*abs( btmp( 3 ) )>abs( t16( 3, 3 ) )&
                      .or.( eight*smlnum )*abs( btmp( 4 ) )>abs( t16( 4, 4 ) ) ) then
              scale = ( one / eight ) / max( abs( btmp( 1 ) ),abs( btmp( 2 ) ), abs( btmp( 3 ) ), &
                        abs( btmp( 4 ) ) )
              btmp( 1 ) = btmp( 1 )*scale
              btmp( 2 ) = btmp( 2 )*scale
              btmp( 3 ) = btmp( 3 )*scale
              btmp( 4 ) = btmp( 4 )*scale
           end if
           do i = 1, 4
              k = 5 - i
              temp = one / t16( k, k )
              tmp( k ) = btmp( k )*temp
              do j = k + 1, 4
                 tmp( k ) = tmp( k ) - ( temp*t16( k, j ) )*tmp( j )
              end do
           end do
           do i = 1, 3
              if( jpiv( 4-i )/=4-i ) then
                 temp = tmp( 4-i )
                 tmp( 4-i ) = tmp( jpiv( 4-i ) )
                 tmp( jpiv( 4-i ) ) = temp
              end if
           end do
           x( 1, 1 ) = tmp( 1 )
           x( 2, 1 ) = tmp( 2 )
           x( 1, 2 ) = tmp( 3 )
           x( 2, 2 ) = tmp( 4 )
           xnorm = max( abs( tmp( 1 ) )+abs( tmp( 3 ) ),abs( tmp( 2 ) )+abs( tmp( 4 ) ) )
           return
     end subroutine stdlib_${ri}$lasy2

#:endif
#:endfor



     module pure subroutine stdlib_slanv2( a, b, c, d, rt1r, rt1i, rt2r, rt2i, cs, sn )
     !! SLANV2 computes the Schur factorization of a real 2-by-2 nonsymmetric
     !! matrix in standard form:
     !! [ A  B ] = [ CS -SN ] [ AA  BB ] [ CS  SN ]
     !! [ C  D ]   [ SN  CS ] [ CC  DD ] [-SN  CS ]
     !! where either
     !! 1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or
     !! 2) AA = DD and BB*CC < 0, so that AA + or - sqrt(BB*CC) are complex
     !! conjugate eigenvalues.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(sp), intent(inout) :: a, b, c, d
           real(sp), intent(out) :: cs, rt1i, rt1r, rt2i, rt2r, sn
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: multpl = 4.0e+0_sp
           
           
           ! Local Scalars 
           real(sp) :: aa, bb, bcmax, bcmis, cc, cs1, dd, eps, p, sab, sac, scale, sigma, sn1, &
                     tau, temp, z, safmin, safmn2, safmx2
           integer(ilp) :: count
           ! Intrinsic Functions 
           ! Executable Statements 
           safmin = stdlib_slamch( 'S' )
           eps = stdlib_slamch( 'P' )
           safmn2 = stdlib_slamch( 'B' )**int( log( safmin / eps ) /log( stdlib_slamch( 'B' ) ) / &
                     two,KIND=ilp)
           safmx2 = one / safmn2
           if( c==zero ) then
              cs = one
              sn = zero
           else if( b==zero ) then
              ! swap rows and columns
              cs = zero
              sn = one
              temp = d
              d = a
              a = temp
              b = -c
              c = zero
           else if( (a-d)==zero .and. sign( one, b )/=sign( one, c ) ) then
              cs = one
              sn = zero
           else
              temp = a - d
              p = half*temp
              bcmax = max( abs( b ), abs( c ) )
              bcmis = min( abs( b ), abs( c ) )*sign( one, b )*sign( one, c )
              scale = max( abs( p ), bcmax )
              z = ( p / scale )*p + ( bcmax / scale )*bcmis
              ! if z is of the order of the machine accuracy, postpone the
              ! decision on the nature of eigenvalues
              if( z>=multpl*eps ) then
                 ! real eigenvalues. compute a and d.
                 z = p + sign( sqrt( scale )*sqrt( z ), p )
                 a = d + z
                 d = d - ( bcmax / z )*bcmis
                 ! compute b and the rotation matrix
                 tau = stdlib_slapy2( c, z )
                 cs = z / tau
                 sn = c / tau
                 b = b - c
                 c = zero
              else
                 ! complex eigenvalues, or real(almost,KIND=sp) equal eigenvalues.
                 ! make diagonal elements equal.
                 count = 0
                 sigma = b + c
                 10 continue
                 count = count + 1
                 scale = max( abs(temp), abs(sigma) )
                 if( scale>=safmx2 ) then
                    sigma = sigma * safmn2
                    temp = temp * safmn2
                    if (count <= 20)goto 10
                 end if
                 if( scale<=safmn2 ) then
                    sigma = sigma * safmx2
                    temp = temp * safmx2
                    if (count <= 20)goto 10
                 end if
                 p = half*temp
                 tau = stdlib_slapy2( sigma, temp )
                 cs = sqrt( half*( one+abs( sigma ) / tau ) )
                 sn = -( p / ( tau*cs ) )*sign( one, sigma )
                 ! compute [ aa  bb ] = [ a  b ] [ cs -sn ]
                         ! [ cc  dd ]   [ c  d ] [ sn  cs ]
                 aa = a*cs + b*sn
                 bb = -a*sn + b*cs
                 cc = c*cs + d*sn
                 dd = -c*sn + d*cs
                 ! compute [ a  b ] = [ cs  sn ] [ aa  bb ]
                         ! [ c  d ]   [-sn  cs ] [ cc  dd ]
                 a = aa*cs + cc*sn
                 b = bb*cs + dd*sn
                 c = -aa*sn + cc*cs
                 d = -bb*sn + dd*cs
                 temp = half*( a+d )
                 a = temp
                 d = temp
                 if( c/=zero ) then
                    if( b/=zero ) then
                       if( sign( one, b )==sign( one, c ) ) then
                          ! real eigenvalues: reduce to upper triangular form
                          sab = sqrt( abs( b ) )
                          sac = sqrt( abs( c ) )
                          p = sign( sab*sac, c )
                          tau = one / sqrt( abs( b+c ) )
                          a = temp + p
                          d = temp - p
                          b = b - c
                          c = zero
                          cs1 = sab*tau
                          sn1 = sac*tau
                          temp = cs*cs1 - sn*sn1
                          sn = cs*sn1 + sn*cs1
                          cs = temp
                       end if
                    else
                       b = -c
                       c = zero
                       temp = cs
                       cs = -sn
                       sn = temp
                    end if
                 end if
              end if
           end if
           ! store eigenvalues in (rt1r,rt1i) and (rt2r,rt2i).
           rt1r = a
           rt2r = d
           if( c==zero ) then
              rt1i = zero
              rt2i = zero
           else
              rt1i = sqrt( abs( b ) )*sqrt( abs( c ) )
              rt2i = -rt1i
           end if
           return
     end subroutine stdlib_slanv2

     module pure subroutine stdlib_dlanv2( a, b, c, d, rt1r, rt1i, rt2r, rt2i, cs, sn )
     !! DLANV2 computes the Schur factorization of a real 2-by-2 nonsymmetric
     !! matrix in standard form:
     !! [ A  B ] = [ CS -SN ] [ AA  BB ] [ CS  SN ]
     !! [ C  D ]   [ SN  CS ] [ CC  DD ] [-SN  CS ]
     !! where either
     !! 1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or
     !! 2) AA = DD and BB*CC < 0, so that AA + or - sqrt(BB*CC) are complex
     !! conjugate eigenvalues.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(dp), intent(inout) :: a, b, c, d
           real(dp), intent(out) :: cs, rt1i, rt1r, rt2i, rt2r, sn
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: multpl = 4.0e+0_dp
           
           
           ! Local Scalars 
           real(dp) :: aa, bb, bcmax, bcmis, cc, cs1, dd, eps, p, sab, sac, scale, sigma, sn1, &
                     tau, temp, z, safmin, safmn2, safmx2
           integer(ilp) :: count
           ! Intrinsic Functions 
           ! Executable Statements 
           safmin = stdlib_dlamch( 'S' )
           eps = stdlib_dlamch( 'P' )
           safmn2 = stdlib_dlamch( 'B' )**int( log( safmin / eps ) /log( stdlib_dlamch( 'B' ) ) / &
                     two,KIND=ilp)
           safmx2 = one / safmn2
           if( c==zero ) then
              cs = one
              sn = zero
           else if( b==zero ) then
              ! swap rows and columns
              cs = zero
              sn = one
              temp = d
              d = a
              a = temp
              b = -c
              c = zero
           else if( ( a-d )==zero .and. sign( one, b )/=sign( one, c ) )then
              cs = one
              sn = zero
           else
              temp = a - d
              p = half*temp
              bcmax = max( abs( b ), abs( c ) )
              bcmis = min( abs( b ), abs( c ) )*sign( one, b )*sign( one, c )
              scale = max( abs( p ), bcmax )
              z = ( p / scale )*p + ( bcmax / scale )*bcmis
              ! if z is of the order of the machine accuracy, postpone the
              ! decision on the nature of eigenvalues
              if( z>=multpl*eps ) then
                 ! real eigenvalues. compute a and d.
                 z = p + sign( sqrt( scale )*sqrt( z ), p )
                 a = d + z
                 d = d - ( bcmax / z )*bcmis
                 ! compute b and the rotation matrix
                 tau = stdlib_dlapy2( c, z )
                 cs = z / tau
                 sn = c / tau
                 b = b - c
                 c = zero
              else
                 ! complex eigenvalues, or real(almost,KIND=dp) equal eigenvalues.
                 ! make diagonal elements equal.
                 count = 0
                 sigma = b + c
                 10 continue
                 count = count + 1
                 scale = max( abs(temp), abs(sigma) )
                 if( scale>=safmx2 ) then
                    sigma = sigma * safmn2
                    temp = temp * safmn2
                    if (count <= 20)goto 10
                 end if
                 if( scale<=safmn2 ) then
                    sigma = sigma * safmx2
                    temp = temp * safmx2
                    if (count <= 20)goto 10
                 end if
                 p = half*temp
                 tau = stdlib_dlapy2( sigma, temp )
                 cs = sqrt( half*( one+abs( sigma ) / tau ) )
                 sn = -( p / ( tau*cs ) )*sign( one, sigma )
                 ! compute [ aa  bb ] = [ a  b ] [ cs -sn ]
                         ! [ cc  dd ]   [ c  d ] [ sn  cs ]
                 aa = a*cs + b*sn
                 bb = -a*sn + b*cs
                 cc = c*cs + d*sn
                 dd = -c*sn + d*cs
                 ! compute [ a  b ] = [ cs  sn ] [ aa  bb ]
                         ! [ c  d ]   [-sn  cs ] [ cc  dd ]
                 a = aa*cs + cc*sn
                 b = bb*cs + dd*sn
                 c = -aa*sn + cc*cs
                 d = -bb*sn + dd*cs
                 temp = half*( a+d )
                 a = temp
                 d = temp
                 if( c/=zero ) then
                    if( b/=zero ) then
                       if( sign( one, b )==sign( one, c ) ) then
                          ! real eigenvalues: reduce to upper triangular form
                          sab = sqrt( abs( b ) )
                          sac = sqrt( abs( c ) )
                          p = sign( sab*sac, c )
                          tau = one / sqrt( abs( b+c ) )
                          a = temp + p
                          d = temp - p
                          b = b - c
                          c = zero
                          cs1 = sab*tau
                          sn1 = sac*tau
                          temp = cs*cs1 - sn*sn1
                          sn = cs*sn1 + sn*cs1
                          cs = temp
                       end if
                    else
                       b = -c
                       c = zero
                       temp = cs
                       cs = -sn
                       sn = temp
                    end if
                 end if
              end if
           end if
           ! store eigenvalues in (rt1r,rt1i) and (rt2r,rt2i).
           rt1r = a
           rt2r = d
           if( c==zero ) then
              rt1i = zero
              rt2i = zero
           else
              rt1i = sqrt( abs( b ) )*sqrt( abs( c ) )
              rt2i = -rt1i
           end if
           return
     end subroutine stdlib_dlanv2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$lanv2( a, b, c, d, rt1r, rt1i, rt2r, rt2i, cs, sn )
     !! DLANV2: computes the Schur factorization of a real 2-by-2 nonsymmetric
     !! matrix in standard form:
     !! [ A  B ] = [ CS -SN ] [ AA  BB ] [ CS  SN ]
     !! [ C  D ]   [ SN  CS ] [ CC  DD ] [-SN  CS ]
     !! where either
     !! 1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or
     !! 2) AA = DD and BB*CC < 0, so that AA + or - sqrt(BB*CC) are complex
     !! conjugate eigenvalues.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(${rk}$), intent(inout) :: a, b, c, d
           real(${rk}$), intent(out) :: cs, rt1i, rt1r, rt2i, rt2r, sn
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: multpl = 4.0e+0_${rk}$
           
           
           ! Local Scalars 
           real(${rk}$) :: aa, bb, bcmax, bcmis, cc, cs1, dd, eps, p, sab, sac, scale, sigma, sn1, &
                     tau, temp, z, safmin, safmn2, safmx2
           integer(ilp) :: count
           ! Intrinsic Functions 
           ! Executable Statements 
           safmin = stdlib_${ri}$lamch( 'S' )
           eps = stdlib_${ri}$lamch( 'P' )
           safmn2 = stdlib_${ri}$lamch( 'B' )**int( log( safmin / eps ) /log( stdlib_${ri}$lamch( 'B' ) ) / &
                     two,KIND=ilp)
           safmx2 = one / safmn2
           if( c==zero ) then
              cs = one
              sn = zero
           else if( b==zero ) then
              ! swap rows and columns
              cs = zero
              sn = one
              temp = d
              d = a
              a = temp
              b = -c
              c = zero
           else if( ( a-d )==zero .and. sign( one, b )/=sign( one, c ) )then
              cs = one
              sn = zero
           else
              temp = a - d
              p = half*temp
              bcmax = max( abs( b ), abs( c ) )
              bcmis = min( abs( b ), abs( c ) )*sign( one, b )*sign( one, c )
              scale = max( abs( p ), bcmax )
              z = ( p / scale )*p + ( bcmax / scale )*bcmis
              ! if z is of the order of the machine accuracy, postpone the
              ! decision on the nature of eigenvalues
              if( z>=multpl*eps ) then
                 ! real eigenvalues. compute a and d.
                 z = p + sign( sqrt( scale )*sqrt( z ), p )
                 a = d + z
                 d = d - ( bcmax / z )*bcmis
                 ! compute b and the rotation matrix
                 tau = stdlib_${ri}$lapy2( c, z )
                 cs = z / tau
                 sn = c / tau
                 b = b - c
                 c = zero
              else
                 ! complex eigenvalues, or real(almost,KIND=${rk}$) equal eigenvalues.
                 ! make diagonal elements equal.
                 count = 0
                 sigma = b + c
                 10 continue
                 count = count + 1
                 scale = max( abs(temp), abs(sigma) )
                 if( scale>=safmx2 ) then
                    sigma = sigma * safmn2
                    temp = temp * safmn2
                    if (count <= 20)goto 10
                 end if
                 if( scale<=safmn2 ) then
                    sigma = sigma * safmx2
                    temp = temp * safmx2
                    if (count <= 20)goto 10
                 end if
                 p = half*temp
                 tau = stdlib_${ri}$lapy2( sigma, temp )
                 cs = sqrt( half*( one+abs( sigma ) / tau ) )
                 sn = -( p / ( tau*cs ) )*sign( one, sigma )
                 ! compute [ aa  bb ] = [ a  b ] [ cs -sn ]
                         ! [ cc  dd ]   [ c  d ] [ sn  cs ]
                 aa = a*cs + b*sn
                 bb = -a*sn + b*cs
                 cc = c*cs + d*sn
                 dd = -c*sn + d*cs
                 ! compute [ a  b ] = [ cs  sn ] [ aa  bb ]
                         ! [ c  d ]   [-sn  cs ] [ cc  dd ]
                 a = aa*cs + cc*sn
                 b = bb*cs + dd*sn
                 c = -aa*sn + cc*cs
                 d = -bb*sn + dd*cs
                 temp = half*( a+d )
                 a = temp
                 d = temp
                 if( c/=zero ) then
                    if( b/=zero ) then
                       if( sign( one, b )==sign( one, c ) ) then
                          ! real eigenvalues: reduce to upper triangular form
                          sab = sqrt( abs( b ) )
                          sac = sqrt( abs( c ) )
                          p = sign( sab*sac, c )
                          tau = one / sqrt( abs( b+c ) )
                          a = temp + p
                          d = temp - p
                          b = b - c
                          c = zero
                          cs1 = sab*tau
                          sn1 = sac*tau
                          temp = cs*cs1 - sn*sn1
                          sn = cs*sn1 + sn*cs1
                          cs = temp
                       end if
                    else
                       b = -c
                       c = zero
                       temp = cs
                       cs = -sn
                       sn = temp
                    end if
                 end if
              end if
           end if
           ! store eigenvalues in (rt1r,rt1i) and (rt2r,rt2i).
           rt1r = a
           rt2r = d
           if( c==zero ) then
              rt1i = zero
              rt2i = zero
           else
              rt1i = sqrt( abs( b ) )*sqrt( abs( c ) )
              rt2i = -rt1i
           end if
           return
     end subroutine stdlib_${ri}$lanv2

#:endif
#:endfor



     module pure subroutine stdlib_sgehd2( n, ilo, ihi, a, lda, tau, work, info )
     !! SGEHD2 reduces a real general matrix A to upper Hessenberg form H by
     !! an orthogonal similarity transformation:  Q**T * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(sp) :: aii
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGEHD2', -info )
              return
           end if
           do i = ilo, ihi - 1
              ! compute elementary reflector h(i) to annihilate a(i+2:ihi,i)
              call stdlib_slarfg( ihi-i, a( i+1, i ), a( min( i+2, n ), i ), 1,tau( i ) )
              aii = a( i+1, i )
              a( i+1, i ) = one
              ! apply h(i) to a(1:ihi,i+1:ihi) from the right
              call stdlib_slarf( 'RIGHT', ihi, ihi-i, a( i+1, i ), 1, tau( i ),a( 1, i+1 ), lda, &
                        work )
              ! apply h(i) to a(i+1:ihi,i+1:n) from the left
              call stdlib_slarf( 'LEFT', ihi-i, n-i, a( i+1, i ), 1, tau( i ),a( i+1, i+1 ), lda, &
                        work )
              a( i+1, i ) = aii
           end do
           return
     end subroutine stdlib_sgehd2

     module pure subroutine stdlib_dgehd2( n, ilo, ihi, a, lda, tau, work, info )
     !! DGEHD2 reduces a real general matrix A to upper Hessenberg form H by
     !! an orthogonal similarity transformation:  Q**T * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(dp) :: aii
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEHD2', -info )
              return
           end if
           do i = ilo, ihi - 1
              ! compute elementary reflector h(i) to annihilate a(i+2:ihi,i)
              call stdlib_dlarfg( ihi-i, a( i+1, i ), a( min( i+2, n ), i ), 1,tau( i ) )
              aii = a( i+1, i )
              a( i+1, i ) = one
              ! apply h(i) to a(1:ihi,i+1:ihi) from the right
              call stdlib_dlarf( 'RIGHT', ihi, ihi-i, a( i+1, i ), 1, tau( i ),a( 1, i+1 ), lda, &
                        work )
              ! apply h(i) to a(i+1:ihi,i+1:n) from the left
              call stdlib_dlarf( 'LEFT', ihi-i, n-i, a( i+1, i ), 1, tau( i ),a( i+1, i+1 ), lda, &
                        work )
              a( i+1, i ) = aii
           end do
           return
     end subroutine stdlib_dgehd2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$gehd2( n, ilo, ihi, a, lda, tau, work, info )
     !! DGEHD2: reduces a real general matrix A to upper Hessenberg form H by
     !! an orthogonal similarity transformation:  Q**T * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(${rk}$) :: aii
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEHD2', -info )
              return
           end if
           do i = ilo, ihi - 1
              ! compute elementary reflector h(i) to annihilate a(i+2:ihi,i)
              call stdlib_${ri}$larfg( ihi-i, a( i+1, i ), a( min( i+2, n ), i ), 1,tau( i ) )
              aii = a( i+1, i )
              a( i+1, i ) = one
              ! apply h(i) to a(1:ihi,i+1:ihi) from the right
              call stdlib_${ri}$larf( 'RIGHT', ihi, ihi-i, a( i+1, i ), 1, tau( i ),a( 1, i+1 ), lda, &
                        work )
              ! apply h(i) to a(i+1:ihi,i+1:n) from the left
              call stdlib_${ri}$larf( 'LEFT', ihi-i, n-i, a( i+1, i ), 1, tau( i ),a( i+1, i+1 ), lda, &
                        work )
              a( i+1, i ) = aii
           end do
           return
     end subroutine stdlib_${ri}$gehd2

#:endif
#:endfor

     module pure subroutine stdlib_cgehd2( n, ilo, ihi, a, lda, tau, work, info )
     !! CGEHD2 reduces a complex general matrix A to upper Hessenberg form H
     !! by a unitary similarity transformation:  Q**H * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           complex(sp) :: alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEHD2', -info )
              return
           end if
           do i = ilo, ihi - 1
              ! compute elementary reflector h(i) to annihilate a(i+2:ihi,i)
              alpha = a( i+1, i )
              call stdlib_clarfg( ihi-i, alpha, a( min( i+2, n ), i ), 1, tau( i ) )
              a( i+1, i ) = cone
              ! apply h(i) to a(1:ihi,i+1:ihi) from the right
              call stdlib_clarf( 'RIGHT', ihi, ihi-i, a( i+1, i ), 1, tau( i ),a( 1, i+1 ), lda, &
                        work )
              ! apply h(i)**h to a(i+1:ihi,i+1:n) from the left
              call stdlib_clarf( 'LEFT', ihi-i, n-i, a( i+1, i ), 1,conjg( tau( i ) ), a( i+1, i+&
                        1 ), lda, work )
              a( i+1, i ) = alpha
           end do
           return
     end subroutine stdlib_cgehd2

     module pure subroutine stdlib_zgehd2( n, ilo, ihi, a, lda, tau, work, info )
     !! ZGEHD2 reduces a complex general matrix A to upper Hessenberg form H
     !! by a unitary similarity transformation:  Q**H * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           complex(dp) :: alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEHD2', -info )
              return
           end if
           do i = ilo, ihi - 1
              ! compute elementary reflector h(i) to annihilate a(i+2:ihi,i)
              alpha = a( i+1, i )
              call stdlib_zlarfg( ihi-i, alpha, a( min( i+2, n ), i ), 1, tau( i ) )
              a( i+1, i ) = cone
              ! apply h(i) to a(1:ihi,i+1:ihi) from the right
              call stdlib_zlarf( 'RIGHT', ihi, ihi-i, a( i+1, i ), 1, tau( i ),a( 1, i+1 ), lda, &
                        work )
              ! apply h(i)**h to a(i+1:ihi,i+1:n) from the left
              call stdlib_zlarf( 'LEFT', ihi-i, n-i, a( i+1, i ), 1,conjg( tau( i ) ), a( i+1, i+&
                        1 ), lda, work )
              a( i+1, i ) = alpha
           end do
           return
     end subroutine stdlib_zgehd2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$gehd2( n, ilo, ihi, a, lda, tau, work, info )
     !! ZGEHD2: reduces a complex general matrix A to upper Hessenberg form H
     !! by a unitary similarity transformation:  Q**H * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           complex(${ck}$) :: alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEHD2', -info )
              return
           end if
           do i = ilo, ihi - 1
              ! compute elementary reflector h(i) to annihilate a(i+2:ihi,i)
              alpha = a( i+1, i )
              call stdlib_${ci}$larfg( ihi-i, alpha, a( min( i+2, n ), i ), 1, tau( i ) )
              a( i+1, i ) = cone
              ! apply h(i) to a(1:ihi,i+1:ihi) from the right
              call stdlib_${ci}$larf( 'RIGHT', ihi, ihi-i, a( i+1, i ), 1, tau( i ),a( 1, i+1 ), lda, &
                        work )
              ! apply h(i)**h to a(i+1:ihi,i+1:n) from the left
              call stdlib_${ci}$larf( 'LEFT', ihi-i, n-i, a( i+1, i ), 1,conjg( tau( i ) ), a( i+1, i+&
                        1 ), lda, work )
              a( i+1, i ) = alpha
           end do
           return
     end subroutine stdlib_${ci}$gehd2

#:endif
#:endfor



     module pure subroutine stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, j1, n1, n2, &
     !! STGEX2 swaps adjacent diagonal blocks (A11, B11) and (A22, B22)
     !! of size 1-by-1 or 2-by-2 in an upper (quasi) triangular matrix pair
     !! (A, B) by an orthogonal equivalence transformation.
     !! (A, B) must be in generalized real Schur canonical form (as returned
     !! by SGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
     !! diagonal blocks. B is upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T
     !! Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T
               work, lwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: j1, lda, ldb, ldq, ldz, lwork, n, n1, n2
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_scopy by calls to stdlib_slaset, or by do
        ! loops. sven hammarling, 1/5/02.
           ! Parameters 
           real(sp), parameter :: twenty = 2.0e+01_sp
           integer(ilp), parameter :: ldst = 4
           logical(lk), parameter :: wands = .true.
           
           
           
           
           ! Local Scalars 
           logical(lk) :: strong, weak
           integer(ilp) :: i, idum, linfo, m
           real(sp) :: bqra21, brqa21, ddum, dnorma, dnormb, dscale, dsum, eps, f, g, sa, sb, &
                     scale, smlnum, thresha, threshb
           ! Local Arrays 
           integer(ilp) :: iwork(ldst)
           real(sp) :: ai(2), ar(2), be(2), ir(ldst,ldst), ircop(ldst,ldst), li(ldst,ldst), licop(&
           ldst,ldst), s(ldst,ldst), scpy(ldst,ldst), t(ldst,ldst), taul(ldst), taur(ldst), tcpy(&
                     ldst,ldst)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=1 .or. n1<=0 .or. n2<=0 )return
           if( n1>n .or. ( j1+n1 )>n )return
           m = n1 + n2
           if( lwork<max( n*m, m*m*2 ) ) then
              info = -16
              work( 1 ) = max( n*m, m*m*2 )
              return
           end if
           weak = .false.
           strong = .false.
           ! make a local copy of selected block
           call stdlib_slaset( 'FULL', ldst, ldst, zero, zero, li, ldst )
           call stdlib_slaset( 'FULL', ldst, ldst, zero, zero, ir, ldst )
           call stdlib_slacpy( 'FULL', m, m, a( j1, j1 ), lda, s, ldst )
           call stdlib_slacpy( 'FULL', m, m, b( j1, j1 ), ldb, t, ldst )
           ! compute threshold for testing acceptance of swapping.
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' ) / eps
           dscale = zero
           dsum = one
           call stdlib_slacpy( 'FULL', m, m, s, ldst, work, m )
           call stdlib_slassq( m*m, work, 1, dscale, dsum )
           dnorma = dscale*sqrt( dsum )
           dscale = zero
           dsum = one
           call stdlib_slacpy( 'FULL', m, m, t, ldst, work, m )
           call stdlib_slassq( m*m, work, 1, dscale, dsum )
           dnormb = dscale*sqrt( dsum )
           ! thres has been changed from
              ! thresh = max( ten*eps*sa, smlnum )
           ! to
              ! thresh = max( twenty*eps*sa, smlnum )
           ! on 04/01/10.
           ! "bug" reported by ondra kamenik, confirmed by julie langou, fixed by
           ! jim demmel and guillaume revy. see forum post 1783.
           thresha = max( twenty*eps*dnorma, smlnum )
           threshb = max( twenty*eps*dnormb, smlnum )
           if( m==2 ) then
              ! case 1: swap 1-by-1 and 1-by-1 blocks.
              ! compute orthogonal ql and rq that swap 1-by-1 and 1-by-1 blocks
              ! using givens rotations and perform the swap tentatively.
              f = s( 2, 2 )*t( 1, 1 ) - t( 2, 2 )*s( 1, 1 )
              g = s( 2, 2 )*t( 1, 2 ) - t( 2, 2 )*s( 1, 2 )
              sa = abs( s( 2, 2 ) ) * abs( t( 1, 1 ) )
              sb = abs( s( 1, 1 ) ) * abs( t( 2, 2 ) )
              call stdlib_slartg( f, g, ir( 1, 2 ), ir( 1, 1 ), ddum )
              ir( 2, 1 ) = -ir( 1, 2 )
              ir( 2, 2 ) = ir( 1, 1 )
              call stdlib_srot( 2, s( 1, 1 ), 1, s( 1, 2 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
              call stdlib_srot( 2, t( 1, 1 ), 1, t( 1, 2 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
              if( sa>=sb ) then
                 call stdlib_slartg( s( 1, 1 ), s( 2, 1 ), li( 1, 1 ), li( 2, 1 ),ddum )
              else
                 call stdlib_slartg( t( 1, 1 ), t( 2, 1 ), li( 1, 1 ), li( 2, 1 ),ddum )
              end if
              call stdlib_srot( 2, s( 1, 1 ), ldst, s( 2, 1 ), ldst, li( 1, 1 ),li( 2, 1 ) )
                        
              call stdlib_srot( 2, t( 1, 1 ), ldst, t( 2, 1 ), ldst, li( 1, 1 ),li( 2, 1 ) )
                        
              li( 2, 2 ) = li( 1, 1 )
              li( 1, 2 ) = -li( 2, 1 )
              ! weak stability test: |s21| <= o(eps f-norm((a)))
                                 ! and  |t21| <= o(eps f-norm((b)))
              weak = abs( s( 2, 1 ) ) <= thresha .and.abs( t( 2, 1 ) ) <= threshb
              if( .not.weak )go to 70
              if( wands ) then
                 ! strong stability test:
                     ! f-norm((a-ql**h*s*qr)) <= o(eps*f-norm((a)))
                     ! and
                     ! f-norm((b-ql**h*t*qr)) <= o(eps*f-norm((b)))
                 call stdlib_slacpy( 'FULL', m, m, a( j1, j1 ), lda, work( m*m+1 ),m )
                 call stdlib_sgemm( 'N', 'N', m, m, m, one, li, ldst, s, ldst, zero,work, m )
                           
                 call stdlib_sgemm( 'N', 'T', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_slassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sa = dscale*sqrt( dsum )
                 call stdlib_slacpy( 'FULL', m, m, b( j1, j1 ), ldb, work( m*m+1 ),m )
                 call stdlib_sgemm( 'N', 'N', m, m, m, one, li, ldst, t, ldst, zero,work, m )
                           
                 call stdlib_sgemm( 'N', 'T', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_slassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sb = dscale*sqrt( dsum )
                 strong = sa<=thresha .and. sb<=threshb
                 if( .not.strong )go to 70
              end if
              ! update (a(j1:j1+m-1, m+j1:n), b(j1:j1+m-1, m+j1:n)) and
                     ! (a(1:j1-1, j1:j1+m), b(1:j1-1, j1:j1+m)).
              call stdlib_srot( j1+1, a( 1, j1 ), 1, a( 1, j1+1 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
                        
              call stdlib_srot( j1+1, b( 1, j1 ), 1, b( 1, j1+1 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
                        
              call stdlib_srot( n-j1+1, a( j1, j1 ), lda, a( j1+1, j1 ), lda,li( 1, 1 ), li( 2, 1 &
                        ) )
              call stdlib_srot( n-j1+1, b( j1, j1 ), ldb, b( j1+1, j1 ), ldb,li( 1, 1 ), li( 2, 1 &
                        ) )
              ! set  n1-by-n2 (2,1) - blocks to zero.
              a( j1+1, j1 ) = zero
              b( j1+1, j1 ) = zero
              ! accumulate transformations into q and z if requested.
              if( wantz )call stdlib_srot( n, z( 1, j1 ), 1, z( 1, j1+1 ), 1, ir( 1, 1 ),ir( 2, 1 &
                        ) )
              if( wantq )call stdlib_srot( n, q( 1, j1 ), 1, q( 1, j1+1 ), 1, li( 1, 1 ),li( 2, 1 &
                        ) )
              ! exit with info = 0 if swap was successfully performed.
              return
           else
              ! case 2: swap 1-by-1 and 2-by-2 blocks, or 2-by-2
                      ! and 2-by-2 blocks.
              ! solve the generalized sylvester equation
                       ! s11 * r - l * s22 = scale * s12
                       ! t11 * r - l * t22 = scale * t12
              ! for r and l. solutions in li and ir.
              call stdlib_slacpy( 'FULL', n1, n2, t( 1, n1+1 ), ldst, li, ldst )
              call stdlib_slacpy( 'FULL', n1, n2, s( 1, n1+1 ), ldst,ir( n2+1, n1+1 ), ldst )
                        
              call stdlib_stgsy2( 'N', 0, n1, n2, s, ldst, s( n1+1, n1+1 ), ldst,ir( n2+1, n1+1 ),&
               ldst, t, ldst, t( n1+1, n1+1 ),ldst, li, ldst, scale, dsum, dscale, iwork, idum,&
                         linfo )
              if( linfo/=0 )go to 70
              ! compute orthogonal matrix ql:
                          ! ql**t * li = [ tl ]
                                       ! [ 0  ]
              ! where
                          ! li =  [      -l              ]
                                ! [ scale * identity(n2) ]
              do i = 1, n2
                 call stdlib_sscal( n1, -one, li( 1, i ), 1 )
                 li( n1+i, i ) = scale
              end do
              call stdlib_sgeqr2( m, n2, li, ldst, taul, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_sorg2r( m, m, n2, li, ldst, taul, work, linfo )
              if( linfo/=0 )go to 70
              ! compute orthogonal matrix rq:
                          ! ir * rq**t =   [ 0  tr],
               ! where ir = [ scale * identity(n1), r ]
              do i = 1, n1
                 ir( n2+i, i ) = scale
              end do
              call stdlib_sgerq2( n1, m, ir( n2+1, 1 ), ldst, taur, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_sorgr2( m, m, n1, ir, ldst, taur, work, linfo )
              if( linfo/=0 )go to 70
              ! perform the swapping tentatively:
              call stdlib_sgemm( 'T', 'N', m, m, m, one, li, ldst, s, ldst, zero,work, m )
              call stdlib_sgemm( 'N', 'T', m, m, m, one, work, m, ir, ldst, zero, s,ldst )
              call stdlib_sgemm( 'T', 'N', m, m, m, one, li, ldst, t, ldst, zero,work, m )
              call stdlib_sgemm( 'N', 'T', m, m, m, one, work, m, ir, ldst, zero, t,ldst )
              call stdlib_slacpy( 'F', m, m, s, ldst, scpy, ldst )
              call stdlib_slacpy( 'F', m, m, t, ldst, tcpy, ldst )
              call stdlib_slacpy( 'F', m, m, ir, ldst, ircop, ldst )
              call stdlib_slacpy( 'F', m, m, li, ldst, licop, ldst )
              ! triangularize the b-part by an rq factorization.
              ! apply transformation (from left) to a-part, giving s.
              call stdlib_sgerq2( m, m, t, ldst, taur, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_sormr2( 'R', 'T', m, m, m, t, ldst, taur, s, ldst, work,linfo )
              if( linfo/=0 )go to 70
              call stdlib_sormr2( 'L', 'N', m, m, m, t, ldst, taur, ir, ldst, work,linfo )
              if( linfo/=0 )go to 70
              ! compute f-norm(s21) in brqa21. (t21 is 0.)
              dscale = zero
              dsum = one
              do i = 1, n2
                 call stdlib_slassq( n1, s( n2+1, i ), 1, dscale, dsum )
              end do
              brqa21 = dscale*sqrt( dsum )
              ! triangularize the b-part by a qr factorization.
              ! apply transformation (from right) to a-part, giving s.
              call stdlib_sgeqr2( m, m, tcpy, ldst, taul, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_sorm2r( 'L', 'T', m, m, m, tcpy, ldst, taul, scpy, ldst,work, info )
                        
              call stdlib_sorm2r( 'R', 'N', m, m, m, tcpy, ldst, taul, licop, ldst,work, info )
                        
              if( linfo/=0 )go to 70
              ! compute f-norm(s21) in bqra21. (t21 is 0.)
              dscale = zero
              dsum = one
              do i = 1, n2
                 call stdlib_slassq( n1, scpy( n2+1, i ), 1, dscale, dsum )
              end do
              bqra21 = dscale*sqrt( dsum )
              ! decide which method to use.
                ! weak stability test:
                   ! f-norm(s21) <= o(eps * f-norm((s)))
              if( bqra21<=brqa21 .and. bqra21<=thresha ) then
                 call stdlib_slacpy( 'F', m, m, scpy, ldst, s, ldst )
                 call stdlib_slacpy( 'F', m, m, tcpy, ldst, t, ldst )
                 call stdlib_slacpy( 'F', m, m, ircop, ldst, ir, ldst )
                 call stdlib_slacpy( 'F', m, m, licop, ldst, li, ldst )
              else if( brqa21>=thresha ) then
                 go to 70
              end if
              ! set lower triangle of b-part to zero
              if (m>1) call stdlib_slaset( 'LOWER', m-1, m-1, zero, zero, t(2,1), ldst )
              if( wands ) then
                 ! strong stability test:
                     ! f-norm((a-ql**h*s*qr)) <= o(eps*f-norm((a)))
                     ! and
                     ! f-norm((b-ql**h*t*qr)) <= o(eps*f-norm((b)))
                 call stdlib_slacpy( 'FULL', m, m, a( j1, j1 ), lda, work( m*m+1 ),m )
                 call stdlib_sgemm( 'N', 'N', m, m, m, one, li, ldst, s, ldst, zero,work, m )
                           
                 call stdlib_sgemm( 'N', 'N', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_slassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sa = dscale*sqrt( dsum )
                 call stdlib_slacpy( 'FULL', m, m, b( j1, j1 ), ldb, work( m*m+1 ),m )
                 call stdlib_sgemm( 'N', 'N', m, m, m, one, li, ldst, t, ldst, zero,work, m )
                           
                 call stdlib_sgemm( 'N', 'N', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_slassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sb = dscale*sqrt( dsum )
                 strong = sa<=thresha .and. sb<=threshb
                 if( .not.strong )go to 70
              end if
              ! if the swap is accepted ("weakly" and "strongly"), apply the
              ! transformations and set n1-by-n2 (2,1)-block to zero.
              call stdlib_slaset( 'FULL', n1, n2, zero, zero, s(n2+1,1), ldst )
              ! copy back m-by-m diagonal block starting at index j1 of (a, b)
              call stdlib_slacpy( 'F', m, m, s, ldst, a( j1, j1 ), lda )
              call stdlib_slacpy( 'F', m, m, t, ldst, b( j1, j1 ), ldb )
              call stdlib_slaset( 'FULL', ldst, ldst, zero, zero, t, ldst )
              ! standardize existing 2-by-2 blocks.
              call stdlib_slaset( 'FULL', m, m, zero, zero, work, m )
              work( 1 ) = one
              t( 1, 1 ) = one
              idum = lwork - m*m - 2
              if( n2>1 ) then
                 call stdlib_slagv2( a( j1, j1 ), lda, b( j1, j1 ), ldb, ar, ai, be,work( 1 ), &
                           work( 2 ), t( 1, 1 ), t( 2, 1 ) )
                 work( m+1 ) = -work( 2 )
                 work( m+2 ) = work( 1 )
                 t( n2, n2 ) = t( 1, 1 )
                 t( 1, 2 ) = -t( 2, 1 )
              end if
              work( m*m ) = one
              t( m, m ) = one
              if( n1>1 ) then
                 call stdlib_slagv2( a( j1+n2, j1+n2 ), lda, b( j1+n2, j1+n2 ), ldb,taur, taul, &
                 work( m*m+1 ), work( n2*m+n2+1 ),work( n2*m+n2+2 ), t( n2+1, n2+1 ),t( m, m-1 ) )
                           
                 work( m*m ) = work( n2*m+n2+1 )
                 work( m*m-1 ) = -work( n2*m+n2+2 )
                 t( m, m ) = t( n2+1, n2+1 )
                 t( m-1, m ) = -t( m, m-1 )
              end if
              call stdlib_sgemm( 'T', 'N', n2, n1, n2, one, work, m, a( j1, j1+n2 ),lda, zero, &
                        work( m*m+1 ), n2 )
              call stdlib_slacpy( 'FULL', n2, n1, work( m*m+1 ), n2, a( j1, j1+n2 ),lda )
              call stdlib_sgemm( 'T', 'N', n2, n1, n2, one, work, m, b( j1, j1+n2 ),ldb, zero, &
                        work( m*m+1 ), n2 )
              call stdlib_slacpy( 'FULL', n2, n1, work( m*m+1 ), n2, b( j1, j1+n2 ),ldb )
              call stdlib_sgemm( 'N', 'N', m, m, m, one, li, ldst, work, m, zero,work( m*m+1 ), m &
                        )
              call stdlib_slacpy( 'FULL', m, m, work( m*m+1 ), m, li, ldst )
              call stdlib_sgemm( 'N', 'N', n2, n1, n1, one, a( j1, j1+n2 ), lda,t( n2+1, n2+1 ), &
                        ldst, zero, work, n2 )
              call stdlib_slacpy( 'FULL', n2, n1, work, n2, a( j1, j1+n2 ), lda )
              call stdlib_sgemm( 'N', 'N', n2, n1, n1, one, b( j1, j1+n2 ), ldb,t( n2+1, n2+1 ), &
                        ldst, zero, work, n2 )
              call stdlib_slacpy( 'FULL', n2, n1, work, n2, b( j1, j1+n2 ), ldb )
              call stdlib_sgemm( 'T', 'N', m, m, m, one, ir, ldst, t, ldst, zero,work, m )
              call stdlib_slacpy( 'FULL', m, m, work, m, ir, ldst )
              ! accumulate transformations into q and z if requested.
              if( wantq ) then
                 call stdlib_sgemm( 'N', 'N', n, m, m, one, q( 1, j1 ), ldq, li,ldst, zero, work, &
                           n )
                 call stdlib_slacpy( 'FULL', n, m, work, n, q( 1, j1 ), ldq )
              end if
              if( wantz ) then
                 call stdlib_sgemm( 'N', 'N', n, m, m, one, z( 1, j1 ), ldz, ir,ldst, zero, work, &
                           n )
                 call stdlib_slacpy( 'FULL', n, m, work, n, z( 1, j1 ), ldz )
              end if
              ! update (a(j1:j1+m-1, m+j1:n), b(j1:j1+m-1, m+j1:n)) and
                      ! (a(1:j1-1, j1:j1+m), b(1:j1-1, j1:j1+m)).
              i = j1 + m
              if( i<=n ) then
                 call stdlib_sgemm( 'T', 'N', m, n-i+1, m, one, li, ldst,a( j1, i ), lda, zero, &
                           work, m )
                 call stdlib_slacpy( 'FULL', m, n-i+1, work, m, a( j1, i ), lda )
                 call stdlib_sgemm( 'T', 'N', m, n-i+1, m, one, li, ldst,b( j1, i ), ldb, zero, &
                           work, m )
                 call stdlib_slacpy( 'FULL', m, n-i+1, work, m, b( j1, i ), ldb )
              end if
              i = j1 - 1
              if( i>0 ) then
                 call stdlib_sgemm( 'N', 'N', i, m, m, one, a( 1, j1 ), lda, ir,ldst, zero, work, &
                           i )
                 call stdlib_slacpy( 'FULL', i, m, work, i, a( 1, j1 ), lda )
                 call stdlib_sgemm( 'N', 'N', i, m, m, one, b( 1, j1 ), ldb, ir,ldst, zero, work, &
                           i )
                 call stdlib_slacpy( 'FULL', i, m, work, i, b( 1, j1 ), ldb )
              end if
              ! exit with info = 0 if swap was successfully performed.
              return
           end if
           ! exit with info = 1 if swap was rejected.
           70 continue
           info = 1
           return
     end subroutine stdlib_stgex2

     module pure subroutine stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, j1, n1, n2, &
     !! DTGEX2 swaps adjacent diagonal blocks (A11, B11) and (A22, B22)
     !! of size 1-by-1 or 2-by-2 in an upper (quasi) triangular matrix pair
     !! (A, B) by an orthogonal equivalence transformation.
     !! (A, B) must be in generalized real Schur canonical form (as returned
     !! by DGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
     !! diagonal blocks. B is upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T
     !! Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T
               work, lwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: j1, lda, ldb, ldq, ldz, lwork, n, n1, n2
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_dcopy by calls to stdlib_dlaset, or by do
        ! loops. sven hammarling, 1/5/02.
           ! Parameters 
           real(dp), parameter :: twenty = 2.0e+01_dp
           integer(ilp), parameter :: ldst = 4
           logical(lk), parameter :: wands = .true.
           
           
           
           
           ! Local Scalars 
           logical(lk) :: strong, weak
           integer(ilp) :: i, idum, linfo, m
           real(dp) :: bqra21, brqa21, ddum, dnorma, dnormb, dscale, dsum, eps, f, g, sa, sb, &
                     scale, smlnum, thresha, threshb
           ! Local Arrays 
           integer(ilp) :: iwork(ldst)
           real(dp) :: ai(2), ar(2), be(2), ir(ldst,ldst), ircop(ldst,ldst), li(ldst,ldst), licop(&
           ldst,ldst), s(ldst,ldst), scpy(ldst,ldst), t(ldst,ldst), taul(ldst), taur(ldst), tcpy(&
                     ldst,ldst)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=1 .or. n1<=0 .or. n2<=0 )return
           if( n1>n .or. ( j1+n1 )>n )return
           m = n1 + n2
           if( lwork<max( 1, n*m, m*m*2 ) ) then
              info = -16
              work( 1 ) = max( 1, n*m, m*m*2 )
              return
           end if
           weak = .false.
           strong = .false.
           ! make a local copy of selected block
           call stdlib_dlaset( 'FULL', ldst, ldst, zero, zero, li, ldst )
           call stdlib_dlaset( 'FULL', ldst, ldst, zero, zero, ir, ldst )
           call stdlib_dlacpy( 'FULL', m, m, a( j1, j1 ), lda, s, ldst )
           call stdlib_dlacpy( 'FULL', m, m, b( j1, j1 ), ldb, t, ldst )
           ! compute threshold for testing acceptance of swapping.
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' ) / eps
           dscale = zero
           dsum = one
           call stdlib_dlacpy( 'FULL', m, m, s, ldst, work, m )
           call stdlib_dlassq( m*m, work, 1, dscale, dsum )
           dnorma = dscale*sqrt( dsum )
           dscale = zero
           dsum = one
           call stdlib_dlacpy( 'FULL', m, m, t, ldst, work, m )
           call stdlib_dlassq( m*m, work, 1, dscale, dsum )
           dnormb = dscale*sqrt( dsum )
           ! thres has been changed from
              ! thresh = max( ten*eps*sa, smlnum )
           ! to
              ! thresh = max( twenty*eps*sa, smlnum )
           ! on 04/01/10.
           ! "bug" reported by ondra kamenik, confirmed by julie langou, fixed by
           ! jim demmel and guillaume revy. see forum post 1783.
           thresha = max( twenty*eps*dnorma, smlnum )
           threshb = max( twenty*eps*dnormb, smlnum )
           if( m==2 ) then
              ! case 1: swap 1-by-1 and 1-by-1 blocks.
              ! compute orthogonal ql and rq that swap 1-by-1 and 1-by-1 blocks
              ! using givens rotations and perform the swap tentatively.
              f = s( 2, 2 )*t( 1, 1 ) - t( 2, 2 )*s( 1, 1 )
              g = s( 2, 2 )*t( 1, 2 ) - t( 2, 2 )*s( 1, 2 )
              sa = abs( s( 2, 2 ) ) * abs( t( 1, 1 ) )
              sb = abs( s( 1, 1 ) ) * abs( t( 2, 2 ) )
              call stdlib_dlartg( f, g, ir( 1, 2 ), ir( 1, 1 ), ddum )
              ir( 2, 1 ) = -ir( 1, 2 )
              ir( 2, 2 ) = ir( 1, 1 )
              call stdlib_drot( 2, s( 1, 1 ), 1, s( 1, 2 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
              call stdlib_drot( 2, t( 1, 1 ), 1, t( 1, 2 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
              if( sa>=sb ) then
                 call stdlib_dlartg( s( 1, 1 ), s( 2, 1 ), li( 1, 1 ), li( 2, 1 ),ddum )
              else
                 call stdlib_dlartg( t( 1, 1 ), t( 2, 1 ), li( 1, 1 ), li( 2, 1 ),ddum )
              end if
              call stdlib_drot( 2, s( 1, 1 ), ldst, s( 2, 1 ), ldst, li( 1, 1 ),li( 2, 1 ) )
                        
              call stdlib_drot( 2, t( 1, 1 ), ldst, t( 2, 1 ), ldst, li( 1, 1 ),li( 2, 1 ) )
                        
              li( 2, 2 ) = li( 1, 1 )
              li( 1, 2 ) = -li( 2, 1 )
              ! weak stability test: |s21| <= o(eps f-norm((a)))
                                 ! and  |t21| <= o(eps f-norm((b)))
              weak = abs( s( 2, 1 ) ) <= thresha .and.abs( t( 2, 1 ) ) <= threshb
              if( .not.weak )go to 70
              if( wands ) then
                 ! strong stability test:
                     ! f-norm((a-ql**h*s*qr)) <= o(eps*f-norm((a)))
                     ! and
                     ! f-norm((b-ql**h*t*qr)) <= o(eps*f-norm((b)))
                 call stdlib_dlacpy( 'FULL', m, m, a( j1, j1 ), lda, work( m*m+1 ),m )
                 call stdlib_dgemm( 'N', 'N', m, m, m, one, li, ldst, s, ldst, zero,work, m )
                           
                 call stdlib_dgemm( 'N', 'T', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_dlassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sa = dscale*sqrt( dsum )
                 call stdlib_dlacpy( 'FULL', m, m, b( j1, j1 ), ldb, work( m*m+1 ),m )
                 call stdlib_dgemm( 'N', 'N', m, m, m, one, li, ldst, t, ldst, zero,work, m )
                           
                 call stdlib_dgemm( 'N', 'T', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_dlassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sb = dscale*sqrt( dsum )
                 strong = sa<=thresha .and. sb<=threshb
                 if( .not.strong )go to 70
              end if
              ! update (a(j1:j1+m-1, m+j1:n), b(j1:j1+m-1, m+j1:n)) and
                     ! (a(1:j1-1, j1:j1+m), b(1:j1-1, j1:j1+m)).
              call stdlib_drot( j1+1, a( 1, j1 ), 1, a( 1, j1+1 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
                        
              call stdlib_drot( j1+1, b( 1, j1 ), 1, b( 1, j1+1 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
                        
              call stdlib_drot( n-j1+1, a( j1, j1 ), lda, a( j1+1, j1 ), lda,li( 1, 1 ), li( 2, 1 &
                        ) )
              call stdlib_drot( n-j1+1, b( j1, j1 ), ldb, b( j1+1, j1 ), ldb,li( 1, 1 ), li( 2, 1 &
                        ) )
              ! set  n1-by-n2 (2,1) - blocks to zero.
              a( j1+1, j1 ) = zero
              b( j1+1, j1 ) = zero
              ! accumulate transformations into q and z if requested.
              if( wantz )call stdlib_drot( n, z( 1, j1 ), 1, z( 1, j1+1 ), 1, ir( 1, 1 ),ir( 2, 1 &
                        ) )
              if( wantq )call stdlib_drot( n, q( 1, j1 ), 1, q( 1, j1+1 ), 1, li( 1, 1 ),li( 2, 1 &
                        ) )
              ! exit with info = 0 if swap was successfully performed.
              return
           else
              ! case 2: swap 1-by-1 and 2-by-2 blocks, or 2-by-2
                      ! and 2-by-2 blocks.
              ! solve the generalized sylvester equation
                       ! s11 * r - l * s22 = scale * s12
                       ! t11 * r - l * t22 = scale * t12
              ! for r and l. solutions in li and ir.
              call stdlib_dlacpy( 'FULL', n1, n2, t( 1, n1+1 ), ldst, li, ldst )
              call stdlib_dlacpy( 'FULL', n1, n2, s( 1, n1+1 ), ldst,ir( n2+1, n1+1 ), ldst )
                        
              call stdlib_dtgsy2( 'N', 0, n1, n2, s, ldst, s( n1+1, n1+1 ), ldst,ir( n2+1, n1+1 ),&
               ldst, t, ldst, t( n1+1, n1+1 ),ldst, li, ldst, scale, dsum, dscale, iwork, idum,&
                         linfo )
              if( linfo/=0 )go to 70
              ! compute orthogonal matrix ql:
                          ! ql**t * li = [ tl ]
                                       ! [ 0  ]
              ! where
                          ! li =  [      -l              ]
                                ! [ scale * identity(n2) ]
              do i = 1, n2
                 call stdlib_dscal( n1, -one, li( 1, i ), 1 )
                 li( n1+i, i ) = scale
              end do
              call stdlib_dgeqr2( m, n2, li, ldst, taul, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_dorg2r( m, m, n2, li, ldst, taul, work, linfo )
              if( linfo/=0 )go to 70
              ! compute orthogonal matrix rq:
                          ! ir * rq**t =   [ 0  tr],
               ! where ir = [ scale * identity(n1), r ]
              do i = 1, n1
                 ir( n2+i, i ) = scale
              end do
              call stdlib_dgerq2( n1, m, ir( n2+1, 1 ), ldst, taur, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_dorgr2( m, m, n1, ir, ldst, taur, work, linfo )
              if( linfo/=0 )go to 70
              ! perform the swapping tentatively:
              call stdlib_dgemm( 'T', 'N', m, m, m, one, li, ldst, s, ldst, zero,work, m )
              call stdlib_dgemm( 'N', 'T', m, m, m, one, work, m, ir, ldst, zero, s,ldst )
              call stdlib_dgemm( 'T', 'N', m, m, m, one, li, ldst, t, ldst, zero,work, m )
              call stdlib_dgemm( 'N', 'T', m, m, m, one, work, m, ir, ldst, zero, t,ldst )
              call stdlib_dlacpy( 'F', m, m, s, ldst, scpy, ldst )
              call stdlib_dlacpy( 'F', m, m, t, ldst, tcpy, ldst )
              call stdlib_dlacpy( 'F', m, m, ir, ldst, ircop, ldst )
              call stdlib_dlacpy( 'F', m, m, li, ldst, licop, ldst )
              ! triangularize the b-part by an rq factorization.
              ! apply transformation (from left) to a-part, giving s.
              call stdlib_dgerq2( m, m, t, ldst, taur, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_dormr2( 'R', 'T', m, m, m, t, ldst, taur, s, ldst, work,linfo )
              if( linfo/=0 )go to 70
              call stdlib_dormr2( 'L', 'N', m, m, m, t, ldst, taur, ir, ldst, work,linfo )
              if( linfo/=0 )go to 70
              ! compute f-norm(s21) in brqa21. (t21 is 0.)
              dscale = zero
              dsum = one
              do i = 1, n2
                 call stdlib_dlassq( n1, s( n2+1, i ), 1, dscale, dsum )
              end do
              brqa21 = dscale*sqrt( dsum )
              ! triangularize the b-part by a qr factorization.
              ! apply transformation (from right) to a-part, giving s.
              call stdlib_dgeqr2( m, m, tcpy, ldst, taul, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_dorm2r( 'L', 'T', m, m, m, tcpy, ldst, taul, scpy, ldst,work, info )
                        
              call stdlib_dorm2r( 'R', 'N', m, m, m, tcpy, ldst, taul, licop, ldst,work, info )
                        
              if( linfo/=0 )go to 70
              ! compute f-norm(s21) in bqra21. (t21 is 0.)
              dscale = zero
              dsum = one
              do i = 1, n2
                 call stdlib_dlassq( n1, scpy( n2+1, i ), 1, dscale, dsum )
              end do
              bqra21 = dscale*sqrt( dsum )
              ! decide which method to use.
                ! weak stability test:
                   ! f-norm(s21) <= o(eps * f-norm((s)))
              if( bqra21<=brqa21 .and. bqra21<=thresha ) then
                 call stdlib_dlacpy( 'F', m, m, scpy, ldst, s, ldst )
                 call stdlib_dlacpy( 'F', m, m, tcpy, ldst, t, ldst )
                 call stdlib_dlacpy( 'F', m, m, ircop, ldst, ir, ldst )
                 call stdlib_dlacpy( 'F', m, m, licop, ldst, li, ldst )
              else if( brqa21>=thresha ) then
                 go to 70
              end if
              ! set lower triangle of b-part to zero
              call stdlib_dlaset( 'LOWER', m-1, m-1, zero, zero, t(2,1), ldst )
              if( wands ) then
                 ! strong stability test:
                     ! f-norm((a-ql**h*s*qr)) <= o(eps*f-norm((a)))
                     ! and
                     ! f-norm((b-ql**h*t*qr)) <= o(eps*f-norm((b)))
                 call stdlib_dlacpy( 'FULL', m, m, a( j1, j1 ), lda, work( m*m+1 ),m )
                 call stdlib_dgemm( 'N', 'N', m, m, m, one, li, ldst, s, ldst, zero,work, m )
                           
                 call stdlib_dgemm( 'N', 'N', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_dlassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sa = dscale*sqrt( dsum )
                 call stdlib_dlacpy( 'FULL', m, m, b( j1, j1 ), ldb, work( m*m+1 ),m )
                 call stdlib_dgemm( 'N', 'N', m, m, m, one, li, ldst, t, ldst, zero,work, m )
                           
                 call stdlib_dgemm( 'N', 'N', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_dlassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sb = dscale*sqrt( dsum )
                 strong = sa<=thresha .and. sb<=threshb
                 if( .not.strong )go to 70
              end if
              ! if the swap is accepted ("weakly" and "strongly"), apply the
              ! transformations and set n1-by-n2 (2,1)-block to zero.
              call stdlib_dlaset( 'FULL', n1, n2, zero, zero, s(n2+1,1), ldst )
              ! copy back m-by-m diagonal block starting at index j1 of (a, b)
              call stdlib_dlacpy( 'F', m, m, s, ldst, a( j1, j1 ), lda )
              call stdlib_dlacpy( 'F', m, m, t, ldst, b( j1, j1 ), ldb )
              call stdlib_dlaset( 'FULL', ldst, ldst, zero, zero, t, ldst )
              ! standardize existing 2-by-2 blocks.
              call stdlib_dlaset( 'FULL', m, m, zero, zero, work, m )
              work( 1 ) = one
              t( 1, 1 ) = one
              idum = lwork - m*m - 2
              if( n2>1 ) then
                 call stdlib_dlagv2( a( j1, j1 ), lda, b( j1, j1 ), ldb, ar, ai, be,work( 1 ), &
                           work( 2 ), t( 1, 1 ), t( 2, 1 ) )
                 work( m+1 ) = -work( 2 )
                 work( m+2 ) = work( 1 )
                 t( n2, n2 ) = t( 1, 1 )
                 t( 1, 2 ) = -t( 2, 1 )
              end if
              work( m*m ) = one
              t( m, m ) = one
              if( n1>1 ) then
                 call stdlib_dlagv2( a( j1+n2, j1+n2 ), lda, b( j1+n2, j1+n2 ), ldb,taur, taul, &
                 work( m*m+1 ), work( n2*m+n2+1 ),work( n2*m+n2+2 ), t( n2+1, n2+1 ),t( m, m-1 ) )
                           
                 work( m*m ) = work( n2*m+n2+1 )
                 work( m*m-1 ) = -work( n2*m+n2+2 )
                 t( m, m ) = t( n2+1, n2+1 )
                 t( m-1, m ) = -t( m, m-1 )
              end if
              call stdlib_dgemm( 'T', 'N', n2, n1, n2, one, work, m, a( j1, j1+n2 ),lda, zero, &
                        work( m*m+1 ), n2 )
              call stdlib_dlacpy( 'FULL', n2, n1, work( m*m+1 ), n2, a( j1, j1+n2 ),lda )
              call stdlib_dgemm( 'T', 'N', n2, n1, n2, one, work, m, b( j1, j1+n2 ),ldb, zero, &
                        work( m*m+1 ), n2 )
              call stdlib_dlacpy( 'FULL', n2, n1, work( m*m+1 ), n2, b( j1, j1+n2 ),ldb )
              call stdlib_dgemm( 'N', 'N', m, m, m, one, li, ldst, work, m, zero,work( m*m+1 ), m &
                        )
              call stdlib_dlacpy( 'FULL', m, m, work( m*m+1 ), m, li, ldst )
              call stdlib_dgemm( 'N', 'N', n2, n1, n1, one, a( j1, j1+n2 ), lda,t( n2+1, n2+1 ), &
                        ldst, zero, work, n2 )
              call stdlib_dlacpy( 'FULL', n2, n1, work, n2, a( j1, j1+n2 ), lda )
              call stdlib_dgemm( 'N', 'N', n2, n1, n1, one, b( j1, j1+n2 ), ldb,t( n2+1, n2+1 ), &
                        ldst, zero, work, n2 )
              call stdlib_dlacpy( 'FULL', n2, n1, work, n2, b( j1, j1+n2 ), ldb )
              call stdlib_dgemm( 'T', 'N', m, m, m, one, ir, ldst, t, ldst, zero,work, m )
              call stdlib_dlacpy( 'FULL', m, m, work, m, ir, ldst )
              ! accumulate transformations into q and z if requested.
              if( wantq ) then
                 call stdlib_dgemm( 'N', 'N', n, m, m, one, q( 1, j1 ), ldq, li,ldst, zero, work, &
                           n )
                 call stdlib_dlacpy( 'FULL', n, m, work, n, q( 1, j1 ), ldq )
              end if
              if( wantz ) then
                 call stdlib_dgemm( 'N', 'N', n, m, m, one, z( 1, j1 ), ldz, ir,ldst, zero, work, &
                           n )
                 call stdlib_dlacpy( 'FULL', n, m, work, n, z( 1, j1 ), ldz )
              end if
              ! update (a(j1:j1+m-1, m+j1:n), b(j1:j1+m-1, m+j1:n)) and
                      ! (a(1:j1-1, j1:j1+m), b(1:j1-1, j1:j1+m)).
              i = j1 + m
              if( i<=n ) then
                 call stdlib_dgemm( 'T', 'N', m, n-i+1, m, one, li, ldst,a( j1, i ), lda, zero, &
                           work, m )
                 call stdlib_dlacpy( 'FULL', m, n-i+1, work, m, a( j1, i ), lda )
                 call stdlib_dgemm( 'T', 'N', m, n-i+1, m, one, li, ldst,b( j1, i ), ldb, zero, &
                           work, m )
                 call stdlib_dlacpy( 'FULL', m, n-i+1, work, m, b( j1, i ), ldb )
              end if
              i = j1 - 1
              if( i>0 ) then
                 call stdlib_dgemm( 'N', 'N', i, m, m, one, a( 1, j1 ), lda, ir,ldst, zero, work, &
                           i )
                 call stdlib_dlacpy( 'FULL', i, m, work, i, a( 1, j1 ), lda )
                 call stdlib_dgemm( 'N', 'N', i, m, m, one, b( 1, j1 ), ldb, ir,ldst, zero, work, &
                           i )
                 call stdlib_dlacpy( 'FULL', i, m, work, i, b( 1, j1 ), ldb )
              end if
              ! exit with info = 0 if swap was successfully performed.
              return
           end if
           ! exit with info = 1 if swap was rejected.
           70 continue
           info = 1
           return
     end subroutine stdlib_dtgex2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, j1, n1, n2, &
     !! DTGEX2: swaps adjacent diagonal blocks (A11, B11) and (A22, B22)
     !! of size 1-by-1 or 2-by-2 in an upper (quasi) triangular matrix pair
     !! (A, B) by an orthogonal equivalence transformation.
     !! (A, B) must be in generalized real Schur canonical form (as returned
     !! by DGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
     !! diagonal blocks. B is upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T
     !! Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T
               work, lwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: j1, lda, ldb, ldq, ldz, lwork, n, n1, n2
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_${ri}$copy by calls to stdlib_${ri}$laset, or by do
        ! loops. sven hammarling, 1/5/02.
           ! Parameters 
           real(${rk}$), parameter :: twenty = 2.0e+01_${rk}$
           integer(ilp), parameter :: ldst = 4
           logical(lk), parameter :: wands = .true.
           
           
           
           
           ! Local Scalars 
           logical(lk) :: strong, weak
           integer(ilp) :: i, idum, linfo, m
           real(${rk}$) :: bqra21, brqa21, ddum, dnorma, dnormb, dscale, dsum, eps, f, g, sa, sb, &
                     scale, smlnum, thresha, threshb
           ! Local Arrays 
           integer(ilp) :: iwork(ldst)
           real(${rk}$) :: ai(2), ar(2), be(2), ir(ldst,ldst), ircop(ldst,ldst), li(ldst,ldst), licop(&
           ldst,ldst), s(ldst,ldst), scpy(ldst,ldst), t(ldst,ldst), taul(ldst), taur(ldst), tcpy(&
                     ldst,ldst)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=1 .or. n1<=0 .or. n2<=0 )return
           if( n1>n .or. ( j1+n1 )>n )return
           m = n1 + n2
           if( lwork<max( 1, n*m, m*m*2 ) ) then
              info = -16
              work( 1 ) = max( 1, n*m, m*m*2 )
              return
           end if
           weak = .false.
           strong = .false.
           ! make a local copy of selected block
           call stdlib_${ri}$laset( 'FULL', ldst, ldst, zero, zero, li, ldst )
           call stdlib_${ri}$laset( 'FULL', ldst, ldst, zero, zero, ir, ldst )
           call stdlib_${ri}$lacpy( 'FULL', m, m, a( j1, j1 ), lda, s, ldst )
           call stdlib_${ri}$lacpy( 'FULL', m, m, b( j1, j1 ), ldb, t, ldst )
           ! compute threshold for testing acceptance of swapping.
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' ) / eps
           dscale = zero
           dsum = one
           call stdlib_${ri}$lacpy( 'FULL', m, m, s, ldst, work, m )
           call stdlib_${ri}$lassq( m*m, work, 1, dscale, dsum )
           dnorma = dscale*sqrt( dsum )
           dscale = zero
           dsum = one
           call stdlib_${ri}$lacpy( 'FULL', m, m, t, ldst, work, m )
           call stdlib_${ri}$lassq( m*m, work, 1, dscale, dsum )
           dnormb = dscale*sqrt( dsum )
           ! thres has been changed from
              ! thresh = max( ten*eps*sa, smlnum )
           ! to
              ! thresh = max( twenty*eps*sa, smlnum )
           ! on 04/01/10.
           ! "bug" reported by ondra kamenik, confirmed by julie langou, fixed by
           ! jim demmel and guillaume revy. see forum post 1783.
           thresha = max( twenty*eps*dnorma, smlnum )
           threshb = max( twenty*eps*dnormb, smlnum )
           if( m==2 ) then
              ! case 1: swap 1-by-1 and 1-by-1 blocks.
              ! compute orthogonal ql and rq that swap 1-by-1 and 1-by-1 blocks
              ! using givens rotations and perform the swap tentatively.
              f = s( 2, 2 )*t( 1, 1 ) - t( 2, 2 )*s( 1, 1 )
              g = s( 2, 2 )*t( 1, 2 ) - t( 2, 2 )*s( 1, 2 )
              sa = abs( s( 2, 2 ) ) * abs( t( 1, 1 ) )
              sb = abs( s( 1, 1 ) ) * abs( t( 2, 2 ) )
              call stdlib_${ri}$lartg( f, g, ir( 1, 2 ), ir( 1, 1 ), ddum )
              ir( 2, 1 ) = -ir( 1, 2 )
              ir( 2, 2 ) = ir( 1, 1 )
              call stdlib_${ri}$rot( 2, s( 1, 1 ), 1, s( 1, 2 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
              call stdlib_${ri}$rot( 2, t( 1, 1 ), 1, t( 1, 2 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
              if( sa>=sb ) then
                 call stdlib_${ri}$lartg( s( 1, 1 ), s( 2, 1 ), li( 1, 1 ), li( 2, 1 ),ddum )
              else
                 call stdlib_${ri}$lartg( t( 1, 1 ), t( 2, 1 ), li( 1, 1 ), li( 2, 1 ),ddum )
              end if
              call stdlib_${ri}$rot( 2, s( 1, 1 ), ldst, s( 2, 1 ), ldst, li( 1, 1 ),li( 2, 1 ) )
                        
              call stdlib_${ri}$rot( 2, t( 1, 1 ), ldst, t( 2, 1 ), ldst, li( 1, 1 ),li( 2, 1 ) )
                        
              li( 2, 2 ) = li( 1, 1 )
              li( 1, 2 ) = -li( 2, 1 )
              ! weak stability test: |s21| <= o(eps f-norm((a)))
                                 ! and  |t21| <= o(eps f-norm((b)))
              weak = abs( s( 2, 1 ) ) <= thresha .and.abs( t( 2, 1 ) ) <= threshb
              if( .not.weak )go to 70
              if( wands ) then
                 ! strong stability test:
                     ! f-norm((a-ql**h*s*qr)) <= o(eps*f-norm((a)))
                     ! and
                     ! f-norm((b-ql**h*t*qr)) <= o(eps*f-norm((b)))
                 call stdlib_${ri}$lacpy( 'FULL', m, m, a( j1, j1 ), lda, work( m*m+1 ),m )
                 call stdlib_${ri}$gemm( 'N', 'N', m, m, m, one, li, ldst, s, ldst, zero,work, m )
                           
                 call stdlib_${ri}$gemm( 'N', 'T', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_${ri}$lassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sa = dscale*sqrt( dsum )
                 call stdlib_${ri}$lacpy( 'FULL', m, m, b( j1, j1 ), ldb, work( m*m+1 ),m )
                 call stdlib_${ri}$gemm( 'N', 'N', m, m, m, one, li, ldst, t, ldst, zero,work, m )
                           
                 call stdlib_${ri}$gemm( 'N', 'T', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_${ri}$lassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sb = dscale*sqrt( dsum )
                 strong = sa<=thresha .and. sb<=threshb
                 if( .not.strong )go to 70
              end if
              ! update (a(j1:j1+m-1, m+j1:n), b(j1:j1+m-1, m+j1:n)) and
                     ! (a(1:j1-1, j1:j1+m), b(1:j1-1, j1:j1+m)).
              call stdlib_${ri}$rot( j1+1, a( 1, j1 ), 1, a( 1, j1+1 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
                        
              call stdlib_${ri}$rot( j1+1, b( 1, j1 ), 1, b( 1, j1+1 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
                        
              call stdlib_${ri}$rot( n-j1+1, a( j1, j1 ), lda, a( j1+1, j1 ), lda,li( 1, 1 ), li( 2, 1 &
                        ) )
              call stdlib_${ri}$rot( n-j1+1, b( j1, j1 ), ldb, b( j1+1, j1 ), ldb,li( 1, 1 ), li( 2, 1 &
                        ) )
              ! set  n1-by-n2 (2,1) - blocks to zero.
              a( j1+1, j1 ) = zero
              b( j1+1, j1 ) = zero
              ! accumulate transformations into q and z if requested.
              if( wantz )call stdlib_${ri}$rot( n, z( 1, j1 ), 1, z( 1, j1+1 ), 1, ir( 1, 1 ),ir( 2, 1 &
                        ) )
              if( wantq )call stdlib_${ri}$rot( n, q( 1, j1 ), 1, q( 1, j1+1 ), 1, li( 1, 1 ),li( 2, 1 &
                        ) )
              ! exit with info = 0 if swap was successfully performed.
              return
           else
              ! case 2: swap 1-by-1 and 2-by-2 blocks, or 2-by-2
                      ! and 2-by-2 blocks.
              ! solve the generalized sylvester equation
                       ! s11 * r - l * s22 = scale * s12
                       ! t11 * r - l * t22 = scale * t12
              ! for r and l. solutions in li and ir.
              call stdlib_${ri}$lacpy( 'FULL', n1, n2, t( 1, n1+1 ), ldst, li, ldst )
              call stdlib_${ri}$lacpy( 'FULL', n1, n2, s( 1, n1+1 ), ldst,ir( n2+1, n1+1 ), ldst )
                        
              call stdlib_${ri}$tgsy2( 'N', 0, n1, n2, s, ldst, s( n1+1, n1+1 ), ldst,ir( n2+1, n1+1 ),&
               ldst, t, ldst, t( n1+1, n1+1 ),ldst, li, ldst, scale, dsum, dscale, iwork, idum,&
                         linfo )
              if( linfo/=0 )go to 70
              ! compute orthogonal matrix ql:
                          ! ql**t * li = [ tl ]
                                       ! [ 0  ]
              ! where
                          ! li =  [      -l              ]
                                ! [ scale * identity(n2) ]
              do i = 1, n2
                 call stdlib_${ri}$scal( n1, -one, li( 1, i ), 1 )
                 li( n1+i, i ) = scale
              end do
              call stdlib_${ri}$geqr2( m, n2, li, ldst, taul, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_${ri}$org2r( m, m, n2, li, ldst, taul, work, linfo )
              if( linfo/=0 )go to 70
              ! compute orthogonal matrix rq:
                          ! ir * rq**t =   [ 0  tr],
               ! where ir = [ scale * identity(n1), r ]
              do i = 1, n1
                 ir( n2+i, i ) = scale
              end do
              call stdlib_${ri}$gerq2( n1, m, ir( n2+1, 1 ), ldst, taur, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_${ri}$orgr2( m, m, n1, ir, ldst, taur, work, linfo )
              if( linfo/=0 )go to 70
              ! perform the swapping tentatively:
              call stdlib_${ri}$gemm( 'T', 'N', m, m, m, one, li, ldst, s, ldst, zero,work, m )
              call stdlib_${ri}$gemm( 'N', 'T', m, m, m, one, work, m, ir, ldst, zero, s,ldst )
              call stdlib_${ri}$gemm( 'T', 'N', m, m, m, one, li, ldst, t, ldst, zero,work, m )
              call stdlib_${ri}$gemm( 'N', 'T', m, m, m, one, work, m, ir, ldst, zero, t,ldst )
              call stdlib_${ri}$lacpy( 'F', m, m, s, ldst, scpy, ldst )
              call stdlib_${ri}$lacpy( 'F', m, m, t, ldst, tcpy, ldst )
              call stdlib_${ri}$lacpy( 'F', m, m, ir, ldst, ircop, ldst )
              call stdlib_${ri}$lacpy( 'F', m, m, li, ldst, licop, ldst )
              ! triangularize the b-part by an rq factorization.
              ! apply transformation (from left) to a-part, giving s.
              call stdlib_${ri}$gerq2( m, m, t, ldst, taur, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_${ri}$ormr2( 'R', 'T', m, m, m, t, ldst, taur, s, ldst, work,linfo )
              if( linfo/=0 )go to 70
              call stdlib_${ri}$ormr2( 'L', 'N', m, m, m, t, ldst, taur, ir, ldst, work,linfo )
              if( linfo/=0 )go to 70
              ! compute f-norm(s21) in brqa21. (t21 is 0.)
              dscale = zero
              dsum = one
              do i = 1, n2
                 call stdlib_${ri}$lassq( n1, s( n2+1, i ), 1, dscale, dsum )
              end do
              brqa21 = dscale*sqrt( dsum )
              ! triangularize the b-part by a qr factorization.
              ! apply transformation (from right) to a-part, giving s.
              call stdlib_${ri}$geqr2( m, m, tcpy, ldst, taul, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_${ri}$orm2r( 'L', 'T', m, m, m, tcpy, ldst, taul, scpy, ldst,work, info )
                        
              call stdlib_${ri}$orm2r( 'R', 'N', m, m, m, tcpy, ldst, taul, licop, ldst,work, info )
                        
              if( linfo/=0 )go to 70
              ! compute f-norm(s21) in bqra21. (t21 is 0.)
              dscale = zero
              dsum = one
              do i = 1, n2
                 call stdlib_${ri}$lassq( n1, scpy( n2+1, i ), 1, dscale, dsum )
              end do
              bqra21 = dscale*sqrt( dsum )
              ! decide which method to use.
                ! weak stability test:
                   ! f-norm(s21) <= o(eps * f-norm((s)))
              if( bqra21<=brqa21 .and. bqra21<=thresha ) then
                 call stdlib_${ri}$lacpy( 'F', m, m, scpy, ldst, s, ldst )
                 call stdlib_${ri}$lacpy( 'F', m, m, tcpy, ldst, t, ldst )
                 call stdlib_${ri}$lacpy( 'F', m, m, ircop, ldst, ir, ldst )
                 call stdlib_${ri}$lacpy( 'F', m, m, licop, ldst, li, ldst )
              else if( brqa21>=thresha ) then
                 go to 70
              end if
              ! set lower triangle of b-part to zero
              if (m>1) call stdlib_${ri}$laset( 'LOWER', m-1, m-1, zero, zero, t(2,1), ldst )
              if( wands ) then
                 ! strong stability test:
                     ! f-norm((a-ql**h*s*qr)) <= o(eps*f-norm((a)))
                     ! and
                     ! f-norm((b-ql**h*t*qr)) <= o(eps*f-norm((b)))
                 call stdlib_${ri}$lacpy( 'FULL', m, m, a( j1, j1 ), lda, work( m*m+1 ),m )
                 call stdlib_${ri}$gemm( 'N', 'N', m, m, m, one, li, ldst, s, ldst, zero,work, m )
                           
                 call stdlib_${ri}$gemm( 'N', 'N', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_${ri}$lassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sa = dscale*sqrt( dsum )
                 call stdlib_${ri}$lacpy( 'FULL', m, m, b( j1, j1 ), ldb, work( m*m+1 ),m )
                 call stdlib_${ri}$gemm( 'N', 'N', m, m, m, one, li, ldst, t, ldst, zero,work, m )
                           
                 call stdlib_${ri}$gemm( 'N', 'N', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_${ri}$lassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sb = dscale*sqrt( dsum )
                 strong = sa<=thresha .and. sb<=threshb
                 if( .not.strong )go to 70
              end if
              ! if the swap is accepted ("weakly" and "strongly"), apply the
              ! transformations and set n1-by-n2 (2,1)-block to zero.
              call stdlib_${ri}$laset( 'FULL', n1, n2, zero, zero, s(n2+1,1), ldst )
              ! copy back m-by-m diagonal block starting at index j1 of (a, b)
              call stdlib_${ri}$lacpy( 'F', m, m, s, ldst, a( j1, j1 ), lda )
              call stdlib_${ri}$lacpy( 'F', m, m, t, ldst, b( j1, j1 ), ldb )
              call stdlib_${ri}$laset( 'FULL', ldst, ldst, zero, zero, t, ldst )
              ! standardize existing 2-by-2 blocks.
              call stdlib_${ri}$laset( 'FULL', m, m, zero, zero, work, m )
              work( 1 ) = one
              t( 1, 1 ) = one
              idum = lwork - m*m - 2
              if( n2>1 ) then
                 call stdlib_${ri}$lagv2( a( j1, j1 ), lda, b( j1, j1 ), ldb, ar, ai, be,work( 1 ), &
                           work( 2 ), t( 1, 1 ), t( 2, 1 ) )
                 work( m+1 ) = -work( 2 )
                 work( m+2 ) = work( 1 )
                 t( n2, n2 ) = t( 1, 1 )
                 t( 1, 2 ) = -t( 2, 1 )
              end if
              work( m*m ) = one
              t( m, m ) = one
              if( n1>1 ) then
                 call stdlib_${ri}$lagv2( a( j1+n2, j1+n2 ), lda, b( j1+n2, j1+n2 ), ldb,taur, taul, &
                 work( m*m+1 ), work( n2*m+n2+1 ),work( n2*m+n2+2 ), t( n2+1, n2+1 ),t( m, m-1 ) )
                           
                 work( m*m ) = work( n2*m+n2+1 )
                 work( m*m-1 ) = -work( n2*m+n2+2 )
                 t( m, m ) = t( n2+1, n2+1 )
                 t( m-1, m ) = -t( m, m-1 )
              end if
              call stdlib_${ri}$gemm( 'T', 'N', n2, n1, n2, one, work, m, a( j1, j1+n2 ),lda, zero, &
                        work( m*m+1 ), n2 )
              call stdlib_${ri}$lacpy( 'FULL', n2, n1, work( m*m+1 ), n2, a( j1, j1+n2 ),lda )
              call stdlib_${ri}$gemm( 'T', 'N', n2, n1, n2, one, work, m, b( j1, j1+n2 ),ldb, zero, &
                        work( m*m+1 ), n2 )
              call stdlib_${ri}$lacpy( 'FULL', n2, n1, work( m*m+1 ), n2, b( j1, j1+n2 ),ldb )
              call stdlib_${ri}$gemm( 'N', 'N', m, m, m, one, li, ldst, work, m, zero,work( m*m+1 ), m &
                        )
              call stdlib_${ri}$lacpy( 'FULL', m, m, work( m*m+1 ), m, li, ldst )
              call stdlib_${ri}$gemm( 'N', 'N', n2, n1, n1, one, a( j1, j1+n2 ), lda,t( n2+1, n2+1 ), &
                        ldst, zero, work, n2 )
              call stdlib_${ri}$lacpy( 'FULL', n2, n1, work, n2, a( j1, j1+n2 ), lda )
              call stdlib_${ri}$gemm( 'N', 'N', n2, n1, n1, one, b( j1, j1+n2 ), ldb,t( n2+1, n2+1 ), &
                        ldst, zero, work, n2 )
              call stdlib_${ri}$lacpy( 'FULL', n2, n1, work, n2, b( j1, j1+n2 ), ldb )
              call stdlib_${ri}$gemm( 'T', 'N', m, m, m, one, ir, ldst, t, ldst, zero,work, m )
              call stdlib_${ri}$lacpy( 'FULL', m, m, work, m, ir, ldst )
              ! accumulate transformations into q and z if requested.
              if( wantq ) then
                 call stdlib_${ri}$gemm( 'N', 'N', n, m, m, one, q( 1, j1 ), ldq, li,ldst, zero, work, &
                           n )
                 call stdlib_${ri}$lacpy( 'FULL', n, m, work, n, q( 1, j1 ), ldq )
              end if
              if( wantz ) then
                 call stdlib_${ri}$gemm( 'N', 'N', n, m, m, one, z( 1, j1 ), ldz, ir,ldst, zero, work, &
                           n )
                 call stdlib_${ri}$lacpy( 'FULL', n, m, work, n, z( 1, j1 ), ldz )
              end if
              ! update (a(j1:j1+m-1, m+j1:n), b(j1:j1+m-1, m+j1:n)) and
                      ! (a(1:j1-1, j1:j1+m), b(1:j1-1, j1:j1+m)).
              i = j1 + m
              if( i<=n ) then
                 call stdlib_${ri}$gemm( 'T', 'N', m, n-i+1, m, one, li, ldst,a( j1, i ), lda, zero, &
                           work, m )
                 call stdlib_${ri}$lacpy( 'FULL', m, n-i+1, work, m, a( j1, i ), lda )
                 call stdlib_${ri}$gemm( 'T', 'N', m, n-i+1, m, one, li, ldst,b( j1, i ), ldb, zero, &
                           work, m )
                 call stdlib_${ri}$lacpy( 'FULL', m, n-i+1, work, m, b( j1, i ), ldb )
              end if
              i = j1 - 1
              if( i>0 ) then
                 call stdlib_${ri}$gemm( 'N', 'N', i, m, m, one, a( 1, j1 ), lda, ir,ldst, zero, work, &
                           i )
                 call stdlib_${ri}$lacpy( 'FULL', i, m, work, i, a( 1, j1 ), lda )
                 call stdlib_${ri}$gemm( 'N', 'N', i, m, m, one, b( 1, j1 ), ldb, ir,ldst, zero, work, &
                           i )
                 call stdlib_${ri}$lacpy( 'FULL', i, m, work, i, b( 1, j1 ), ldb )
              end if
              ! exit with info = 0 if swap was successfully performed.
              return
           end if
           ! exit with info = 1 if swap was rejected.
           70 continue
           info = 1
           return
     end subroutine stdlib_${ri}$tgex2

#:endif
#:endfor

     module pure subroutine stdlib_ctgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, j1, info )
     !! CTGEX2 swaps adjacent diagonal 1 by 1 blocks (A11,B11) and (A22,B22)
     !! in an upper triangular matrix pair (A, B) by an unitary equivalence
     !! transformation.
     !! (A, B) must be in generalized Schur canonical form, that is, A and
     !! B are both upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H
     !! Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: j1, lda, ldb, ldq, ldz, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: twenty = 2.0e+1_sp
           integer(ilp), parameter :: ldst = 2
           logical(lk), parameter :: wands = .true.
           
           
           
           
           ! Local Scalars 
           logical(lk) :: strong, weak
           integer(ilp) :: i, m
           real(sp) :: cq, cz, eps, sa, sb, scale, smlnum, sum, thresha, threshb
           complex(sp) :: cdum, f, g, sq, sz
           ! Local Arrays 
           complex(sp) :: s(ldst,ldst), t(ldst,ldst), work(8)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=1 )return
           m = ldst
           weak = .false.
           strong = .false.
           ! make a local copy of selected block in (a, b)
           call stdlib_clacpy( 'FULL', m, m, a( j1, j1 ), lda, s, ldst )
           call stdlib_clacpy( 'FULL', m, m, b( j1, j1 ), ldb, t, ldst )
           ! compute the threshold for testing the acceptance of swapping.
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' ) / eps
           scale = real( czero,KIND=sp)
           sum = real( cone,KIND=sp)
           call stdlib_clacpy( 'FULL', m, m, s, ldst, work, m )
           call stdlib_clacpy( 'FULL', m, m, t, ldst, work( m*m+1 ), m )
           call stdlib_classq( m*m, work, 1, scale, sum )
           sa = scale*sqrt( sum )
           scale = real( czero,KIND=sp)
           sum = real( cone,KIND=sp)
           call stdlib_classq( m*m, work(m*m+1), 1, scale, sum )
           sb = scale*sqrt( sum )
           ! thres has been changed from
              ! thresh = max( ten*eps*sa, smlnum )
           ! to
              ! thresh = max( twenty*eps*sa, smlnum )
           ! on 04/01/10.
           ! "bug" reported by ondra kamenik, confirmed by julie langou, fixed by
           ! jim demmel and guillaume revy. see forum post 1783.
           thresha = max( twenty*eps*sa, smlnum )
           threshb = max( twenty*eps*sb, smlnum )
           ! compute unitary ql and rq that swap 1-by-1 and 1-by-1 blocks
           ! using givens rotations and perform the swap tentatively.
           f = s( 2, 2 )*t( 1, 1 ) - t( 2, 2 )*s( 1, 1 )
           g = s( 2, 2 )*t( 1, 2 ) - t( 2, 2 )*s( 1, 2 )
           sa = abs( s( 2, 2 ) ) * abs( t( 1, 1 ) )
           sb = abs( s( 1, 1 ) ) * abs( t( 2, 2 ) )
           call stdlib_clartg( g, f, cz, sz, cdum )
           sz = -sz
           call stdlib_crot( 2, s( 1, 1 ), 1, s( 1, 2 ), 1, cz, conjg( sz ) )
           call stdlib_crot( 2, t( 1, 1 ), 1, t( 1, 2 ), 1, cz, conjg( sz ) )
           if( sa>=sb ) then
              call stdlib_clartg( s( 1, 1 ), s( 2, 1 ), cq, sq, cdum )
           else
              call stdlib_clartg( t( 1, 1 ), t( 2, 1 ), cq, sq, cdum )
           end if
           call stdlib_crot( 2, s( 1, 1 ), ldst, s( 2, 1 ), ldst, cq, sq )
           call stdlib_crot( 2, t( 1, 1 ), ldst, t( 2, 1 ), ldst, cq, sq )
           ! weak stability test: |s21| <= o(eps f-norm((a)))
                                ! and  |t21| <= o(eps f-norm((b)))
           weak = abs( s( 2, 1 ) )<=thresha .and.abs( t( 2, 1 ) )<=threshb
           if( .not.weak )go to 20
           if( wands ) then
              ! strong stability test:
                 ! f-norm((a-ql**h*s*qr, b-ql**h*t*qr)) <= o(eps*f-norm((a, b)))
              call stdlib_clacpy( 'FULL', m, m, s, ldst, work, m )
              call stdlib_clacpy( 'FULL', m, m, t, ldst, work( m*m+1 ), m )
              call stdlib_crot( 2, work, 1, work( 3 ), 1, cz, -conjg( sz ) )
              call stdlib_crot( 2, work( 5 ), 1, work( 7 ), 1, cz, -conjg( sz ) )
              call stdlib_crot( 2, work, 2, work( 2 ), 2, cq, -sq )
              call stdlib_crot( 2, work( 5 ), 2, work( 6 ), 2, cq, -sq )
              do i = 1, 2
                 work( i ) = work( i ) - a( j1+i-1, j1 )
                 work( i+2 ) = work( i+2 ) - a( j1+i-1, j1+1 )
                 work( i+4 ) = work( i+4 ) - b( j1+i-1, j1 )
                 work( i+6 ) = work( i+6 ) - b( j1+i-1, j1+1 )
              end do
              scale = real( czero,KIND=sp)
              sum = real( cone,KIND=sp)
              call stdlib_classq( m*m, work, 1, scale, sum )
              sa = scale*sqrt( sum )
              scale = real( czero,KIND=sp)
              sum = real( cone,KIND=sp)
              call stdlib_classq( m*m, work(m*m+1), 1, scale, sum )
              sb = scale*sqrt( sum )
              strong = sa<=thresha .and. sb<=threshb
              if( .not.strong )go to 20
           end if
           ! if the swap is accepted ("weakly" and "strongly"), apply the
           ! equivalence transformations to the original matrix pair (a,b)
           call stdlib_crot( j1+1, a( 1, j1 ), 1, a( 1, j1+1 ), 1, cz, conjg( sz ) )
           call stdlib_crot( j1+1, b( 1, j1 ), 1, b( 1, j1+1 ), 1, cz, conjg( sz ) )
           call stdlib_crot( n-j1+1, a( j1, j1 ), lda, a( j1+1, j1 ), lda, cq, sq )
           call stdlib_crot( n-j1+1, b( j1, j1 ), ldb, b( j1+1, j1 ), ldb, cq, sq )
           ! set  n1 by n2 (2,1) blocks to 0
           a( j1+1, j1 ) = czero
           b( j1+1, j1 ) = czero
           ! accumulate transformations into q and z if requested.
           if( wantz )call stdlib_crot( n, z( 1, j1 ), 1, z( 1, j1+1 ), 1, cz, conjg( sz ) )
                     
           if( wantq )call stdlib_crot( n, q( 1, j1 ), 1, q( 1, j1+1 ), 1, cq, conjg( sq ) )
                     
           ! exit with info = 0 if swap was successfully performed.
           return
           ! exit with info = 1 if swap was rejected.
           20 continue
           info = 1
           return
     end subroutine stdlib_ctgex2

     module pure subroutine stdlib_ztgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, j1, info )
     !! ZTGEX2 swaps adjacent diagonal 1 by 1 blocks (A11,B11) and (A22,B22)
     !! in an upper triangular matrix pair (A, B) by an unitary equivalence
     !! transformation.
     !! (A, B) must be in generalized Schur canonical form, that is, A and
     !! B are both upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H
     !! Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: j1, lda, ldb, ldq, ldz, n
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: twenty = 2.0e+1_dp
           integer(ilp), parameter :: ldst = 2
           logical(lk), parameter :: wands = .true.
           
           
           
           
           ! Local Scalars 
           logical(lk) :: strong, weak
           integer(ilp) :: i, m
           real(dp) :: cq, cz, eps, sa, sb, scale, smlnum, sum, thresha, threshb
           complex(dp) :: cdum, f, g, sq, sz
           ! Local Arrays 
           complex(dp) :: s(ldst,ldst), t(ldst,ldst), work(8)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=1 )return
           m = ldst
           weak = .false.
           strong = .false.
           ! make a local copy of selected block in (a, b)
           call stdlib_zlacpy( 'FULL', m, m, a( j1, j1 ), lda, s, ldst )
           call stdlib_zlacpy( 'FULL', m, m, b( j1, j1 ), ldb, t, ldst )
           ! compute the threshold for testing the acceptance of swapping.
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' ) / eps
           scale = real( czero,KIND=dp)
           sum = real( cone,KIND=dp)
           call stdlib_zlacpy( 'FULL', m, m, s, ldst, work, m )
           call stdlib_zlacpy( 'FULL', m, m, t, ldst, work( m*m+1 ), m )
           call stdlib_zlassq( m*m, work, 1, scale, sum )
           sa = scale*sqrt( sum )
           scale = real( czero,KIND=dp)
           sum = real( cone,KIND=dp)
           call stdlib_zlassq( m*m, work(m*m+1), 1, scale, sum )
           sb = scale*sqrt( sum )
           ! thres has been changed from
              ! thresh = max( ten*eps*sa, smlnum )
           ! to
              ! thresh = max( twenty*eps*sa, smlnum )
           ! on 04/01/10.
           ! "bug" reported by ondra kamenik, confirmed by julie langou, fixed by
           ! jim demmel and guillaume revy. see forum post 1783.
           thresha = max( twenty*eps*sa, smlnum )
           threshb = max( twenty*eps*sb, smlnum )
           ! compute unitary ql and rq that swap 1-by-1 and 1-by-1 blocks
           ! using givens rotations and perform the swap tentatively.
           f = s( 2, 2 )*t( 1, 1 ) - t( 2, 2 )*s( 1, 1 )
           g = s( 2, 2 )*t( 1, 2 ) - t( 2, 2 )*s( 1, 2 )
           sa = abs( s( 2, 2 ) ) * abs( t( 1, 1 ) )
           sb = abs( s( 1, 1 ) ) * abs( t( 2, 2 ) )
           call stdlib_zlartg( g, f, cz, sz, cdum )
           sz = -sz
           call stdlib_zrot( 2, s( 1, 1 ), 1, s( 1, 2 ), 1, cz, conjg( sz ) )
           call stdlib_zrot( 2, t( 1, 1 ), 1, t( 1, 2 ), 1, cz, conjg( sz ) )
           if( sa>=sb ) then
              call stdlib_zlartg( s( 1, 1 ), s( 2, 1 ), cq, sq, cdum )
           else
              call stdlib_zlartg( t( 1, 1 ), t( 2, 1 ), cq, sq, cdum )
           end if
           call stdlib_zrot( 2, s( 1, 1 ), ldst, s( 2, 1 ), ldst, cq, sq )
           call stdlib_zrot( 2, t( 1, 1 ), ldst, t( 2, 1 ), ldst, cq, sq )
           ! weak stability test: |s21| <= o(eps f-norm((a)))
                                ! and  |t21| <= o(eps f-norm((b)))
           weak = abs( s( 2, 1 ) )<=thresha .and.abs( t( 2, 1 ) )<=threshb
           if( .not.weak )go to 20
           if( wands ) then
              ! strong stability test:
                 ! f-norm((a-ql**h*s*qr)) <= o(eps*f-norm((a)))
                 ! and
                 ! f-norm((b-ql**h*t*qr)) <= o(eps*f-norm((b)))
              call stdlib_zlacpy( 'FULL', m, m, s, ldst, work, m )
              call stdlib_zlacpy( 'FULL', m, m, t, ldst, work( m*m+1 ), m )
              call stdlib_zrot( 2, work, 1, work( 3 ), 1, cz, -conjg( sz ) )
              call stdlib_zrot( 2, work( 5 ), 1, work( 7 ), 1, cz, -conjg( sz ) )
              call stdlib_zrot( 2, work, 2, work( 2 ), 2, cq, -sq )
              call stdlib_zrot( 2, work( 5 ), 2, work( 6 ), 2, cq, -sq )
              do i = 1, 2
                 work( i ) = work( i ) - a( j1+i-1, j1 )
                 work( i+2 ) = work( i+2 ) - a( j1+i-1, j1+1 )
                 work( i+4 ) = work( i+4 ) - b( j1+i-1, j1 )
                 work( i+6 ) = work( i+6 ) - b( j1+i-1, j1+1 )
              end do
              scale = real( czero,KIND=dp)
              sum = real( cone,KIND=dp)
              call stdlib_zlassq( m*m, work, 1, scale, sum )
              sa = scale*sqrt( sum )
              scale = real( czero,KIND=dp)
              sum = real( cone,KIND=dp)
              call stdlib_zlassq( m*m, work(m*m+1), 1, scale, sum )
              sb = scale*sqrt( sum )
              strong = sa<=thresha .and. sb<=threshb
              if( .not.strong )go to 20
           end if
           ! if the swap is accepted ("weakly" and "strongly"), apply the
           ! equivalence transformations to the original matrix pair (a,b)
           call stdlib_zrot( j1+1, a( 1, j1 ), 1, a( 1, j1+1 ), 1, cz,conjg( sz ) )
           call stdlib_zrot( j1+1, b( 1, j1 ), 1, b( 1, j1+1 ), 1, cz,conjg( sz ) )
           call stdlib_zrot( n-j1+1, a( j1, j1 ), lda, a( j1+1, j1 ), lda, cq, sq )
           call stdlib_zrot( n-j1+1, b( j1, j1 ), ldb, b( j1+1, j1 ), ldb, cq, sq )
           ! set  n1 by n2 (2,1) blocks to 0
           a( j1+1, j1 ) = czero
           b( j1+1, j1 ) = czero
           ! accumulate transformations into q and z if requested.
           if( wantz )call stdlib_zrot( n, z( 1, j1 ), 1, z( 1, j1+1 ), 1, cz,conjg( sz ) )
                     
           if( wantq )call stdlib_zrot( n, q( 1, j1 ), 1, q( 1, j1+1 ), 1, cq,conjg( sq ) )
                     
           ! exit with info = 0 if swap was successfully performed.
           return
           ! exit with info = 1 if swap was rejected.
           20 continue
           info = 1
           return
     end subroutine stdlib_ztgex2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, j1, info )
     !! ZTGEX2: swaps adjacent diagonal 1 by 1 blocks (A11,B11) and (A22,B22)
     !! in an upper triangular matrix pair (A, B) by an unitary equivalence
     !! transformation.
     !! (A, B) must be in generalized Schur canonical form, that is, A and
     !! B are both upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H
     !! Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: j1, lda, ldb, ldq, ldz, n
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: twenty = 2.0e+1_${ck}$
           integer(ilp), parameter :: ldst = 2
           logical(lk), parameter :: wands = .true.
           
           
           
           
           ! Local Scalars 
           logical(lk) :: strong, weak
           integer(ilp) :: i, m
           real(${ck}$) :: cq, cz, eps, sa, sb, scale, smlnum, sum, thresha, threshb
           complex(${ck}$) :: cdum, f, g, sq, sz
           ! Local Arrays 
           complex(${ck}$) :: s(ldst,ldst), t(ldst,ldst), work(8)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=1 )return
           m = ldst
           weak = .false.
           strong = .false.
           ! make a local copy of selected block in (a, b)
           call stdlib_${ci}$lacpy( 'FULL', m, m, a( j1, j1 ), lda, s, ldst )
           call stdlib_${ci}$lacpy( 'FULL', m, m, b( j1, j1 ), ldb, t, ldst )
           ! compute the threshold for testing the acceptance of swapping.
           eps = stdlib_${c2ri(ci)}$lamch( 'P' )
           smlnum = stdlib_${c2ri(ci)}$lamch( 'S' ) / eps
           scale = real( czero,KIND=${ck}$)
           sum = real( cone,KIND=${ck}$)
           call stdlib_${ci}$lacpy( 'FULL', m, m, s, ldst, work, m )
           call stdlib_${ci}$lacpy( 'FULL', m, m, t, ldst, work( m*m+1 ), m )
           call stdlib_${ci}$lassq( m*m, work, 1, scale, sum )
           sa = scale*sqrt( sum )
           scale = real( czero,KIND=${ck}$)
           sum = real( cone,KIND=${ck}$)
           call stdlib_${ci}$lassq( m*m, work(m*m+1), 1, scale, sum )
           sb = scale*sqrt( sum )
           ! thres has been changed from
              ! thresh = max( ten*eps*sa, smlnum )
           ! to
              ! thresh = max( twenty*eps*sa, smlnum )
           ! on 04/01/10.
           ! "bug" reported by ondra kamenik, confirmed by julie langou, fixed by
           ! jim demmel and guillaume revy. see forum post 1783.
           thresha = max( twenty*eps*sa, smlnum )
           threshb = max( twenty*eps*sb, smlnum )
           ! compute unitary ql and rq that swap 1-by-1 and 1-by-1 blocks
           ! using givens rotations and perform the swap tentatively.
           f = s( 2, 2 )*t( 1, 1 ) - t( 2, 2 )*s( 1, 1 )
           g = s( 2, 2 )*t( 1, 2 ) - t( 2, 2 )*s( 1, 2 )
           sa = abs( s( 2, 2 ) ) * abs( t( 1, 1 ) )
           sb = abs( s( 1, 1 ) ) * abs( t( 2, 2 ) )
           call stdlib_${ci}$lartg( g, f, cz, sz, cdum )
           sz = -sz
           call stdlib_${ci}$rot( 2, s( 1, 1 ), 1, s( 1, 2 ), 1, cz, conjg( sz ) )
           call stdlib_${ci}$rot( 2, t( 1, 1 ), 1, t( 1, 2 ), 1, cz, conjg( sz ) )
           if( sa>=sb ) then
              call stdlib_${ci}$lartg( s( 1, 1 ), s( 2, 1 ), cq, sq, cdum )
           else
              call stdlib_${ci}$lartg( t( 1, 1 ), t( 2, 1 ), cq, sq, cdum )
           end if
           call stdlib_${ci}$rot( 2, s( 1, 1 ), ldst, s( 2, 1 ), ldst, cq, sq )
           call stdlib_${ci}$rot( 2, t( 1, 1 ), ldst, t( 2, 1 ), ldst, cq, sq )
           ! weak stability test: |s21| <= o(eps f-norm((a)))
                                ! and  |t21| <= o(eps f-norm((b)))
           weak = abs( s( 2, 1 ) )<=thresha .and.abs( t( 2, 1 ) )<=threshb
           if( .not.weak )go to 20
           if( wands ) then
              ! strong stability test:
                 ! f-norm((a-ql**h*s*qr)) <= o(eps*f-norm((a)))
                 ! and
                 ! f-norm((b-ql**h*t*qr)) <= o(eps*f-norm((b)))
              call stdlib_${ci}$lacpy( 'FULL', m, m, s, ldst, work, m )
              call stdlib_${ci}$lacpy( 'FULL', m, m, t, ldst, work( m*m+1 ), m )
              call stdlib_${ci}$rot( 2, work, 1, work( 3 ), 1, cz, -conjg( sz ) )
              call stdlib_${ci}$rot( 2, work( 5 ), 1, work( 7 ), 1, cz, -conjg( sz ) )
              call stdlib_${ci}$rot( 2, work, 2, work( 2 ), 2, cq, -sq )
              call stdlib_${ci}$rot( 2, work( 5 ), 2, work( 6 ), 2, cq, -sq )
              do i = 1, 2
                 work( i ) = work( i ) - a( j1+i-1, j1 )
                 work( i+2 ) = work( i+2 ) - a( j1+i-1, j1+1 )
                 work( i+4 ) = work( i+4 ) - b( j1+i-1, j1 )
                 work( i+6 ) = work( i+6 ) - b( j1+i-1, j1+1 )
              end do
              scale = real( czero,KIND=${ck}$)
              sum = real( cone,KIND=${ck}$)
              call stdlib_${ci}$lassq( m*m, work, 1, scale, sum )
              sa = scale*sqrt( sum )
              scale = real( czero,KIND=${ck}$)
              sum = real( cone,KIND=${ck}$)
              call stdlib_${ci}$lassq( m*m, work(m*m+1), 1, scale, sum )
              sb = scale*sqrt( sum )
              strong = sa<=thresha .and. sb<=threshb
              if( .not.strong )go to 20
           end if
           ! if the swap is accepted ("weakly" and "strongly"), apply the
           ! equivalence transformations to the original matrix pair (a,b)
           call stdlib_${ci}$rot( j1+1, a( 1, j1 ), 1, a( 1, j1+1 ), 1, cz,conjg( sz ) )
           call stdlib_${ci}$rot( j1+1, b( 1, j1 ), 1, b( 1, j1+1 ), 1, cz,conjg( sz ) )
           call stdlib_${ci}$rot( n-j1+1, a( j1, j1 ), lda, a( j1+1, j1 ), lda, cq, sq )
           call stdlib_${ci}$rot( n-j1+1, b( j1, j1 ), ldb, b( j1+1, j1 ), ldb, cq, sq )
           ! set  n1 by n2 (2,1) blocks to 0
           a( j1+1, j1 ) = czero
           b( j1+1, j1 ) = czero
           ! accumulate transformations into q and z if requested.
           if( wantz )call stdlib_${ci}$rot( n, z( 1, j1 ), 1, z( 1, j1+1 ), 1, cz,conjg( sz ) )
                     
           if( wantq )call stdlib_${ci}$rot( n, q( 1, j1 ), 1, q( 1, j1+1 ), 1, cq,conjg( sq ) )
                     
           ! exit with info = 0 if swap was successfully performed.
           return
           ! exit with info = 1 if swap was rejected.
           20 continue
           info = 1
           return
     end subroutine stdlib_${ci}$tgex2

#:endif
#:endfor



     module pure subroutine stdlib_sgebal( job, n, a, lda, ilo, ihi, scale, info )
     !! SGEBAL balances a general real matrix A.  This involves, first,
     !! permuting A by a similarity transformation to isolate eigenvalues
     !! in the first 1 to ILO-1 and last IHI+1 to N elements on the
     !! diagonal; and second, applying a diagonal similarity transformation
     !! to rows and columns ILO to IHI to make the rows and columns as
     !! close in norm as possible.  Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrix, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: scale(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sclfac = 2.0e+0_sp
           real(sp), parameter :: factor = 0.95e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: noconv
           integer(ilp) :: i, ica, iexc, ira, j, k, l, m
           real(sp) :: c, ca, f, g, r, ra, s, sfmax1, sfmax2, sfmin1, sfmin2
           ! Intrinsic Functions 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGEBAL', -info )
              return
           end if
           k = 1
           l = n
           if( n==0 )go to 210
           if( stdlib_lsame( job, 'N' ) ) then
              do i = 1, n
                 scale( i ) = one
              end do
              go to 210
           end if
           if( stdlib_lsame( job, 'S' ) )go to 120
           ! permutation to isolate eigenvalues if possible
           go to 50
           ! row and column exchange.
           20 continue
           scale( m ) = j
           if( j==m )go to 30
           call stdlib_sswap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_sswap( n-k+1, a( j, k ), lda, a( m, k ), lda )
           30 continue
           go to ( 40, 80 )iexc
           ! search for rows isolating an eigenvalue and push them down.
           40 continue
           if( l==1 )go to 210
           l = l - 1
           50 continue
           loop_70: do j = l, 1, -1
              loop_60: do i = 1, l
                 if( i==j )cycle loop_60
                 if( a( j, i )/=zero )cycle loop_70
              end do loop_60
              m = l
              iexc = 1
              go to 20
           end do loop_70
           go to 90
           ! search for columns isolating an eigenvalue and push them left.
           80 continue
           k = k + 1
           90 continue
           loop_110: do j = k, l
              loop_100: do i = k, l
                 if( i==j )cycle loop_100
                 if( a( i, j )/=zero )cycle loop_110
              end do loop_100
              m = k
              iexc = 2
              go to 20
           end do loop_110
           120 continue
           do i = k, l
              scale( i ) = one
           end do
           if( stdlib_lsame( job, 'P' ) )go to 210
           ! balance the submatrix in rows k to l.
           ! iterative loop for norm reduction
           sfmin1 = stdlib_slamch( 'S' ) / stdlib_slamch( 'P' )
           sfmax1 = one / sfmin1
           sfmin2 = sfmin1*sclfac
           sfmax2 = one / sfmin2
           140 continue
           noconv = .false.
           loop_200: do i = k, l
              c = stdlib_snrm2( l-k+1, a( k, i ), 1 )
              r = stdlib_snrm2( l-k+1, a( i, k ), lda )
              ica = stdlib_isamax( l, a( 1, i ), 1 )
              ca = abs( a( ica, i ) )
              ira = stdlib_isamax( n-k+1, a( i, k ), lda )
              ra = abs( a( i, ira+k-1 ) )
              ! guard against zero c or r due to underflow.
              if( c==zero .or. r==zero )cycle loop_200
              g = r / sclfac
              f = one
              s = c + r
              160 continue
              if( c>=g .or. max( f, c, ca )>=sfmax2 .or.min( r, g, ra )<=sfmin2 )go to 170
              f = f*sclfac
              c = c*sclfac
              ca = ca*sclfac
              r = r / sclfac
              g = g / sclfac
              ra = ra / sclfac
              go to 160
              170 continue
              g = c / sclfac
              180 continue
              if( g<r .or. max( r, ra )>=sfmax2 .or.min( f, c, g, ca )<=sfmin2 )go to 190
                 if( stdlib_sisnan( c+f+ca+r+g+ra ) ) then
                 ! exit if nan to avoid infinite loop
                 info = -3
                 call stdlib_xerbla( 'SGEBAL', -info )
                 return
              end if
              f = f / sclfac
              c = c / sclfac
              g = g / sclfac
              ca = ca / sclfac
              r = r*sclfac
              ra = ra*sclfac
              go to 180
              ! now balance.
              190 continue
              if( ( c+r )>=factor*s )cycle loop_200
              if( f<one .and. scale( i )<one ) then
                 if( f*scale( i )<=sfmin1 )cycle loop_200
              end if
              if( f>one .and. scale( i )>one ) then
                 if( scale( i )>=sfmax1 / f )cycle loop_200
              end if
              g = one / f
              scale( i ) = scale( i )*f
              noconv = .true.
              call stdlib_sscal( n-k+1, g, a( i, k ), lda )
              call stdlib_sscal( l, f, a( 1, i ), 1 )
           end do loop_200
           if( noconv )go to 140
           210 continue
           ilo = k
           ihi = l
           return
     end subroutine stdlib_sgebal

     module pure subroutine stdlib_dgebal( job, n, a, lda, ilo, ihi, scale, info )
     !! DGEBAL balances a general real matrix A.  This involves, first,
     !! permuting A by a similarity transformation to isolate eigenvalues
     !! in the first 1 to ILO-1 and last IHI+1 to N elements on the
     !! diagonal; and second, applying a diagonal similarity transformation
     !! to rows and columns ILO to IHI to make the rows and columns as
     !! close in norm as possible.  Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrix, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: scale(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sclfac = 2.0e+0_dp
           real(dp), parameter :: factor = 0.95e+0_dp
           
           
           
           ! Local Scalars 
           logical(lk) :: noconv
           integer(ilp) :: i, ica, iexc, ira, j, k, l, m
           real(dp) :: c, ca, f, g, r, ra, s, sfmax1, sfmax2, sfmin1, sfmin2
           ! Intrinsic Functions 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEBAL', -info )
              return
           end if
           k = 1
           l = n
           if( n==0 )go to 210
           if( stdlib_lsame( job, 'N' ) ) then
              do i = 1, n
                 scale( i ) = one
              end do
              go to 210
           end if
           if( stdlib_lsame( job, 'S' ) )go to 120
           ! permutation to isolate eigenvalues if possible
           go to 50
           ! row and column exchange.
           20 continue
           scale( m ) = j
           if( j==m )go to 30
           call stdlib_dswap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_dswap( n-k+1, a( j, k ), lda, a( m, k ), lda )
           30 continue
           go to ( 40, 80 )iexc
           ! search for rows isolating an eigenvalue and push them down.
           40 continue
           if( l==1 )go to 210
           l = l - 1
           50 continue
           loop_70: do j = l, 1, -1
              loop_60: do i = 1, l
                 if( i==j )cycle loop_60
                 if( a( j, i )/=zero )cycle loop_70
              end do loop_60
              m = l
              iexc = 1
              go to 20
           end do loop_70
           go to 90
           ! search for columns isolating an eigenvalue and push them left.
           80 continue
           k = k + 1
           90 continue
           loop_110: do j = k, l
              loop_100: do i = k, l
                 if( i==j )cycle loop_100
                 if( a( i, j )/=zero )cycle loop_110
              end do loop_100
              m = k
              iexc = 2
              go to 20
           end do loop_110
           120 continue
           do i = k, l
              scale( i ) = one
           end do
           if( stdlib_lsame( job, 'P' ) )go to 210
           ! balance the submatrix in rows k to l.
           ! iterative loop for norm reduction
           sfmin1 = stdlib_dlamch( 'S' ) / stdlib_dlamch( 'P' )
           sfmax1 = one / sfmin1
           sfmin2 = sfmin1*sclfac
           sfmax2 = one / sfmin2
           140 continue
           noconv = .false.
           loop_200: do i = k, l
              c = stdlib_dnrm2( l-k+1, a( k, i ), 1 )
              r = stdlib_dnrm2( l-k+1, a( i, k ), lda )
              ica = stdlib_idamax( l, a( 1, i ), 1 )
              ca = abs( a( ica, i ) )
              ira = stdlib_idamax( n-k+1, a( i, k ), lda )
              ra = abs( a( i, ira+k-1 ) )
              ! guard against zero c or r due to underflow.
              if( c==zero .or. r==zero )cycle loop_200
              g = r / sclfac
              f = one
              s = c + r
              160 continue
              if( c>=g .or. max( f, c, ca )>=sfmax2 .or.min( r, g, ra )<=sfmin2 )go to 170
                 if( stdlib_disnan( c+f+ca+r+g+ra ) ) then
                 ! exit if nan to avoid infinite loop
                 info = -3
                 call stdlib_xerbla( 'DGEBAL', -info )
                 return
              end if
              f = f*sclfac
              c = c*sclfac
              ca = ca*sclfac
              r = r / sclfac
              g = g / sclfac
              ra = ra / sclfac
              go to 160
              170 continue
              g = c / sclfac
              180 continue
              if( g<r .or. max( r, ra )>=sfmax2 .or.min( f, c, g, ca )<=sfmin2 )go to 190
              f = f / sclfac
              c = c / sclfac
              g = g / sclfac
              ca = ca / sclfac
              r = r*sclfac
              ra = ra*sclfac
              go to 180
              ! now balance.
              190 continue
              if( ( c+r )>=factor*s )cycle loop_200
              if( f<one .and. scale( i )<one ) then
                 if( f*scale( i )<=sfmin1 )cycle loop_200
              end if
              if( f>one .and. scale( i )>one ) then
                 if( scale( i )>=sfmax1 / f )cycle loop_200
              end if
              g = one / f
              scale( i ) = scale( i )*f
              noconv = .true.
              call stdlib_dscal( n-k+1, g, a( i, k ), lda )
              call stdlib_dscal( l, f, a( 1, i ), 1 )
           end do loop_200
           if( noconv )go to 140
           210 continue
           ilo = k
           ihi = l
           return
     end subroutine stdlib_dgebal

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$gebal( job, n, a, lda, ilo, ihi, scale, info )
     !! DGEBAL: balances a general real matrix A.  This involves, first,
     !! permuting A by a similarity transformation to isolate eigenvalues
     !! in the first 1 to ILO-1 and last IHI+1 to N elements on the
     !! diagonal; and second, applying a diagonal similarity transformation
     !! to rows and columns ILO to IHI to make the rows and columns as
     !! close in norm as possible.  Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrix, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: scale(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: sclfac = 2.0e+0_${rk}$
           real(${rk}$), parameter :: factor = 0.95e+0_${rk}$
           
           
           
           ! Local Scalars 
           logical(lk) :: noconv
           integer(ilp) :: i, ica, iexc, ira, j, k, l, m
           real(${rk}$) :: c, ca, f, g, r, ra, s, sfmax1, sfmax2, sfmin1, sfmin2
           ! Intrinsic Functions 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEBAL', -info )
              return
           end if
           k = 1
           l = n
           if( n==0 )go to 210
           if( stdlib_lsame( job, 'N' ) ) then
              do i = 1, n
                 scale( i ) = one
              end do
              go to 210
           end if
           if( stdlib_lsame( job, 'S' ) )go to 120
           ! permutation to isolate eigenvalues if possible
           go to 50
           ! row and column exchange.
           20 continue
           scale( m ) = j
           if( j==m )go to 30
           call stdlib_${ri}$swap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_${ri}$swap( n-k+1, a( j, k ), lda, a( m, k ), lda )
           30 continue
           go to ( 40, 80 )iexc
           ! search for rows isolating an eigenvalue and push them down.
           40 continue
           if( l==1 )go to 210
           l = l - 1
           50 continue
           loop_70: do j = l, 1, -1
              loop_60: do i = 1, l
                 if( i==j )cycle loop_60
                 if( a( j, i )/=zero )cycle loop_70
              end do loop_60
              m = l
              iexc = 1
              go to 20
           end do loop_70
           go to 90
           ! search for columns isolating an eigenvalue and push them left.
           80 continue
           k = k + 1
           90 continue
           loop_110: do j = k, l
              loop_100: do i = k, l
                 if( i==j )cycle loop_100
                 if( a( i, j )/=zero )cycle loop_110
              end do loop_100
              m = k
              iexc = 2
              go to 20
           end do loop_110
           120 continue
           do i = k, l
              scale( i ) = one
           end do
           if( stdlib_lsame( job, 'P' ) )go to 210
           ! balance the submatrix in rows k to l.
           ! iterative loop for norm reduction
           sfmin1 = stdlib_${ri}$lamch( 'S' ) / stdlib_${ri}$lamch( 'P' )
           sfmax1 = one / sfmin1
           sfmin2 = sfmin1*sclfac
           sfmax2 = one / sfmin2
           140 continue
           noconv = .false.
           loop_200: do i = k, l
              c = stdlib_${ri}$nrm2( l-k+1, a( k, i ), 1 )
              r = stdlib_${ri}$nrm2( l-k+1, a( i, k ), lda )
              ica = stdlib_i${ri}$amax( l, a( 1, i ), 1 )
              ca = abs( a( ica, i ) )
              ira = stdlib_i${ri}$amax( n-k+1, a( i, k ), lda )
              ra = abs( a( i, ira+k-1 ) )
              ! guard against zero c or r due to underflow.
              if( c==zero .or. r==zero )cycle loop_200
              g = r / sclfac
              f = one
              s = c + r
              160 continue
              if( c>=g .or. max( f, c, ca )>=sfmax2 .or.min( r, g, ra )<=sfmin2 )go to 170
                 if( stdlib_${ri}$isnan( c+f+ca+r+g+ra ) ) then
                 ! exit if nan to avoid infinite loop
                 info = -3
                 call stdlib_xerbla( 'DGEBAL', -info )
                 return
              end if
              f = f*sclfac
              c = c*sclfac
              ca = ca*sclfac
              r = r / sclfac
              g = g / sclfac
              ra = ra / sclfac
              go to 160
              170 continue
              g = c / sclfac
              180 continue
              if( g<r .or. max( r, ra )>=sfmax2 .or.min( f, c, g, ca )<=sfmin2 )go to 190
              f = f / sclfac
              c = c / sclfac
              g = g / sclfac
              ca = ca / sclfac
              r = r*sclfac
              ra = ra*sclfac
              go to 180
              ! now balance.
              190 continue
              if( ( c+r )>=factor*s )cycle loop_200
              if( f<one .and. scale( i )<one ) then
                 if( f*scale( i )<=sfmin1 )cycle loop_200
              end if
              if( f>one .and. scale( i )>one ) then
                 if( scale( i )>=sfmax1 / f )cycle loop_200
              end if
              g = one / f
              scale( i ) = scale( i )*f
              noconv = .true.
              call stdlib_${ri}$scal( n-k+1, g, a( i, k ), lda )
              call stdlib_${ri}$scal( l, f, a( 1, i ), 1 )
           end do loop_200
           if( noconv )go to 140
           210 continue
           ilo = k
           ihi = l
           return
     end subroutine stdlib_${ri}$gebal

#:endif
#:endfor

     module pure subroutine stdlib_cgebal( job, n, a, lda, ilo, ihi, scale, info )
     !! CGEBAL balances a general complex matrix A.  This involves, first,
     !! permuting A by a similarity transformation to isolate eigenvalues
     !! in the first 1 to ILO-1 and last IHI+1 to N elements on the
     !! diagonal; and second, applying a diagonal similarity transformation
     !! to rows and columns ILO to IHI to make the rows and columns as
     !! close in norm as possible.  Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrix, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(sp), intent(out) :: scale(*)
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sclfac = 2.0e+0_sp
           real(sp), parameter :: factor = 0.95e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: noconv
           integer(ilp) :: i, ica, iexc, ira, j, k, l, m
           real(sp) :: c, ca, f, g, r, ra, s, sfmax1, sfmax2, sfmin1, sfmin2
           ! Intrinsic Functions 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEBAL', -info )
              return
           end if
           k = 1
           l = n
           if( n==0 )go to 210
           if( stdlib_lsame( job, 'N' ) ) then
              do i = 1, n
                 scale( i ) = one
              end do
              go to 210
           end if
           if( stdlib_lsame( job, 'S' ) )go to 120
           ! permutation to isolate eigenvalues if possible
           go to 50
           ! row and column exchange.
           20 continue
           scale( m ) = j
           if( j==m )go to 30
           call stdlib_cswap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_cswap( n-k+1, a( j, k ), lda, a( m, k ), lda )
           30 continue
           go to ( 40, 80 )iexc
           ! search for rows isolating an eigenvalue and push them down.
           40 continue
           if( l==1 )go to 210
           l = l - 1
           50 continue
           loop_70: do j = l, 1, -1
              loop_60: do i = 1, l
                 if( i==j )cycle loop_60
                 if( real( a( j, i ),KIND=sp)/=zero .or. aimag( a( j, i ) )/=zero )cycle &
                           loop_70
              end do loop_60
              m = l
              iexc = 1
              go to 20
           end do loop_70
           go to 90
           ! search for columns isolating an eigenvalue and push them left.
           80 continue
           k = k + 1
           90 continue
           loop_110: do j = k, l
              loop_100: do i = k, l
                 if( i==j )cycle loop_100
                 if( real( a( i, j ),KIND=sp)/=zero .or. aimag( a( i, j ) )/=zero )cycle &
                           loop_110
              end do loop_100
              m = k
              iexc = 2
              go to 20
           end do loop_110
           120 continue
           do i = k, l
              scale( i ) = one
           end do
           if( stdlib_lsame( job, 'P' ) )go to 210
           ! balance the submatrix in rows k to l.
           ! iterative loop for norm reduction
           sfmin1 = stdlib_slamch( 'S' ) / stdlib_slamch( 'P' )
           sfmax1 = one / sfmin1
           sfmin2 = sfmin1*sclfac
           sfmax2 = one / sfmin2
           140 continue
           noconv = .false.
           loop_200: do i = k, l
              c = stdlib_scnrm2( l-k+1, a( k, i ), 1 )
              r = stdlib_scnrm2( l-k+1, a( i , k ), lda )
              ica = stdlib_icamax( l, a( 1, i ), 1 )
              ca = abs( a( ica, i ) )
              ira = stdlib_icamax( n-k+1, a( i, k ), lda )
              ra = abs( a( i, ira+k-1 ) )
              ! guard against zero c or r due to underflow.
              if( c==zero .or. r==zero )cycle loop_200
              g = r / sclfac
              f = one
              s = c + r
              160 continue
              if( c>=g .or. max( f, c, ca )>=sfmax2 .or.min( r, g, ra )<=sfmin2 )go to 170
                 if( stdlib_sisnan( c+f+ca+r+g+ra ) ) then
                 ! exit if nan to avoid infinite loop
                 info = -3
                 call stdlib_xerbla( 'CGEBAL', -info )
                 return
              end if
              f = f*sclfac
              c = c*sclfac
              ca = ca*sclfac
              r = r / sclfac
              g = g / sclfac
              ra = ra / sclfac
              go to 160
              170 continue
              g = c / sclfac
              180 continue
              if( g<r .or. max( r, ra )>=sfmax2 .or.min( f, c, g, ca )<=sfmin2 )go to 190
              f = f / sclfac
              c = c / sclfac
              g = g / sclfac
              ca = ca / sclfac
              r = r*sclfac
              ra = ra*sclfac
              go to 180
              ! now balance.
              190 continue
              if( ( c+r )>=factor*s )cycle loop_200
              if( f<one .and. scale( i )<one ) then
                 if( f*scale( i )<=sfmin1 )cycle loop_200
              end if
              if( f>one .and. scale( i )>one ) then
                 if( scale( i )>=sfmax1 / f )cycle loop_200
              end if
              g = one / f
              scale( i ) = scale( i )*f
              noconv = .true.
              call stdlib_csscal( n-k+1, g, a( i, k ), lda )
              call stdlib_csscal( l, f, a( 1, i ), 1 )
           end do loop_200
           if( noconv )go to 140
           210 continue
           ilo = k
           ihi = l
           return
     end subroutine stdlib_cgebal

     module pure subroutine stdlib_zgebal( job, n, a, lda, ilo, ihi, scale, info )
     !! ZGEBAL balances a general complex matrix A.  This involves, first,
     !! permuting A by a similarity transformation to isolate eigenvalues
     !! in the first 1 to ILO-1 and last IHI+1 to N elements on the
     !! diagonal; and second, applying a diagonal similarity transformation
     !! to rows and columns ILO to IHI to make the rows and columns as
     !! close in norm as possible.  Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrix, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(dp), intent(out) :: scale(*)
           complex(dp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sclfac = 2.0e+0_dp
           real(dp), parameter :: factor = 0.95e+0_dp
           
           
           
           ! Local Scalars 
           logical(lk) :: noconv
           integer(ilp) :: i, ica, iexc, ira, j, k, l, m
           real(dp) :: c, ca, f, g, r, ra, s, sfmax1, sfmax2, sfmin1, sfmin2
           ! Intrinsic Functions 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEBAL', -info )
              return
           end if
           k = 1
           l = n
           if( n==0 )go to 210
           if( stdlib_lsame( job, 'N' ) ) then
              do i = 1, n
                 scale( i ) = one
              end do
              go to 210
           end if
           if( stdlib_lsame( job, 'S' ) )go to 120
           ! permutation to isolate eigenvalues if possible
           go to 50
           ! row and column exchange.
           20 continue
           scale( m ) = j
           if( j==m )go to 30
           call stdlib_zswap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_zswap( n-k+1, a( j, k ), lda, a( m, k ), lda )
           30 continue
           go to ( 40, 80 )iexc
           ! search for rows isolating an eigenvalue and push them down.
           40 continue
           if( l==1 )go to 210
           l = l - 1
           50 continue
           loop_70: do j = l, 1, -1
              loop_60: do i = 1, l
                 if( i==j )cycle loop_60
                 if( real( a( j, i ),KIND=dp)/=zero .or. aimag( a( j, i ) )/=zero )cycle &
                           loop_70
              end do loop_60
              m = l
              iexc = 1
              go to 20
           end do loop_70
           go to 90
           ! search for columns isolating an eigenvalue and push them left.
           80 continue
           k = k + 1
           90 continue
           loop_110: do j = k, l
              loop_100: do i = k, l
                 if( i==j )cycle loop_100
                 if( real( a( i, j ),KIND=dp)/=zero .or. aimag( a( i, j ) )/=zero )cycle &
                           loop_110
              end do loop_100
              m = k
              iexc = 2
              go to 20
           end do loop_110
           120 continue
           do i = k, l
              scale( i ) = one
           end do
           if( stdlib_lsame( job, 'P' ) )go to 210
           ! balance the submatrix in rows k to l.
           ! iterative loop for norm reduction
           sfmin1 = stdlib_dlamch( 'S' ) / stdlib_dlamch( 'P' )
           sfmax1 = one / sfmin1
           sfmin2 = sfmin1*sclfac
           sfmax2 = one / sfmin2
           140 continue
           noconv = .false.
           loop_200: do i = k, l
              c = stdlib_dznrm2( l-k+1, a( k, i ), 1 )
              r = stdlib_dznrm2( l-k+1, a( i, k ), lda )
              ica = stdlib_izamax( l, a( 1, i ), 1 )
              ca = abs( a( ica, i ) )
              ira = stdlib_izamax( n-k+1, a( i, k ), lda )
              ra = abs( a( i, ira+k-1 ) )
              ! guard against zero c or r due to underflow.
              if( c==zero .or. r==zero )cycle loop_200
              g = r / sclfac
              f = one
              s = c + r
              160 continue
              if( c>=g .or. max( f, c, ca )>=sfmax2 .or.min( r, g, ra )<=sfmin2 )go to 170
                 if( stdlib_disnan( c+f+ca+r+g+ra ) ) then
                 ! exit if nan to avoid infinite loop
                 info = -3
                 call stdlib_xerbla( 'ZGEBAL', -info )
                 return
              end if
              f = f*sclfac
              c = c*sclfac
              ca = ca*sclfac
              r = r / sclfac
              g = g / sclfac
              ra = ra / sclfac
              go to 160
              170 continue
              g = c / sclfac
              180 continue
              if( g<r .or. max( r, ra )>=sfmax2 .or.min( f, c, g, ca )<=sfmin2 )go to 190
              f = f / sclfac
              c = c / sclfac
              g = g / sclfac
              ca = ca / sclfac
              r = r*sclfac
              ra = ra*sclfac
              go to 180
              ! now balance.
              190 continue
              if( ( c+r )>=factor*s )cycle loop_200
              if( f<one .and. scale( i )<one ) then
                 if( f*scale( i )<=sfmin1 )cycle loop_200
              end if
              if( f>one .and. scale( i )>one ) then
                 if( scale( i )>=sfmax1 / f )cycle loop_200
              end if
              g = one / f
              scale( i ) = scale( i )*f
              noconv = .true.
              call stdlib_zdscal( n-k+1, g, a( i, k ), lda )
              call stdlib_zdscal( l, f, a( 1, i ), 1 )
           end do loop_200
           if( noconv )go to 140
           210 continue
           ilo = k
           ihi = l
           return
     end subroutine stdlib_zgebal

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$gebal( job, n, a, lda, ilo, ihi, scale, info )
     !! ZGEBAL: balances a general complex matrix A.  This involves, first,
     !! permuting A by a similarity transformation to isolate eigenvalues
     !! in the first 1 to ILO-1 and last IHI+1 to N elements on the
     !! diagonal; and second, applying a diagonal similarity transformation
     !! to rows and columns ILO to IHI to make the rows and columns as
     !! close in norm as possible.  Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrix, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(${ck}$), intent(out) :: scale(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: sclfac = 2.0e+0_${ck}$
           real(${ck}$), parameter :: factor = 0.95e+0_${ck}$
           
           
           
           ! Local Scalars 
           logical(lk) :: noconv
           integer(ilp) :: i, ica, iexc, ira, j, k, l, m
           real(${ck}$) :: c, ca, f, g, r, ra, s, sfmax1, sfmax2, sfmin1, sfmin2
           ! Intrinsic Functions 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEBAL', -info )
              return
           end if
           k = 1
           l = n
           if( n==0 )go to 210
           if( stdlib_lsame( job, 'N' ) ) then
              do i = 1, n
                 scale( i ) = one
              end do
              go to 210
           end if
           if( stdlib_lsame( job, 'S' ) )go to 120
           ! permutation to isolate eigenvalues if possible
           go to 50
           ! row and column exchange.
           20 continue
           scale( m ) = j
           if( j==m )go to 30
           call stdlib_${ci}$swap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_${ci}$swap( n-k+1, a( j, k ), lda, a( m, k ), lda )
           30 continue
           go to ( 40, 80 )iexc
           ! search for rows isolating an eigenvalue and push them down.
           40 continue
           if( l==1 )go to 210
           l = l - 1
           50 continue
           loop_70: do j = l, 1, -1
              loop_60: do i = 1, l
                 if( i==j )cycle loop_60
                 if( real( a( j, i ),KIND=${ck}$)/=zero .or. aimag( a( j, i ) )/=zero )cycle &
                           loop_70
              end do loop_60
              m = l
              iexc = 1
              go to 20
           end do loop_70
           go to 90
           ! search for columns isolating an eigenvalue and push them left.
           80 continue
           k = k + 1
           90 continue
           loop_110: do j = k, l
              loop_100: do i = k, l
                 if( i==j )cycle loop_100
                 if( real( a( i, j ),KIND=${ck}$)/=zero .or. aimag( a( i, j ) )/=zero )cycle &
                           loop_110
              end do loop_100
              m = k
              iexc = 2
              go to 20
           end do loop_110
           120 continue
           do i = k, l
              scale( i ) = one
           end do
           if( stdlib_lsame( job, 'P' ) )go to 210
           ! balance the submatrix in rows k to l.
           ! iterative loop for norm reduction
           sfmin1 = stdlib_${c2ri(ci)}$lamch( 'S' ) / stdlib_${c2ri(ci)}$lamch( 'P' )
           sfmax1 = one / sfmin1
           sfmin2 = sfmin1*sclfac
           sfmax2 = one / sfmin2
           140 continue
           noconv = .false.
           loop_200: do i = k, l
              c = stdlib_${c2ri(ci)}$znrm2( l-k+1, a( k, i ), 1 )
              r = stdlib_${c2ri(ci)}$znrm2( l-k+1, a( i, k ), lda )
              ica = stdlib_i${ci}$amax( l, a( 1, i ), 1 )
              ca = abs( a( ica, i ) )
              ira = stdlib_i${ci}$amax( n-k+1, a( i, k ), lda )
              ra = abs( a( i, ira+k-1 ) )
              ! guard against zero c or r due to underflow.
              if( c==zero .or. r==zero )cycle loop_200
              g = r / sclfac
              f = one
              s = c + r
              160 continue
              if( c>=g .or. max( f, c, ca )>=sfmax2 .or.min( r, g, ra )<=sfmin2 )go to 170
                 if( stdlib_${c2ri(ci)}$isnan( c+f+ca+r+g+ra ) ) then
                 ! exit if nan to avoid infinite loop
                 info = -3
                 call stdlib_xerbla( 'ZGEBAL', -info )
                 return
              end if
              f = f*sclfac
              c = c*sclfac
              ca = ca*sclfac
              r = r / sclfac
              g = g / sclfac
              ra = ra / sclfac
              go to 160
              170 continue
              g = c / sclfac
              180 continue
              if( g<r .or. max( r, ra )>=sfmax2 .or.min( f, c, g, ca )<=sfmin2 )go to 190
              f = f / sclfac
              c = c / sclfac
              g = g / sclfac
              ca = ca / sclfac
              r = r*sclfac
              ra = ra*sclfac
              go to 180
              ! now balance.
              190 continue
              if( ( c+r )>=factor*s )cycle loop_200
              if( f<one .and. scale( i )<one ) then
                 if( f*scale( i )<=sfmin1 )cycle loop_200
              end if
              if( f>one .and. scale( i )>one ) then
                 if( scale( i )>=sfmax1 / f )cycle loop_200
              end if
              g = one / f
              scale( i ) = scale( i )*f
              noconv = .true.
              call stdlib_${ci}$dscal( n-k+1, g, a( i, k ), lda )
              call stdlib_${ci}$dscal( l, f, a( 1, i ), 1 )
           end do loop_200
           if( noconv )go to 140
           210 continue
           ilo = k
           ihi = l
           return
     end subroutine stdlib_${ci}$gebal

#:endif
#:endfor



     module pure subroutine stdlib_sormhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, lwork, &
     !! SORMHR overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! IHI-ILO elementary reflectors, as returned by SGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(in) :: ihi, ilo, lda, ldc, lwork, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*), c(ldc,*)
           real(sp), intent(in) :: tau(*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, lquery
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, nh, ni, nq, nw
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           left = stdlib_lsame( side, 'L' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'T' ) )&
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 .or. ilo>max( 1, nq ) ) then
              info = -5
           else if( ihi<min( ilo, nq ) .or. ihi>nq ) then
              info = -6
           else if( lda<max( 1, nq ) ) then
              info = -8
           else if( ldc<max( 1, m ) ) then
              info = -11
           else if( lwork<nw .and. .not.lquery ) then
              info = -13
           end if
           if( info==0 ) then
              if( left ) then
                 nb = stdlib_ilaenv( 1, 'SORMQR', side // trans, nh, n, nh, -1 )
              else
                 nb = stdlib_ilaenv( 1, 'SORMQR', side // trans, m, nh, nh, -1 )
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SORMHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. nh==0 ) then
              work( 1 ) = 1
              return
           end if
           if( left ) then
              mi = nh
              ni = n
              i1 = ilo + 1
              i2 = 1
           else
              mi = m
              ni = nh
              i1 = 1
              i2 = ilo + 1
           end if
           call stdlib_sormqr( side, trans, mi, ni, nh, a( ilo+1, ilo ), lda,tau( ilo ), c( i1, &
                     i2 ), ldc, work, lwork, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_sormhr

     module pure subroutine stdlib_dormhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, lwork, &
     !! DORMHR overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! IHI-ILO elementary reflectors, as returned by DGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(in) :: ihi, ilo, lda, ldc, lwork, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*), c(ldc,*)
           real(dp), intent(in) :: tau(*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, lquery
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, nh, ni, nq, nw
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           left = stdlib_lsame( side, 'L' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'T' ) )&
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 .or. ilo>max( 1, nq ) ) then
              info = -5
           else if( ihi<min( ilo, nq ) .or. ihi>nq ) then
              info = -6
           else if( lda<max( 1, nq ) ) then
              info = -8
           else if( ldc<max( 1, m ) ) then
              info = -11
           else if( lwork<nw .and. .not.lquery ) then
              info = -13
           end if
           if( info==0 ) then
              if( left ) then
                 nb = stdlib_ilaenv( 1, 'DORMQR', side // trans, nh, n, nh, -1 )
              else
                 nb = stdlib_ilaenv( 1, 'DORMQR', side // trans, m, nh, nh, -1 )
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORMHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. nh==0 ) then
              work( 1 ) = 1
              return
           end if
           if( left ) then
              mi = nh
              ni = n
              i1 = ilo + 1
              i2 = 1
           else
              mi = m
              ni = nh
              i1 = 1
              i2 = ilo + 1
           end if
           call stdlib_dormqr( side, trans, mi, ni, nh, a( ilo+1, ilo ), lda,tau( ilo ), c( i1, &
                     i2 ), ldc, work, lwork, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dormhr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$ormhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, lwork, &
     !! DORMHR: overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! IHI-ILO elementary reflectors, as returned by DGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(in) :: ihi, ilo, lda, ldc, lwork, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), c(ldc,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, lquery
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, nh, ni, nq, nw
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           left = stdlib_lsame( side, 'L' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'T' ) )&
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 .or. ilo>max( 1, nq ) ) then
              info = -5
           else if( ihi<min( ilo, nq ) .or. ihi>nq ) then
              info = -6
           else if( lda<max( 1, nq ) ) then
              info = -8
           else if( ldc<max( 1, m ) ) then
              info = -11
           else if( lwork<nw .and. .not.lquery ) then
              info = -13
           end if
           if( info==0 ) then
              if( left ) then
                 nb = stdlib_ilaenv( 1, 'DORMQR', side // trans, nh, n, nh, -1 )
              else
                 nb = stdlib_ilaenv( 1, 'DORMQR', side // trans, m, nh, nh, -1 )
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORMHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. nh==0 ) then
              work( 1 ) = 1
              return
           end if
           if( left ) then
              mi = nh
              ni = n
              i1 = ilo + 1
              i2 = 1
           else
              mi = m
              ni = nh
              i1 = 1
              i2 = ilo + 1
           end if
           call stdlib_${ri}$ormqr( side, trans, mi, ni, nh, a( ilo+1, ilo ), lda,tau( ilo ), c( i1, &
                     i2 ), ldc, work, lwork, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$ormhr

#:endif
#:endfor



     module subroutine stdlib_sggev( jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai,beta, vl, ldvl, vr, &
     !! SGGEV computes for a pair of N-by-N real nonsymmetric matrices (A,B)
     !! the generalized eigenvalues, and optionally, the left and/or right
     !! generalized eigenvectors.
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j).
     !! The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! u(j)**H * A  = lambda(j) * u(j)**H * B .
     !! where u(j)**H is the conjugate-transpose of u(j).
               ldvr, work, lwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: alphai(*), alphar(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
                     
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery
           character :: chtemp
           integer(ilp) :: icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, in, iright, irows, itau, &
                     iwrk, jc, jr, maxwrk, minwrk
           real(sp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -12
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -14
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv. the workspace is
             ! computed assuming ilo = 1 and ihi = n, the worst case.)
           if( info==0 ) then
              minwrk = max( 1, 8*n )
              maxwrk = max( 1, n*( 7 +stdlib_ilaenv( 1, 'SGEQRF', ' ', n, 1, n, 0 ) ) )
              maxwrk = max( maxwrk, n*( 7 +stdlib_ilaenv( 1, 'SORMQR', ' ', n, 1, n, 0 ) ) )
                        
              if( ilvl ) then
                 maxwrk = max( maxwrk, n*( 7 +stdlib_ilaenv( 1, 'SORGQR', ' ', n, 1, n, -1 ) ) )
                           
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery )info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGGEV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_slange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_slascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_slange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_slascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrices a, b to isolate eigenvalues if possible
           ! (workspace: need 6*n)
           ileft = 1
           iright = n + 1
           iwrk = iright + n
           call stdlib_sggbal( 'P', n, a, lda, b, ldb, ilo, ihi, work( ileft ),work( iright ), &
                     work( iwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           if( ilv ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = iwrk
           iwrk = itau + irows
           call stdlib_sgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           ! (workspace: need n, prefer n*nb)
           call stdlib_sormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl
           ! (workspace: need n, prefer n*nb)
           if( ilvl ) then
              call stdlib_slaset( 'FULL', n, n, zero, one, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_slacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_sorgqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vr
           if( ilvr )call stdlib_slaset( 'FULL', n, n, zero, one, vr, ldvr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           if( ilv ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_sgghrd( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        ierr )
           else
              call stdlib_sgghrd( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur forms and schur vectors)
           ! (workspace: need n)
           iwrk = itau
           if( ilv ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_shgeqz( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vl, ldvl, vr, ldvr,work( iwrk ), lwork+1-iwrk, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 110
           end if
           ! compute eigenvectors
           ! (workspace: need 6*n)
           if( ilv ) then
              if( ilvl ) then
                 if( ilvr ) then
                    chtemp = 'B'
                 else
                    chtemp = 'L'
                 end if
              else
                 chtemp = 'R'
              end if
              call stdlib_stgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl, ldvl,vr, ldvr, n, &
                        in, work( iwrk ), ierr )
              if( ierr/=0 ) then
                 info = n + 2
                 go to 110
              end if
              ! undo balancing on vl and vr and normalization
              ! (workspace: none needed)
              if( ilvl ) then
                 call stdlib_sggbak( 'P', 'L', n, ilo, ihi, work( ileft ),work( iright ), n, vl, &
                           ldvl, ierr )
                 loop_50: do jc = 1, n
                    if( alphai( jc )<zero )cycle loop_50
                    temp = zero
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          temp = max( temp, abs( vl( jr, jc ) ) )
                       end do
                    else
                       do jr = 1, n
                          temp = max( temp, abs( vl( jr, jc ) )+abs( vl( jr, jc+1 ) ) )
                       end do
                    end if
                    if( temp<smlnum )cycle loop_50
                    temp = one / temp
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          vl( jr, jc ) = vl( jr, jc )*temp
                       end do
                    else
                       do jr = 1, n
                          vl( jr, jc ) = vl( jr, jc )*temp
                          vl( jr, jc+1 ) = vl( jr, jc+1 )*temp
                       end do
                    end if
                 end do loop_50
              end if
              if( ilvr ) then
                 call stdlib_sggbak( 'P', 'R', n, ilo, ihi, work( ileft ),work( iright ), n, vr, &
                           ldvr, ierr )
                 loop_100: do jc = 1, n
                    if( alphai( jc )<zero )cycle loop_100
                    temp = zero
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          temp = max( temp, abs( vr( jr, jc ) ) )
                       end do
                    else
                       do jr = 1, n
                          temp = max( temp, abs( vr( jr, jc ) )+abs( vr( jr, jc+1 ) ) )
                       end do
                    end if
                    if( temp<smlnum )cycle loop_100
                    temp = one / temp
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          vr( jr, jc ) = vr( jr, jc )*temp
                       end do
                    else
                       do jr = 1, n
                          vr( jr, jc ) = vr( jr, jc )*temp
                          vr( jr, jc+1 ) = vr( jr, jc+1 )*temp
                       end do
                    end if
                 end do loop_100
              end if
              ! end of eigenvector calculation
           end if
           ! undo scaling if necessary
           110 continue
           if( ilascl ) then
              call stdlib_slascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_slascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_slascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_sggev

     module subroutine stdlib_dggev( jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai,beta, vl, ldvl, vr, &
     !! DGGEV computes for a pair of N-by-N real nonsymmetric matrices (A,B)
     !! the generalized eigenvalues, and optionally, the left and/or right
     !! generalized eigenvectors.
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j).
     !! The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! u(j)**H * A  = lambda(j) * u(j)**H * B .
     !! where u(j)**H is the conjugate-transpose of u(j).
               ldvr, work, lwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: alphai(*), alphar(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
                     
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery
           character :: chtemp
           integer(ilp) :: icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, in, iright, irows, itau, &
                     iwrk, jc, jr, maxwrk, minwrk
           real(dp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -12
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -14
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv. the workspace is
             ! computed assuming ilo = 1 and ihi = n, the worst case.)
           if( info==0 ) then
              minwrk = max( 1, 8*n )
              maxwrk = max( 1, n*( 7 +stdlib_ilaenv( 1, 'DGEQRF', ' ', n, 1, n, 0 ) ) )
              maxwrk = max( maxwrk, n*( 7 +stdlib_ilaenv( 1, 'DORMQR', ' ', n, 1, n, 0 ) ) )
                        
              if( ilvl ) then
                 maxwrk = max( maxwrk, n*( 7 +stdlib_ilaenv( 1, 'DORGQR', ' ', n, 1, n, -1 ) ) )
                           
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery )info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGEV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' )
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_dlange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_dlascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_dlange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_dlascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrices a, b to isolate eigenvalues if possible
           ! (workspace: need 6*n)
           ileft = 1
           iright = n + 1
           iwrk = iright + n
           call stdlib_dggbal( 'P', n, a, lda, b, ldb, ilo, ihi, work( ileft ),work( iright ), &
                     work( iwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           if( ilv ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = iwrk
           iwrk = itau + irows
           call stdlib_dgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           ! (workspace: need n, prefer n*nb)
           call stdlib_dormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl
           ! (workspace: need n, prefer n*nb)
           if( ilvl ) then
              call stdlib_dlaset( 'FULL', n, n, zero, one, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_dlacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_dorgqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vr
           if( ilvr )call stdlib_dlaset( 'FULL', n, n, zero, one, vr, ldvr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           if( ilv ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_dgghrd( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        ierr )
           else
              call stdlib_dgghrd( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur forms and schur vectors)
           ! (workspace: need n)
           iwrk = itau
           if( ilv ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_dhgeqz( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vl, ldvl, vr, ldvr,work( iwrk ), lwork+1-iwrk, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 110
           end if
           ! compute eigenvectors
           ! (workspace: need 6*n)
           if( ilv ) then
              if( ilvl ) then
                 if( ilvr ) then
                    chtemp = 'B'
                 else
                    chtemp = 'L'
                 end if
              else
                 chtemp = 'R'
              end if
              call stdlib_dtgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl, ldvl,vr, ldvr, n, &
                        in, work( iwrk ), ierr )
              if( ierr/=0 ) then
                 info = n + 2
                 go to 110
              end if
              ! undo balancing on vl and vr and normalization
              ! (workspace: none needed)
              if( ilvl ) then
                 call stdlib_dggbak( 'P', 'L', n, ilo, ihi, work( ileft ),work( iright ), n, vl, &
                           ldvl, ierr )
                 loop_50: do jc = 1, n
                    if( alphai( jc )<zero )cycle loop_50
                    temp = zero
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          temp = max( temp, abs( vl( jr, jc ) ) )
                       end do
                    else
                       do jr = 1, n
                          temp = max( temp, abs( vl( jr, jc ) )+abs( vl( jr, jc+1 ) ) )
                       end do
                    end if
                    if( temp<smlnum )cycle loop_50
                    temp = one / temp
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          vl( jr, jc ) = vl( jr, jc )*temp
                       end do
                    else
                       do jr = 1, n
                          vl( jr, jc ) = vl( jr, jc )*temp
                          vl( jr, jc+1 ) = vl( jr, jc+1 )*temp
                       end do
                    end if
                 end do loop_50
              end if
              if( ilvr ) then
                 call stdlib_dggbak( 'P', 'R', n, ilo, ihi, work( ileft ),work( iright ), n, vr, &
                           ldvr, ierr )
                 loop_100: do jc = 1, n
                    if( alphai( jc )<zero )cycle loop_100
                    temp = zero
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          temp = max( temp, abs( vr( jr, jc ) ) )
                       end do
                    else
                       do jr = 1, n
                          temp = max( temp, abs( vr( jr, jc ) )+abs( vr( jr, jc+1 ) ) )
                       end do
                    end if
                    if( temp<smlnum )cycle loop_100
                    temp = one / temp
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          vr( jr, jc ) = vr( jr, jc )*temp
                       end do
                    else
                       do jr = 1, n
                          vr( jr, jc ) = vr( jr, jc )*temp
                          vr( jr, jc+1 ) = vr( jr, jc+1 )*temp
                       end do
                    end if
                 end do loop_100
              end if
              ! end of eigenvector calculation
           end if
           ! undo scaling if necessary
           110 continue
           if( ilascl ) then
              call stdlib_dlascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_dlascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_dlascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_dggev

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$ggev( jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai,beta, vl, ldvl, vr, &
     !! DGGEV: computes for a pair of N-by-N real nonsymmetric matrices (A,B)
     !! the generalized eigenvalues, and optionally, the left and/or right
     !! generalized eigenvectors.
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j).
     !! The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! u(j)**H * A  = lambda(j) * u(j)**H * B .
     !! where u(j)**H is the conjugate-transpose of u(j).
               ldvr, work, lwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
                     
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery
           character :: chtemp
           integer(ilp) :: icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, in, iright, irows, itau, &
                     iwrk, jc, jr, maxwrk, minwrk
           real(${rk}$) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -12
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -14
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv. the workspace is
             ! computed assuming ilo = 1 and ihi = n, the worst case.)
           if( info==0 ) then
              minwrk = max( 1, 8*n )
              maxwrk = max( 1, n*( 7 +stdlib_ilaenv( 1, 'DGEQRF', ' ', n, 1, n, 0 ) ) )
              maxwrk = max( maxwrk, n*( 7 +stdlib_ilaenv( 1, 'DORMQR', ' ', n, 1, n, 0 ) ) )
                        
              if( ilvl ) then
                 maxwrk = max( maxwrk, n*( 7 +stdlib_ilaenv( 1, 'DORGQR', ' ', n, 1, n, -1 ) ) )
                           
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery )info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGEV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_${ri}$lascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_${ri}$lange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_${ri}$lascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrices a, b to isolate eigenvalues if possible
           ! (workspace: need 6*n)
           ileft = 1
           iright = n + 1
           iwrk = iright + n
           call stdlib_${ri}$ggbal( 'P', n, a, lda, b, ldb, ilo, ihi, work( ileft ),work( iright ), &
                     work( iwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           if( ilv ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = iwrk
           iwrk = itau + irows
           call stdlib_${ri}$geqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           ! (workspace: need n, prefer n*nb)
           call stdlib_${ri}$ormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl
           ! (workspace: need n, prefer n*nb)
           if( ilvl ) then
              call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_${ri}$lacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_${ri}$orgqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vr
           if( ilvr )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vr, ldvr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           if( ilv ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_${ri}$gghrd( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        ierr )
           else
              call stdlib_${ri}$gghrd( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur forms and schur vectors)
           ! (workspace: need n)
           iwrk = itau
           if( ilv ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_${ri}$hgeqz( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vl, ldvl, vr, ldvr,work( iwrk ), lwork+1-iwrk, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 110
           end if
           ! compute eigenvectors
           ! (workspace: need 6*n)
           if( ilv ) then
              if( ilvl ) then
                 if( ilvr ) then
                    chtemp = 'B'
                 else
                    chtemp = 'L'
                 end if
              else
                 chtemp = 'R'
              end if
              call stdlib_${ri}$tgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl, ldvl,vr, ldvr, n, &
                        in, work( iwrk ), ierr )
              if( ierr/=0 ) then
                 info = n + 2
                 go to 110
              end if
              ! undo balancing on vl and vr and normalization
              ! (workspace: none needed)
              if( ilvl ) then
                 call stdlib_${ri}$ggbak( 'P', 'L', n, ilo, ihi, work( ileft ),work( iright ), n, vl, &
                           ldvl, ierr )
                 loop_50: do jc = 1, n
                    if( alphai( jc )<zero )cycle loop_50
                    temp = zero
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          temp = max( temp, abs( vl( jr, jc ) ) )
                       end do
                    else
                       do jr = 1, n
                          temp = max( temp, abs( vl( jr, jc ) )+abs( vl( jr, jc+1 ) ) )
                       end do
                    end if
                    if( temp<smlnum )cycle loop_50
                    temp = one / temp
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          vl( jr, jc ) = vl( jr, jc )*temp
                       end do
                    else
                       do jr = 1, n
                          vl( jr, jc ) = vl( jr, jc )*temp
                          vl( jr, jc+1 ) = vl( jr, jc+1 )*temp
                       end do
                    end if
                 end do loop_50
              end if
              if( ilvr ) then
                 call stdlib_${ri}$ggbak( 'P', 'R', n, ilo, ihi, work( ileft ),work( iright ), n, vr, &
                           ldvr, ierr )
                 loop_100: do jc = 1, n
                    if( alphai( jc )<zero )cycle loop_100
                    temp = zero
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          temp = max( temp, abs( vr( jr, jc ) ) )
                       end do
                    else
                       do jr = 1, n
                          temp = max( temp, abs( vr( jr, jc ) )+abs( vr( jr, jc+1 ) ) )
                       end do
                    end if
                    if( temp<smlnum )cycle loop_100
                    temp = one / temp
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          vr( jr, jc ) = vr( jr, jc )*temp
                       end do
                    else
                       do jr = 1, n
                          vr( jr, jc ) = vr( jr, jc )*temp
                          vr( jr, jc+1 ) = vr( jr, jc+1 )*temp
                       end do
                    end if
                 end do loop_100
              end if
              ! end of eigenvector calculation
           end if
           ! undo scaling if necessary
           110 continue
           if( ilascl ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_${ri}$ggev

#:endif
#:endfor

     module subroutine stdlib_cggev( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,vl, ldvl, vr, ldvr, &
     !! CGGEV computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, and optionally, the left and/or
     !! right generalized eigenvectors.
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right generalized eigenvector v(j) corresponding to the
     !! generalized eigenvalue lambda(j) of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j).
     !! The left generalized eigenvector u(j) corresponding to the
     !! generalized eigenvalues lambda(j) of (A,B) satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H * B
     !! where u(j)**H is the conjugate-transpose of u(j).
               work, lwork, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: alpha(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery
           character :: chtemp
           integer(ilp) :: icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, in, iright, irows, irwrk,&
                      itau, iwrk, jc, jr, lwkmin, lwkopt
           real(sp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           complex(sp) :: x
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=sp) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -11
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -13
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv. the workspace is
             ! computed assuming ilo = 1 and ihi = n, the worst case.)
           if( info==0 ) then
              lwkmin = max( 1, 2*n )
              lwkopt = max( 1, n + n*stdlib_ilaenv( 1, 'CGEQRF', ' ', n, 1, n, 0 ) )
              lwkopt = max( lwkopt, n +n*stdlib_ilaenv( 1, 'CUNMQR', ' ', n, 1, n, 0 ) )
              if( ilvl ) then
                 lwkopt = max( lwkopt, n +n*stdlib_ilaenv( 1, 'CUNGQR', ' ', n, 1, n, -1 ) )
                           
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery )info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGEV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_slamch( 'E' )*stdlib_slamch( 'B' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_clascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_clange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrices a, b to isolate eigenvalues if possible
           ! (real workspace: need 6*n)
           ileft = 1
           iright = n + 1
           irwrk = iright + n
           call stdlib_cggbal( 'P', n, a, lda, b, ldb, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     rwork( irwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (complex workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           if( ilv ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = 1
           iwrk = itau + irows
           call stdlib_cgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           ! (complex workspace: need n, prefer n*nb)
           call stdlib_cunmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl
           ! (complex workspace: need n, prefer n*nb)
           if( ilvl ) then
              call stdlib_claset( 'FULL', n, n, czero, cone, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_clacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_cungqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vr
           if( ilvr )call stdlib_claset( 'FULL', n, n, czero, cone, vr, ldvr )
           ! reduce to generalized hessenberg form
           if( ilv ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_cgghrd( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        ierr )
           else
              call stdlib_cgghrd( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur form and schur vectors)
           ! (complex workspace: need n)
           ! (real workspace: need n)
           iwrk = itau
           if( ilv ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_chgeqz( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vl, &
                     ldvl, vr, ldvr, work( iwrk ),lwork+1-iwrk, rwork( irwrk ), ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 70
           end if
           ! compute eigenvectors
           ! (real workspace: need 2*n)
           ! (complex workspace: need 2*n)
           if( ilv ) then
              if( ilvl ) then
                 if( ilvr ) then
                    chtemp = 'B'
                 else
                    chtemp = 'L'
                 end if
              else
                 chtemp = 'R'
              end if
              call stdlib_ctgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl, ldvl,vr, ldvr, n, &
                        in, work( iwrk ), rwork( irwrk ),ierr )
              if( ierr/=0 ) then
                 info = n + 2
                 go to 70
              end if
              ! undo balancing on vl and vr and normalization
              ! (workspace: none needed)
              if( ilvl ) then
                 call stdlib_cggbak( 'P', 'L', n, ilo, ihi, rwork( ileft ),rwork( iright ), n, vl,&
                            ldvl, ierr )
                 loop_30: do jc = 1, n
                    temp = zero
                    do jr = 1, n
                       temp = max( temp, abs1( vl( jr, jc ) ) )
                    end do
                    if( temp<smlnum )cycle loop_30
                    temp = one / temp
                    do jr = 1, n
                       vl( jr, jc ) = vl( jr, jc )*temp
                    end do
                 end do loop_30
              end if
              if( ilvr ) then
                 call stdlib_cggbak( 'P', 'R', n, ilo, ihi, rwork( ileft ),rwork( iright ), n, vr,&
                            ldvr, ierr )
                 loop_60: do jc = 1, n
                    temp = zero
                    do jr = 1, n
                       temp = max( temp, abs1( vr( jr, jc ) ) )
                    end do
                    if( temp<smlnum )cycle loop_60
                    temp = one / temp
                    do jr = 1, n
                       vr( jr, jc ) = vr( jr, jc )*temp
                    end do
                 end do loop_60
              end if
           end if
           ! undo scaling if necessary
           70 continue
           if( ilascl )call stdlib_clascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cggev

     module subroutine stdlib_zggev( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,vl, ldvl, vr, ldvr, &
     !! ZGGEV computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, and optionally, the left and/or
     !! right generalized eigenvectors.
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right generalized eigenvector v(j) corresponding to the
     !! generalized eigenvalue lambda(j) of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j).
     !! The left generalized eigenvector u(j) corresponding to the
     !! generalized eigenvalues lambda(j) of (A,B) satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H * B
     !! where u(j)**H is the conjugate-transpose of u(j).
               work, lwork, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: alpha(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery
           character :: chtemp
           integer(ilp) :: icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, in, iright, irows, irwrk,&
                      itau, iwrk, jc, jr, lwkmin, lwkopt
           real(dp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           complex(dp) :: x
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=dp) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -11
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -13
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv. the workspace is
             ! computed assuming ilo = 1 and ihi = n, the worst case.)
           if( info==0 ) then
              lwkmin = max( 1, 2*n )
              lwkopt = max( 1, n + n*stdlib_ilaenv( 1, 'ZGEQRF', ' ', n, 1, n, 0 ) )
              lwkopt = max( lwkopt, n +n*stdlib_ilaenv( 1, 'ZUNMQR', ' ', n, 1, n, 0 ) )
              if( ilvl ) then
                 lwkopt = max( lwkopt, n +n*stdlib_ilaenv( 1, 'ZUNGQR', ' ', n, 1, n, -1 ) )
                           
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery )info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGEV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_dlamch( 'E' )*stdlib_dlamch( 'B' )
           smlnum = stdlib_dlamch( 'S' )
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_zlange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_zlascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_zlange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_zlascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrices a, b to isolate eigenvalues if possible
           ! (real workspace: need 6*n)
           ileft = 1
           iright = n + 1
           irwrk = iright + n
           call stdlib_zggbal( 'P', n, a, lda, b, ldb, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     rwork( irwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (complex workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           if( ilv ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = 1
           iwrk = itau + irows
           call stdlib_zgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           ! (complex workspace: need n, prefer n*nb)
           call stdlib_zunmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl
           ! (complex workspace: need n, prefer n*nb)
           if( ilvl ) then
              call stdlib_zlaset( 'FULL', n, n, czero, cone, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_zlacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_zungqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vr
           if( ilvr )call stdlib_zlaset( 'FULL', n, n, czero, cone, vr, ldvr )
           ! reduce to generalized hessenberg form
           if( ilv ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_zgghrd( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        ierr )
           else
              call stdlib_zgghrd( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur form and schur vectors)
           ! (complex workspace: need n)
           ! (real workspace: need n)
           iwrk = itau
           if( ilv ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_zhgeqz( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vl, &
                     ldvl, vr, ldvr, work( iwrk ),lwork+1-iwrk, rwork( irwrk ), ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 70
           end if
           ! compute eigenvectors
           ! (real workspace: need 2*n)
           ! (complex workspace: need 2*n)
           if( ilv ) then
              if( ilvl ) then
                 if( ilvr ) then
                    chtemp = 'B'
                 else
                    chtemp = 'L'
                 end if
              else
                 chtemp = 'R'
              end if
              call stdlib_ztgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl, ldvl,vr, ldvr, n, &
                        in, work( iwrk ), rwork( irwrk ),ierr )
              if( ierr/=0 ) then
                 info = n + 2
                 go to 70
              end if
              ! undo balancing on vl and vr and normalization
              ! (workspace: none needed)
              if( ilvl ) then
                 call stdlib_zggbak( 'P', 'L', n, ilo, ihi, rwork( ileft ),rwork( iright ), n, vl,&
                            ldvl, ierr )
                 loop_30: do jc = 1, n
                    temp = zero
                    do jr = 1, n
                       temp = max( temp, abs1( vl( jr, jc ) ) )
                    end do
                    if( temp<smlnum )cycle loop_30
                    temp = one / temp
                    do jr = 1, n
                       vl( jr, jc ) = vl( jr, jc )*temp
                    end do
                 end do loop_30
              end if
              if( ilvr ) then
                 call stdlib_zggbak( 'P', 'R', n, ilo, ihi, rwork( ileft ),rwork( iright ), n, vr,&
                            ldvr, ierr )
                 loop_60: do jc = 1, n
                    temp = zero
                    do jr = 1, n
                       temp = max( temp, abs1( vr( jr, jc ) ) )
                    end do
                    if( temp<smlnum )cycle loop_60
                    temp = one / temp
                    do jr = 1, n
                       vr( jr, jc ) = vr( jr, jc )*temp
                    end do
                 end do loop_60
              end if
           end if
           ! undo scaling if necessary
           70 continue
           if( ilascl )call stdlib_zlascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           if( ilbscl )call stdlib_zlascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zggev

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$ggev( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,vl, ldvl, vr, ldvr, &
     !! ZGGEV: computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, and optionally, the left and/or
     !! right generalized eigenvectors.
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right generalized eigenvector v(j) corresponding to the
     !! generalized eigenvalue lambda(j) of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j).
     !! The left generalized eigenvector u(j) corresponding to the
     !! generalized eigenvalues lambda(j) of (A,B) satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H * B
     !! where u(j)**H is the conjugate-transpose of u(j).
               work, lwork, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: alpha(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery
           character :: chtemp
           integer(ilp) :: icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, in, iright, irows, irwrk,&
                      itau, iwrk, jc, jr, lwkmin, lwkopt
           real(${ck}$) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           complex(${ck}$) :: x
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=${ck}$) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -11
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -13
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv. the workspace is
             ! computed assuming ilo = 1 and ihi = n, the worst case.)
           if( info==0 ) then
              lwkmin = max( 1, 2*n )
              lwkopt = max( 1, n + n*stdlib_ilaenv( 1, 'ZGEQRF', ' ', n, 1, n, 0 ) )
              lwkopt = max( lwkopt, n +n*stdlib_ilaenv( 1, 'ZUNMQR', ' ', n, 1, n, 0 ) )
              if( ilvl ) then
                 lwkopt = max( lwkopt, n +n*stdlib_ilaenv( 1, 'ZUNGQR', ' ', n, 1, n, -1 ) )
                           
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery )info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGEV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_${c2ri(ci)}$lamch( 'E' )*stdlib_${c2ri(ci)}$lamch( 'B' )
           smlnum = stdlib_${c2ri(ci)}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${c2ri(ci)}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ci}$lange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_${ci}$lascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_${ci}$lange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_${ci}$lascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrices a, b to isolate eigenvalues if possible
           ! (real workspace: need 6*n)
           ileft = 1
           iright = n + 1
           irwrk = iright + n
           call stdlib_${ci}$ggbal( 'P', n, a, lda, b, ldb, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     rwork( irwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (complex workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           if( ilv ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = 1
           iwrk = itau + irows
           call stdlib_${ci}$geqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           ! (complex workspace: need n, prefer n*nb)
           call stdlib_${ci}$unmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl
           ! (complex workspace: need n, prefer n*nb)
           if( ilvl ) then
              call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_${ci}$lacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_${ci}$ungqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vr
           if( ilvr )call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, vr, ldvr )
           ! reduce to generalized hessenberg form
           if( ilv ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_${ci}$gghrd( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        ierr )
           else
              call stdlib_${ci}$gghrd( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur form and schur vectors)
           ! (complex workspace: need n)
           ! (real workspace: need n)
           iwrk = itau
           if( ilv ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_${ci}$hgeqz( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vl, &
                     ldvl, vr, ldvr, work( iwrk ),lwork+1-iwrk, rwork( irwrk ), ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 70
           end if
           ! compute eigenvectors
           ! (real workspace: need 2*n)
           ! (complex workspace: need 2*n)
           if( ilv ) then
              if( ilvl ) then
                 if( ilvr ) then
                    chtemp = 'B'
                 else
                    chtemp = 'L'
                 end if
              else
                 chtemp = 'R'
              end if
              call stdlib_${ci}$tgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl, ldvl,vr, ldvr, n, &
                        in, work( iwrk ), rwork( irwrk ),ierr )
              if( ierr/=0 ) then
                 info = n + 2
                 go to 70
              end if
              ! undo balancing on vl and vr and normalization
              ! (workspace: none needed)
              if( ilvl ) then
                 call stdlib_${ci}$ggbak( 'P', 'L', n, ilo, ihi, rwork( ileft ),rwork( iright ), n, vl,&
                            ldvl, ierr )
                 loop_30: do jc = 1, n
                    temp = zero
                    do jr = 1, n
                       temp = max( temp, abs1( vl( jr, jc ) ) )
                    end do
                    if( temp<smlnum )cycle loop_30
                    temp = one / temp
                    do jr = 1, n
                       vl( jr, jc ) = vl( jr, jc )*temp
                    end do
                 end do loop_30
              end if
              if( ilvr ) then
                 call stdlib_${ci}$ggbak( 'P', 'R', n, ilo, ihi, rwork( ileft ),rwork( iright ), n, vr,&
                            ldvr, ierr )
                 loop_60: do jc = 1, n
                    temp = zero
                    do jr = 1, n
                       temp = max( temp, abs1( vr( jr, jc ) ) )
                    end do
                    if( temp<smlnum )cycle loop_60
                    temp = one / temp
                    do jr = 1, n
                       vr( jr, jc ) = vr( jr, jc )*temp
                    end do
                 end do loop_60
              end if
           end if
           ! undo scaling if necessary
           70 continue
           if( ilascl )call stdlib_${ci}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           if( ilbscl )call stdlib_${ci}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$ggev

#:endif
#:endfor



     module pure subroutine stdlib_slaein( rightv, noinit, n, h, ldh, wr, wi, vr, vi, b,ldb, work, eps3, &
     !! SLAEIN uses inverse iteration to find a right or left eigenvector
     !! corresponding to the eigenvalue (WR,WI) of a real upper Hessenberg
     !! matrix H.
               smlnum, bignum, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: noinit, rightv
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldh, n
           real(sp), intent(in) :: bignum, eps3, smlnum, wi, wr
           ! Array Arguments 
           real(sp), intent(out) :: b(ldb,*), work(*)
           real(sp), intent(in) :: h(ldh,*)
           real(sp), intent(inout) :: vi(*), vr(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: tenth = 1.0e-1_sp
           
           ! Local Scalars 
           character :: normin, trans
           integer(ilp) :: i, i1, i2, i3, ierr, its, j
           real(sp) :: absbii, absbjj, ei, ej, growto, norm, nrmsml, rec, rootn, scale, temp, &
                     vcrit, vmax, vnorm, w, w1, x, xi, xr, y
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! growto is the threshold used in the acceptance test for an
           ! eigenvector.
           rootn = sqrt( real( n,KIND=sp) )
           growto = tenth / rootn
           nrmsml = max( one, eps3*rootn )*smlnum
           ! form b = h - (wr,wi)*i (except that the subdiagonal elements and
           ! the imaginary parts of the diagonal elements are not stored).
           do j = 1, n
              do i = 1, j - 1
                 b( i, j ) = h( i, j )
              end do
              b( j, j ) = h( j, j ) - wr
           end do
           if( wi==zero ) then
              ! real eigenvalue.
              if( noinit ) then
                 ! set initial vector.
                 do i = 1, n
                    vr( i ) = eps3
                 end do
              else
                 ! scale supplied initial vector.
                 vnorm = stdlib_snrm2( n, vr, 1 )
                 call stdlib_sscal( n, ( eps3*rootn ) / max( vnorm, nrmsml ), vr,1 )
              end if
              if( rightv ) then
                 ! lu decomposition with partial pivoting of b, replacing zero
                 ! pivots by eps3.
                 do i = 1, n - 1
                    ei = h( i+1, i )
                    if( abs( b( i, i ) )<abs( ei ) ) then
                       ! interchange rows and eliminate.
                       x = b( i, i ) / ei
                       b( i, i ) = ei
                       do j = i + 1, n
                          temp = b( i+1, j )
                          b( i+1, j ) = b( i, j ) - x*temp
                          b( i, j ) = temp
                       end do
                    else
                       ! eliminate without interchange.
                       if( b( i, i )==zero )b( i, i ) = eps3
                       x = ei / b( i, i )
                       if( x/=zero ) then
                          do j = i + 1, n
                             b( i+1, j ) = b( i+1, j ) - x*b( i, j )
                          end do
                       end if
                    end if
                 end do
                 if( b( n, n )==zero )b( n, n ) = eps3
                 trans = 'N'
              else
                 ! ul decomposition with partial pivoting of b, replacing zero
                 ! pivots by eps3.
                 do j = n, 2, -1
                    ej = h( j, j-1 )
                    if( abs( b( j, j ) )<abs( ej ) ) then
                       ! interchange columns and eliminate.
                       x = b( j, j ) / ej
                       b( j, j ) = ej
                       do i = 1, j - 1
                          temp = b( i, j-1 )
                          b( i, j-1 ) = b( i, j ) - x*temp
                          b( i, j ) = temp
                       end do
                    else
                       ! eliminate without interchange.
                       if( b( j, j )==zero )b( j, j ) = eps3
                       x = ej / b( j, j )
                       if( x/=zero ) then
                          do i = 1, j - 1
                             b( i, j-1 ) = b( i, j-1 ) - x*b( i, j )
                          end do
                       end if
                    end if
                 end do
                 if( b( 1, 1 )==zero )b( 1, 1 ) = eps3
                 trans = 'T'
              end if
              normin = 'N'
              do its = 1, n
                 ! solve u*x = scale*v for a right eigenvector
                   ! or u**t*x = scale*v for a left eigenvector,
                 ! overwriting x on v.
                 call stdlib_slatrs( 'UPPER', trans, 'NONUNIT', normin, n, b, ldb,vr, scale, work,&
                            ierr )
                 normin = 'Y'
                 ! test for sufficient growth in the norm of v.
                 vnorm = stdlib_sasum( n, vr, 1 )
                 if( vnorm>=growto*scale )go to 120
                 ! choose new orthogonal starting vector and try again.
                 temp = eps3 / ( rootn+one )
                 vr( 1 ) = eps3
                 do i = 2, n
                    vr( i ) = temp
                 end do
                 vr( n-its+1 ) = vr( n-its+1 ) - eps3*rootn
              end do
              ! failure to find eigenvector in n iterations.
              info = 1
              120 continue
              ! normalize eigenvector.
              i = stdlib_isamax( n, vr, 1 )
              call stdlib_sscal( n, one / abs( vr( i ) ), vr, 1 )
           else
              ! complex eigenvalue.
              if( noinit ) then
                 ! set initial vector.
                 do i = 1, n
                    vr( i ) = eps3
                    vi( i ) = zero
                 end do
              else
                 ! scale supplied initial vector.
                 norm = stdlib_slapy2( stdlib_snrm2( n, vr, 1 ), stdlib_snrm2( n, vi, 1 ) )
                           
                 rec = ( eps3*rootn ) / max( norm, nrmsml )
                 call stdlib_sscal( n, rec, vr, 1 )
                 call stdlib_sscal( n, rec, vi, 1 )
              end if
              if( rightv ) then
                 ! lu decomposition with partial pivoting of b, replacing zero
                 ! pivots by eps3.
                 ! the imaginary part of the (i,j)-th element of u is stored in
                 ! b(j+1,i).
                 b( 2, 1 ) = -wi
                 do i = 2, n
                    b( i+1, 1 ) = zero
                 end do
                 loop_170: do i = 1, n - 1
                    absbii = stdlib_slapy2( b( i, i ), b( i+1, i ) )
                    ei = h( i+1, i )
                    if( absbii<abs( ei ) ) then
                       ! interchange rows and eliminate.
                       xr = b( i, i ) / ei
                       xi = b( i+1, i ) / ei
                       b( i, i ) = ei
                       b( i+1, i ) = zero
                       do j = i + 1, n
                          temp = b( i+1, j )
                          b( i+1, j ) = b( i, j ) - xr*temp
                          b( j+1, i+1 ) = b( j+1, i ) - xi*temp
                          b( i, j ) = temp
                          b( j+1, i ) = zero
                       end do
                       b( i+2, i ) = -wi
                       b( i+1, i+1 ) = b( i+1, i+1 ) - xi*wi
                       b( i+2, i+1 ) = b( i+2, i+1 ) + xr*wi
                    else
                       ! eliminate without interchanging rows.
                       if( absbii==zero ) then
                          b( i, i ) = eps3
                          b( i+1, i ) = zero
                          absbii = eps3
                       end if
                       ei = ( ei / absbii ) / absbii
                       xr = b( i, i )*ei
                       xi = -b( i+1, i )*ei
                       do j = i + 1, n
                          b( i+1, j ) = b( i+1, j ) - xr*b( i, j ) +xi*b( j+1, i )
                          b( j+1, i+1 ) = -xr*b( j+1, i ) - xi*b( i, j )
                       end do
                       b( i+2, i+1 ) = b( i+2, i+1 ) - wi
                    end if
                    ! compute 1-norm of offdiagonal elements of i-th row.
                    work( i ) = stdlib_sasum( n-i, b( i, i+1 ), ldb ) +stdlib_sasum( n-i, b( i+2, &
                              i ), 1 )
                 end do loop_170
                 if( b( n, n )==zero .and. b( n+1, n )==zero )b( n, n ) = eps3
                 work( n ) = zero
                 i1 = n
                 i2 = 1
                 i3 = -1
              else
                 ! ul decomposition with partial pivoting of conjg(b),
                 ! replacing zero pivots by eps3.
                 ! the imaginary part of the (i,j)-th element of u is stored in
                 ! b(j+1,i).
                 b( n+1, n ) = wi
                 do j = 1, n - 1
                    b( n+1, j ) = zero
                 end do
                 loop_210: do j = n, 2, -1
                    ej = h( j, j-1 )
                    absbjj = stdlib_slapy2( b( j, j ), b( j+1, j ) )
                    if( absbjj<abs( ej ) ) then
                       ! interchange columns and eliminate
                       xr = b( j, j ) / ej
                       xi = b( j+1, j ) / ej
                       b( j, j ) = ej
                       b( j+1, j ) = zero
                       do i = 1, j - 1
                          temp = b( i, j-1 )
                          b( i, j-1 ) = b( i, j ) - xr*temp
                          b( j, i ) = b( j+1, i ) - xi*temp
                          b( i, j ) = temp
                          b( j+1, i ) = zero
                       end do
                       b( j+1, j-1 ) = wi
                       b( j-1, j-1 ) = b( j-1, j-1 ) + xi*wi
                       b( j, j-1 ) = b( j, j-1 ) - xr*wi
                    else
                       ! eliminate without interchange.
                       if( absbjj==zero ) then
                          b( j, j ) = eps3
                          b( j+1, j ) = zero
                          absbjj = eps3
                       end if
                       ej = ( ej / absbjj ) / absbjj
                       xr = b( j, j )*ej
                       xi = -b( j+1, j )*ej
                       do i = 1, j - 1
                          b( i, j-1 ) = b( i, j-1 ) - xr*b( i, j ) +xi*b( j+1, i )
                          b( j, i ) = -xr*b( j+1, i ) - xi*b( i, j )
                       end do
                       b( j, j-1 ) = b( j, j-1 ) + wi
                    end if
                    ! compute 1-norm of offdiagonal elements of j-th column.
                    work( j ) = stdlib_sasum( j-1, b( 1, j ), 1 ) +stdlib_sasum( j-1, b( j+1, 1 ),&
                               ldb )
                 end do loop_210
                 if( b( 1, 1 )==zero .and. b( 2, 1 )==zero )b( 1, 1 ) = eps3
                 work( 1 ) = zero
                 i1 = 1
                 i2 = n
                 i3 = 1
              end if
              loop_270: do its = 1, n
                 scale = one
                 vmax = one
                 vcrit = bignum
                 ! solve u*(xr,xi) = scale*(vr,vi) for a right eigenvector,
                   ! or u**t*(xr,xi) = scale*(vr,vi) for a left eigenvector,
                 ! overwriting (xr,xi) on (vr,vi).
                 loop_250: do i = i1, i2, i3
                    if( work( i )>vcrit ) then
                       rec = one / vmax
                       call stdlib_sscal( n, rec, vr, 1 )
                       call stdlib_sscal( n, rec, vi, 1 )
                       scale = scale*rec
                       vmax = one
                       vcrit = bignum
                    end if
                    xr = vr( i )
                    xi = vi( i )
                    if( rightv ) then
                       do j = i + 1, n
                          xr = xr - b( i, j )*vr( j ) + b( j+1, i )*vi( j )
                          xi = xi - b( i, j )*vi( j ) - b( j+1, i )*vr( j )
                       end do
                    else
                       do j = 1, i - 1
                          xr = xr - b( j, i )*vr( j ) + b( i+1, j )*vi( j )
                          xi = xi - b( j, i )*vi( j ) - b( i+1, j )*vr( j )
                       end do
                    end if
                    w = abs( b( i, i ) ) + abs( b( i+1, i ) )
                    if( w>smlnum ) then
                       if( w<one ) then
                          w1 = abs( xr ) + abs( xi )
                          if( w1>w*bignum ) then
                             rec = one / w1
                             call stdlib_sscal( n, rec, vr, 1 )
                             call stdlib_sscal( n, rec, vi, 1 )
                             xr = vr( i )
                             xi = vi( i )
                             scale = scale*rec
                             vmax = vmax*rec
                          end if
                       end if
                       ! divide by diagonal element of b.
                       call stdlib_sladiv( xr, xi, b( i, i ), b( i+1, i ), vr( i ),vi( i ) )
                                 
                       vmax = max( abs( vr( i ) )+abs( vi( i ) ), vmax )
                       vcrit = bignum / vmax
                    else
                       do j = 1, n
                          vr( j ) = zero
                          vi( j ) = zero
                       end do
                       vr( i ) = one
                       vi( i ) = one
                       scale = zero
                       vmax = one
                       vcrit = bignum
                    end if
                 end do loop_250
                 ! test for sufficient growth in the norm of (vr,vi).
                 vnorm = stdlib_sasum( n, vr, 1 ) + stdlib_sasum( n, vi, 1 )
                 if( vnorm>=growto*scale )go to 280
                 ! choose a new orthogonal starting vector and try again.
                 y = eps3 / ( rootn+one )
                 vr( 1 ) = eps3
                 vi( 1 ) = zero
                 do i = 2, n
                    vr( i ) = y
                    vi( i ) = zero
                 end do
                 vr( n-its+1 ) = vr( n-its+1 ) - eps3*rootn
              end do loop_270
              ! failure to find eigenvector in n iterations
              info = 1
              280 continue
              ! normalize eigenvector.
              vnorm = zero
              do i = 1, n
                 vnorm = max( vnorm, abs( vr( i ) )+abs( vi( i ) ) )
              end do
              call stdlib_sscal( n, one / vnorm, vr, 1 )
              call stdlib_sscal( n, one / vnorm, vi, 1 )
           end if
           return
     end subroutine stdlib_slaein

     module pure subroutine stdlib_dlaein( rightv, noinit, n, h, ldh, wr, wi, vr, vi, b,ldb, work, eps3, &
     !! DLAEIN uses inverse iteration to find a right or left eigenvector
     !! corresponding to the eigenvalue (WR,WI) of a real upper Hessenberg
     !! matrix H.
               smlnum, bignum, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: noinit, rightv
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldh, n
           real(dp), intent(in) :: bignum, eps3, smlnum, wi, wr
           ! Array Arguments 
           real(dp), intent(out) :: b(ldb,*), work(*)
           real(dp), intent(in) :: h(ldh,*)
           real(dp), intent(inout) :: vi(*), vr(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: tenth = 1.0e-1_dp
           
           ! Local Scalars 
           character :: normin, trans
           integer(ilp) :: i, i1, i2, i3, ierr, its, j
           real(dp) :: absbii, absbjj, ei, ej, growto, norm, nrmsml, rec, rootn, scale, temp, &
                     vcrit, vmax, vnorm, w, w1, x, xi, xr, y
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! growto is the threshold used in the acceptance test for an
           ! eigenvector.
           rootn = sqrt( real( n,KIND=dp) )
           growto = tenth / rootn
           nrmsml = max( one, eps3*rootn )*smlnum
           ! form b = h - (wr,wi)*i (except that the subdiagonal elements and
           ! the imaginary parts of the diagonal elements are not stored).
           do j = 1, n
              do i = 1, j - 1
                 b( i, j ) = h( i, j )
              end do
              b( j, j ) = h( j, j ) - wr
           end do
           if( wi==zero ) then
              ! real eigenvalue.
              if( noinit ) then
                 ! set initial vector.
                 do i = 1, n
                    vr( i ) = eps3
                 end do
              else
                 ! scale supplied initial vector.
                 vnorm = stdlib_dnrm2( n, vr, 1 )
                 call stdlib_dscal( n, ( eps3*rootn ) / max( vnorm, nrmsml ), vr,1 )
              end if
              if( rightv ) then
                 ! lu decomposition with partial pivoting of b, replacing zero
                 ! pivots by eps3.
                 do i = 1, n - 1
                    ei = h( i+1, i )
                    if( abs( b( i, i ) )<abs( ei ) ) then
                       ! interchange rows and eliminate.
                       x = b( i, i ) / ei
                       b( i, i ) = ei
                       do j = i + 1, n
                          temp = b( i+1, j )
                          b( i+1, j ) = b( i, j ) - x*temp
                          b( i, j ) = temp
                       end do
                    else
                       ! eliminate without interchange.
                       if( b( i, i )==zero )b( i, i ) = eps3
                       x = ei / b( i, i )
                       if( x/=zero ) then
                          do j = i + 1, n
                             b( i+1, j ) = b( i+1, j ) - x*b( i, j )
                          end do
                       end if
                    end if
                 end do
                 if( b( n, n )==zero )b( n, n ) = eps3
                 trans = 'N'
              else
                 ! ul decomposition with partial pivoting of b, replacing zero
                 ! pivots by eps3.
                 do j = n, 2, -1
                    ej = h( j, j-1 )
                    if( abs( b( j, j ) )<abs( ej ) ) then
                       ! interchange columns and eliminate.
                       x = b( j, j ) / ej
                       b( j, j ) = ej
                       do i = 1, j - 1
                          temp = b( i, j-1 )
                          b( i, j-1 ) = b( i, j ) - x*temp
                          b( i, j ) = temp
                       end do
                    else
                       ! eliminate without interchange.
                       if( b( j, j )==zero )b( j, j ) = eps3
                       x = ej / b( j, j )
                       if( x/=zero ) then
                          do i = 1, j - 1
                             b( i, j-1 ) = b( i, j-1 ) - x*b( i, j )
                          end do
                       end if
                    end if
                 end do
                 if( b( 1, 1 )==zero )b( 1, 1 ) = eps3
                 trans = 'T'
              end if
              normin = 'N'
              do its = 1, n
                 ! solve u*x = scale*v for a right eigenvector
                   ! or u**t*x = scale*v for a left eigenvector,
                 ! overwriting x on v.
                 call stdlib_dlatrs( 'UPPER', trans, 'NONUNIT', normin, n, b, ldb,vr, scale, work,&
                            ierr )
                 normin = 'Y'
                 ! test for sufficient growth in the norm of v.
                 vnorm = stdlib_dasum( n, vr, 1 )
                 if( vnorm>=growto*scale )go to 120
                 ! choose new orthogonal starting vector and try again.
                 temp = eps3 / ( rootn+one )
                 vr( 1 ) = eps3
                 do i = 2, n
                    vr( i ) = temp
                 end do
                 vr( n-its+1 ) = vr( n-its+1 ) - eps3*rootn
              end do
              ! failure to find eigenvector in n iterations.
              info = 1
              120 continue
              ! normalize eigenvector.
              i = stdlib_idamax( n, vr, 1 )
              call stdlib_dscal( n, one / abs( vr( i ) ), vr, 1 )
           else
              ! complex eigenvalue.
              if( noinit ) then
                 ! set initial vector.
                 do i = 1, n
                    vr( i ) = eps3
                    vi( i ) = zero
                 end do
              else
                 ! scale supplied initial vector.
                 norm = stdlib_dlapy2( stdlib_dnrm2( n, vr, 1 ), stdlib_dnrm2( n, vi, 1 ) )
                           
                 rec = ( eps3*rootn ) / max( norm, nrmsml )
                 call stdlib_dscal( n, rec, vr, 1 )
                 call stdlib_dscal( n, rec, vi, 1 )
              end if
              if( rightv ) then
                 ! lu decomposition with partial pivoting of b, replacing zero
                 ! pivots by eps3.
                 ! the imaginary part of the (i,j)-th element of u is stored in
                 ! b(j+1,i).
                 b( 2, 1 ) = -wi
                 do i = 2, n
                    b( i+1, 1 ) = zero
                 end do
                 loop_170: do i = 1, n - 1
                    absbii = stdlib_dlapy2( b( i, i ), b( i+1, i ) )
                    ei = h( i+1, i )
                    if( absbii<abs( ei ) ) then
                       ! interchange rows and eliminate.
                       xr = b( i, i ) / ei
                       xi = b( i+1, i ) / ei
                       b( i, i ) = ei
                       b( i+1, i ) = zero
                       do j = i + 1, n
                          temp = b( i+1, j )
                          b( i+1, j ) = b( i, j ) - xr*temp
                          b( j+1, i+1 ) = b( j+1, i ) - xi*temp
                          b( i, j ) = temp
                          b( j+1, i ) = zero
                       end do
                       b( i+2, i ) = -wi
                       b( i+1, i+1 ) = b( i+1, i+1 ) - xi*wi
                       b( i+2, i+1 ) = b( i+2, i+1 ) + xr*wi
                    else
                       ! eliminate without interchanging rows.
                       if( absbii==zero ) then
                          b( i, i ) = eps3
                          b( i+1, i ) = zero
                          absbii = eps3
                       end if
                       ei = ( ei / absbii ) / absbii
                       xr = b( i, i )*ei
                       xi = -b( i+1, i )*ei
                       do j = i + 1, n
                          b( i+1, j ) = b( i+1, j ) - xr*b( i, j ) +xi*b( j+1, i )
                          b( j+1, i+1 ) = -xr*b( j+1, i ) - xi*b( i, j )
                       end do
                       b( i+2, i+1 ) = b( i+2, i+1 ) - wi
                    end if
                    ! compute 1-norm of offdiagonal elements of i-th row.
                    work( i ) = stdlib_dasum( n-i, b( i, i+1 ), ldb ) +stdlib_dasum( n-i, b( i+2, &
                              i ), 1 )
                 end do loop_170
                 if( b( n, n )==zero .and. b( n+1, n )==zero )b( n, n ) = eps3
                 work( n ) = zero
                 i1 = n
                 i2 = 1
                 i3 = -1
              else
                 ! ul decomposition with partial pivoting of conjg(b),
                 ! replacing zero pivots by eps3.
                 ! the imaginary part of the (i,j)-th element of u is stored in
                 ! b(j+1,i).
                 b( n+1, n ) = wi
                 do j = 1, n - 1
                    b( n+1, j ) = zero
                 end do
                 loop_210: do j = n, 2, -1
                    ej = h( j, j-1 )
                    absbjj = stdlib_dlapy2( b( j, j ), b( j+1, j ) )
                    if( absbjj<abs( ej ) ) then
                       ! interchange columns and eliminate
                       xr = b( j, j ) / ej
                       xi = b( j+1, j ) / ej
                       b( j, j ) = ej
                       b( j+1, j ) = zero
                       do i = 1, j - 1
                          temp = b( i, j-1 )
                          b( i, j-1 ) = b( i, j ) - xr*temp
                          b( j, i ) = b( j+1, i ) - xi*temp
                          b( i, j ) = temp
                          b( j+1, i ) = zero
                       end do
                       b( j+1, j-1 ) = wi
                       b( j-1, j-1 ) = b( j-1, j-1 ) + xi*wi
                       b( j, j-1 ) = b( j, j-1 ) - xr*wi
                    else
                       ! eliminate without interchange.
                       if( absbjj==zero ) then
                          b( j, j ) = eps3
                          b( j+1, j ) = zero
                          absbjj = eps3
                       end if
                       ej = ( ej / absbjj ) / absbjj
                       xr = b( j, j )*ej
                       xi = -b( j+1, j )*ej
                       do i = 1, j - 1
                          b( i, j-1 ) = b( i, j-1 ) - xr*b( i, j ) +xi*b( j+1, i )
                          b( j, i ) = -xr*b( j+1, i ) - xi*b( i, j )
                       end do
                       b( j, j-1 ) = b( j, j-1 ) + wi
                    end if
                    ! compute 1-norm of offdiagonal elements of j-th column.
                    work( j ) = stdlib_dasum( j-1, b( 1, j ), 1 ) +stdlib_dasum( j-1, b( j+1, 1 ),&
                               ldb )
                 end do loop_210
                 if( b( 1, 1 )==zero .and. b( 2, 1 )==zero )b( 1, 1 ) = eps3
                 work( 1 ) = zero
                 i1 = 1
                 i2 = n
                 i3 = 1
              end if
              loop_270: do its = 1, n
                 scale = one
                 vmax = one
                 vcrit = bignum
                 ! solve u*(xr,xi) = scale*(vr,vi) for a right eigenvector,
                   ! or u**t*(xr,xi) = scale*(vr,vi) for a left eigenvector,
                 ! overwriting (xr,xi) on (vr,vi).
                 loop_250: do i = i1, i2, i3
                    if( work( i )>vcrit ) then
                       rec = one / vmax
                       call stdlib_dscal( n, rec, vr, 1 )
                       call stdlib_dscal( n, rec, vi, 1 )
                       scale = scale*rec
                       vmax = one
                       vcrit = bignum
                    end if
                    xr = vr( i )
                    xi = vi( i )
                    if( rightv ) then
                       do j = i + 1, n
                          xr = xr - b( i, j )*vr( j ) + b( j+1, i )*vi( j )
                          xi = xi - b( i, j )*vi( j ) - b( j+1, i )*vr( j )
                       end do
                    else
                       do j = 1, i - 1
                          xr = xr - b( j, i )*vr( j ) + b( i+1, j )*vi( j )
                          xi = xi - b( j, i )*vi( j ) - b( i+1, j )*vr( j )
                       end do
                    end if
                    w = abs( b( i, i ) ) + abs( b( i+1, i ) )
                    if( w>smlnum ) then
                       if( w<one ) then
                          w1 = abs( xr ) + abs( xi )
                          if( w1>w*bignum ) then
                             rec = one / w1
                             call stdlib_dscal( n, rec, vr, 1 )
                             call stdlib_dscal( n, rec, vi, 1 )
                             xr = vr( i )
                             xi = vi( i )
                             scale = scale*rec
                             vmax = vmax*rec
                          end if
                       end if
                       ! divide by diagonal element of b.
                       call stdlib_dladiv( xr, xi, b( i, i ), b( i+1, i ), vr( i ),vi( i ) )
                                 
                       vmax = max( abs( vr( i ) )+abs( vi( i ) ), vmax )
                       vcrit = bignum / vmax
                    else
                       do j = 1, n
                          vr( j ) = zero
                          vi( j ) = zero
                       end do
                       vr( i ) = one
                       vi( i ) = one
                       scale = zero
                       vmax = one
                       vcrit = bignum
                    end if
                 end do loop_250
                 ! test for sufficient growth in the norm of (vr,vi).
                 vnorm = stdlib_dasum( n, vr, 1 ) + stdlib_dasum( n, vi, 1 )
                 if( vnorm>=growto*scale )go to 280
                 ! choose a new orthogonal starting vector and try again.
                 y = eps3 / ( rootn+one )
                 vr( 1 ) = eps3
                 vi( 1 ) = zero
                 do i = 2, n
                    vr( i ) = y
                    vi( i ) = zero
                 end do
                 vr( n-its+1 ) = vr( n-its+1 ) - eps3*rootn
              end do loop_270
              ! failure to find eigenvector in n iterations
              info = 1
              280 continue
              ! normalize eigenvector.
              vnorm = zero
              do i = 1, n
                 vnorm = max( vnorm, abs( vr( i ) )+abs( vi( i ) ) )
              end do
              call stdlib_dscal( n, one / vnorm, vr, 1 )
              call stdlib_dscal( n, one / vnorm, vi, 1 )
           end if
           return
     end subroutine stdlib_dlaein

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$laein( rightv, noinit, n, h, ldh, wr, wi, vr, vi, b,ldb, work, eps3, &
     !! DLAEIN: uses inverse iteration to find a right or left eigenvector
     !! corresponding to the eigenvalue (WR,WI) of a real upper Hessenberg
     !! matrix H.
               smlnum, bignum, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: noinit, rightv
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldh, n
           real(${rk}$), intent(in) :: bignum, eps3, smlnum, wi, wr
           ! Array Arguments 
           real(${rk}$), intent(out) :: b(ldb,*), work(*)
           real(${rk}$), intent(in) :: h(ldh,*)
           real(${rk}$), intent(inout) :: vi(*), vr(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: tenth = 1.0e-1_${rk}$
           
           ! Local Scalars 
           character :: normin, trans
           integer(ilp) :: i, i1, i2, i3, ierr, its, j
           real(${rk}$) :: absbii, absbjj, ei, ej, growto, norm, nrmsml, rec, rootn, scale, temp, &
                     vcrit, vmax, vnorm, w, w1, x, xi, xr, y
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! growto is the threshold used in the acceptance test for an
           ! eigenvector.
           rootn = sqrt( real( n,KIND=${rk}$) )
           growto = tenth / rootn
           nrmsml = max( one, eps3*rootn )*smlnum
           ! form b = h - (wr,wi)*i (except that the subdiagonal elements and
           ! the imaginary parts of the diagonal elements are not stored).
           do j = 1, n
              do i = 1, j - 1
                 b( i, j ) = h( i, j )
              end do
              b( j, j ) = h( j, j ) - wr
           end do
           if( wi==zero ) then
              ! real eigenvalue.
              if( noinit ) then
                 ! set initial vector.
                 do i = 1, n
                    vr( i ) = eps3
                 end do
              else
                 ! scale supplied initial vector.
                 vnorm = stdlib_${ri}$nrm2( n, vr, 1 )
                 call stdlib_${ri}$scal( n, ( eps3*rootn ) / max( vnorm, nrmsml ), vr,1 )
              end if
              if( rightv ) then
                 ! lu decomposition with partial pivoting of b, replacing zero
                 ! pivots by eps3.
                 do i = 1, n - 1
                    ei = h( i+1, i )
                    if( abs( b( i, i ) )<abs( ei ) ) then
                       ! interchange rows and eliminate.
                       x = b( i, i ) / ei
                       b( i, i ) = ei
                       do j = i + 1, n
                          temp = b( i+1, j )
                          b( i+1, j ) = b( i, j ) - x*temp
                          b( i, j ) = temp
                       end do
                    else
                       ! eliminate without interchange.
                       if( b( i, i )==zero )b( i, i ) = eps3
                       x = ei / b( i, i )
                       if( x/=zero ) then
                          do j = i + 1, n
                             b( i+1, j ) = b( i+1, j ) - x*b( i, j )
                          end do
                       end if
                    end if
                 end do
                 if( b( n, n )==zero )b( n, n ) = eps3
                 trans = 'N'
              else
                 ! ul decomposition with partial pivoting of b, replacing zero
                 ! pivots by eps3.
                 do j = n, 2, -1
                    ej = h( j, j-1 )
                    if( abs( b( j, j ) )<abs( ej ) ) then
                       ! interchange columns and eliminate.
                       x = b( j, j ) / ej
                       b( j, j ) = ej
                       do i = 1, j - 1
                          temp = b( i, j-1 )
                          b( i, j-1 ) = b( i, j ) - x*temp
                          b( i, j ) = temp
                       end do
                    else
                       ! eliminate without interchange.
                       if( b( j, j )==zero )b( j, j ) = eps3
                       x = ej / b( j, j )
                       if( x/=zero ) then
                          do i = 1, j - 1
                             b( i, j-1 ) = b( i, j-1 ) - x*b( i, j )
                          end do
                       end if
                    end if
                 end do
                 if( b( 1, 1 )==zero )b( 1, 1 ) = eps3
                 trans = 'T'
              end if
              normin = 'N'
              do its = 1, n
                 ! solve u*x = scale*v for a right eigenvector
                   ! or u**t*x = scale*v for a left eigenvector,
                 ! overwriting x on v.
                 call stdlib_${ri}$latrs( 'UPPER', trans, 'NONUNIT', normin, n, b, ldb,vr, scale, work,&
                            ierr )
                 normin = 'Y'
                 ! test for sufficient growth in the norm of v.
                 vnorm = stdlib_${ri}$asum( n, vr, 1 )
                 if( vnorm>=growto*scale )go to 120
                 ! choose new orthogonal starting vector and try again.
                 temp = eps3 / ( rootn+one )
                 vr( 1 ) = eps3
                 do i = 2, n
                    vr( i ) = temp
                 end do
                 vr( n-its+1 ) = vr( n-its+1 ) - eps3*rootn
              end do
              ! failure to find eigenvector in n iterations.
              info = 1
              120 continue
              ! normalize eigenvector.
              i = stdlib_i${ri}$amax( n, vr, 1 )
              call stdlib_${ri}$scal( n, one / abs( vr( i ) ), vr, 1 )
           else
              ! complex eigenvalue.
              if( noinit ) then
                 ! set initial vector.
                 do i = 1, n
                    vr( i ) = eps3
                    vi( i ) = zero
                 end do
              else
                 ! scale supplied initial vector.
                 norm = stdlib_${ri}$lapy2( stdlib_${ri}$nrm2( n, vr, 1 ), stdlib_${ri}$nrm2( n, vi, 1 ) )
                           
                 rec = ( eps3*rootn ) / max( norm, nrmsml )
                 call stdlib_${ri}$scal( n, rec, vr, 1 )
                 call stdlib_${ri}$scal( n, rec, vi, 1 )
              end if
              if( rightv ) then
                 ! lu decomposition with partial pivoting of b, replacing zero
                 ! pivots by eps3.
                 ! the imaginary part of the (i,j)-th element of u is stored in
                 ! b(j+1,i).
                 b( 2, 1 ) = -wi
                 do i = 2, n
                    b( i+1, 1 ) = zero
                 end do
                 loop_170: do i = 1, n - 1
                    absbii = stdlib_${ri}$lapy2( b( i, i ), b( i+1, i ) )
                    ei = h( i+1, i )
                    if( absbii<abs( ei ) ) then
                       ! interchange rows and eliminate.
                       xr = b( i, i ) / ei
                       xi = b( i+1, i ) / ei
                       b( i, i ) = ei
                       b( i+1, i ) = zero
                       do j = i + 1, n
                          temp = b( i+1, j )
                          b( i+1, j ) = b( i, j ) - xr*temp
                          b( j+1, i+1 ) = b( j+1, i ) - xi*temp
                          b( i, j ) = temp
                          b( j+1, i ) = zero
                       end do
                       b( i+2, i ) = -wi
                       b( i+1, i+1 ) = b( i+1, i+1 ) - xi*wi
                       b( i+2, i+1 ) = b( i+2, i+1 ) + xr*wi
                    else
                       ! eliminate without interchanging rows.
                       if( absbii==zero ) then
                          b( i, i ) = eps3
                          b( i+1, i ) = zero
                          absbii = eps3
                       end if
                       ei = ( ei / absbii ) / absbii
                       xr = b( i, i )*ei
                       xi = -b( i+1, i )*ei
                       do j = i + 1, n
                          b( i+1, j ) = b( i+1, j ) - xr*b( i, j ) +xi*b( j+1, i )
                          b( j+1, i+1 ) = -xr*b( j+1, i ) - xi*b( i, j )
                       end do
                       b( i+2, i+1 ) = b( i+2, i+1 ) - wi
                    end if
                    ! compute 1-norm of offdiagonal elements of i-th row.
                    work( i ) = stdlib_${ri}$asum( n-i, b( i, i+1 ), ldb ) +stdlib_${ri}$asum( n-i, b( i+2, &
                              i ), 1 )
                 end do loop_170
                 if( b( n, n )==zero .and. b( n+1, n )==zero )b( n, n ) = eps3
                 work( n ) = zero
                 i1 = n
                 i2 = 1
                 i3 = -1
              else
                 ! ul decomposition with partial pivoting of conjg(b),
                 ! replacing zero pivots by eps3.
                 ! the imaginary part of the (i,j)-th element of u is stored in
                 ! b(j+1,i).
                 b( n+1, n ) = wi
                 do j = 1, n - 1
                    b( n+1, j ) = zero
                 end do
                 loop_210: do j = n, 2, -1
                    ej = h( j, j-1 )
                    absbjj = stdlib_${ri}$lapy2( b( j, j ), b( j+1, j ) )
                    if( absbjj<abs( ej ) ) then
                       ! interchange columns and eliminate
                       xr = b( j, j ) / ej
                       xi = b( j+1, j ) / ej
                       b( j, j ) = ej
                       b( j+1, j ) = zero
                       do i = 1, j - 1
                          temp = b( i, j-1 )
                          b( i, j-1 ) = b( i, j ) - xr*temp
                          b( j, i ) = b( j+1, i ) - xi*temp
                          b( i, j ) = temp
                          b( j+1, i ) = zero
                       end do
                       b( j+1, j-1 ) = wi
                       b( j-1, j-1 ) = b( j-1, j-1 ) + xi*wi
                       b( j, j-1 ) = b( j, j-1 ) - xr*wi
                    else
                       ! eliminate without interchange.
                       if( absbjj==zero ) then
                          b( j, j ) = eps3
                          b( j+1, j ) = zero
                          absbjj = eps3
                       end if
                       ej = ( ej / absbjj ) / absbjj
                       xr = b( j, j )*ej
                       xi = -b( j+1, j )*ej
                       do i = 1, j - 1
                          b( i, j-1 ) = b( i, j-1 ) - xr*b( i, j ) +xi*b( j+1, i )
                          b( j, i ) = -xr*b( j+1, i ) - xi*b( i, j )
                       end do
                       b( j, j-1 ) = b( j, j-1 ) + wi
                    end if
                    ! compute 1-norm of offdiagonal elements of j-th column.
                    work( j ) = stdlib_${ri}$asum( j-1, b( 1, j ), 1 ) +stdlib_${ri}$asum( j-1, b( j+1, 1 ),&
                               ldb )
                 end do loop_210
                 if( b( 1, 1 )==zero .and. b( 2, 1 )==zero )b( 1, 1 ) = eps3
                 work( 1 ) = zero
                 i1 = 1
                 i2 = n
                 i3 = 1
              end if
              loop_270: do its = 1, n
                 scale = one
                 vmax = one
                 vcrit = bignum
                 ! solve u*(xr,xi) = scale*(vr,vi) for a right eigenvector,
                   ! or u**t*(xr,xi) = scale*(vr,vi) for a left eigenvector,
                 ! overwriting (xr,xi) on (vr,vi).
                 loop_250: do i = i1, i2, i3
                    if( work( i )>vcrit ) then
                       rec = one / vmax
                       call stdlib_${ri}$scal( n, rec, vr, 1 )
                       call stdlib_${ri}$scal( n, rec, vi, 1 )
                       scale = scale*rec
                       vmax = one
                       vcrit = bignum
                    end if
                    xr = vr( i )
                    xi = vi( i )
                    if( rightv ) then
                       do j = i + 1, n
                          xr = xr - b( i, j )*vr( j ) + b( j+1, i )*vi( j )
                          xi = xi - b( i, j )*vi( j ) - b( j+1, i )*vr( j )
                       end do
                    else
                       do j = 1, i - 1
                          xr = xr - b( j, i )*vr( j ) + b( i+1, j )*vi( j )
                          xi = xi - b( j, i )*vi( j ) - b( i+1, j )*vr( j )
                       end do
                    end if
                    w = abs( b( i, i ) ) + abs( b( i+1, i ) )
                    if( w>smlnum ) then
                       if( w<one ) then
                          w1 = abs( xr ) + abs( xi )
                          if( w1>w*bignum ) then
                             rec = one / w1
                             call stdlib_${ri}$scal( n, rec, vr, 1 )
                             call stdlib_${ri}$scal( n, rec, vi, 1 )
                             xr = vr( i )
                             xi = vi( i )
                             scale = scale*rec
                             vmax = vmax*rec
                          end if
                       end if
                       ! divide by diagonal element of b.
                       call stdlib_${ri}$ladiv( xr, xi, b( i, i ), b( i+1, i ), vr( i ),vi( i ) )
                                 
                       vmax = max( abs( vr( i ) )+abs( vi( i ) ), vmax )
                       vcrit = bignum / vmax
                    else
                       do j = 1, n
                          vr( j ) = zero
                          vi( j ) = zero
                       end do
                       vr( i ) = one
                       vi( i ) = one
                       scale = zero
                       vmax = one
                       vcrit = bignum
                    end if
                 end do loop_250
                 ! test for sufficient growth in the norm of (vr,vi).
                 vnorm = stdlib_${ri}$asum( n, vr, 1 ) + stdlib_${ri}$asum( n, vi, 1 )
                 if( vnorm>=growto*scale )go to 280
                 ! choose a new orthogonal starting vector and try again.
                 y = eps3 / ( rootn+one )
                 vr( 1 ) = eps3
                 vi( 1 ) = zero
                 do i = 2, n
                    vr( i ) = y
                    vi( i ) = zero
                 end do
                 vr( n-its+1 ) = vr( n-its+1 ) - eps3*rootn
              end do loop_270
              ! failure to find eigenvector in n iterations
              info = 1
              280 continue
              ! normalize eigenvector.
              vnorm = zero
              do i = 1, n
                 vnorm = max( vnorm, abs( vr( i ) )+abs( vi( i ) ) )
              end do
              call stdlib_${ri}$scal( n, one / vnorm, vr, 1 )
              call stdlib_${ri}$scal( n, one / vnorm, vi, 1 )
           end if
           return
     end subroutine stdlib_${ri}$laein

#:endif
#:endfor

     module pure subroutine stdlib_claein( rightv, noinit, n, h, ldh, w, v, b, ldb, rwork,eps3, smlnum, &
     !! CLAEIN uses inverse iteration to find a right or left eigenvector
     !! corresponding to the eigenvalue W of a complex upper Hessenberg
     !! matrix H.
               info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: noinit, rightv
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldh, n
           real(sp), intent(in) :: eps3, smlnum
           complex(sp), intent(in) :: w
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(out) :: b(ldb,*)
           complex(sp), intent(in) :: h(ldh,*)
           complex(sp), intent(inout) :: v(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: tenth = 1.0e-1_sp
           
           
           ! Local Scalars 
           character :: normin, trans
           integer(ilp) :: i, ierr, its, j
           real(sp) :: growto, nrmsml, rootn, rtemp, scale, vnorm
           complex(sp) :: cdum, ei, ej, temp, x
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! growto is the threshold used in the acceptance test for an
           ! eigenvector.
           rootn = sqrt( real( n,KIND=sp) )
           growto = tenth / rootn
           nrmsml = max( one, eps3*rootn )*smlnum
           ! form b = h - w*i (except that the subdiagonal elements are not
           ! stored).
           do j = 1, n
              do i = 1, j - 1
                 b( i, j ) = h( i, j )
              end do
              b( j, j ) = h( j, j ) - w
           end do
           if( noinit ) then
              ! initialize v.
              do i = 1, n
                 v( i ) = eps3
              end do
           else
              ! scale supplied initial vector.
              vnorm = stdlib_scnrm2( n, v, 1 )
              call stdlib_csscal( n, ( eps3*rootn ) / max( vnorm, nrmsml ), v, 1 )
           end if
           if( rightv ) then
              ! lu decomposition with partial pivoting of b, replacing czero
              ! pivots by eps3.
              do i = 1, n - 1
                 ei = h( i+1, i )
                 if( cabs1( b( i, i ) )<cabs1( ei ) ) then
                    ! interchange rows and eliminate.
                    x = stdlib_cladiv( b( i, i ), ei )
                    b( i, i ) = ei
                    do j = i + 1, n
                       temp = b( i+1, j )
                       b( i+1, j ) = b( i, j ) - x*temp
                       b( i, j ) = temp
                    end do
                 else
                    ! eliminate without interchange.
                    if( b( i, i )==czero )b( i, i ) = eps3
                    x = stdlib_cladiv( ei, b( i, i ) )
                    if( x/=czero ) then
                       do j = i + 1, n
                          b( i+1, j ) = b( i+1, j ) - x*b( i, j )
                       end do
                    end if
                 end if
              end do
              if( b( n, n )==czero )b( n, n ) = eps3
              trans = 'N'
           else
              ! ul decomposition with partial pivoting of b, replacing czero
              ! pivots by eps3.
              do j = n, 2, -1
                 ej = h( j, j-1 )
                 if( cabs1( b( j, j ) )<cabs1( ej ) ) then
                    ! interchange columns and eliminate.
                    x = stdlib_cladiv( b( j, j ), ej )
                    b( j, j ) = ej
                    do i = 1, j - 1
                       temp = b( i, j-1 )
                       b( i, j-1 ) = b( i, j ) - x*temp
                       b( i, j ) = temp
                    end do
                 else
                    ! eliminate without interchange.
                    if( b( j, j )==czero )b( j, j ) = eps3
                    x = stdlib_cladiv( ej, b( j, j ) )
                    if( x/=czero ) then
                       do i = 1, j - 1
                          b( i, j-1 ) = b( i, j-1 ) - x*b( i, j )
                       end do
                    end if
                 end if
              end do
              if( b( 1, 1 )==czero )b( 1, 1 ) = eps3
              trans = 'C'
           end if
           normin = 'N'
           do its = 1, n
              ! solve u*x = scale*v for a right eigenvector
                ! or u**h *x = scale*v for a left eigenvector,
              ! overwriting x on v.
              call stdlib_clatrs( 'UPPER', trans, 'NONUNIT', normin, n, b, ldb, v,scale, rwork, &
                        ierr )
              normin = 'Y'
              ! test for sufficient growth in the norm of v.
              vnorm = stdlib_scasum( n, v, 1 )
              if( vnorm>=growto*scale )go to 120
              ! choose new orthogonal starting vector and try again.
              rtemp = eps3 / ( rootn+one )
              v( 1 ) = eps3
              do i = 2, n
                 v( i ) = rtemp
              end do
              v( n-its+1 ) = v( n-its+1 ) - eps3*rootn
           end do
           ! failure to find eigenvector in n iterations.
           info = 1
           120 continue
           ! normalize eigenvector.
           i = stdlib_icamax( n, v, 1 )
           call stdlib_csscal( n, one / cabs1( v( i ) ), v, 1 )
           return
     end subroutine stdlib_claein

     module pure subroutine stdlib_zlaein( rightv, noinit, n, h, ldh, w, v, b, ldb, rwork,eps3, smlnum, &
     !! ZLAEIN uses inverse iteration to find a right or left eigenvector
     !! corresponding to the eigenvalue W of a complex upper Hessenberg
     !! matrix H.
               info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: noinit, rightv
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldh, n
           real(dp), intent(in) :: eps3, smlnum
           complex(dp), intent(in) :: w
           ! Array Arguments 
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(out) :: b(ldb,*)
           complex(dp), intent(in) :: h(ldh,*)
           complex(dp), intent(inout) :: v(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: tenth = 1.0e-1_dp
           
           
           ! Local Scalars 
           character :: normin, trans
           integer(ilp) :: i, ierr, its, j
           real(dp) :: growto, nrmsml, rootn, rtemp, scale, vnorm
           complex(dp) :: cdum, ei, ej, temp, x
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! growto is the threshold used in the acceptance test for an
           ! eigenvector.
           rootn = sqrt( real( n,KIND=dp) )
           growto = tenth / rootn
           nrmsml = max( one, eps3*rootn )*smlnum
           ! form b = h - w*i (except that the subdiagonal elements are not
           ! stored).
           do j = 1, n
              do i = 1, j - 1
                 b( i, j ) = h( i, j )
              end do
              b( j, j ) = h( j, j ) - w
           end do
           if( noinit ) then
              ! initialize v.
              do i = 1, n
                 v( i ) = eps3
              end do
           else
              ! scale supplied initial vector.
              vnorm = stdlib_dznrm2( n, v, 1 )
              call stdlib_zdscal( n, ( eps3*rootn ) / max( vnorm, nrmsml ), v, 1 )
           end if
           if( rightv ) then
              ! lu decomposition with partial pivoting of b, replacing czero
              ! pivots by eps3.
              do i = 1, n - 1
                 ei = h( i+1, i )
                 if( cabs1( b( i, i ) )<cabs1( ei ) ) then
                    ! interchange rows and eliminate.
                    x = stdlib_zladiv( b( i, i ), ei )
                    b( i, i ) = ei
                    do j = i + 1, n
                       temp = b( i+1, j )
                       b( i+1, j ) = b( i, j ) - x*temp
                       b( i, j ) = temp
                    end do
                 else
                    ! eliminate without interchange.
                    if( b( i, i )==czero )b( i, i ) = eps3
                    x = stdlib_zladiv( ei, b( i, i ) )
                    if( x/=czero ) then
                       do j = i + 1, n
                          b( i+1, j ) = b( i+1, j ) - x*b( i, j )
                       end do
                    end if
                 end if
              end do
              if( b( n, n )==czero )b( n, n ) = eps3
              trans = 'N'
           else
              ! ul decomposition with partial pivoting of b, replacing czero
              ! pivots by eps3.
              do j = n, 2, -1
                 ej = h( j, j-1 )
                 if( cabs1( b( j, j ) )<cabs1( ej ) ) then
                    ! interchange columns and eliminate.
                    x = stdlib_zladiv( b( j, j ), ej )
                    b( j, j ) = ej
                    do i = 1, j - 1
                       temp = b( i, j-1 )
                       b( i, j-1 ) = b( i, j ) - x*temp
                       b( i, j ) = temp
                    end do
                 else
                    ! eliminate without interchange.
                    if( b( j, j )==czero )b( j, j ) = eps3
                    x = stdlib_zladiv( ej, b( j, j ) )
                    if( x/=czero ) then
                       do i = 1, j - 1
                          b( i, j-1 ) = b( i, j-1 ) - x*b( i, j )
                       end do
                    end if
                 end if
              end do
              if( b( 1, 1 )==czero )b( 1, 1 ) = eps3
              trans = 'C'
           end if
           normin = 'N'
           do its = 1, n
              ! solve u*x = scale*v for a right eigenvector
                ! or u**h *x = scale*v for a left eigenvector,
              ! overwriting x on v.
              call stdlib_zlatrs( 'UPPER', trans, 'NONUNIT', normin, n, b, ldb, v,scale, rwork, &
                        ierr )
              normin = 'Y'
              ! test for sufficient growth in the norm of v.
              vnorm = stdlib_dzasum( n, v, 1 )
              if( vnorm>=growto*scale )go to 120
              ! choose new orthogonal starting vector and try again.
              rtemp = eps3 / ( rootn+one )
              v( 1 ) = eps3
              do i = 2, n
                 v( i ) = rtemp
              end do
              v( n-its+1 ) = v( n-its+1 ) - eps3*rootn
           end do
           ! failure to find eigenvector in n iterations.
           info = 1
           120 continue
           ! normalize eigenvector.
           i = stdlib_izamax( n, v, 1 )
           call stdlib_zdscal( n, one / cabs1( v( i ) ), v, 1 )
           return
     end subroutine stdlib_zlaein

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$laein( rightv, noinit, n, h, ldh, w, v, b, ldb, rwork,eps3, smlnum, &
     !! ZLAEIN: uses inverse iteration to find a right or left eigenvector
     !! corresponding to the eigenvalue W of a complex upper Hessenberg
     !! matrix H.
               info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: noinit, rightv
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldh, n
           real(${ck}$), intent(in) :: eps3, smlnum
           complex(${ck}$), intent(in) :: w
           ! Array Arguments 
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(out) :: b(ldb,*)
           complex(${ck}$), intent(in) :: h(ldh,*)
           complex(${ck}$), intent(inout) :: v(*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: tenth = 1.0e-1_${ck}$
           
           
           ! Local Scalars 
           character :: normin, trans
           integer(ilp) :: i, ierr, its, j
           real(${ck}$) :: growto, nrmsml, rootn, rtemp, scale, vnorm
           complex(${ck}$) :: cdum, ei, ej, temp, x
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! growto is the threshold used in the acceptance test for an
           ! eigenvector.
           rootn = sqrt( real( n,KIND=${ck}$) )
           growto = tenth / rootn
           nrmsml = max( one, eps3*rootn )*smlnum
           ! form b = h - w*i (except that the subdiagonal elements are not
           ! stored).
           do j = 1, n
              do i = 1, j - 1
                 b( i, j ) = h( i, j )
              end do
              b( j, j ) = h( j, j ) - w
           end do
           if( noinit ) then
              ! initialize v.
              do i = 1, n
                 v( i ) = eps3
              end do
           else
              ! scale supplied initial vector.
              vnorm = stdlib_${c2ri(ci)}$znrm2( n, v, 1 )
              call stdlib_${ci}$dscal( n, ( eps3*rootn ) / max( vnorm, nrmsml ), v, 1 )
           end if
           if( rightv ) then
              ! lu decomposition with partial pivoting of b, replacing czero
              ! pivots by eps3.
              do i = 1, n - 1
                 ei = h( i+1, i )
                 if( cabs1( b( i, i ) )<cabs1( ei ) ) then
                    ! interchange rows and eliminate.
                    x = stdlib_${ci}$ladiv( b( i, i ), ei )
                    b( i, i ) = ei
                    do j = i + 1, n
                       temp = b( i+1, j )
                       b( i+1, j ) = b( i, j ) - x*temp
                       b( i, j ) = temp
                    end do
                 else
                    ! eliminate without interchange.
                    if( b( i, i )==czero )b( i, i ) = eps3
                    x = stdlib_${ci}$ladiv( ei, b( i, i ) )
                    if( x/=czero ) then
                       do j = i + 1, n
                          b( i+1, j ) = b( i+1, j ) - x*b( i, j )
                       end do
                    end if
                 end if
              end do
              if( b( n, n )==czero )b( n, n ) = eps3
              trans = 'N'
           else
              ! ul decomposition with partial pivoting of b, replacing czero
              ! pivots by eps3.
              do j = n, 2, -1
                 ej = h( j, j-1 )
                 if( cabs1( b( j, j ) )<cabs1( ej ) ) then
                    ! interchange columns and eliminate.
                    x = stdlib_${ci}$ladiv( b( j, j ), ej )
                    b( j, j ) = ej
                    do i = 1, j - 1
                       temp = b( i, j-1 )
                       b( i, j-1 ) = b( i, j ) - x*temp
                       b( i, j ) = temp
                    end do
                 else
                    ! eliminate without interchange.
                    if( b( j, j )==czero )b( j, j ) = eps3
                    x = stdlib_${ci}$ladiv( ej, b( j, j ) )
                    if( x/=czero ) then
                       do i = 1, j - 1
                          b( i, j-1 ) = b( i, j-1 ) - x*b( i, j )
                       end do
                    end if
                 end if
              end do
              if( b( 1, 1 )==czero )b( 1, 1 ) = eps3
              trans = 'C'
           end if
           normin = 'N'
           do its = 1, n
              ! solve u*x = scale*v for a right eigenvector
                ! or u**h *x = scale*v for a left eigenvector,
              ! overwriting x on v.
              call stdlib_${ci}$latrs( 'UPPER', trans, 'NONUNIT', normin, n, b, ldb, v,scale, rwork, &
                        ierr )
              normin = 'Y'
              ! test for sufficient growth in the norm of v.
              vnorm = stdlib_${c2ri(ci)}$zasum( n, v, 1 )
              if( vnorm>=growto*scale )go to 120
              ! choose new orthogonal starting vector and try again.
              rtemp = eps3 / ( rootn+one )
              v( 1 ) = eps3
              do i = 2, n
                 v( i ) = rtemp
              end do
              v( n-its+1 ) = v( n-its+1 ) - eps3*rootn
           end do
           ! failure to find eigenvector in n iterations.
           info = 1
           120 continue
           ! normalize eigenvector.
           i = stdlib_i${ci}$amax( n, v, 1 )
           call stdlib_${ci}$dscal( n, one / cabs1( v( i ) ), v, 1 )
           return
     end subroutine stdlib_${ci}$laein

#:endif
#:endfor



     module subroutine stdlib_slaexc( wantq, n, t, ldt, q, ldq, j1, n1, n2, work,info )
     !! SLAEXC swaps adjacent diagonal blocks T11 and T22 of order 1 or 2 in
     !! an upper quasi-triangular matrix T by an orthogonal similarity
     !! transformation.
     !! T must be in Schur canonical form, that is, block upper triangular
     !! with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block
     !! has its diagonal elements equal and its off-diagonal elements of
     !! opposite sign.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: j1, ldq, ldt, n, n1, n2
           ! Array Arguments 
           real(sp), intent(inout) :: q(ldq,*), t(ldt,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: ldd = 4
           integer(ilp), parameter :: ldx = 2
           
           
           
           ! Local Scalars 
           integer(ilp) :: ierr, j2, j3, j4, k, nd
           real(sp) :: cs, dnorm, eps, scale, smlnum, sn, t11, t22, t33, tau, tau1, tau2, temp, &
                     thresh, wi1, wi2, wr1, wr2, xnorm
           ! Local Arrays 
           real(sp) :: d(ldd,4), u(3), u1(3), u2(3), x(ldx,2)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n==0 .or. n1==0 .or. n2==0 )return
           if( j1+n1>n )return
           j2 = j1 + 1
           j3 = j1 + 2
           j4 = j1 + 3
           if( n1==1 .and. n2==1 ) then
              ! swap two 1-by-1 blocks.
              t11 = t( j1, j1 )
              t22 = t( j2, j2 )
              ! determine the transformation to perform the interchange.
              call stdlib_slartg( t( j1, j2 ), t22-t11, cs, sn, temp )
              ! apply transformation to the matrix t.
              if( j3<=n )call stdlib_srot( n-j1-1, t( j1, j3 ), ldt, t( j2, j3 ), ldt, cs,sn )
                        
              call stdlib_srot( j1-1, t( 1, j1 ), 1, t( 1, j2 ), 1, cs, sn )
              t( j1, j1 ) = t22
              t( j2, j2 ) = t11
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_srot( n, q( 1, j1 ), 1, q( 1, j2 ), 1, cs, sn )
              end if
           else
              ! swapping involves at least one 2-by-2 block.
              ! copy the diagonal block of order n1+n2 to the local array d
              ! and compute its norm.
              nd = n1 + n2
              call stdlib_slacpy( 'FULL', nd, nd, t( j1, j1 ), ldt, d, ldd )
              dnorm = stdlib_slange( 'MAX', nd, nd, d, ldd, work )
              ! compute machine-dependent threshold for test for accepting
              ! swap.
              eps = stdlib_slamch( 'P' )
              smlnum = stdlib_slamch( 'S' ) / eps
              thresh = max( ten*eps*dnorm, smlnum )
              ! solve t11*x - x*t22 = scale*t12 for x.
              call stdlib_slasy2( .false., .false., -1, n1, n2, d, ldd,d( n1+1, n1+1 ), ldd, d( 1,&
                         n1+1 ), ldd, scale, x,ldx, xnorm, ierr )
              ! swap the adjacent diagonal blocks.
              k = n1 + n1 + n2 - 3
              go to ( 10, 20, 30 )k
              10 continue
              ! n1 = 1, n2 = 2: generate elementary reflector h so that:
              ! ( scale, x11, x12 ) h = ( 0, 0, * )
              u( 1 ) = scale
              u( 2 ) = x( 1, 1 )
              u( 3 ) = x( 1, 2 )
              call stdlib_slarfg( 3, u( 3 ), u, 1, tau )
              u( 3 ) = one
              t11 = t( j1, j1 )
              ! perform swap provisionally on diagonal block in d.
              call stdlib_slarfx( 'L', 3, 3, u, tau, d, ldd, work )
              call stdlib_slarfx( 'R', 3, 3, u, tau, d, ldd, work )
              ! test whether to reject swap.
              if( max( abs( d( 3, 1 ) ), abs( d( 3, 2 ) ), abs( d( 3,3 )-t11 ) )>thresh )go to &
                        50
              ! accept swap: apply transformation to the entire matrix t.
              call stdlib_slarfx( 'L', 3, n-j1+1, u, tau, t( j1, j1 ), ldt, work )
              call stdlib_slarfx( 'R', j2, 3, u, tau, t( 1, j1 ), ldt, work )
              t( j3, j1 ) = zero
              t( j3, j2 ) = zero
              t( j3, j3 ) = t11
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_slarfx( 'R', n, 3, u, tau, q( 1, j1 ), ldq, work )
              end if
              go to 40
              20 continue
              ! n1 = 2, n2 = 1: generate elementary reflector h so that:
              ! h (  -x11 ) = ( * )
                ! (  -x21 ) = ( 0 )
                ! ( scale ) = ( 0 )
              u( 1 ) = -x( 1, 1 )
              u( 2 ) = -x( 2, 1 )
              u( 3 ) = scale
              call stdlib_slarfg( 3, u( 1 ), u( 2 ), 1, tau )
              u( 1 ) = one
              t33 = t( j3, j3 )
              ! perform swap provisionally on diagonal block in d.
              call stdlib_slarfx( 'L', 3, 3, u, tau, d, ldd, work )
              call stdlib_slarfx( 'R', 3, 3, u, tau, d, ldd, work )
              ! test whether to reject swap.
              if( max( abs( d( 2, 1 ) ), abs( d( 3, 1 ) ), abs( d( 1,1 )-t33 ) )>thresh )go to &
                        50
              ! accept swap: apply transformation to the entire matrix t.
              call stdlib_slarfx( 'R', j3, 3, u, tau, t( 1, j1 ), ldt, work )
              call stdlib_slarfx( 'L', 3, n-j1, u, tau, t( j1, j2 ), ldt, work )
              t( j1, j1 ) = t33
              t( j2, j1 ) = zero
              t( j3, j1 ) = zero
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_slarfx( 'R', n, 3, u, tau, q( 1, j1 ), ldq, work )
              end if
              go to 40
              30 continue
              ! n1 = 2, n2 = 2: generate elementary reflectors h(1) and h(2) so
              ! that:
              ! h(2) h(1) (  -x11  -x12 ) = (  *  * )
                        ! (  -x21  -x22 )   (  0  * )
                        ! ( scale    0  )   (  0  0 )
                        ! (    0  scale )   (  0  0 )
              u1( 1 ) = -x( 1, 1 )
              u1( 2 ) = -x( 2, 1 )
              u1( 3 ) = scale
              call stdlib_slarfg( 3, u1( 1 ), u1( 2 ), 1, tau1 )
              u1( 1 ) = one
              temp = -tau1*( x( 1, 2 )+u1( 2 )*x( 2, 2 ) )
              u2( 1 ) = -temp*u1( 2 ) - x( 2, 2 )
              u2( 2 ) = -temp*u1( 3 )
              u2( 3 ) = scale
              call stdlib_slarfg( 3, u2( 1 ), u2( 2 ), 1, tau2 )
              u2( 1 ) = one
              ! perform swap provisionally on diagonal block in d.
              call stdlib_slarfx( 'L', 3, 4, u1, tau1, d, ldd, work )
              call stdlib_slarfx( 'R', 4, 3, u1, tau1, d, ldd, work )
              call stdlib_slarfx( 'L', 3, 4, u2, tau2, d( 2, 1 ), ldd, work )
              call stdlib_slarfx( 'R', 4, 3, u2, tau2, d( 1, 2 ), ldd, work )
              ! test whether to reject swap.
              if( max( abs( d( 3, 1 ) ), abs( d( 3, 2 ) ), abs( d( 4, 1 ) ),abs( d( 4, 2 ) ) )&
                        >thresh )go to 50
              ! accept swap: apply transformation to the entire matrix t.
              call stdlib_slarfx( 'L', 3, n-j1+1, u1, tau1, t( j1, j1 ), ldt, work )
              call stdlib_slarfx( 'R', j4, 3, u1, tau1, t( 1, j1 ), ldt, work )
              call stdlib_slarfx( 'L', 3, n-j1+1, u2, tau2, t( j2, j1 ), ldt, work )
              call stdlib_slarfx( 'R', j4, 3, u2, tau2, t( 1, j2 ), ldt, work )
              t( j3, j1 ) = zero
              t( j3, j2 ) = zero
              t( j4, j1 ) = zero
              t( j4, j2 ) = zero
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_slarfx( 'R', n, 3, u1, tau1, q( 1, j1 ), ldq, work )
                 call stdlib_slarfx( 'R', n, 3, u2, tau2, q( 1, j2 ), ldq, work )
              end if
              40 continue
              if( n2==2 ) then
                 ! standardize new 2-by-2 block t11
                 call stdlib_slanv2( t( j1, j1 ), t( j1, j2 ), t( j2, j1 ),t( j2, j2 ), wr1, wi1, &
                           wr2, wi2, cs, sn )
                 call stdlib_srot( n-j1-1, t( j1, j1+2 ), ldt, t( j2, j1+2 ), ldt,cs, sn )
                 call stdlib_srot( j1-1, t( 1, j1 ), 1, t( 1, j2 ), 1, cs, sn )
                 if( wantq )call stdlib_srot( n, q( 1, j1 ), 1, q( 1, j2 ), 1, cs, sn )
              end if
              if( n1==2 ) then
                 ! standardize new 2-by-2 block t22
                 j3 = j1 + n2
                 j4 = j3 + 1
                 call stdlib_slanv2( t( j3, j3 ), t( j3, j4 ), t( j4, j3 ),t( j4, j4 ), wr1, wi1, &
                           wr2, wi2, cs, sn )
                 if( j3+2<=n )call stdlib_srot( n-j3-1, t( j3, j3+2 ), ldt, t( j4, j3+2 ),ldt, cs,&
                            sn )
                 call stdlib_srot( j3-1, t( 1, j3 ), 1, t( 1, j4 ), 1, cs, sn )
                 if( wantq )call stdlib_srot( n, q( 1, j3 ), 1, q( 1, j4 ), 1, cs, sn )
              end if
           end if
           return
           ! exit with info = 1 if swap was rejected.
        50 info = 1
           return
     end subroutine stdlib_slaexc

     module subroutine stdlib_dlaexc( wantq, n, t, ldt, q, ldq, j1, n1, n2, work,info )
     !! DLAEXC swaps adjacent diagonal blocks T11 and T22 of order 1 or 2 in
     !! an upper quasi-triangular matrix T by an orthogonal similarity
     !! transformation.
     !! T must be in Schur canonical form, that is, block upper triangular
     !! with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block
     !! has its diagonal elements equal and its off-diagonal elements of
     !! opposite sign.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: j1, ldq, ldt, n, n1, n2
           ! Array Arguments 
           real(dp), intent(inout) :: q(ldq,*), t(ldt,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: ldd = 4
           integer(ilp), parameter :: ldx = 2
           
           
           
           ! Local Scalars 
           integer(ilp) :: ierr, j2, j3, j4, k, nd
           real(dp) :: cs, dnorm, eps, scale, smlnum, sn, t11, t22, t33, tau, tau1, tau2, temp, &
                     thresh, wi1, wi2, wr1, wr2, xnorm
           ! Local Arrays 
           real(dp) :: d(ldd,4), u(3), u1(3), u2(3), x(ldx,2)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n==0 .or. n1==0 .or. n2==0 )return
           if( j1+n1>n )return
           j2 = j1 + 1
           j3 = j1 + 2
           j4 = j1 + 3
           if( n1==1 .and. n2==1 ) then
              ! swap two 1-by-1 blocks.
              t11 = t( j1, j1 )
              t22 = t( j2, j2 )
              ! determine the transformation to perform the interchange.
              call stdlib_dlartg( t( j1, j2 ), t22-t11, cs, sn, temp )
              ! apply transformation to the matrix t.
              if( j3<=n )call stdlib_drot( n-j1-1, t( j1, j3 ), ldt, t( j2, j3 ), ldt, cs,sn )
                        
              call stdlib_drot( j1-1, t( 1, j1 ), 1, t( 1, j2 ), 1, cs, sn )
              t( j1, j1 ) = t22
              t( j2, j2 ) = t11
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_drot( n, q( 1, j1 ), 1, q( 1, j2 ), 1, cs, sn )
              end if
           else
              ! swapping involves at least one 2-by-2 block.
              ! copy the diagonal block of order n1+n2 to the local array d
              ! and compute its norm.
              nd = n1 + n2
              call stdlib_dlacpy( 'FULL', nd, nd, t( j1, j1 ), ldt, d, ldd )
              dnorm = stdlib_dlange( 'MAX', nd, nd, d, ldd, work )
              ! compute machine-dependent threshold for test for accepting
              ! swap.
              eps = stdlib_dlamch( 'P' )
              smlnum = stdlib_dlamch( 'S' ) / eps
              thresh = max( ten*eps*dnorm, smlnum )
              ! solve t11*x - x*t22 = scale*t12 for x.
              call stdlib_dlasy2( .false., .false., -1, n1, n2, d, ldd,d( n1+1, n1+1 ), ldd, d( 1,&
                         n1+1 ), ldd, scale, x,ldx, xnorm, ierr )
              ! swap the adjacent diagonal blocks.
              k = n1 + n1 + n2 - 3
              go to ( 10, 20, 30 )k
              10 continue
              ! n1 = 1, n2 = 2: generate elementary reflector h so that:
              ! ( scale, x11, x12 ) h = ( 0, 0, * )
              u( 1 ) = scale
              u( 2 ) = x( 1, 1 )
              u( 3 ) = x( 1, 2 )
              call stdlib_dlarfg( 3, u( 3 ), u, 1, tau )
              u( 3 ) = one
              t11 = t( j1, j1 )
              ! perform swap provisionally on diagonal block in d.
              call stdlib_dlarfx( 'L', 3, 3, u, tau, d, ldd, work )
              call stdlib_dlarfx( 'R', 3, 3, u, tau, d, ldd, work )
              ! test whether to reject swap.
              if( max( abs( d( 3, 1 ) ), abs( d( 3, 2 ) ), abs( d( 3,3 )-t11 ) )>thresh )go to &
                        50
              ! accept swap: apply transformation to the entire matrix t.
              call stdlib_dlarfx( 'L', 3, n-j1+1, u, tau, t( j1, j1 ), ldt, work )
              call stdlib_dlarfx( 'R', j2, 3, u, tau, t( 1, j1 ), ldt, work )
              t( j3, j1 ) = zero
              t( j3, j2 ) = zero
              t( j3, j3 ) = t11
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_dlarfx( 'R', n, 3, u, tau, q( 1, j1 ), ldq, work )
              end if
              go to 40
              20 continue
              ! n1 = 2, n2 = 1: generate elementary reflector h so that:
              ! h (  -x11 ) = ( * )
                ! (  -x21 ) = ( 0 )
                ! ( scale ) = ( 0 )
              u( 1 ) = -x( 1, 1 )
              u( 2 ) = -x( 2, 1 )
              u( 3 ) = scale
              call stdlib_dlarfg( 3, u( 1 ), u( 2 ), 1, tau )
              u( 1 ) = one
              t33 = t( j3, j3 )
              ! perform swap provisionally on diagonal block in d.
              call stdlib_dlarfx( 'L', 3, 3, u, tau, d, ldd, work )
              call stdlib_dlarfx( 'R', 3, 3, u, tau, d, ldd, work )
              ! test whether to reject swap.
              if( max( abs( d( 2, 1 ) ), abs( d( 3, 1 ) ), abs( d( 1,1 )-t33 ) )>thresh )go to &
                        50
              ! accept swap: apply transformation to the entire matrix t.
              call stdlib_dlarfx( 'R', j3, 3, u, tau, t( 1, j1 ), ldt, work )
              call stdlib_dlarfx( 'L', 3, n-j1, u, tau, t( j1, j2 ), ldt, work )
              t( j1, j1 ) = t33
              t( j2, j1 ) = zero
              t( j3, j1 ) = zero
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_dlarfx( 'R', n, 3, u, tau, q( 1, j1 ), ldq, work )
              end if
              go to 40
              30 continue
              ! n1 = 2, n2 = 2: generate elementary reflectors h(1) and h(2) so
              ! that:
              ! h(2) h(1) (  -x11  -x12 ) = (  *  * )
                        ! (  -x21  -x22 )   (  0  * )
                        ! ( scale    0  )   (  0  0 )
                        ! (    0  scale )   (  0  0 )
              u1( 1 ) = -x( 1, 1 )
              u1( 2 ) = -x( 2, 1 )
              u1( 3 ) = scale
              call stdlib_dlarfg( 3, u1( 1 ), u1( 2 ), 1, tau1 )
              u1( 1 ) = one
              temp = -tau1*( x( 1, 2 )+u1( 2 )*x( 2, 2 ) )
              u2( 1 ) = -temp*u1( 2 ) - x( 2, 2 )
              u2( 2 ) = -temp*u1( 3 )
              u2( 3 ) = scale
              call stdlib_dlarfg( 3, u2( 1 ), u2( 2 ), 1, tau2 )
              u2( 1 ) = one
              ! perform swap provisionally on diagonal block in d.
              call stdlib_dlarfx( 'L', 3, 4, u1, tau1, d, ldd, work )
              call stdlib_dlarfx( 'R', 4, 3, u1, tau1, d, ldd, work )
              call stdlib_dlarfx( 'L', 3, 4, u2, tau2, d( 2, 1 ), ldd, work )
              call stdlib_dlarfx( 'R', 4, 3, u2, tau2, d( 1, 2 ), ldd, work )
              ! test whether to reject swap.
              if( max( abs( d( 3, 1 ) ), abs( d( 3, 2 ) ), abs( d( 4, 1 ) ),abs( d( 4, 2 ) ) )&
                        >thresh )go to 50
              ! accept swap: apply transformation to the entire matrix t.
              call stdlib_dlarfx( 'L', 3, n-j1+1, u1, tau1, t( j1, j1 ), ldt, work )
              call stdlib_dlarfx( 'R', j4, 3, u1, tau1, t( 1, j1 ), ldt, work )
              call stdlib_dlarfx( 'L', 3, n-j1+1, u2, tau2, t( j2, j1 ), ldt, work )
              call stdlib_dlarfx( 'R', j4, 3, u2, tau2, t( 1, j2 ), ldt, work )
              t( j3, j1 ) = zero
              t( j3, j2 ) = zero
              t( j4, j1 ) = zero
              t( j4, j2 ) = zero
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_dlarfx( 'R', n, 3, u1, tau1, q( 1, j1 ), ldq, work )
                 call stdlib_dlarfx( 'R', n, 3, u2, tau2, q( 1, j2 ), ldq, work )
              end if
              40 continue
              if( n2==2 ) then
                 ! standardize new 2-by-2 block t11
                 call stdlib_dlanv2( t( j1, j1 ), t( j1, j2 ), t( j2, j1 ),t( j2, j2 ), wr1, wi1, &
                           wr2, wi2, cs, sn )
                 call stdlib_drot( n-j1-1, t( j1, j1+2 ), ldt, t( j2, j1+2 ), ldt,cs, sn )
                 call stdlib_drot( j1-1, t( 1, j1 ), 1, t( 1, j2 ), 1, cs, sn )
                 if( wantq )call stdlib_drot( n, q( 1, j1 ), 1, q( 1, j2 ), 1, cs, sn )
              end if
              if( n1==2 ) then
                 ! standardize new 2-by-2 block t22
                 j3 = j1 + n2
                 j4 = j3 + 1
                 call stdlib_dlanv2( t( j3, j3 ), t( j3, j4 ), t( j4, j3 ),t( j4, j4 ), wr1, wi1, &
                           wr2, wi2, cs, sn )
                 if( j3+2<=n )call stdlib_drot( n-j3-1, t( j3, j3+2 ), ldt, t( j4, j3+2 ),ldt, cs,&
                            sn )
                 call stdlib_drot( j3-1, t( 1, j3 ), 1, t( 1, j4 ), 1, cs, sn )
                 if( wantq )call stdlib_drot( n, q( 1, j3 ), 1, q( 1, j4 ), 1, cs, sn )
              end if
           end if
           return
           ! exit with info = 1 if swap was rejected.
           50 continue
           info = 1
           return
     end subroutine stdlib_dlaexc

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, j1, n1, n2, work,info )
     !! DLAEXC: swaps adjacent diagonal blocks T11 and T22 of order 1 or 2 in
     !! an upper quasi-triangular matrix T by an orthogonal similarity
     !! transformation.
     !! T must be in Schur canonical form, that is, block upper triangular
     !! with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block
     !! has its diagonal elements equal and its off-diagonal elements of
     !! opposite sign.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: j1, ldq, ldt, n, n1, n2
           ! Array Arguments 
           real(${rk}$), intent(inout) :: q(ldq,*), t(ldt,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: ldd = 4
           integer(ilp), parameter :: ldx = 2
           
           
           
           ! Local Scalars 
           integer(ilp) :: ierr, j2, j3, j4, k, nd
           real(${rk}$) :: cs, dnorm, eps, scale, smlnum, sn, t11, t22, t33, tau, tau1, tau2, temp, &
                     thresh, wi1, wi2, wr1, wr2, xnorm
           ! Local Arrays 
           real(${rk}$) :: d(ldd,4), u(3), u1(3), u2(3), x(ldx,2)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n==0 .or. n1==0 .or. n2==0 )return
           if( j1+n1>n )return
           j2 = j1 + 1
           j3 = j1 + 2
           j4 = j1 + 3
           if( n1==1 .and. n2==1 ) then
              ! swap two 1-by-1 blocks.
              t11 = t( j1, j1 )
              t22 = t( j2, j2 )
              ! determine the transformation to perform the interchange.
              call stdlib_${ri}$lartg( t( j1, j2 ), t22-t11, cs, sn, temp )
              ! apply transformation to the matrix t.
              if( j3<=n )call stdlib_${ri}$rot( n-j1-1, t( j1, j3 ), ldt, t( j2, j3 ), ldt, cs,sn )
                        
              call stdlib_${ri}$rot( j1-1, t( 1, j1 ), 1, t( 1, j2 ), 1, cs, sn )
              t( j1, j1 ) = t22
              t( j2, j2 ) = t11
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_${ri}$rot( n, q( 1, j1 ), 1, q( 1, j2 ), 1, cs, sn )
              end if
           else
              ! swapping involves at least one 2-by-2 block.
              ! copy the diagonal block of order n1+n2 to the local array d
              ! and compute its norm.
              nd = n1 + n2
              call stdlib_${ri}$lacpy( 'FULL', nd, nd, t( j1, j1 ), ldt, d, ldd )
              dnorm = stdlib_${ri}$lange( 'MAX', nd, nd, d, ldd, work )
              ! compute machine-dependent threshold for test for accepting
              ! swap.
              eps = stdlib_${ri}$lamch( 'P' )
              smlnum = stdlib_${ri}$lamch( 'S' ) / eps
              thresh = max( ten*eps*dnorm, smlnum )
              ! solve t11*x - x*t22 = scale*t12 for x.
              call stdlib_${ri}$lasy2( .false., .false., -1, n1, n2, d, ldd,d( n1+1, n1+1 ), ldd, d( 1,&
                         n1+1 ), ldd, scale, x,ldx, xnorm, ierr )
              ! swap the adjacent diagonal blocks.
              k = n1 + n1 + n2 - 3
              go to ( 10, 20, 30 )k
              10 continue
              ! n1 = 1, n2 = 2: generate elementary reflector h so that:
              ! ( scale, x11, x12 ) h = ( 0, 0, * )
              u( 1 ) = scale
              u( 2 ) = x( 1, 1 )
              u( 3 ) = x( 1, 2 )
              call stdlib_${ri}$larfg( 3, u( 3 ), u, 1, tau )
              u( 3 ) = one
              t11 = t( j1, j1 )
              ! perform swap provisionally on diagonal block in d.
              call stdlib_${ri}$larfx( 'L', 3, 3, u, tau, d, ldd, work )
              call stdlib_${ri}$larfx( 'R', 3, 3, u, tau, d, ldd, work )
              ! test whether to reject swap.
              if( max( abs( d( 3, 1 ) ), abs( d( 3, 2 ) ), abs( d( 3,3 )-t11 ) )>thresh )go to &
                        50
              ! accept swap: apply transformation to the entire matrix t.
              call stdlib_${ri}$larfx( 'L', 3, n-j1+1, u, tau, t( j1, j1 ), ldt, work )
              call stdlib_${ri}$larfx( 'R', j2, 3, u, tau, t( 1, j1 ), ldt, work )
              t( j3, j1 ) = zero
              t( j3, j2 ) = zero
              t( j3, j3 ) = t11
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_${ri}$larfx( 'R', n, 3, u, tau, q( 1, j1 ), ldq, work )
              end if
              go to 40
              20 continue
              ! n1 = 2, n2 = 1: generate elementary reflector h so that:
              ! h (  -x11 ) = ( * )
                ! (  -x21 ) = ( 0 )
                ! ( scale ) = ( 0 )
              u( 1 ) = -x( 1, 1 )
              u( 2 ) = -x( 2, 1 )
              u( 3 ) = scale
              call stdlib_${ri}$larfg( 3, u( 1 ), u( 2 ), 1, tau )
              u( 1 ) = one
              t33 = t( j3, j3 )
              ! perform swap provisionally on diagonal block in d.
              call stdlib_${ri}$larfx( 'L', 3, 3, u, tau, d, ldd, work )
              call stdlib_${ri}$larfx( 'R', 3, 3, u, tau, d, ldd, work )
              ! test whether to reject swap.
              if( max( abs( d( 2, 1 ) ), abs( d( 3, 1 ) ), abs( d( 1,1 )-t33 ) )>thresh )go to &
                        50
              ! accept swap: apply transformation to the entire matrix t.
              call stdlib_${ri}$larfx( 'R', j3, 3, u, tau, t( 1, j1 ), ldt, work )
              call stdlib_${ri}$larfx( 'L', 3, n-j1, u, tau, t( j1, j2 ), ldt, work )
              t( j1, j1 ) = t33
              t( j2, j1 ) = zero
              t( j3, j1 ) = zero
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_${ri}$larfx( 'R', n, 3, u, tau, q( 1, j1 ), ldq, work )
              end if
              go to 40
              30 continue
              ! n1 = 2, n2 = 2: generate elementary reflectors h(1) and h(2) so
              ! that:
              ! h(2) h(1) (  -x11  -x12 ) = (  *  * )
                        ! (  -x21  -x22 )   (  0  * )
                        ! ( scale    0  )   (  0  0 )
                        ! (    0  scale )   (  0  0 )
              u1( 1 ) = -x( 1, 1 )
              u1( 2 ) = -x( 2, 1 )
              u1( 3 ) = scale
              call stdlib_${ri}$larfg( 3, u1( 1 ), u1( 2 ), 1, tau1 )
              u1( 1 ) = one
              temp = -tau1*( x( 1, 2 )+u1( 2 )*x( 2, 2 ) )
              u2( 1 ) = -temp*u1( 2 ) - x( 2, 2 )
              u2( 2 ) = -temp*u1( 3 )
              u2( 3 ) = scale
              call stdlib_${ri}$larfg( 3, u2( 1 ), u2( 2 ), 1, tau2 )
              u2( 1 ) = one
              ! perform swap provisionally on diagonal block in d.
              call stdlib_${ri}$larfx( 'L', 3, 4, u1, tau1, d, ldd, work )
              call stdlib_${ri}$larfx( 'R', 4, 3, u1, tau1, d, ldd, work )
              call stdlib_${ri}$larfx( 'L', 3, 4, u2, tau2, d( 2, 1 ), ldd, work )
              call stdlib_${ri}$larfx( 'R', 4, 3, u2, tau2, d( 1, 2 ), ldd, work )
              ! test whether to reject swap.
              if( max( abs( d( 3, 1 ) ), abs( d( 3, 2 ) ), abs( d( 4, 1 ) ),abs( d( 4, 2 ) ) )&
                        >thresh )go to 50
              ! accept swap: apply transformation to the entire matrix t.
              call stdlib_${ri}$larfx( 'L', 3, n-j1+1, u1, tau1, t( j1, j1 ), ldt, work )
              call stdlib_${ri}$larfx( 'R', j4, 3, u1, tau1, t( 1, j1 ), ldt, work )
              call stdlib_${ri}$larfx( 'L', 3, n-j1+1, u2, tau2, t( j2, j1 ), ldt, work )
              call stdlib_${ri}$larfx( 'R', j4, 3, u2, tau2, t( 1, j2 ), ldt, work )
              t( j3, j1 ) = zero
              t( j3, j2 ) = zero
              t( j4, j1 ) = zero
              t( j4, j2 ) = zero
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_${ri}$larfx( 'R', n, 3, u1, tau1, q( 1, j1 ), ldq, work )
                 call stdlib_${ri}$larfx( 'R', n, 3, u2, tau2, q( 1, j2 ), ldq, work )
              end if
              40 continue
              if( n2==2 ) then
                 ! standardize new 2-by-2 block t11
                 call stdlib_${ri}$lanv2( t( j1, j1 ), t( j1, j2 ), t( j2, j1 ),t( j2, j2 ), wr1, wi1, &
                           wr2, wi2, cs, sn )
                 call stdlib_${ri}$rot( n-j1-1, t( j1, j1+2 ), ldt, t( j2, j1+2 ), ldt,cs, sn )
                 call stdlib_${ri}$rot( j1-1, t( 1, j1 ), 1, t( 1, j2 ), 1, cs, sn )
                 if( wantq )call stdlib_${ri}$rot( n, q( 1, j1 ), 1, q( 1, j2 ), 1, cs, sn )
              end if
              if( n1==2 ) then
                 ! standardize new 2-by-2 block t22
                 j3 = j1 + n2
                 j4 = j3 + 1
                 call stdlib_${ri}$lanv2( t( j3, j3 ), t( j3, j4 ), t( j4, j3 ),t( j4, j4 ), wr1, wi1, &
                           wr2, wi2, cs, sn )
                 if( j3+2<=n )call stdlib_${ri}$rot( n-j3-1, t( j3, j3+2 ), ldt, t( j4, j3+2 ),ldt, cs,&
                            sn )
                 call stdlib_${ri}$rot( j3-1, t( 1, j3 ), 1, t( 1, j4 ), 1, cs, sn )
                 if( wantq )call stdlib_${ri}$rot( n, q( 1, j3 ), 1, q( 1, j4 ), 1, cs, sn )
              end if
           end if
           return
           ! exit with info = 1 if swap was rejected.
           50 continue
           info = 1
           return
     end subroutine stdlib_${ri}$laexc

#:endif
#:endfor



     module pure subroutine stdlib_stgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alphar, alphai, &
     !! STGSEN reorders the generalized real Schur decomposition of a real
     !! matrix pair (A, B) (in terms of an orthonormal equivalence trans-
     !! formation Q**T * (A, B) * Z), so that a selected cluster of eigenvalues
     !! appears in the leading diagonal blocks of the upper quasi-triangular
     !! matrix A and the upper triangular B. The leading columns of Q and
     !! Z form orthonormal bases of the corresponding left and right eigen-
     !! spaces (deflating subspaces). (A, B) must be in generalized real
     !! Schur canonical form (as returned by SGGES), i.e. A is block upper
     !! triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper
     !! triangular.
     !! STGSEN also computes the generalized eigenvalues
     !! w(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
     !! of the reordered matrix pair (A, B).
     !! Optionally, STGSEN computes the estimates of reciprocal condition
     !! numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
     !! (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
     !! between the matrix pairs (A11, B11) and (A22,B22) that correspond to
     !! the selected cluster and the eigenvalues outside the cluster, resp.,
     !! and norms of "projections" onto left and right eigenspaces w.r.t.
     !! the selected cluster in the (1,1)-block.
               beta, q, ldq, z, ldz, m, pl,pr, dif, work, lwork, iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(in) :: ijob, lda, ldb, ldq, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(sp), intent(out) :: pl, pr
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(sp), intent(out) :: alphai(*), alphar(*), beta(*), dif(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: idifjb = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, pair, swap, wantd, wantd1, wantd2, wantp
           integer(ilp) :: i, ierr, ijb, k, kase, kk, ks, liwmin, lwmin, mn2, n1, n2
           real(sp) :: dscale, dsum, eps, rdscal, smlnum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           info = 0
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( ijob<0 .or. ijob>5 ) then
              info = -1
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -14
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STGSEN', -info )
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' ) / eps
           ierr = 0
           wantp = ijob==1 .or. ijob>=4
           wantd1 = ijob==2 .or. ijob==4
           wantd2 = ijob==3 .or. ijob==5
           wantd = wantd1 .or. wantd2
           ! set m to the dimension of the specified pair of deflating
           ! subspaces.
           m = 0
           pair = .false.
           if( .not.lquery .or. ijob/=0 ) then
           do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 if( k<n ) then
                    if( a( k+1, k )==zero ) then
                       if( select( k ) )m = m + 1
                    else
                       pair = .true.
                       if( select( k ) .or. select( k+1 ) )m = m + 2
                    end if
                 else
                    if( select( n ) )m = m + 1
                 end if
              end if
           end do
           end if
           if( ijob==1 .or. ijob==2 .or. ijob==4 ) then
              lwmin = max( 1, 4*n+16, 2*m*(n-m) )
              liwmin = max( 1, n+6 )
           else if( ijob==3 .or. ijob==5 ) then
              lwmin = max( 1, 4*n+16, 4*m*(n-m) )
              liwmin = max( 1, 2*m*(n-m), n+6 )
           else
              lwmin = max( 1, 4*n+16 )
              liwmin = 1
           end if
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           if( lwork<lwmin .and. .not.lquery ) then
              info = -22
           else if( liwork<liwmin .and. .not.lquery ) then
              info = -24
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STGSEN', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( m==n .or. m==0 ) then
              if( wantp ) then
                 pl = one
                 pr = one
              end if
              if( wantd ) then
                 dscale = zero
                 dsum = one
                 do i = 1, n
                    call stdlib_slassq( n, a( 1, i ), 1, dscale, dsum )
                    call stdlib_slassq( n, b( 1, i ), 1, dscale, dsum )
                 end do
                 dif( 1 ) = dscale*sqrt( dsum )
                 dif( 2 ) = dif( 1 )
              end if
              go to 60
           end if
           ! collect the selected blocks at the top-left corner of (a, b).
           ks = 0
           pair = .false.
           loop_30: do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 swap = select( k )
                 if( k<n ) then
                    if( a( k+1, k )/=zero ) then
                       pair = .true.
                       swap = swap .or. select( k+1 )
                    end if
                 end if
                 if( swap ) then
                    ks = ks + 1
                    ! swap the k-th block to position ks.
                    ! perform the reordering of diagonal blocks in (a, b)
                    ! by orthogonal transformation matrices and update
                    ! q and z accordingly (if requested):
                    kk = k
                    if( k/=ks )call stdlib_stgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz,&
                               kk, ks, work, lwork, ierr )
                    if( ierr>0 ) then
                       ! swap is rejected: exit.
                       info = 1
                       if( wantp ) then
                          pl = zero
                          pr = zero
                       end if
                       if( wantd ) then
                          dif( 1 ) = zero
                          dif( 2 ) = zero
                       end if
                       go to 60
                    end if
                    if( pair )ks = ks + 1
                 end if
              end if
           end do loop_30
           if( wantp ) then
              ! solve generalized sylvester equation for r and l
              ! and compute pl and pr.
              n1 = m
              n2 = n - m
              i = n1 + 1
              ijb = 0
              call stdlib_slacpy( 'FULL', n1, n2, a( 1, i ), lda, work, n1 )
              call stdlib_slacpy( 'FULL', n1, n2, b( 1, i ), ldb, work( n1*n2+1 ),n1 )
              call stdlib_stgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b( i,&
               i ), ldb, work( n1*n2+1 ), n1,dscale, dif( 1 ), work( n1*n2*2+1 ),lwork-2*n1*n2, &
                         iwork, ierr )
              ! estimate the reciprocal of norms of "projections" onto left
              ! and right eigenspaces.
              rdscal = zero
              dsum = one
              call stdlib_slassq( n1*n2, work, 1, rdscal, dsum )
              pl = rdscal*sqrt( dsum )
              if( pl==zero ) then
                 pl = one
              else
                 pl = dscale / ( sqrt( dscale*dscale / pl+pl )*sqrt( pl ) )
              end if
              rdscal = zero
              dsum = one
              call stdlib_slassq( n1*n2, work( n1*n2+1 ), 1, rdscal, dsum )
              pr = rdscal*sqrt( dsum )
              if( pr==zero ) then
                 pr = one
              else
                 pr = dscale / ( sqrt( dscale*dscale / pr+pr )*sqrt( pr ) )
              end if
           end if
           if( wantd ) then
              ! compute estimates of difu and difl.
              if( wantd1 ) then
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = idifjb
                 ! frobenius norm-based difu-estimate.
                 call stdlib_stgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b(&
                  i, i ), ldb, work( n1*n2+1 ),n1, dscale, dif( 1 ), work( 2*n1*n2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
                 ! frobenius norm-based difl-estimate.
                 call stdlib_stgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda, work,n2, b( i, i ),&
                  ldb, b, ldb, work( n1*n2+1 ),n2, dscale, dif( 2 ), work( 2*n1*n2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
              else
                 ! compute 1-norm-based estimates of difu and difl using
                 ! reversed communication with stdlib_slacn2. in each step a
                 ! generalized sylvester equation or a transposed variant
                 ! is solved.
                 kase = 0
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = 0
                 mn2 = 2*n1*n2
                 ! 1-norm-based estimate of difu.
                 40 continue
                 call stdlib_slacn2( mn2, work( mn2+1 ), work, iwork, dif( 1 ),kase, isave )
                           
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation.
                       call stdlib_stgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_stgsyl( 'T', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 40
                 end if
                 dif( 1 ) = dscale / dif( 1 )
                 ! 1-norm-based estimate of difl.
                 50 continue
                 call stdlib_slacn2( mn2, work( mn2+1 ), work, iwork, dif( 2 ),kase, isave )
                           
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation.
                       call stdlib_stgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b( &
                       i, i ), ldb, b, ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_stgsyl( 'T', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b( &
                       i, i ), ldb, b, ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 50
                 end if
                 dif( 2 ) = dscale / dif( 2 )
              end if
           end if
           60 continue
           ! compute generalized eigenvalues of reordered pair (a, b) and
           ! normalize the generalized schur form.
           pair = .false.
           loop_70: do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 if( k<n ) then
                    if( a( k+1, k )/=zero ) then
                       pair = .true.
                    end if
                 end if
                 if( pair ) then
                   ! compute the eigenvalue(s) at position k.
                    work( 1 ) = a( k, k )
                    work( 2 ) = a( k+1, k )
                    work( 3 ) = a( k, k+1 )
                    work( 4 ) = a( k+1, k+1 )
                    work( 5 ) = b( k, k )
                    work( 6 ) = b( k+1, k )
                    work( 7 ) = b( k, k+1 )
                    work( 8 ) = b( k+1, k+1 )
                    call stdlib_slag2( work, 2, work( 5 ), 2, smlnum*eps, beta( k ),beta( k+1 ), &
                              alphar( k ), alphar( k+1 ),alphai( k ) )
                    alphai( k+1 ) = -alphai( k )
                 else
                    if( sign( one, b( k, k ) )<zero ) then
                       ! if b(k,k) is negative, make it positive
                       do i = 1, n
                          a( k, i ) = -a( k, i )
                          b( k, i ) = -b( k, i )
                          if( wantq ) q( i, k ) = -q( i, k )
                       end do
                    end if
                    alphar( k ) = a( k, k )
                    alphai( k ) = zero
                    beta( k ) = b( k, k )
                 end if
              end if
           end do loop_70
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_stgsen

     module pure subroutine stdlib_dtgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alphar, alphai, &
     !! DTGSEN reorders the generalized real Schur decomposition of a real
     !! matrix pair (A, B) (in terms of an orthonormal equivalence trans-
     !! formation Q**T * (A, B) * Z), so that a selected cluster of eigenvalues
     !! appears in the leading diagonal blocks of the upper quasi-triangular
     !! matrix A and the upper triangular B. The leading columns of Q and
     !! Z form orthonormal bases of the corresponding left and right eigen-
     !! spaces (deflating subspaces). (A, B) must be in generalized real
     !! Schur canonical form (as returned by DGGES), i.e. A is block upper
     !! triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper
     !! triangular.
     !! DTGSEN also computes the generalized eigenvalues
     !! w(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
     !! of the reordered matrix pair (A, B).
     !! Optionally, DTGSEN computes the estimates of reciprocal condition
     !! numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
     !! (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
     !! between the matrix pairs (A11, B11) and (A22,B22) that correspond to
     !! the selected cluster and the eigenvalues outside the cluster, resp.,
     !! and norms of "projections" onto left and right eigenspaces w.r.t.
     !! the selected cluster in the (1,1)-block.
               beta, q, ldq, z, ldz, m, pl,pr, dif, work, lwork, iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(in) :: ijob, lda, ldb, ldq, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(dp), intent(out) :: pl, pr
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(dp), intent(out) :: alphai(*), alphar(*), beta(*), dif(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: idifjb = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, pair, swap, wantd, wantd1, wantd2, wantp
           integer(ilp) :: i, ierr, ijb, k, kase, kk, ks, liwmin, lwmin, mn2, n1, n2
           real(dp) :: dscale, dsum, eps, rdscal, smlnum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           info = 0
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( ijob<0 .or. ijob>5 ) then
              info = -1
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -14
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSEN', -info )
              return
           end if
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' ) / eps
           ierr = 0
           wantp = ijob==1 .or. ijob>=4
           wantd1 = ijob==2 .or. ijob==4
           wantd2 = ijob==3 .or. ijob==5
           wantd = wantd1 .or. wantd2
           ! set m to the dimension of the specified pair of deflating
           ! subspaces.
           m = 0
           pair = .false.
           if( .not.lquery .or. ijob/=0 ) then
           do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 if( k<n ) then
                    if( a( k+1, k )==zero ) then
                       if( select( k ) )m = m + 1
                    else
                       pair = .true.
                       if( select( k ) .or. select( k+1 ) )m = m + 2
                    end if
                 else
                    if( select( n ) )m = m + 1
                 end if
              end if
           end do
           end if
           if( ijob==1 .or. ijob==2 .or. ijob==4 ) then
              lwmin = max( 1, 4*n+16, 2*m*( n-m ) )
              liwmin = max( 1, n+6 )
           else if( ijob==3 .or. ijob==5 ) then
              lwmin = max( 1, 4*n+16, 4*m*( n-m ) )
              liwmin = max( 1, 2*m*( n-m ), n+6 )
           else
              lwmin = max( 1, 4*n+16 )
              liwmin = 1
           end if
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           if( lwork<lwmin .and. .not.lquery ) then
              info = -22
           else if( liwork<liwmin .and. .not.lquery ) then
              info = -24
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSEN', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( m==n .or. m==0 ) then
              if( wantp ) then
                 pl = one
                 pr = one
              end if
              if( wantd ) then
                 dscale = zero
                 dsum = one
                 do i = 1, n
                    call stdlib_dlassq( n, a( 1, i ), 1, dscale, dsum )
                    call stdlib_dlassq( n, b( 1, i ), 1, dscale, dsum )
                 end do
                 dif( 1 ) = dscale*sqrt( dsum )
                 dif( 2 ) = dif( 1 )
              end if
              go to 60
           end if
           ! collect the selected blocks at the top-left corner of (a, b).
           ks = 0
           pair = .false.
           loop_30: do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 swap = select( k )
                 if( k<n ) then
                    if( a( k+1, k )/=zero ) then
                       pair = .true.
                       swap = swap .or. select( k+1 )
                    end if
                 end if
                 if( swap ) then
                    ks = ks + 1
                    ! swap the k-th block to position ks.
                    ! perform the reordering of diagonal blocks in (a, b)
                    ! by orthogonal transformation matrices and update
                    ! q and z accordingly (if requested):
                    kk = k
                    if( k/=ks )call stdlib_dtgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz,&
                               kk, ks, work, lwork, ierr )
                    if( ierr>0 ) then
                       ! swap is rejected: exit.
                       info = 1
                       if( wantp ) then
                          pl = zero
                          pr = zero
                       end if
                       if( wantd ) then
                          dif( 1 ) = zero
                          dif( 2 ) = zero
                       end if
                       go to 60
                    end if
                    if( pair )ks = ks + 1
                 end if
              end if
           end do loop_30
           if( wantp ) then
              ! solve generalized sylvester equation for r and l
              ! and compute pl and pr.
              n1 = m
              n2 = n - m
              i = n1 + 1
              ijb = 0
              call stdlib_dlacpy( 'FULL', n1, n2, a( 1, i ), lda, work, n1 )
              call stdlib_dlacpy( 'FULL', n1, n2, b( 1, i ), ldb, work( n1*n2+1 ),n1 )
              call stdlib_dtgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b( i,&
               i ), ldb, work( n1*n2+1 ), n1,dscale, dif( 1 ), work( n1*n2*2+1 ),lwork-2*n1*n2, &
                         iwork, ierr )
              ! estimate the reciprocal of norms of "projections" onto left
              ! and right eigenspaces.
              rdscal = zero
              dsum = one
              call stdlib_dlassq( n1*n2, work, 1, rdscal, dsum )
              pl = rdscal*sqrt( dsum )
              if( pl==zero ) then
                 pl = one
              else
                 pl = dscale / ( sqrt( dscale*dscale / pl+pl )*sqrt( pl ) )
              end if
              rdscal = zero
              dsum = one
              call stdlib_dlassq( n1*n2, work( n1*n2+1 ), 1, rdscal, dsum )
              pr = rdscal*sqrt( dsum )
              if( pr==zero ) then
                 pr = one
              else
                 pr = dscale / ( sqrt( dscale*dscale / pr+pr )*sqrt( pr ) )
              end if
           end if
           if( wantd ) then
              ! compute estimates of difu and difl.
              if( wantd1 ) then
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = idifjb
                 ! frobenius norm-based difu-estimate.
                 call stdlib_dtgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b(&
                  i, i ), ldb, work( n1*n2+1 ),n1, dscale, dif( 1 ), work( 2*n1*n2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
                 ! frobenius norm-based difl-estimate.
                 call stdlib_dtgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda, work,n2, b( i, i ),&
                  ldb, b, ldb, work( n1*n2+1 ),n2, dscale, dif( 2 ), work( 2*n1*n2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
              else
                 ! compute 1-norm-based estimates of difu and difl using
                 ! reversed communication with stdlib_dlacn2. in each step a
                 ! generalized sylvester equation or a transposed variant
                 ! is solved.
                 kase = 0
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = 0
                 mn2 = 2*n1*n2
                 ! 1-norm-based estimate of difu.
                 40 continue
                 call stdlib_dlacn2( mn2, work( mn2+1 ), work, iwork, dif( 1 ),kase, isave )
                           
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation.
                       call stdlib_dtgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_dtgsyl( 'T', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 40
                 end if
                 dif( 1 ) = dscale / dif( 1 )
                 ! 1-norm-based estimate of difl.
                 50 continue
                 call stdlib_dlacn2( mn2, work( mn2+1 ), work, iwork, dif( 2 ),kase, isave )
                           
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation.
                       call stdlib_dtgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b( &
                       i, i ), ldb, b, ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_dtgsyl( 'T', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b( &
                       i, i ), ldb, b, ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 50
                 end if
                 dif( 2 ) = dscale / dif( 2 )
              end if
           end if
           60 continue
           ! compute generalized eigenvalues of reordered pair (a, b) and
           ! normalize the generalized schur form.
           pair = .false.
           loop_80: do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 if( k<n ) then
                    if( a( k+1, k )/=zero ) then
                       pair = .true.
                    end if
                 end if
                 if( pair ) then
                   ! compute the eigenvalue(s) at position k.
                    work( 1 ) = a( k, k )
                    work( 2 ) = a( k+1, k )
                    work( 3 ) = a( k, k+1 )
                    work( 4 ) = a( k+1, k+1 )
                    work( 5 ) = b( k, k )
                    work( 6 ) = b( k+1, k )
                    work( 7 ) = b( k, k+1 )
                    work( 8 ) = b( k+1, k+1 )
                    call stdlib_dlag2( work, 2, work( 5 ), 2, smlnum*eps, beta( k ),beta( k+1 ), &
                              alphar( k ), alphar( k+1 ),alphai( k ) )
                    alphai( k+1 ) = -alphai( k )
                 else
                    if( sign( one, b( k, k ) )<zero ) then
                       ! if b(k,k) is negative, make it positive
                       do i = 1, n
                          a( k, i ) = -a( k, i )
                          b( k, i ) = -b( k, i )
                          if( wantq ) q( i, k ) = -q( i, k )
                       end do
                    end if
                    alphar( k ) = a( k, k )
                    alphai( k ) = zero
                    beta( k ) = b( k, k )
                 end if
              end if
           end do loop_80
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_dtgsen

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$tgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alphar, alphai, &
     !! DTGSEN: reorders the generalized real Schur decomposition of a real
     !! matrix pair (A, B) (in terms of an orthonormal equivalence trans-
     !! formation Q**T * (A, B) * Z), so that a selected cluster of eigenvalues
     !! appears in the leading diagonal blocks of the upper quasi-triangular
     !! matrix A and the upper triangular B. The leading columns of Q and
     !! Z form orthonormal bases of the corresponding left and right eigen-
     !! spaces (deflating subspaces). (A, B) must be in generalized real
     !! Schur canonical form (as returned by DGGES), i.e. A is block upper
     !! triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper
     !! triangular.
     !! DTGSEN also computes the generalized eigenvalues
     !! w(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
     !! of the reordered matrix pair (A, B).
     !! Optionally, DTGSEN computes the estimates of reciprocal condition
     !! numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
     !! (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
     !! between the matrix pairs (A11, B11) and (A22,B22) that correspond to
     !! the selected cluster and the eigenvalues outside the cluster, resp.,
     !! and norms of "projections" onto left and right eigenspaces w.r.t.
     !! the selected cluster in the (1,1)-block.
               beta, q, ldq, z, ldz, m, pl,pr, dif, work, lwork, iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(in) :: ijob, lda, ldb, ldq, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(${rk}$), intent(out) :: pl, pr
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), dif(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: idifjb = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, pair, swap, wantd, wantd1, wantd2, wantp
           integer(ilp) :: i, ierr, ijb, k, kase, kk, ks, liwmin, lwmin, mn2, n1, n2
           real(${rk}$) :: dscale, dsum, eps, rdscal, smlnum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           info = 0
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( ijob<0 .or. ijob>5 ) then
              info = -1
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -14
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSEN', -info )
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' ) / eps
           ierr = 0
           wantp = ijob==1 .or. ijob>=4
           wantd1 = ijob==2 .or. ijob==4
           wantd2 = ijob==3 .or. ijob==5
           wantd = wantd1 .or. wantd2
           ! set m to the dimension of the specified pair of deflating
           ! subspaces.
           m = 0
           pair = .false.
           if( .not.lquery .or. ijob/=0 ) then
           do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 if( k<n ) then
                    if( a( k+1, k )==zero ) then
                       if( select( k ) )m = m + 1
                    else
                       pair = .true.
                       if( select( k ) .or. select( k+1 ) )m = m + 2
                    end if
                 else
                    if( select( n ) )m = m + 1
                 end if
              end if
           end do
           end if
           if( ijob==1 .or. ijob==2 .or. ijob==4 ) then
              lwmin = max( 1, 4*n+16, 2*m*( n-m ) )
              liwmin = max( 1, n+6 )
           else if( ijob==3 .or. ijob==5 ) then
              lwmin = max( 1, 4*n+16, 4*m*( n-m ) )
              liwmin = max( 1, 2*m*( n-m ), n+6 )
           else
              lwmin = max( 1, 4*n+16 )
              liwmin = 1
           end if
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           if( lwork<lwmin .and. .not.lquery ) then
              info = -22
           else if( liwork<liwmin .and. .not.lquery ) then
              info = -24
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSEN', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( m==n .or. m==0 ) then
              if( wantp ) then
                 pl = one
                 pr = one
              end if
              if( wantd ) then
                 dscale = zero
                 dsum = one
                 do i = 1, n
                    call stdlib_${ri}$lassq( n, a( 1, i ), 1, dscale, dsum )
                    call stdlib_${ri}$lassq( n, b( 1, i ), 1, dscale, dsum )
                 end do
                 dif( 1 ) = dscale*sqrt( dsum )
                 dif( 2 ) = dif( 1 )
              end if
              go to 60
           end if
           ! collect the selected blocks at the top-left corner of (a, b).
           ks = 0
           pair = .false.
           loop_30: do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 swap = select( k )
                 if( k<n ) then
                    if( a( k+1, k )/=zero ) then
                       pair = .true.
                       swap = swap .or. select( k+1 )
                    end if
                 end if
                 if( swap ) then
                    ks = ks + 1
                    ! swap the k-th block to position ks.
                    ! perform the reordering of diagonal blocks in (a, b)
                    ! by orthogonal transformation matrices and update
                    ! q and z accordingly (if requested):
                    kk = k
                    if( k/=ks )call stdlib_${ri}$tgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz,&
                               kk, ks, work, lwork, ierr )
                    if( ierr>0 ) then
                       ! swap is rejected: exit.
                       info = 1
                       if( wantp ) then
                          pl = zero
                          pr = zero
                       end if
                       if( wantd ) then
                          dif( 1 ) = zero
                          dif( 2 ) = zero
                       end if
                       go to 60
                    end if
                    if( pair )ks = ks + 1
                 end if
              end if
           end do loop_30
           if( wantp ) then
              ! solve generalized sylvester equation for r and l
              ! and compute pl and pr.
              n1 = m
              n2 = n - m
              i = n1 + 1
              ijb = 0
              call stdlib_${ri}$lacpy( 'FULL', n1, n2, a( 1, i ), lda, work, n1 )
              call stdlib_${ri}$lacpy( 'FULL', n1, n2, b( 1, i ), ldb, work( n1*n2+1 ),n1 )
              call stdlib_${ri}$tgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b( i,&
               i ), ldb, work( n1*n2+1 ), n1,dscale, dif( 1 ), work( n1*n2*2+1 ),lwork-2*n1*n2, &
                         iwork, ierr )
              ! estimate the reciprocal of norms of "projections" onto left
              ! and right eigenspaces.
              rdscal = zero
              dsum = one
              call stdlib_${ri}$lassq( n1*n2, work, 1, rdscal, dsum )
              pl = rdscal*sqrt( dsum )
              if( pl==zero ) then
                 pl = one
              else
                 pl = dscale / ( sqrt( dscale*dscale / pl+pl )*sqrt( pl ) )
              end if
              rdscal = zero
              dsum = one
              call stdlib_${ri}$lassq( n1*n2, work( n1*n2+1 ), 1, rdscal, dsum )
              pr = rdscal*sqrt( dsum )
              if( pr==zero ) then
                 pr = one
              else
                 pr = dscale / ( sqrt( dscale*dscale / pr+pr )*sqrt( pr ) )
              end if
           end if
           if( wantd ) then
              ! compute estimates of difu and difl.
              if( wantd1 ) then
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = idifjb
                 ! frobenius norm-based difu-estimate.
                 call stdlib_${ri}$tgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b(&
                  i, i ), ldb, work( n1*n2+1 ),n1, dscale, dif( 1 ), work( 2*n1*n2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
                 ! frobenius norm-based difl-estimate.
                 call stdlib_${ri}$tgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda, work,n2, b( i, i ),&
                  ldb, b, ldb, work( n1*n2+1 ),n2, dscale, dif( 2 ), work( 2*n1*n2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
              else
                 ! compute 1-norm-based estimates of difu and difl using
                 ! reversed communication with stdlib_${ri}$lacn2. in each step a
                 ! generalized sylvester equation or a transposed variant
                 ! is solved.
                 kase = 0
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = 0
                 mn2 = 2*n1*n2
                 ! 1-norm-based estimate of difu.
                 40 continue
                 call stdlib_${ri}$lacn2( mn2, work( mn2+1 ), work, iwork, dif( 1 ),kase, isave )
                           
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation.
                       call stdlib_${ri}$tgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_${ri}$tgsyl( 'T', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 40
                 end if
                 dif( 1 ) = dscale / dif( 1 )
                 ! 1-norm-based estimate of difl.
                 50 continue
                 call stdlib_${ri}$lacn2( mn2, work( mn2+1 ), work, iwork, dif( 2 ),kase, isave )
                           
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation.
                       call stdlib_${ri}$tgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b( &
                       i, i ), ldb, b, ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_${ri}$tgsyl( 'T', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b( &
                       i, i ), ldb, b, ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 50
                 end if
                 dif( 2 ) = dscale / dif( 2 )
              end if
           end if
           60 continue
           ! compute generalized eigenvalues of reordered pair (a, b) and
           ! normalize the generalized schur form.
           pair = .false.
           loop_80: do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 if( k<n ) then
                    if( a( k+1, k )/=zero ) then
                       pair = .true.
                    end if
                 end if
                 if( pair ) then
                   ! compute the eigenvalue(s) at position k.
                    work( 1 ) = a( k, k )
                    work( 2 ) = a( k+1, k )
                    work( 3 ) = a( k, k+1 )
                    work( 4 ) = a( k+1, k+1 )
                    work( 5 ) = b( k, k )
                    work( 6 ) = b( k+1, k )
                    work( 7 ) = b( k, k+1 )
                    work( 8 ) = b( k+1, k+1 )
                    call stdlib_${ri}$lag2( work, 2, work( 5 ), 2, smlnum*eps, beta( k ),beta( k+1 ), &
                              alphar( k ), alphar( k+1 ),alphai( k ) )
                    alphai( k+1 ) = -alphai( k )
                 else
                    if( sign( one, b( k, k ) )<zero ) then
                       ! if b(k,k) is negative, make it positive
                       do i = 1, n
                          a( k, i ) = -a( k, i )
                          b( k, i ) = -b( k, i )
                          if( wantq ) q( i, k ) = -q( i, k )
                       end do
                    end if
                    alphar( k ) = a( k, k )
                    alphai( k ) = zero
                    beta( k ) = b( k, k )
                 end if
              end if
           end do loop_80
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ri}$tgsen

#:endif
#:endfor

     module pure subroutine stdlib_ctgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alpha, beta, q, &
     !! CTGSEN reorders the generalized Schur decomposition of a complex
     !! matrix pair (A, B) (in terms of an unitary equivalence trans-
     !! formation Q**H * (A, B) * Z), so that a selected cluster of eigenvalues
     !! appears in the leading diagonal blocks of the pair (A,B). The leading
     !! columns of Q and Z form unitary bases of the corresponding left and
     !! right eigenspaces (deflating subspaces). (A, B) must be in
     !! generalized Schur canonical form, that is, A and B are both upper
     !! triangular.
     !! CTGSEN also computes the generalized eigenvalues
     !! w(j)= ALPHA(j) / BETA(j)
     !! of the reordered matrix pair (A, B).
     !! Optionally, the routine computes estimates of reciprocal condition
     !! numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
     !! (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
     !! between the matrix pairs (A11, B11) and (A22,B22) that correspond to
     !! the selected cluster and the eigenvalues outside the cluster, resp.,
     !! and norms of "projections" onto left and right eigenspaces w.r.t.
     !! the selected cluster in the (1,1)-block.
               ldq, z, ldz, m, pl, pr, dif,work, lwork, iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(in) :: ijob, lda, ldb, ldq, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(sp), intent(out) :: pl, pr
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(out) :: dif(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           complex(sp), intent(out) :: alpha(*), beta(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: idifjb = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, swap, wantd, wantd1, wantd2, wantp
           integer(ilp) :: i, ierr, ijb, k, kase, ks, liwmin, lwmin, mn2, n1, n2
           real(sp) :: dscale, dsum, rdscal, safmin
           complex(sp) :: temp1, temp2
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           info = 0
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( ijob<0 .or. ijob>5 ) then
              info = -1
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -13
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGSEN', -info )
              return
           end if
           ierr = 0
           wantp = ijob==1 .or. ijob>=4
           wantd1 = ijob==2 .or. ijob==4
           wantd2 = ijob==3 .or. ijob==5
           wantd = wantd1 .or. wantd2
           ! set m to the dimension of the specified pair of deflating
           ! subspaces.
           m = 0
           if( .not.lquery .or. ijob/=0 ) then
           do k = 1, n
              alpha( k ) = a( k, k )
              beta( k ) = b( k, k )
              if( k<n ) then
                 if( select( k ) )m = m + 1
              else
                 if( select( n ) )m = m + 1
              end if
           end do
           end if
           if( ijob==1 .or. ijob==2 .or. ijob==4 ) then
              lwmin = max( 1, 2*m*(n-m) )
              liwmin = max( 1, n+2 )
           else if( ijob==3 .or. ijob==5 ) then
              lwmin = max( 1, 4*m*(n-m) )
              liwmin = max( 1, 2*m*(n-m), n+2 )
           else
              lwmin = 1
              liwmin = 1
           end if
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           if( lwork<lwmin .and. .not.lquery ) then
              info = -21
           else if( liwork<liwmin .and. .not.lquery ) then
              info = -23
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGSEN', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( m==n .or. m==0 ) then
              if( wantp ) then
                 pl = one
                 pr = one
              end if
              if( wantd ) then
                 dscale = zero
                 dsum = one
                 do i = 1, n
                    call stdlib_classq( n, a( 1, i ), 1, dscale, dsum )
                    call stdlib_classq( n, b( 1, i ), 1, dscale, dsum )
                 end do
                 dif( 1 ) = dscale*sqrt( dsum )
                 dif( 2 ) = dif( 1 )
              end if
              go to 70
           end if
           ! get machine constant
           safmin = stdlib_slamch( 'S' )
           ! collect the selected blocks at the top-left corner of (a, b).
           ks = 0
           do k = 1, n
              swap = select( k )
              if( swap ) then
                 ks = ks + 1
                 ! swap the k-th block to position ks. compute unitary q
                 ! and z that will swap adjacent diagonal blocks in (a, b).
                 if( k/=ks )call stdlib_ctgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, k,&
                            ks, ierr )
                 if( ierr>0 ) then
                    ! swap is rejected: exit.
                    info = 1
                    if( wantp ) then
                       pl = zero
                       pr = zero
                    end if
                    if( wantd ) then
                       dif( 1 ) = zero
                       dif( 2 ) = zero
                    end if
                    go to 70
                 end if
              end if
           end do
           if( wantp ) then
              ! solve generalized sylvester equation for r and l:
                         ! a11 * r - l * a22 = a12
                         ! b11 * r - l * b22 = b12
              n1 = m
              n2 = n - m
              i = n1 + 1
              call stdlib_clacpy( 'FULL', n1, n2, a( 1, i ), lda, work, n1 )
              call stdlib_clacpy( 'FULL', n1, n2, b( 1, i ), ldb, work( n1*n2+1 ),n1 )
              ijb = 0
              call stdlib_ctgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b( i,&
               i ), ldb, work( n1*n2+1 ), n1,dscale, dif( 1 ), work( n1*n2*2+1 ),lwork-2*n1*n2, &
                         iwork, ierr )
              ! estimate the reciprocal of norms of "projections" onto
              ! left and right eigenspaces
              rdscal = zero
              dsum = one
              call stdlib_classq( n1*n2, work, 1, rdscal, dsum )
              pl = rdscal*sqrt( dsum )
              if( pl==zero ) then
                 pl = one
              else
                 pl = dscale / ( sqrt( dscale*dscale / pl+pl )*sqrt( pl ) )
              end if
              rdscal = zero
              dsum = one
              call stdlib_classq( n1*n2, work( n1*n2+1 ), 1, rdscal, dsum )
              pr = rdscal*sqrt( dsum )
              if( pr==zero ) then
                 pr = one
              else
                 pr = dscale / ( sqrt( dscale*dscale / pr+pr )*sqrt( pr ) )
              end if
           end if
           if( wantd ) then
              ! compute estimates difu and difl.
              if( wantd1 ) then
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = idifjb
                 ! frobenius norm-based difu estimate.
                 call stdlib_ctgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b(&
                  i, i ), ldb, work( n1*n2+1 ),n1, dscale, dif( 1 ), work( n1*n2*2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
                 ! frobenius norm-based difl estimate.
                 call stdlib_ctgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda, work,n2, b( i, i ),&
                  ldb, b, ldb, work( n1*n2+1 ),n2, dscale, dif( 2 ), work( n1*n2*2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
              else
                 ! compute 1-norm-based estimates of difu and difl using
                 ! reversed communication with stdlib_clacn2. in each step a
                 ! generalized sylvester equation or a transposed variant
                 ! is solved.
                 kase = 0
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = 0
                 mn2 = 2*n1*n2
                 ! 1-norm-based estimate of difu.
                 40 continue
                 call stdlib_clacn2( mn2, work( mn2+1 ), work, dif( 1 ), kase,isave )
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation
                       call stdlib_ctgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_ctgsyl( 'C', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 40
                 end if
                 dif( 1 ) = dscale / dif( 1 )
                 ! 1-norm-based estimate of difl.
                 50 continue
                 call stdlib_clacn2( mn2, work( mn2+1 ), work, dif( 2 ), kase,isave )
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation
                       call stdlib_ctgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b( &
                       i, i ), ldb, b, ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_ctgsyl( 'C', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 50
                 end if
                 dif( 2 ) = dscale / dif( 2 )
              end if
           end if
           ! if b(k,k) is complex, make it real and positive (normalization
           ! of the generalized schur form) and store the generalized
           ! eigenvalues of reordered pair (a, b)
           do k = 1, n
              dscale = abs( b( k, k ) )
              if( dscale>safmin ) then
                 temp1 = conjg( b( k, k ) / dscale )
                 temp2 = b( k, k ) / dscale
                 b( k, k ) = dscale
                 call stdlib_cscal( n-k, temp1, b( k, k+1 ), ldb )
                 call stdlib_cscal( n-k+1, temp1, a( k, k ), lda )
                 if( wantq )call stdlib_cscal( n, temp2, q( 1, k ), 1 )
              else
                 b( k, k ) = cmplx( zero, zero,KIND=sp)
              end if
              alpha( k ) = a( k, k )
              beta( k ) = b( k, k )
           end do
           70 continue
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_ctgsen

     module pure subroutine stdlib_ztgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alpha, beta, q, &
     !! ZTGSEN reorders the generalized Schur decomposition of a complex
     !! matrix pair (A, B) (in terms of an unitary equivalence trans-
     !! formation Q**H * (A, B) * Z), so that a selected cluster of eigenvalues
     !! appears in the leading diagonal blocks of the pair (A,B). The leading
     !! columns of Q and Z form unitary bases of the corresponding left and
     !! right eigenspaces (deflating subspaces). (A, B) must be in
     !! generalized Schur canonical form, that is, A and B are both upper
     !! triangular.
     !! ZTGSEN also computes the generalized eigenvalues
     !! w(j)= ALPHA(j) / BETA(j)
     !! of the reordered matrix pair (A, B).
     !! Optionally, the routine computes estimates of reciprocal condition
     !! numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
     !! (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
     !! between the matrix pairs (A11, B11) and (A22,B22) that correspond to
     !! the selected cluster and the eigenvalues outside the cluster, resp.,
     !! and norms of "projections" onto left and right eigenspaces w.r.t.
     !! the selected cluster in the (1,1)-block.
               ldq, z, ldz, m, pl, pr, dif,work, lwork, iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(in) :: ijob, lda, ldb, ldq, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(dp), intent(out) :: pl, pr
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(out) :: dif(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           complex(dp), intent(out) :: alpha(*), beta(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: idifjb = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, swap, wantd, wantd1, wantd2, wantp
           integer(ilp) :: i, ierr, ijb, k, kase, ks, liwmin, lwmin, mn2, n1, n2
           real(dp) :: dscale, dsum, rdscal, safmin
           complex(dp) :: temp1, temp2
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           info = 0
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( ijob<0 .or. ijob>5 ) then
              info = -1
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -13
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGSEN', -info )
              return
           end if
           ierr = 0
           wantp = ijob==1 .or. ijob>=4
           wantd1 = ijob==2 .or. ijob==4
           wantd2 = ijob==3 .or. ijob==5
           wantd = wantd1 .or. wantd2
           ! set m to the dimension of the specified pair of deflating
           ! subspaces.
           m = 0
           if( .not.lquery .or. ijob/=0 ) then
           do k = 1, n
              alpha( k ) = a( k, k )
              beta( k ) = b( k, k )
              if( k<n ) then
                 if( select( k ) )m = m + 1
              else
                 if( select( n ) )m = m + 1
              end if
           end do
           end if
           if( ijob==1 .or. ijob==2 .or. ijob==4 ) then
              lwmin = max( 1, 2*m*( n-m ) )
              liwmin = max( 1, n+2 )
           else if( ijob==3 .or. ijob==5 ) then
              lwmin = max( 1, 4*m*( n-m ) )
              liwmin = max( 1, 2*m*( n-m ), n+2 )
           else
              lwmin = 1
              liwmin = 1
           end if
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           if( lwork<lwmin .and. .not.lquery ) then
              info = -21
           else if( liwork<liwmin .and. .not.lquery ) then
              info = -23
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGSEN', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( m==n .or. m==0 ) then
              if( wantp ) then
                 pl = one
                 pr = one
              end if
              if( wantd ) then
                 dscale = zero
                 dsum = one
                 do i = 1, n
                    call stdlib_zlassq( n, a( 1, i ), 1, dscale, dsum )
                    call stdlib_zlassq( n, b( 1, i ), 1, dscale, dsum )
                 end do
                 dif( 1 ) = dscale*sqrt( dsum )
                 dif( 2 ) = dif( 1 )
              end if
              go to 70
           end if
           ! get machine constant
           safmin = stdlib_dlamch( 'S' )
           ! collect the selected blocks at the top-left corner of (a, b).
           ks = 0
           do k = 1, n
              swap = select( k )
              if( swap ) then
                 ks = ks + 1
                 ! swap the k-th block to position ks. compute unitary q
                 ! and z that will swap adjacent diagonal blocks in (a, b).
                 if( k/=ks )call stdlib_ztgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, k,&
                            ks, ierr )
                 if( ierr>0 ) then
                    ! swap is rejected: exit.
                    info = 1
                    if( wantp ) then
                       pl = zero
                       pr = zero
                    end if
                    if( wantd ) then
                       dif( 1 ) = zero
                       dif( 2 ) = zero
                    end if
                    go to 70
                 end if
              end if
           end do
           if( wantp ) then
              ! solve generalized sylvester equation for r and l:
                         ! a11 * r - l * a22 = a12
                         ! b11 * r - l * b22 = b12
              n1 = m
              n2 = n - m
              i = n1 + 1
              call stdlib_zlacpy( 'FULL', n1, n2, a( 1, i ), lda, work, n1 )
              call stdlib_zlacpy( 'FULL', n1, n2, b( 1, i ), ldb, work( n1*n2+1 ),n1 )
              ijb = 0
              call stdlib_ztgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b( i,&
               i ), ldb, work( n1*n2+1 ), n1,dscale, dif( 1 ), work( n1*n2*2+1 ),lwork-2*n1*n2, &
                         iwork, ierr )
              ! estimate the reciprocal of norms of "projections" onto
              ! left and right eigenspaces
              rdscal = zero
              dsum = one
              call stdlib_zlassq( n1*n2, work, 1, rdscal, dsum )
              pl = rdscal*sqrt( dsum )
              if( pl==zero ) then
                 pl = one
              else
                 pl = dscale / ( sqrt( dscale*dscale / pl+pl )*sqrt( pl ) )
              end if
              rdscal = zero
              dsum = one
              call stdlib_zlassq( n1*n2, work( n1*n2+1 ), 1, rdscal, dsum )
              pr = rdscal*sqrt( dsum )
              if( pr==zero ) then
                 pr = one
              else
                 pr = dscale / ( sqrt( dscale*dscale / pr+pr )*sqrt( pr ) )
              end if
           end if
           if( wantd ) then
              ! compute estimates difu and difl.
              if( wantd1 ) then
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = idifjb
                 ! frobenius norm-based difu estimate.
                 call stdlib_ztgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b(&
                  i, i ), ldb, work( n1*n2+1 ),n1, dscale, dif( 1 ), work( n1*n2*2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
                 ! frobenius norm-based difl estimate.
                 call stdlib_ztgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda, work,n2, b( i, i ),&
                  ldb, b, ldb, work( n1*n2+1 ),n2, dscale, dif( 2 ), work( n1*n2*2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
              else
                 ! compute 1-norm-based estimates of difu and difl using
                 ! reversed communication with stdlib_zlacn2. in each step a
                 ! generalized sylvester equation or a transposed variant
                 ! is solved.
                 kase = 0
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = 0
                 mn2 = 2*n1*n2
                 ! 1-norm-based estimate of difu.
                 40 continue
                 call stdlib_zlacn2( mn2, work( mn2+1 ), work, dif( 1 ), kase,isave )
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation
                       call stdlib_ztgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_ztgsyl( 'C', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 40
                 end if
                 dif( 1 ) = dscale / dif( 1 )
                 ! 1-norm-based estimate of difl.
                 50 continue
                 call stdlib_zlacn2( mn2, work( mn2+1 ), work, dif( 2 ), kase,isave )
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation
                       call stdlib_ztgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b( &
                       i, i ), ldb, b, ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_ztgsyl( 'C', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 50
                 end if
                 dif( 2 ) = dscale / dif( 2 )
              end if
           end if
           ! if b(k,k) is complex, make it real and positive (normalization
           ! of the generalized schur form) and store the generalized
           ! eigenvalues of reordered pair (a, b)
           do k = 1, n
              dscale = abs( b( k, k ) )
              if( dscale>safmin ) then
                 temp1 = conjg( b( k, k ) / dscale )
                 temp2 = b( k, k ) / dscale
                 b( k, k ) = dscale
                 call stdlib_zscal( n-k, temp1, b( k, k+1 ), ldb )
                 call stdlib_zscal( n-k+1, temp1, a( k, k ), lda )
                 if( wantq )call stdlib_zscal( n, temp2, q( 1, k ), 1 )
              else
                 b( k, k ) = cmplx( zero, zero,KIND=dp)
              end if
              alpha( k ) = a( k, k )
              beta( k ) = b( k, k )
           end do
           70 continue
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_ztgsen

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$tgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alpha, beta, q, &
     !! ZTGSEN: reorders the generalized Schur decomposition of a complex
     !! matrix pair (A, B) (in terms of an unitary equivalence trans-
     !! formation Q**H * (A, B) * Z), so that a selected cluster of eigenvalues
     !! appears in the leading diagonal blocks of the pair (A,B). The leading
     !! columns of Q and Z form unitary bases of the corresponding left and
     !! right eigenspaces (deflating subspaces). (A, B) must be in
     !! generalized Schur canonical form, that is, A and B are both upper
     !! triangular.
     !! ZTGSEN also computes the generalized eigenvalues
     !! w(j)= ALPHA(j) / BETA(j)
     !! of the reordered matrix pair (A, B).
     !! Optionally, the routine computes estimates of reciprocal condition
     !! numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
     !! (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
     !! between the matrix pairs (A11, B11) and (A22,B22) that correspond to
     !! the selected cluster and the eigenvalues outside the cluster, resp.,
     !! and norms of "projections" onto left and right eigenspaces w.r.t.
     !! the selected cluster in the (1,1)-block.
               ldq, z, ldz, m, pl, pr, dif,work, lwork, iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(in) :: ijob, lda, ldb, ldq, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(${ck}$), intent(out) :: pl, pr
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${ck}$), intent(out) :: dif(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           complex(${ck}$), intent(out) :: alpha(*), beta(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: idifjb = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, swap, wantd, wantd1, wantd2, wantp
           integer(ilp) :: i, ierr, ijb, k, kase, ks, liwmin, lwmin, mn2, n1, n2
           real(${ck}$) :: dscale, dsum, rdscal, safmin
           complex(${ck}$) :: temp1, temp2
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           info = 0
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( ijob<0 .or. ijob>5 ) then
              info = -1
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -13
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGSEN', -info )
              return
           end if
           ierr = 0
           wantp = ijob==1 .or. ijob>=4
           wantd1 = ijob==2 .or. ijob==4
           wantd2 = ijob==3 .or. ijob==5
           wantd = wantd1 .or. wantd2
           ! set m to the dimension of the specified pair of deflating
           ! subspaces.
           m = 0
           if( .not.lquery .or. ijob/=0 ) then
           do k = 1, n
              alpha( k ) = a( k, k )
              beta( k ) = b( k, k )
              if( k<n ) then
                 if( select( k ) )m = m + 1
              else
                 if( select( n ) )m = m + 1
              end if
           end do
           end if
           if( ijob==1 .or. ijob==2 .or. ijob==4 ) then
              lwmin = max( 1, 2*m*( n-m ) )
              liwmin = max( 1, n+2 )
           else if( ijob==3 .or. ijob==5 ) then
              lwmin = max( 1, 4*m*( n-m ) )
              liwmin = max( 1, 2*m*( n-m ), n+2 )
           else
              lwmin = 1
              liwmin = 1
           end if
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           if( lwork<lwmin .and. .not.lquery ) then
              info = -21
           else if( liwork<liwmin .and. .not.lquery ) then
              info = -23
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGSEN', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( m==n .or. m==0 ) then
              if( wantp ) then
                 pl = one
                 pr = one
              end if
              if( wantd ) then
                 dscale = zero
                 dsum = one
                 do i = 1, n
                    call stdlib_${ci}$lassq( n, a( 1, i ), 1, dscale, dsum )
                    call stdlib_${ci}$lassq( n, b( 1, i ), 1, dscale, dsum )
                 end do
                 dif( 1 ) = dscale*sqrt( dsum )
                 dif( 2 ) = dif( 1 )
              end if
              go to 70
           end if
           ! get machine constant
           safmin = stdlib_${c2ri(ci)}$lamch( 'S' )
           ! collect the selected blocks at the top-left corner of (a, b).
           ks = 0
           do k = 1, n
              swap = select( k )
              if( swap ) then
                 ks = ks + 1
                 ! swap the k-th block to position ks. compute unitary q
                 ! and z that will swap adjacent diagonal blocks in (a, b).
                 if( k/=ks )call stdlib_${ci}$tgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, k,&
                            ks, ierr )
                 if( ierr>0 ) then
                    ! swap is rejected: exit.
                    info = 1
                    if( wantp ) then
                       pl = zero
                       pr = zero
                    end if
                    if( wantd ) then
                       dif( 1 ) = zero
                       dif( 2 ) = zero
                    end if
                    go to 70
                 end if
              end if
           end do
           if( wantp ) then
              ! solve generalized sylvester equation for r and l:
                         ! a11 * r - l * a22 = a12
                         ! b11 * r - l * b22 = b12
              n1 = m
              n2 = n - m
              i = n1 + 1
              call stdlib_${ci}$lacpy( 'FULL', n1, n2, a( 1, i ), lda, work, n1 )
              call stdlib_${ci}$lacpy( 'FULL', n1, n2, b( 1, i ), ldb, work( n1*n2+1 ),n1 )
              ijb = 0
              call stdlib_${ci}$tgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b( i,&
               i ), ldb, work( n1*n2+1 ), n1,dscale, dif( 1 ), work( n1*n2*2+1 ),lwork-2*n1*n2, &
                         iwork, ierr )
              ! estimate the reciprocal of norms of "projections" onto
              ! left and right eigenspaces
              rdscal = zero
              dsum = one
              call stdlib_${ci}$lassq( n1*n2, work, 1, rdscal, dsum )
              pl = rdscal*sqrt( dsum )
              if( pl==zero ) then
                 pl = one
              else
                 pl = dscale / ( sqrt( dscale*dscale / pl+pl )*sqrt( pl ) )
              end if
              rdscal = zero
              dsum = one
              call stdlib_${ci}$lassq( n1*n2, work( n1*n2+1 ), 1, rdscal, dsum )
              pr = rdscal*sqrt( dsum )
              if( pr==zero ) then
                 pr = one
              else
                 pr = dscale / ( sqrt( dscale*dscale / pr+pr )*sqrt( pr ) )
              end if
           end if
           if( wantd ) then
              ! compute estimates difu and difl.
              if( wantd1 ) then
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = idifjb
                 ! frobenius norm-based difu estimate.
                 call stdlib_${ci}$tgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b(&
                  i, i ), ldb, work( n1*n2+1 ),n1, dscale, dif( 1 ), work( n1*n2*2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
                 ! frobenius norm-based difl estimate.
                 call stdlib_${ci}$tgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda, work,n2, b( i, i ),&
                  ldb, b, ldb, work( n1*n2+1 ),n2, dscale, dif( 2 ), work( n1*n2*2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
              else
                 ! compute 1-norm-based estimates of difu and difl using
                 ! reversed communication with stdlib_${ci}$lacn2. in each step a
                 ! generalized sylvester equation or a transposed variant
                 ! is solved.
                 kase = 0
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = 0
                 mn2 = 2*n1*n2
                 ! 1-norm-based estimate of difu.
                 40 continue
                 call stdlib_${ci}$lacn2( mn2, work( mn2+1 ), work, dif( 1 ), kase,isave )
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation
                       call stdlib_${ci}$tgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_${ci}$tgsyl( 'C', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 40
                 end if
                 dif( 1 ) = dscale / dif( 1 )
                 ! 1-norm-based estimate of difl.
                 50 continue
                 call stdlib_${ci}$lacn2( mn2, work( mn2+1 ), work, dif( 2 ), kase,isave )
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation
                       call stdlib_${ci}$tgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b( &
                       i, i ), ldb, b, ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_${ci}$tgsyl( 'C', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 50
                 end if
                 dif( 2 ) = dscale / dif( 2 )
              end if
           end if
           ! if b(k,k) is complex, make it real and positive (normalization
           ! of the generalized schur form) and store the generalized
           ! eigenvalues of reordered pair (a, b)
           do k = 1, n
              dscale = abs( b( k, k ) )
              if( dscale>safmin ) then
                 temp1 = conjg( b( k, k ) / dscale )
                 temp2 = b( k, k ) / dscale
                 b( k, k ) = dscale
                 call stdlib_${ci}$scal( n-k, temp1, b( k, k+1 ), ldb )
                 call stdlib_${ci}$scal( n-k+1, temp1, a( k, k ), lda )
                 if( wantq )call stdlib_${ci}$scal( n, temp2, q( 1, k ), 1 )
              else
                 b( k, k ) = cmplx( zero, zero,KIND=${ck}$)
              end if
              alpha( k ) = a( k, k )
              beta( k ) = b( k, k )
           end do
           70 continue
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ci}$tgsen

#:endif
#:endfor



     module subroutine stdlib_strsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm, m, &
     !! STRSNA estimates reciprocal condition numbers for specified
     !! eigenvalues and/or right eigenvectors of a real upper
     !! quasi-triangular matrix T (or of any matrix Q*T*Q**T with Q
     !! orthogonal).
     !! T must be in Schur canonical form (as returned by SHSEQR), that is,
     !! block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
     !! 2-by-2 diagonal block has its diagonal elements equal and its
     !! off-diagonal elements of opposite sign.
               work, ldwork, iwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, ldwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(out) :: s(*), sep(*), work(ldwork,*)
           real(sp), intent(in) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: pair, somcon, wantbh, wants, wantsp
           integer(ilp) :: i, ierr, ifst, ilst, j, k, kase, ks, n2, nn
           real(sp) :: bignum, cond, cs, delta, dumm, eps, est, lnrm, mu, prod, prod1, prod2, &
                     rnrm, scale, smlnum, sn
           ! Local Arrays 
           integer(ilp) :: isave(3)
           real(sp) :: dummy(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantsp = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           info = 0
           if( .not.wants .and. .not.wantsp ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( wants .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( wants .and. ldvr<n ) ) then
              info = -10
           else
              ! set m to the number of eigenpairs for which condition numbers
              ! are required, and test mm.
              if( somcon ) then
                 m = 0
                 pair = .false.
                 do k = 1, n
                    if( pair ) then
                       pair = .false.
                    else
                       if( k<n ) then
                          if( t( k+1, k )==zero ) then
                             if( select( k ) )m = m + 1
                          else
                             pair = .true.
                             if( select( k ) .or. select( k+1 ) )m = m + 2
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( mm<m ) then
                 info = -13
              else if( ldwork<1 .or. ( wantsp .and. ldwork<n ) ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STRSNA', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( somcon ) then
                 if( .not.select( 1 ) )return
              end if
              if( wants )s( 1 ) = one
              if( wantsp )sep( 1 ) = abs( t( 1, 1 ) )
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' ) / eps
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           ks = 0
           pair = .false.
           loop_60: do k = 1, n
              ! determine whether t(k,k) begins a 1-by-1 or 2-by-2 block.
              if( pair ) then
                 pair = .false.
                 cycle loop_60
              else
                 if( k<n )pair = t( k+1, k )/=zero
              end if
              ! determine whether condition numbers are required for the k-th
              ! eigenpair.
              if( somcon ) then
                 if( pair ) then
                    if( .not.select( k ) .and. .not.select( k+1 ) )cycle loop_60
                 else
                    if( .not.select( k ) )cycle loop_60
                 end if
              end if
              ks = ks + 1
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 if( .not.pair ) then
                    ! real eigenvalue.
                    prod = stdlib_sdot( n, vr( 1, ks ), 1, vl( 1, ks ), 1 )
                    rnrm = stdlib_snrm2( n, vr( 1, ks ), 1 )
                    lnrm = stdlib_snrm2( n, vl( 1, ks ), 1 )
                    s( ks ) = abs( prod ) / ( rnrm*lnrm )
                 else
                    ! complex eigenvalue.
                    prod1 = stdlib_sdot( n, vr( 1, ks ), 1, vl( 1, ks ), 1 )
                    prod1 = prod1 + stdlib_sdot( n, vr( 1, ks+1 ), 1, vl( 1, ks+1 ),1 )
                    prod2 = stdlib_sdot( n, vl( 1, ks ), 1, vr( 1, ks+1 ), 1 )
                    prod2 = prod2 - stdlib_sdot( n, vl( 1, ks+1 ), 1, vr( 1, ks ),1 )
                    rnrm = stdlib_slapy2( stdlib_snrm2( n, vr( 1, ks ), 1 ),stdlib_snrm2( n, vr( &
                              1, ks+1 ), 1 ) )
                    lnrm = stdlib_slapy2( stdlib_snrm2( n, vl( 1, ks ), 1 ),stdlib_snrm2( n, vl( &
                              1, ks+1 ), 1 ) )
                    cond = stdlib_slapy2( prod1, prod2 ) / ( rnrm*lnrm )
                    s( ks ) = cond
                    s( ks+1 ) = cond
                 end if
              end if
              if( wantsp ) then
                 ! estimate the reciprocal condition number of the k-th
                 ! eigenvector.
                 ! copy the matrix t to the array work and swap the diagonal
                 ! block beginning at t(k,k) to the (1,1) position.
                 call stdlib_slacpy( 'FULL', n, n, t, ldt, work, ldwork )
                 ifst = k
                 ilst = 1
                 call stdlib_strexc( 'NO Q', n, work, ldwork, dummy, 1, ifst, ilst,work( 1, n+1 ),&
                            ierr )
                 if( ierr==1 .or. ierr==2 ) then
                    ! could not swap because blocks not well separated
                    scale = one
                    est = bignum
                 else
                    ! reordering successful
                    if( work( 2, 1 )==zero ) then
                       ! form c = t22 - lambda*i in work(2:n,2:n).
                       do i = 2, n
                          work( i, i ) = work( i, i ) - work( 1, 1 )
                       end do
                       n2 = 1
                       nn = n - 1
                    else
                       ! triangularize the 2 by 2 block by unitary
                       ! transformation u = [  cs   i*ss ]
                                          ! [ i*ss   cs  ].
                       ! such that the (1,1) position of work is complex
                       ! eigenvalue lambda with positive imaginary part. (2,2)
                       ! position of work is the complex eigenvalue lambda
                       ! with negative imaginary  part.
                       mu = sqrt( abs( work( 1, 2 ) ) )*sqrt( abs( work( 2, 1 ) ) )
                       delta = stdlib_slapy2( mu, work( 2, 1 ) )
                       cs = mu / delta
                       sn = -work( 2, 1 ) / delta
                       ! form
                       ! c**t = work(2:n,2:n) + i*[rwork(1) ..... rwork(n-1) ]
                                                ! [   mu                     ]
                                                ! [         ..               ]
                                                ! [             ..           ]
                                                ! [                  mu      ]
                       ! where c**t is transpose of matrix c,
                       ! and rwork is stored starting in the n+1-st column of
                       ! work.
                       do j = 3, n
                          work( 2, j ) = cs*work( 2, j )
                          work( j, j ) = work( j, j ) - work( 1, 1 )
                       end do
                       work( 2, 2 ) = zero
                       work( 1, n+1 ) = two*mu
                       do i = 2, n - 1
                          work( i, n+1 ) = sn*work( 1, i+1 )
                       end do
                       n2 = 2
                       nn = 2*( n-1 )
                    end if
                    ! estimate norm(inv(c**t))
                    est = zero
                    kase = 0
                    50 continue
                    call stdlib_slacn2( nn, work( 1, n+2 ), work( 1, n+4 ), iwork,est, kase, &
                              isave )
                    if( kase/=0 ) then
                       if( kase==1 ) then
                          if( n2==1 ) then
                             ! real eigenvalue: solve c**t*x = scale*c.
                             call stdlib_slaqtr( .true., .true., n-1, work( 2, 2 ),ldwork, dummy, &
                                       dumm, scale,work( 1, n+4 ), work( 1, n+6 ),ierr )
                          else
                             ! complex eigenvalue: solve
                             ! c**t*(p+iq) = scale*(c+id) in real arithmetic.
                             call stdlib_slaqtr( .true., .false., n-1, work( 2, 2 ),ldwork, work( &
                                       1, n+1 ), mu, scale,work( 1, n+4 ), work( 1, n+6 ),ierr )
                          end if
                       else
                          if( n2==1 ) then
                             ! real eigenvalue: solve c*x = scale*c.
                             call stdlib_slaqtr( .false., .true., n-1, work( 2, 2 ),ldwork, dummy,&
                                        dumm, scale,work( 1, n+4 ), work( 1, n+6 ),ierr )
                          else
                             ! complex eigenvalue: solve
                             ! c*(p+iq) = scale*(c+id) in real arithmetic.
                             call stdlib_slaqtr( .false., .false., n-1,work( 2, 2 ), ldwork,work( &
                                       1, n+1 ), mu, scale,work( 1, n+4 ), work( 1, n+6 ),ierr )
                          end if
                       end if
                       go to 50
                    end if
                 end if
                 sep( ks ) = scale / max( est, smlnum )
                 if( pair )sep( ks+1 ) = sep( ks )
              end if
              if( pair )ks = ks + 1
           end do loop_60
           return
     end subroutine stdlib_strsna

     module subroutine stdlib_dtrsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm, m, &
     !! DTRSNA estimates reciprocal condition numbers for specified
     !! eigenvalues and/or right eigenvectors of a real upper
     !! quasi-triangular matrix T (or of any matrix Q*T*Q**T with Q
     !! orthogonal).
     !! T must be in Schur canonical form (as returned by DHSEQR), that is,
     !! block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
     !! 2-by-2 diagonal block has its diagonal elements equal and its
     !! off-diagonal elements of opposite sign.
               work, ldwork, iwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, ldwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(out) :: s(*), sep(*), work(ldwork,*)
           real(dp), intent(in) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: pair, somcon, wantbh, wants, wantsp
           integer(ilp) :: i, ierr, ifst, ilst, j, k, kase, ks, n2, nn
           real(dp) :: bignum, cond, cs, delta, dumm, eps, est, lnrm, mu, prod, prod1, prod2, &
                     rnrm, scale, smlnum, sn
           ! Local Arrays 
           integer(ilp) :: isave(3)
           real(dp) :: dummy(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantsp = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           info = 0
           if( .not.wants .and. .not.wantsp ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( wants .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( wants .and. ldvr<n ) ) then
              info = -10
           else
              ! set m to the number of eigenpairs for which condition numbers
              ! are required, and test mm.
              if( somcon ) then
                 m = 0
                 pair = .false.
                 do k = 1, n
                    if( pair ) then
                       pair = .false.
                    else
                       if( k<n ) then
                          if( t( k+1, k )==zero ) then
                             if( select( k ) )m = m + 1
                          else
                             pair = .true.
                             if( select( k ) .or. select( k+1 ) )m = m + 2
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( mm<m ) then
                 info = -13
              else if( ldwork<1 .or. ( wantsp .and. ldwork<n ) ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTRSNA', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( somcon ) then
                 if( .not.select( 1 ) )return
              end if
              if( wants )s( 1 ) = one
              if( wantsp )sep( 1 ) = abs( t( 1, 1 ) )
              return
           end if
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' ) / eps
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           ks = 0
           pair = .false.
           loop_60: do k = 1, n
              ! determine whether t(k,k) begins a 1-by-1 or 2-by-2 block.
              if( pair ) then
                 pair = .false.
                 cycle loop_60
              else
                 if( k<n )pair = t( k+1, k )/=zero
              end if
              ! determine whether condition numbers are required for the k-th
              ! eigenpair.
              if( somcon ) then
                 if( pair ) then
                    if( .not.select( k ) .and. .not.select( k+1 ) )cycle loop_60
                 else
                    if( .not.select( k ) )cycle loop_60
                 end if
              end if
              ks = ks + 1
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 if( .not.pair ) then
                    ! real eigenvalue.
                    prod = stdlib_ddot( n, vr( 1, ks ), 1, vl( 1, ks ), 1 )
                    rnrm = stdlib_dnrm2( n, vr( 1, ks ), 1 )
                    lnrm = stdlib_dnrm2( n, vl( 1, ks ), 1 )
                    s( ks ) = abs( prod ) / ( rnrm*lnrm )
                 else
                    ! complex eigenvalue.
                    prod1 = stdlib_ddot( n, vr( 1, ks ), 1, vl( 1, ks ), 1 )
                    prod1 = prod1 + stdlib_ddot( n, vr( 1, ks+1 ), 1, vl( 1, ks+1 ),1 )
                    prod2 = stdlib_ddot( n, vl( 1, ks ), 1, vr( 1, ks+1 ), 1 )
                    prod2 = prod2 - stdlib_ddot( n, vl( 1, ks+1 ), 1, vr( 1, ks ),1 )
                    rnrm = stdlib_dlapy2( stdlib_dnrm2( n, vr( 1, ks ), 1 ),stdlib_dnrm2( n, vr( &
                              1, ks+1 ), 1 ) )
                    lnrm = stdlib_dlapy2( stdlib_dnrm2( n, vl( 1, ks ), 1 ),stdlib_dnrm2( n, vl( &
                              1, ks+1 ), 1 ) )
                    cond = stdlib_dlapy2( prod1, prod2 ) / ( rnrm*lnrm )
                    s( ks ) = cond
                    s( ks+1 ) = cond
                 end if
              end if
              if( wantsp ) then
                 ! estimate the reciprocal condition number of the k-th
                 ! eigenvector.
                 ! copy the matrix t to the array work and swap the diagonal
                 ! block beginning at t(k,k) to the (1,1) position.
                 call stdlib_dlacpy( 'FULL', n, n, t, ldt, work, ldwork )
                 ifst = k
                 ilst = 1
                 call stdlib_dtrexc( 'NO Q', n, work, ldwork, dummy, 1, ifst, ilst,work( 1, n+1 ),&
                            ierr )
                 if( ierr==1 .or. ierr==2 ) then
                    ! could not swap because blocks not well separated
                    scale = one
                    est = bignum
                 else
                    ! reordering successful
                    if( work( 2, 1 )==zero ) then
                       ! form c = t22 - lambda*i in work(2:n,2:n).
                       do i = 2, n
                          work( i, i ) = work( i, i ) - work( 1, 1 )
                       end do
                       n2 = 1
                       nn = n - 1
                    else
                       ! triangularize the 2 by 2 block by unitary
                       ! transformation u = [  cs   i*ss ]
                                          ! [ i*ss   cs  ].
                       ! such that the (1,1) position of work is complex
                       ! eigenvalue lambda with positive imaginary part. (2,2)
                       ! position of work is the complex eigenvalue lambda
                       ! with negative imaginary  part.
                       mu = sqrt( abs( work( 1, 2 ) ) )*sqrt( abs( work( 2, 1 ) ) )
                       delta = stdlib_dlapy2( mu, work( 2, 1 ) )
                       cs = mu / delta
                       sn = -work( 2, 1 ) / delta
                       ! form
                       ! c**t = work(2:n,2:n) + i*[rwork(1) ..... rwork(n-1) ]
                                                ! [   mu                     ]
                                                ! [         ..               ]
                                                ! [             ..           ]
                                                ! [                  mu      ]
                       ! where c**t is transpose of matrix c,
                       ! and rwork is stored starting in the n+1-st column of
                       ! work.
                       do j = 3, n
                          work( 2, j ) = cs*work( 2, j )
                          work( j, j ) = work( j, j ) - work( 1, 1 )
                       end do
                       work( 2, 2 ) = zero
                       work( 1, n+1 ) = two*mu
                       do i = 2, n - 1
                          work( i, n+1 ) = sn*work( 1, i+1 )
                       end do
                       n2 = 2
                       nn = 2*( n-1 )
                    end if
                    ! estimate norm(inv(c**t))
                    est = zero
                    kase = 0
                    50 continue
                    call stdlib_dlacn2( nn, work( 1, n+2 ), work( 1, n+4 ), iwork,est, kase, &
                              isave )
                    if( kase/=0 ) then
                       if( kase==1 ) then
                          if( n2==1 ) then
                             ! real eigenvalue: solve c**t*x = scale*c.
                             call stdlib_dlaqtr( .true., .true., n-1, work( 2, 2 ),ldwork, dummy, &
                                       dumm, scale,work( 1, n+4 ), work( 1, n+6 ),ierr )
                          else
                             ! complex eigenvalue: solve
                             ! c**t*(p+iq) = scale*(c+id) in real arithmetic.
                             call stdlib_dlaqtr( .true., .false., n-1, work( 2, 2 ),ldwork, work( &
                                       1, n+1 ), mu, scale,work( 1, n+4 ), work( 1, n+6 ),ierr )
                          end if
                       else
                          if( n2==1 ) then
                             ! real eigenvalue: solve c*x = scale*c.
                             call stdlib_dlaqtr( .false., .true., n-1, work( 2, 2 ),ldwork, dummy,&
                                        dumm, scale,work( 1, n+4 ), work( 1, n+6 ),ierr )
                          else
                             ! complex eigenvalue: solve
                             ! c*(p+iq) = scale*(c+id) in real arithmetic.
                             call stdlib_dlaqtr( .false., .false., n-1,work( 2, 2 ), ldwork,work( &
                                       1, n+1 ), mu, scale,work( 1, n+4 ), work( 1, n+6 ),ierr )
                          end if
                       end if
                       go to 50
                    end if
                 end if
                 sep( ks ) = scale / max( est, smlnum )
                 if( pair )sep( ks+1 ) = sep( ks )
              end if
              if( pair )ks = ks + 1
           end do loop_60
           return
     end subroutine stdlib_dtrsna

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$trsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm, m, &
     !! DTRSNA: estimates reciprocal condition numbers for specified
     !! eigenvalues and/or right eigenvectors of a real upper
     !! quasi-triangular matrix T (or of any matrix Q*T*Q**T with Q
     !! orthogonal).
     !! T must be in Schur canonical form (as returned by DHSEQR), that is,
     !! block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
     !! 2-by-2 diagonal block has its diagonal elements equal and its
     !! off-diagonal elements of opposite sign.
               work, ldwork, iwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, ldwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(out) :: s(*), sep(*), work(ldwork,*)
           real(${rk}$), intent(in) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: pair, somcon, wantbh, wants, wantsp
           integer(ilp) :: i, ierr, ifst, ilst, j, k, kase, ks, n2, nn
           real(${rk}$) :: bignum, cond, cs, delta, dumm, eps, est, lnrm, mu, prod, prod1, prod2, &
                     rnrm, scale, smlnum, sn
           ! Local Arrays 
           integer(ilp) :: isave(3)
           real(${rk}$) :: dummy(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantsp = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           info = 0
           if( .not.wants .and. .not.wantsp ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( wants .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( wants .and. ldvr<n ) ) then
              info = -10
           else
              ! set m to the number of eigenpairs for which condition numbers
              ! are required, and test mm.
              if( somcon ) then
                 m = 0
                 pair = .false.
                 do k = 1, n
                    if( pair ) then
                       pair = .false.
                    else
                       if( k<n ) then
                          if( t( k+1, k )==zero ) then
                             if( select( k ) )m = m + 1
                          else
                             pair = .true.
                             if( select( k ) .or. select( k+1 ) )m = m + 2
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( mm<m ) then
                 info = -13
              else if( ldwork<1 .or. ( wantsp .and. ldwork<n ) ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTRSNA', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( somcon ) then
                 if( .not.select( 1 ) )return
              end if
              if( wants )s( 1 ) = one
              if( wantsp )sep( 1 ) = abs( t( 1, 1 ) )
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' ) / eps
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           ks = 0
           pair = .false.
           loop_60: do k = 1, n
              ! determine whether t(k,k) begins a 1-by-1 or 2-by-2 block.
              if( pair ) then
                 pair = .false.
                 cycle loop_60
              else
                 if( k<n )pair = t( k+1, k )/=zero
              end if
              ! determine whether condition numbers are required for the k-th
              ! eigenpair.
              if( somcon ) then
                 if( pair ) then
                    if( .not.select( k ) .and. .not.select( k+1 ) )cycle loop_60
                 else
                    if( .not.select( k ) )cycle loop_60
                 end if
              end if
              ks = ks + 1
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 if( .not.pair ) then
                    ! real eigenvalue.
                    prod = stdlib_${ri}$dot( n, vr( 1, ks ), 1, vl( 1, ks ), 1 )
                    rnrm = stdlib_${ri}$nrm2( n, vr( 1, ks ), 1 )
                    lnrm = stdlib_${ri}$nrm2( n, vl( 1, ks ), 1 )
                    s( ks ) = abs( prod ) / ( rnrm*lnrm )
                 else
                    ! complex eigenvalue.
                    prod1 = stdlib_${ri}$dot( n, vr( 1, ks ), 1, vl( 1, ks ), 1 )
                    prod1 = prod1 + stdlib_${ri}$dot( n, vr( 1, ks+1 ), 1, vl( 1, ks+1 ),1 )
                    prod2 = stdlib_${ri}$dot( n, vl( 1, ks ), 1, vr( 1, ks+1 ), 1 )
                    prod2 = prod2 - stdlib_${ri}$dot( n, vl( 1, ks+1 ), 1, vr( 1, ks ),1 )
                    rnrm = stdlib_${ri}$lapy2( stdlib_${ri}$nrm2( n, vr( 1, ks ), 1 ),stdlib_${ri}$nrm2( n, vr( &
                              1, ks+1 ), 1 ) )
                    lnrm = stdlib_${ri}$lapy2( stdlib_${ri}$nrm2( n, vl( 1, ks ), 1 ),stdlib_${ri}$nrm2( n, vl( &
                              1, ks+1 ), 1 ) )
                    cond = stdlib_${ri}$lapy2( prod1, prod2 ) / ( rnrm*lnrm )
                    s( ks ) = cond
                    s( ks+1 ) = cond
                 end if
              end if
              if( wantsp ) then
                 ! estimate the reciprocal condition number of the k-th
                 ! eigenvector.
                 ! copy the matrix t to the array work and swap the diagonal
                 ! block beginning at t(k,k) to the (1,1) position.
                 call stdlib_${ri}$lacpy( 'FULL', n, n, t, ldt, work, ldwork )
                 ifst = k
                 ilst = 1
                 call stdlib_${ri}$trexc( 'NO Q', n, work, ldwork, dummy, 1, ifst, ilst,work( 1, n+1 ),&
                            ierr )
                 if( ierr==1 .or. ierr==2 ) then
                    ! could not swap because blocks not well separated
                    scale = one
                    est = bignum
                 else
                    ! reordering successful
                    if( work( 2, 1 )==zero ) then
                       ! form c = t22 - lambda*i in work(2:n,2:n).
                       do i = 2, n
                          work( i, i ) = work( i, i ) - work( 1, 1 )
                       end do
                       n2 = 1
                       nn = n - 1
                    else
                       ! triangularize the 2 by 2 block by unitary
                       ! transformation u = [  cs   i*ss ]
                                          ! [ i*ss   cs  ].
                       ! such that the (1,1) position of work is complex
                       ! eigenvalue lambda with positive imaginary part. (2,2)
                       ! position of work is the complex eigenvalue lambda
                       ! with negative imaginary  part.
                       mu = sqrt( abs( work( 1, 2 ) ) )*sqrt( abs( work( 2, 1 ) ) )
                       delta = stdlib_${ri}$lapy2( mu, work( 2, 1 ) )
                       cs = mu / delta
                       sn = -work( 2, 1 ) / delta
                       ! form
                       ! c**t = work(2:n,2:n) + i*[rwork(1) ..... rwork(n-1) ]
                                                ! [   mu                     ]
                                                ! [         ..               ]
                                                ! [             ..           ]
                                                ! [                  mu      ]
                       ! where c**t is transpose of matrix c,
                       ! and rwork is stored starting in the n+1-st column of
                       ! work.
                       do j = 3, n
                          work( 2, j ) = cs*work( 2, j )
                          work( j, j ) = work( j, j ) - work( 1, 1 )
                       end do
                       work( 2, 2 ) = zero
                       work( 1, n+1 ) = two*mu
                       do i = 2, n - 1
                          work( i, n+1 ) = sn*work( 1, i+1 )
                       end do
                       n2 = 2
                       nn = 2*( n-1 )
                    end if
                    ! estimate norm(inv(c**t))
                    est = zero
                    kase = 0
                    50 continue
                    call stdlib_${ri}$lacn2( nn, work( 1, n+2 ), work( 1, n+4 ), iwork,est, kase, &
                              isave )
                    if( kase/=0 ) then
                       if( kase==1 ) then
                          if( n2==1 ) then
                             ! real eigenvalue: solve c**t*x = scale*c.
                             call stdlib_${ri}$laqtr( .true., .true., n-1, work( 2, 2 ),ldwork, dummy, &
                                       dumm, scale,work( 1, n+4 ), work( 1, n+6 ),ierr )
                          else
                             ! complex eigenvalue: solve
                             ! c**t*(p+iq) = scale*(c+id) in real arithmetic.
                             call stdlib_${ri}$laqtr( .true., .false., n-1, work( 2, 2 ),ldwork, work( &
                                       1, n+1 ), mu, scale,work( 1, n+4 ), work( 1, n+6 ),ierr )
                          end if
                       else
                          if( n2==1 ) then
                             ! real eigenvalue: solve c*x = scale*c.
                             call stdlib_${ri}$laqtr( .false., .true., n-1, work( 2, 2 ),ldwork, dummy,&
                                        dumm, scale,work( 1, n+4 ), work( 1, n+6 ),ierr )
                          else
                             ! complex eigenvalue: solve
                             ! c*(p+iq) = scale*(c+id) in real arithmetic.
                             call stdlib_${ri}$laqtr( .false., .false., n-1,work( 2, 2 ), ldwork,work( &
                                       1, n+1 ), mu, scale,work( 1, n+4 ), work( 1, n+6 ),ierr )
                          end if
                       end if
                       go to 50
                    end if
                 end if
                 sep( ks ) = scale / max( est, smlnum )
                 if( pair )sep( ks+1 ) = sep( ks )
              end if
              if( pair )ks = ks + 1
           end do loop_60
           return
     end subroutine stdlib_${ri}$trsna

#:endif
#:endfor

     module pure subroutine stdlib_ctrsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm,&
     !! CTRSNA estimates reciprocal condition numbers for specified
     !! eigenvalues and/or right eigenvectors of a complex upper triangular
     !! matrix T (or of any matrix Q*T*Q**H with Q unitary).
                m, work, ldwork, rwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, ldwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(sp), intent(out) :: rwork(*), s(*), sep(*)
           complex(sp), intent(in) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(sp), intent(out) :: work(ldwork,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: somcon, wantbh, wants, wantsp
           character :: normin
           integer(ilp) :: i, ierr, ix, j, k, kase, ks
           real(sp) :: bignum, eps, est, lnrm, rnrm, scale, smlnum, xnorm
           complex(sp) :: cdum, prod
           ! Local Arrays 
           integer(ilp) :: isave(3)
           complex(sp) :: dummy(1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantsp = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           ! set m to the number of eigenpairs for which condition numbers are
           ! to be computed.
           if( somcon ) then
              m = 0
              do j = 1, n
                 if( select( j ) )m = m + 1
              end do
           else
              m = n
           end if
           info = 0
           if( .not.wants .and. .not.wantsp ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( wants .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( wants .and. ldvr<n ) ) then
              info = -10
           else if( mm<m ) then
              info = -13
           else if( ldwork<1 .or. ( wantsp .and. ldwork<n ) ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTRSNA', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( somcon ) then
                 if( .not.select( 1 ) )return
              end if
              if( wants )s( 1 ) = one
              if( wantsp )sep( 1 ) = abs( t( 1, 1 ) )
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' ) / eps
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           ks = 1
           loop_50: do k = 1, n
              if( somcon ) then
                 if( .not.select( k ) )cycle loop_50
              end if
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 prod = stdlib_cdotc( n, vr( 1, ks ), 1, vl( 1, ks ), 1 )
                 rnrm = stdlib_scnrm2( n, vr( 1, ks ), 1 )
                 lnrm = stdlib_scnrm2( n, vl( 1, ks ), 1 )
                 s( ks ) = abs( prod ) / ( rnrm*lnrm )
              end if
              if( wantsp ) then
                 ! estimate the reciprocal condition number of the k-th
                 ! eigenvector.
                 ! copy the matrix t to the array work and swap the k-th
                 ! diagonal element to the (1,1) position.
                 call stdlib_clacpy( 'FULL', n, n, t, ldt, work, ldwork )
                 call stdlib_ctrexc( 'NO Q', n, work, ldwork, dummy, 1, k, 1, ierr )
                 ! form  c = t22 - lambda*i in work(2:n,2:n).
                 do i = 2, n
                    work( i, i ) = work( i, i ) - work( 1, 1 )
                 end do
                 ! estimate a lower bound for the 1-norm of inv(c**h). the 1st
                 ! and (n+1)th columns of work are used to store work vectors.
                 sep( ks ) = zero
                 est = zero
                 kase = 0
                 normin = 'N'
                 30 continue
                 call stdlib_clacn2( n-1, work( 1, n+1 ), work, est, kase, isave )
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve c**h*x = scale*b
                       call stdlib_clatrs( 'UPPER', 'CONJUGATE TRANSPOSE','NONUNIT', normin, n-1, &
                                 work( 2, 2 ),ldwork, work, scale, rwork, ierr )
                    else
                       ! solve c*x = scale*b
                       call stdlib_clatrs( 'UPPER', 'NO TRANSPOSE', 'NONUNIT',normin, n-1, work( &
                                 2, 2 ), ldwork, work,scale, rwork, ierr )
                    end if
                    normin = 'Y'
                    if( scale/=one ) then
                       ! multiply by 1/scale if doing so will not cause
                       ! overflow.
                       ix = stdlib_icamax( n-1, work, 1 )
                       xnorm = cabs1( work( ix, 1 ) )
                       if( scale<xnorm*smlnum .or. scale==zero )go to 40
                       call stdlib_csrscl( n, scale, work, 1 )
                    end if
                    go to 30
                 end if
                 sep( ks ) = one / max( est, smlnum )
              end if
              40 continue
              ks = ks + 1
           end do loop_50
           return
     end subroutine stdlib_ctrsna

     module pure subroutine stdlib_ztrsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm,&
     !! ZTRSNA estimates reciprocal condition numbers for specified
     !! eigenvalues and/or right eigenvectors of a complex upper triangular
     !! matrix T (or of any matrix Q*T*Q**H with Q unitary).
                m, work, ldwork, rwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, ldwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(dp), intent(out) :: rwork(*), s(*), sep(*)
           complex(dp), intent(in) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(dp), intent(out) :: work(ldwork,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: somcon, wantbh, wants, wantsp
           character :: normin
           integer(ilp) :: i, ierr, ix, j, k, kase, ks
           real(dp) :: bignum, eps, est, lnrm, rnrm, scale, smlnum, xnorm
           complex(dp) :: cdum, prod
           ! Local Arrays 
           integer(ilp) :: isave(3)
           complex(dp) :: dummy(1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantsp = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           ! set m to the number of eigenpairs for which condition numbers are
           ! to be computed.
           if( somcon ) then
              m = 0
              do j = 1, n
                 if( select( j ) )m = m + 1
              end do
           else
              m = n
           end if
           info = 0
           if( .not.wants .and. .not.wantsp ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( wants .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( wants .and. ldvr<n ) ) then
              info = -10
           else if( mm<m ) then
              info = -13
           else if( ldwork<1 .or. ( wantsp .and. ldwork<n ) ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTRSNA', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( somcon ) then
                 if( .not.select( 1 ) )return
              end if
              if( wants )s( 1 ) = one
              if( wantsp )sep( 1 ) = abs( t( 1, 1 ) )
              return
           end if
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' ) / eps
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           ks = 1
           loop_50: do k = 1, n
              if( somcon ) then
                 if( .not.select( k ) )cycle loop_50
              end if
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 prod = stdlib_zdotc( n, vr( 1, ks ), 1, vl( 1, ks ), 1 )
                 rnrm = stdlib_dznrm2( n, vr( 1, ks ), 1 )
                 lnrm = stdlib_dznrm2( n, vl( 1, ks ), 1 )
                 s( ks ) = abs( prod ) / ( rnrm*lnrm )
              end if
              if( wantsp ) then
                 ! estimate the reciprocal condition number of the k-th
                 ! eigenvector.
                 ! copy the matrix t to the array work and swap the k-th
                 ! diagonal element to the (1,1) position.
                 call stdlib_zlacpy( 'FULL', n, n, t, ldt, work, ldwork )
                 call stdlib_ztrexc( 'NO Q', n, work, ldwork, dummy, 1, k, 1, ierr )
                 ! form  c = t22 - lambda*i in work(2:n,2:n).
                 do i = 2, n
                    work( i, i ) = work( i, i ) - work( 1, 1 )
                 end do
                 ! estimate a lower bound for the 1-norm of inv(c**h). the 1st
                 ! and (n+1)th columns of work are used to store work vectors.
                 sep( ks ) = zero
                 est = zero
                 kase = 0
                 normin = 'N'
                 30 continue
                 call stdlib_zlacn2( n-1, work( 1, n+1 ), work, est, kase, isave )
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve c**h*x = scale*b
                       call stdlib_zlatrs( 'UPPER', 'CONJUGATE TRANSPOSE','NONUNIT', normin, n-1, &
                                 work( 2, 2 ),ldwork, work, scale, rwork, ierr )
                    else
                       ! solve c*x = scale*b
                       call stdlib_zlatrs( 'UPPER', 'NO TRANSPOSE', 'NONUNIT',normin, n-1, work( &
                                 2, 2 ), ldwork, work,scale, rwork, ierr )
                    end if
                    normin = 'Y'
                    if( scale/=one ) then
                       ! multiply by 1/scale if doing so will not cause
                       ! overflow.
                       ix = stdlib_izamax( n-1, work, 1 )
                       xnorm = cabs1( work( ix, 1 ) )
                       if( scale<xnorm*smlnum .or. scale==zero )go to 40
                       call stdlib_zdrscl( n, scale, work, 1 )
                    end if
                    go to 30
                 end if
                 sep( ks ) = one / max( est, smlnum )
              end if
              40 continue
              ks = ks + 1
           end do loop_50
           return
     end subroutine stdlib_ztrsna

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$trsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm,&
     !! ZTRSNA: estimates reciprocal condition numbers for specified
     !! eigenvalues and/or right eigenvectors of a complex upper triangular
     !! matrix T (or of any matrix Q*T*Q**H with Q unitary).
                m, work, ldwork, rwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, ldwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(${ck}$), intent(out) :: rwork(*), s(*), sep(*)
           complex(${ck}$), intent(in) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(${ck}$), intent(out) :: work(ldwork,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: somcon, wantbh, wants, wantsp
           character :: normin
           integer(ilp) :: i, ierr, ix, j, k, kase, ks
           real(${ck}$) :: bignum, eps, est, lnrm, rnrm, scale, smlnum, xnorm
           complex(${ck}$) :: cdum, prod
           ! Local Arrays 
           integer(ilp) :: isave(3)
           complex(${ck}$) :: dummy(1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantsp = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           ! set m to the number of eigenpairs for which condition numbers are
           ! to be computed.
           if( somcon ) then
              m = 0
              do j = 1, n
                 if( select( j ) )m = m + 1
              end do
           else
              m = n
           end if
           info = 0
           if( .not.wants .and. .not.wantsp ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( wants .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( wants .and. ldvr<n ) ) then
              info = -10
           else if( mm<m ) then
              info = -13
           else if( ldwork<1 .or. ( wantsp .and. ldwork<n ) ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTRSNA', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( somcon ) then
                 if( .not.select( 1 ) )return
              end if
              if( wants )s( 1 ) = one
              if( wantsp )sep( 1 ) = abs( t( 1, 1 ) )
              return
           end if
           ! get machine constants
           eps = stdlib_${c2ri(ci)}$lamch( 'P' )
           smlnum = stdlib_${c2ri(ci)}$lamch( 'S' ) / eps
           bignum = one / smlnum
           call stdlib_${c2ri(ci)}$labad( smlnum, bignum )
           ks = 1
           loop_50: do k = 1, n
              if( somcon ) then
                 if( .not.select( k ) )cycle loop_50
              end if
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 prod = stdlib_${ci}$dotc( n, vr( 1, ks ), 1, vl( 1, ks ), 1 )
                 rnrm = stdlib_${c2ri(ci)}$znrm2( n, vr( 1, ks ), 1 )
                 lnrm = stdlib_${c2ri(ci)}$znrm2( n, vl( 1, ks ), 1 )
                 s( ks ) = abs( prod ) / ( rnrm*lnrm )
              end if
              if( wantsp ) then
                 ! estimate the reciprocal condition number of the k-th
                 ! eigenvector.
                 ! copy the matrix t to the array work and swap the k-th
                 ! diagonal element to the (1,1) position.
                 call stdlib_${ci}$lacpy( 'FULL', n, n, t, ldt, work, ldwork )
                 call stdlib_${ci}$trexc( 'NO Q', n, work, ldwork, dummy, 1, k, 1, ierr )
                 ! form  c = t22 - lambda*i in work(2:n,2:n).
                 do i = 2, n
                    work( i, i ) = work( i, i ) - work( 1, 1 )
                 end do
                 ! estimate a lower bound for the 1-norm of inv(c**h). the 1st
                 ! and (n+1)th columns of work are used to store work vectors.
                 sep( ks ) = zero
                 est = zero
                 kase = 0
                 normin = 'N'
                 30 continue
                 call stdlib_${ci}$lacn2( n-1, work( 1, n+1 ), work, est, kase, isave )
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve c**h*x = scale*b
                       call stdlib_${ci}$latrs( 'UPPER', 'CONJUGATE TRANSPOSE','NONUNIT', normin, n-1, &
                                 work( 2, 2 ),ldwork, work, scale, rwork, ierr )
                    else
                       ! solve c*x = scale*b
                       call stdlib_${ci}$latrs( 'UPPER', 'NO TRANSPOSE', 'NONUNIT',normin, n-1, work( &
                                 2, 2 ), ldwork, work,scale, rwork, ierr )
                    end if
                    normin = 'Y'
                    if( scale/=one ) then
                       ! multiply by 1/scale if doing so will not cause
                       ! overflow.
                       ix = stdlib_i${ci}$amax( n-1, work, 1 )
                       xnorm = cabs1( work( ix, 1 ) )
                       if( scale<xnorm*smlnum .or. scale==zero )go to 40
                       call stdlib_${ci}$drscl( n, scale, work, 1 )
                    end if
                    go to 30
                 end if
                 sep( ks ) = one / max( est, smlnum )
              end if
              40 continue
              ks = ks + 1
           end do loop_50
           return
     end subroutine stdlib_${ci}$trsna

#:endif
#:endfor



     module subroutine stdlib_slaqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, ns, nd,&
     !! SLAQR2 is identical to SLAQR3 except that it avoids
     !! recursion by calling SLAHQR instead of SLAQR4.
     !! Aggressive early deflation:
     !! This subroutine accepts as input an upper Hessenberg matrix
     !! H and performs an orthogonal similarity transformation
     !! designed to detect and deflate fully converged eigenvalues from
     !! a trailing principal submatrix.  On output H has been over-
     !! written by a new Hessenberg matrix that is a perturbation of
     !! an orthogonal similarity transformation of H.  It is to be
     !! hoped that the final version of H has many zero subdiagonal
     !! entries.
                sr, si, v, ldv, nh, t,ldt, nv, wv, ldwv, work, lwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(ilp), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(sp), intent(out) :: si(*), sr(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
        ! ================================================================
           
           ! Local Scalars 
           real(sp) :: aa, bb, beta, cc, cs, dd, evi, evk, foo, s, safmax, safmin, smlnum, sn, &
                     tau, ulp
           integer(ilp) :: i, ifst, ilst, info, infqr, j, jw, k, kcol, kend, kln, krow, kwtop, &
                     ltop, lwk1, lwk2, lwkopt
           logical(lk) :: bulge, sorted
           ! Intrinsic Functions 
           ! Executable Statements 
           ! ==== estimate optimal workspace. ====
           jw = min( nw, kbot-ktop+1 )
           if( jw<=2 ) then
              lwkopt = 1
           else
              ! ==== workspace query call to stdlib_sgehrd ====
              call stdlib_sgehrd( jw, 1, jw-1, t, ldt, work, work, -1, info )
              lwk1 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_sormhr ====
              call stdlib_sormhr( 'R', 'N', jw, jw, 1, jw-1, t, ldt, work, v, ldv,work, -1, info )
                        
              lwk2 = int( work( 1 ),KIND=ilp)
              ! ==== optimal workspace ====
              lwkopt = jw + max( lwk1, lwk2 )
           end if
           ! ==== quick return in case of workspace query. ====
           if( lwork==-1 ) then
              work( 1 ) = real( lwkopt,KIND=sp)
              return
           end if
           ! ==== nothing to do ...
           ! ... for an empty active block ... ====
           ns = 0
           nd = 0
           work( 1 ) = one
           if( ktop>kbot )return
           ! ... nor for an empty deflation window. ====
           if( nw<1 )return
           ! ==== machine constants ====
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = one / safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=sp) / ulp )
           ! ==== setup deflation window ====
           jw = min( nw, kbot-ktop+1 )
           kwtop = kbot - jw + 1
           if( kwtop==ktop ) then
              s = zero
           else
              s = h( kwtop, kwtop-1 )
           end if
           if( kbot==kwtop ) then
              ! ==== 1-by-1 deflation window: not much to do ====
              sr( kwtop ) = h( kwtop, kwtop )
              si( kwtop ) = zero
              ns = 1
              nd = 0
              if( abs( s )<=max( smlnum, ulp*abs( h( kwtop, kwtop ) ) ) )then
                 ns = 0
                 nd = 1
                 if( kwtop>ktop )h( kwtop, kwtop-1 ) = zero
              end if
              work( 1 ) = one
              return
           end if
           ! ==== convert to spike-triangular form.  (in case of a
           ! .    rare qr failure, this routine continues to do
           ! .    aggressive early deflation using that part of
           ! .    the deflation window that converged using infqr
           ! .    here and there to keep track.) ====
           call stdlib_slacpy( 'U', jw, jw, h( kwtop, kwtop ), ldh, t, ldt )
           call stdlib_scopy( jw-1, h( kwtop+1, kwtop ), ldh+1, t( 2, 1 ), ldt+1 )
           call stdlib_slaset( 'A', jw, jw, zero, one, v, ldv )
           call stdlib_slahqr( .true., .true., jw, 1, jw, t, ldt, sr( kwtop ),si( kwtop ), 1, jw, &
                     v, ldv, infqr )
           ! ==== stdlib_strexc needs a clean margin near the diagonal ====
           do j = 1, jw - 3
              t( j+2, j ) = zero
              t( j+3, j ) = zero
           end do
           if( jw>2 )t( jw, jw-2 ) = zero
           ! ==== deflation detection loop ====
           ns = jw
           ilst = infqr + 1
           20 continue
           if( ilst<=ns ) then
              if( ns==1 ) then
                 bulge = .false.
              else
                 bulge = t( ns, ns-1 )/=zero
              end if
              ! ==== small spike tip test for deflation ====
              if( .not.bulge ) then
                 ! ==== real eigenvalue ====
                 foo = abs( t( ns, ns ) )
                 if( foo==zero )foo = abs( s )
                 if( abs( s*v( 1, ns ) )<=max( smlnum, ulp*foo ) ) then
                    ! ==== deflatable ====
                    ns = ns - 1
                 else
                    ! ==== undeflatable.   move it up out of the way.
                    ! .    (stdlib_strexc can not fail in this case.) ====
                    ifst = ns
                    call stdlib_strexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    ilst = ilst + 1
                 end if
              else
                 ! ==== complex conjugate pair ====
                 foo = abs( t( ns, ns ) ) + sqrt( abs( t( ns, ns-1 ) ) )*sqrt( abs( t( ns-1, ns ) &
                           ) )
                 if( foo==zero )foo = abs( s )
                 if( max( abs( s*v( 1, ns ) ), abs( s*v( 1, ns-1 ) ) )<=max( smlnum, ulp*foo ) ) &
                           then
                    ! ==== deflatable ====
                    ns = ns - 2
                 else
                    ! ==== undeflatable. move them up out of the way.
                    ! .    fortunately, stdlib_strexc does the right thing with
                    ! .    ilst in case of a rare exchange failure. ====
                    ifst = ns
                    call stdlib_strexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    ilst = ilst + 2
                 end if
              end if
              ! ==== end deflation detection loop ====
              go to 20
           end if
              ! ==== return to hessenberg form ====
           if( ns==0 )s = zero
           if( ns<jw ) then
              ! ==== sorting diagonal blocks of t improves accuracy for
              ! .    graded matrices.  bubble sort deals well with
              ! .    exchange failures. ====
              sorted = .false.
              i = ns + 1
              30 continue
              if( sorted )go to 50
              sorted = .true.
              kend = i - 1
              i = infqr + 1
              if( i==ns ) then
                 k = i + 1
              else if( t( i+1, i )==zero ) then
                 k = i + 1
              else
                 k = i + 2
              end if
              40 continue
              if( k<=kend ) then
                 if( k==i+1 ) then
                    evi = abs( t( i, i ) )
                 else
                    evi = abs( t( i, i ) ) + sqrt( abs( t( i+1, i ) ) )*sqrt( abs( t( i, i+1 ) ) )
                              
                 end if
                 if( k==kend ) then
                    evk = abs( t( k, k ) )
                 else if( t( k+1, k )==zero ) then
                    evk = abs( t( k, k ) )
                 else
                    evk = abs( t( k, k ) ) + sqrt( abs( t( k+1, k ) ) )*sqrt( abs( t( k, k+1 ) ) )
                              
                 end if
                 if( evi>=evk ) then
                    i = k
                 else
                    sorted = .false.
                    ifst = i
                    ilst = k
                    call stdlib_strexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    if( info==0 ) then
                       i = ilst
                    else
                       i = k
                    end if
                 end if
                 if( i==kend ) then
                    k = i + 1
                 else if( t( i+1, i )==zero ) then
                    k = i + 1
                 else
                    k = i + 2
                 end if
                 go to 40
              end if
              go to 30
              50 continue
           end if
           ! ==== restore shift/eigenvalue array from t ====
           i = jw
           60 continue
           if( i>=infqr+1 ) then
              if( i==infqr+1 ) then
                 sr( kwtop+i-1 ) = t( i, i )
                 si( kwtop+i-1 ) = zero
                 i = i - 1
              else if( t( i, i-1 )==zero ) then
                 sr( kwtop+i-1 ) = t( i, i )
                 si( kwtop+i-1 ) = zero
                 i = i - 1
              else
                 aa = t( i-1, i-1 )
                 cc = t( i, i-1 )
                 bb = t( i-1, i )
                 dd = t( i, i )
                 call stdlib_slanv2( aa, bb, cc, dd, sr( kwtop+i-2 ),si( kwtop+i-2 ), sr( kwtop+i-&
                           1 ),si( kwtop+i-1 ), cs, sn )
                 i = i - 2
              end if
              go to 60
           end if
           if( ns<jw .or. s==zero ) then
              if( ns>1 .and. s/=zero ) then
                 ! ==== reflect spike back into lower triangle ====
                 call stdlib_scopy( ns, v, ldv, work, 1 )
                 beta = work( 1 )
                 call stdlib_slarfg( ns, beta, work( 2 ), 1, tau )
                 work( 1 ) = one
                 call stdlib_slaset( 'L', jw-2, jw-2, zero, zero, t( 3, 1 ), ldt )
                 call stdlib_slarf( 'L', ns, jw, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_slarf( 'R', ns, ns, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_slarf( 'R', jw, ns, work, 1, tau, v, ldv,work( jw+1 ) )
                 call stdlib_sgehrd( jw, 1, ns, t, ldt, work, work( jw+1 ),lwork-jw, info )
                           
              end if
              ! ==== copy updated reduced window into place ====
              if( kwtop>1 )h( kwtop, kwtop-1 ) = s*v( 1, 1 )
              call stdlib_slacpy( 'U', jw, jw, t, ldt, h( kwtop, kwtop ), ldh )
              call stdlib_scopy( jw-1, t( 2, 1 ), ldt+1, h( kwtop+1, kwtop ),ldh+1 )
              ! ==== accumulate orthogonal matrix in order update
              ! .    h and z, if requested.  ====
              if( ns>1 .and. s/=zero )call stdlib_sormhr( 'R', 'N', jw, ns, 1, ns, t, ldt, work, &
                        v, ldv,work( jw+1 ), lwork-jw, info )
              ! ==== update vertical slab in h ====
              if( wantt ) then
                 ltop = 1
              else
                 ltop = ktop
              end if
              do krow = ltop, kwtop - 1, nv
                 kln = min( nv, kwtop-krow )
                 call stdlib_sgemm( 'N', 'N', kln, jw, jw, one, h( krow, kwtop ),ldh, v, ldv, &
                           zero, wv, ldwv )
                 call stdlib_slacpy( 'A', kln, jw, wv, ldwv, h( krow, kwtop ), ldh )
              end do
              ! ==== update horizontal slab in h ====
              if( wantt ) then
                 do kcol = kbot + 1, n, nh
                    kln = min( nh, n-kcol+1 )
                    call stdlib_sgemm( 'C', 'N', jw, kln, jw, one, v, ldv,h( kwtop, kcol ), ldh, &
                              zero, t, ldt )
                    call stdlib_slacpy( 'A', jw, kln, t, ldt, h( kwtop, kcol ),ldh )
                 end do
              end if
              ! ==== update vertical slab in z ====
              if( wantz ) then
                 do krow = iloz, ihiz, nv
                    kln = min( nv, ihiz-krow+1 )
                    call stdlib_sgemm( 'N', 'N', kln, jw, jw, one, z( krow, kwtop ),ldz, v, ldv, &
                              zero, wv, ldwv )
                    call stdlib_slacpy( 'A', kln, jw, wv, ldwv, z( krow, kwtop ),ldz )
                 end do
              end if
           end if
           ! ==== return the number of deflations ... ====
           nd = jw - ns
           ! ==== ... and the number of shifts. (subtracting
           ! .    infqr from the spike length takes care
           ! .    of the case of a rare qr failure while
           ! .    calculating eigenvalues of the deflation
           ! .    window.)  ====
           ns = ns - infqr
            ! ==== return optimal workspace. ====
           work( 1 ) = real( lwkopt,KIND=sp)
     end subroutine stdlib_slaqr2

     module subroutine stdlib_dlaqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, ns, nd,&
     !! DLAQR2 is identical to DLAQR3 except that it avoids
     !! recursion by calling DLAHQR instead of DLAQR4.
     !! Aggressive early deflation:
     !! This subroutine accepts as input an upper Hessenberg matrix
     !! H and performs an orthogonal similarity transformation
     !! designed to detect and deflate fully converged eigenvalues from
     !! a trailing principal submatrix.  On output H has been over-
     !! written by a new Hessenberg matrix that is a perturbation of
     !! an orthogonal similarity transformation of H.  It is to be
     !! hoped that the final version of H has many zero subdiagonal
     !! entries.
                sr, si, v, ldv, nh, t,ldt, nv, wv, ldwv, work, lwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(ilp), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(dp), intent(out) :: si(*), sr(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
        ! ================================================================
           
           ! Local Scalars 
           real(dp) :: aa, bb, beta, cc, cs, dd, evi, evk, foo, s, safmax, safmin, smlnum, sn, &
                     tau, ulp
           integer(ilp) :: i, ifst, ilst, info, infqr, j, jw, k, kcol, kend, kln, krow, kwtop, &
                     ltop, lwk1, lwk2, lwkopt
           logical(lk) :: bulge, sorted
           ! Intrinsic Functions 
           ! Executable Statements 
           ! ==== estimate optimal workspace. ====
           jw = min( nw, kbot-ktop+1 )
           if( jw<=2 ) then
              lwkopt = 1
           else
              ! ==== workspace query call to stdlib_dgehrd ====
              call stdlib_dgehrd( jw, 1, jw-1, t, ldt, work, work, -1, info )
              lwk1 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_dormhr ====
              call stdlib_dormhr( 'R', 'N', jw, jw, 1, jw-1, t, ldt, work, v, ldv,work, -1, info )
                        
              lwk2 = int( work( 1 ),KIND=ilp)
              ! ==== optimal workspace ====
              lwkopt = jw + max( lwk1, lwk2 )
           end if
           ! ==== quick return in case of workspace query. ====
           if( lwork==-1 ) then
              work( 1 ) = real( lwkopt,KIND=dp)
              return
           end if
           ! ==== nothing to do ...
           ! ... for an empty active block ... ====
           ns = 0
           nd = 0
           work( 1 ) = one
           if( ktop>kbot )return
           ! ... nor for an empty deflation window. ====
           if( nw<1 )return
           ! ==== machine constants ====
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safmax = one / safmin
           call stdlib_dlabad( safmin, safmax )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=dp) / ulp )
           ! ==== setup deflation window ====
           jw = min( nw, kbot-ktop+1 )
           kwtop = kbot - jw + 1
           if( kwtop==ktop ) then
              s = zero
           else
              s = h( kwtop, kwtop-1 )
           end if
           if( kbot==kwtop ) then
              ! ==== 1-by-1 deflation window: not much to do ====
              sr( kwtop ) = h( kwtop, kwtop )
              si( kwtop ) = zero
              ns = 1
              nd = 0
              if( abs( s )<=max( smlnum, ulp*abs( h( kwtop, kwtop ) ) ) )then
                 ns = 0
                 nd = 1
                 if( kwtop>ktop )h( kwtop, kwtop-1 ) = zero
              end if
              work( 1 ) = one
              return
           end if
           ! ==== convert to spike-triangular form.  (in case of a
           ! .    rare qr failure, this routine continues to do
           ! .    aggressive early deflation using that part of
           ! .    the deflation window that converged using infqr
           ! .    here and there to keep track.) ====
           call stdlib_dlacpy( 'U', jw, jw, h( kwtop, kwtop ), ldh, t, ldt )
           call stdlib_dcopy( jw-1, h( kwtop+1, kwtop ), ldh+1, t( 2, 1 ), ldt+1 )
           call stdlib_dlaset( 'A', jw, jw, zero, one, v, ldv )
           call stdlib_dlahqr( .true., .true., jw, 1, jw, t, ldt, sr( kwtop ),si( kwtop ), 1, jw, &
                     v, ldv, infqr )
           ! ==== stdlib_dtrexc needs a clean margin near the diagonal ====
           do j = 1, jw - 3
              t( j+2, j ) = zero
              t( j+3, j ) = zero
           end do
           if( jw>2 )t( jw, jw-2 ) = zero
           ! ==== deflation detection loop ====
           ns = jw
           ilst = infqr + 1
           20 continue
           if( ilst<=ns ) then
              if( ns==1 ) then
                 bulge = .false.
              else
                 bulge = t( ns, ns-1 )/=zero
              end if
              ! ==== small spike tip test for deflation ====
              if( .not.bulge ) then
                 ! ==== real eigenvalue ====
                 foo = abs( t( ns, ns ) )
                 if( foo==zero )foo = abs( s )
                 if( abs( s*v( 1, ns ) )<=max( smlnum, ulp*foo ) ) then
                    ! ==== deflatable ====
                    ns = ns - 1
                 else
                    ! ==== undeflatable.   move it up out of the way.
                    ! .    (stdlib_dtrexc can not fail in this case.) ====
                    ifst = ns
                    call stdlib_dtrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    ilst = ilst + 1
                 end if
              else
                 ! ==== complex conjugate pair ====
                 foo = abs( t( ns, ns ) ) + sqrt( abs( t( ns, ns-1 ) ) )*sqrt( abs( t( ns-1, ns ) &
                           ) )
                 if( foo==zero )foo = abs( s )
                 if( max( abs( s*v( 1, ns ) ), abs( s*v( 1, ns-1 ) ) )<=max( smlnum, ulp*foo ) ) &
                           then
                    ! ==== deflatable ====
                    ns = ns - 2
                 else
                    ! ==== undeflatable. move them up out of the way.
                    ! .    fortunately, stdlib_dtrexc does the right thing with
                    ! .    ilst in case of a rare exchange failure. ====
                    ifst = ns
                    call stdlib_dtrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    ilst = ilst + 2
                 end if
              end if
              ! ==== end deflation detection loop ====
              go to 20
           end if
              ! ==== return to hessenberg form ====
           if( ns==0 )s = zero
           if( ns<jw ) then
              ! ==== sorting diagonal blocks of t improves accuracy for
              ! .    graded matrices.  bubble sort deals well with
              ! .    exchange failures. ====
              sorted = .false.
              i = ns + 1
              30 continue
              if( sorted )go to 50
              sorted = .true.
              kend = i - 1
              i = infqr + 1
              if( i==ns ) then
                 k = i + 1
              else if( t( i+1, i )==zero ) then
                 k = i + 1
              else
                 k = i + 2
              end if
              40 continue
              if( k<=kend ) then
                 if( k==i+1 ) then
                    evi = abs( t( i, i ) )
                 else
                    evi = abs( t( i, i ) ) + sqrt( abs( t( i+1, i ) ) )*sqrt( abs( t( i, i+1 ) ) )
                              
                 end if
                 if( k==kend ) then
                    evk = abs( t( k, k ) )
                 else if( t( k+1, k )==zero ) then
                    evk = abs( t( k, k ) )
                 else
                    evk = abs( t( k, k ) ) + sqrt( abs( t( k+1, k ) ) )*sqrt( abs( t( k, k+1 ) ) )
                              
                 end if
                 if( evi>=evk ) then
                    i = k
                 else
                    sorted = .false.
                    ifst = i
                    ilst = k
                    call stdlib_dtrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    if( info==0 ) then
                       i = ilst
                    else
                       i = k
                    end if
                 end if
                 if( i==kend ) then
                    k = i + 1
                 else if( t( i+1, i )==zero ) then
                    k = i + 1
                 else
                    k = i + 2
                 end if
                 go to 40
              end if
              go to 30
              50 continue
           end if
           ! ==== restore shift/eigenvalue array from t ====
           i = jw
           60 continue
           if( i>=infqr+1 ) then
              if( i==infqr+1 ) then
                 sr( kwtop+i-1 ) = t( i, i )
                 si( kwtop+i-1 ) = zero
                 i = i - 1
              else if( t( i, i-1 )==zero ) then
                 sr( kwtop+i-1 ) = t( i, i )
                 si( kwtop+i-1 ) = zero
                 i = i - 1
              else
                 aa = t( i-1, i-1 )
                 cc = t( i, i-1 )
                 bb = t( i-1, i )
                 dd = t( i, i )
                 call stdlib_dlanv2( aa, bb, cc, dd, sr( kwtop+i-2 ),si( kwtop+i-2 ), sr( kwtop+i-&
                           1 ),si( kwtop+i-1 ), cs, sn )
                 i = i - 2
              end if
              go to 60
           end if
           if( ns<jw .or. s==zero ) then
              if( ns>1 .and. s/=zero ) then
                 ! ==== reflect spike back into lower triangle ====
                 call stdlib_dcopy( ns, v, ldv, work, 1 )
                 beta = work( 1 )
                 call stdlib_dlarfg( ns, beta, work( 2 ), 1, tau )
                 work( 1 ) = one
                 call stdlib_dlaset( 'L', jw-2, jw-2, zero, zero, t( 3, 1 ), ldt )
                 call stdlib_dlarf( 'L', ns, jw, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_dlarf( 'R', ns, ns, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_dlarf( 'R', jw, ns, work, 1, tau, v, ldv,work( jw+1 ) )
                 call stdlib_dgehrd( jw, 1, ns, t, ldt, work, work( jw+1 ),lwork-jw, info )
                           
              end if
              ! ==== copy updated reduced window into place ====
              if( kwtop>1 )h( kwtop, kwtop-1 ) = s*v( 1, 1 )
              call stdlib_dlacpy( 'U', jw, jw, t, ldt, h( kwtop, kwtop ), ldh )
              call stdlib_dcopy( jw-1, t( 2, 1 ), ldt+1, h( kwtop+1, kwtop ),ldh+1 )
              ! ==== accumulate orthogonal matrix in order update
              ! .    h and z, if requested.  ====
              if( ns>1 .and. s/=zero )call stdlib_dormhr( 'R', 'N', jw, ns, 1, ns, t, ldt, work, &
                        v, ldv,work( jw+1 ), lwork-jw, info )
              ! ==== update vertical slab in h ====
              if( wantt ) then
                 ltop = 1
              else
                 ltop = ktop
              end if
              do krow = ltop, kwtop - 1, nv
                 kln = min( nv, kwtop-krow )
                 call stdlib_dgemm( 'N', 'N', kln, jw, jw, one, h( krow, kwtop ),ldh, v, ldv, &
                           zero, wv, ldwv )
                 call stdlib_dlacpy( 'A', kln, jw, wv, ldwv, h( krow, kwtop ), ldh )
              end do
              ! ==== update horizontal slab in h ====
              if( wantt ) then
                 do kcol = kbot + 1, n, nh
                    kln = min( nh, n-kcol+1 )
                    call stdlib_dgemm( 'C', 'N', jw, kln, jw, one, v, ldv,h( kwtop, kcol ), ldh, &
                              zero, t, ldt )
                    call stdlib_dlacpy( 'A', jw, kln, t, ldt, h( kwtop, kcol ),ldh )
                 end do
              end if
              ! ==== update vertical slab in z ====
              if( wantz ) then
                 do krow = iloz, ihiz, nv
                    kln = min( nv, ihiz-krow+1 )
                    call stdlib_dgemm( 'N', 'N', kln, jw, jw, one, z( krow, kwtop ),ldz, v, ldv, &
                              zero, wv, ldwv )
                    call stdlib_dlacpy( 'A', kln, jw, wv, ldwv, z( krow, kwtop ),ldz )
                 end do
              end if
           end if
           ! ==== return the number of deflations ... ====
           nd = jw - ns
           ! ==== ... and the number of shifts. (subtracting
           ! .    infqr from the spike length takes care
           ! .    of the case of a rare qr failure while
           ! .    calculating eigenvalues of the deflation
           ! .    window.)  ====
           ns = ns - infqr
            ! ==== return optimal workspace. ====
           work( 1 ) = real( lwkopt,KIND=dp)
     end subroutine stdlib_dlaqr2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$laqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, ns, nd,&
     !! DLAQR2: is identical to DLAQR3 except that it avoids
     !! recursion by calling DLAHQR instead of DLAQR4.
     !! Aggressive early deflation:
     !! This subroutine accepts as input an upper Hessenberg matrix
     !! H and performs an orthogonal similarity transformation
     !! designed to detect and deflate fully converged eigenvalues from
     !! a trailing principal submatrix.  On output H has been over-
     !! written by a new Hessenberg matrix that is a perturbation of
     !! an orthogonal similarity transformation of H.  It is to be
     !! hoped that the final version of H has many zero subdiagonal
     !! entries.
                sr, si, v, ldv, nh, t,ldt, nv, wv, ldwv, work, lwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(ilp), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(${rk}$), intent(inout) :: h(ldh,*), z(ldz,*)
           real(${rk}$), intent(out) :: si(*), sr(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
        ! ================================================================
           
           ! Local Scalars 
           real(${rk}$) :: aa, bb, beta, cc, cs, dd, evi, evk, foo, s, safmax, safmin, smlnum, sn, &
                     tau, ulp
           integer(ilp) :: i, ifst, ilst, info, infqr, j, jw, k, kcol, kend, kln, krow, kwtop, &
                     ltop, lwk1, lwk2, lwkopt
           logical(lk) :: bulge, sorted
           ! Intrinsic Functions 
           ! Executable Statements 
           ! ==== estimate optimal workspace. ====
           jw = min( nw, kbot-ktop+1 )
           if( jw<=2 ) then
              lwkopt = 1
           else
              ! ==== workspace query call to stdlib_${ri}$gehrd ====
              call stdlib_${ri}$gehrd( jw, 1, jw-1, t, ldt, work, work, -1, info )
              lwk1 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_${ri}$ormhr ====
              call stdlib_${ri}$ormhr( 'R', 'N', jw, jw, 1, jw-1, t, ldt, work, v, ldv,work, -1, info )
                        
              lwk2 = int( work( 1 ),KIND=ilp)
              ! ==== optimal workspace ====
              lwkopt = jw + max( lwk1, lwk2 )
           end if
           ! ==== quick return in case of workspace query. ====
           if( lwork==-1 ) then
              work( 1 ) = real( lwkopt,KIND=${rk}$)
              return
           end if
           ! ==== nothing to do ...
           ! ... for an empty active block ... ====
           ns = 0
           nd = 0
           work( 1 ) = one
           if( ktop>kbot )return
           ! ... nor for an empty deflation window. ====
           if( nw<1 )return
           ! ==== machine constants ====
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safmax = one / safmin
           call stdlib_${ri}$labad( safmin, safmax )
           ulp = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=${rk}$) / ulp )
           ! ==== setup deflation window ====
           jw = min( nw, kbot-ktop+1 )
           kwtop = kbot - jw + 1
           if( kwtop==ktop ) then
              s = zero
           else
              s = h( kwtop, kwtop-1 )
           end if
           if( kbot==kwtop ) then
              ! ==== 1-by-1 deflation window: not much to do ====
              sr( kwtop ) = h( kwtop, kwtop )
              si( kwtop ) = zero
              ns = 1
              nd = 0
              if( abs( s )<=max( smlnum, ulp*abs( h( kwtop, kwtop ) ) ) )then
                 ns = 0
                 nd = 1
                 if( kwtop>ktop )h( kwtop, kwtop-1 ) = zero
              end if
              work( 1 ) = one
              return
           end if
           ! ==== convert to spike-triangular form.  (in case of a
           ! .    rare qr failure, this routine continues to do
           ! .    aggressive early deflation using that part of
           ! .    the deflation window that converged using infqr
           ! .    here and there to keep track.) ====
           call stdlib_${ri}$lacpy( 'U', jw, jw, h( kwtop, kwtop ), ldh, t, ldt )
           call stdlib_${ri}$copy( jw-1, h( kwtop+1, kwtop ), ldh+1, t( 2, 1 ), ldt+1 )
           call stdlib_${ri}$laset( 'A', jw, jw, zero, one, v, ldv )
           call stdlib_${ri}$lahqr( .true., .true., jw, 1, jw, t, ldt, sr( kwtop ),si( kwtop ), 1, jw, &
                     v, ldv, infqr )
           ! ==== stdlib_${ri}$trexc needs a clean margin near the diagonal ====
           do j = 1, jw - 3
              t( j+2, j ) = zero
              t( j+3, j ) = zero
           end do
           if( jw>2 )t( jw, jw-2 ) = zero
           ! ==== deflation detection loop ====
           ns = jw
           ilst = infqr + 1
           20 continue
           if( ilst<=ns ) then
              if( ns==1 ) then
                 bulge = .false.
              else
                 bulge = t( ns, ns-1 )/=zero
              end if
              ! ==== small spike tip test for deflation ====
              if( .not.bulge ) then
                 ! ==== real eigenvalue ====
                 foo = abs( t( ns, ns ) )
                 if( foo==zero )foo = abs( s )
                 if( abs( s*v( 1, ns ) )<=max( smlnum, ulp*foo ) ) then
                    ! ==== deflatable ====
                    ns = ns - 1
                 else
                    ! ==== undeflatable.   move it up out of the way.
                    ! .    (stdlib_${ri}$trexc can not fail in this case.) ====
                    ifst = ns
                    call stdlib_${ri}$trexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    ilst = ilst + 1
                 end if
              else
                 ! ==== complex conjugate pair ====
                 foo = abs( t( ns, ns ) ) + sqrt( abs( t( ns, ns-1 ) ) )*sqrt( abs( t( ns-1, ns ) &
                           ) )
                 if( foo==zero )foo = abs( s )
                 if( max( abs( s*v( 1, ns ) ), abs( s*v( 1, ns-1 ) ) )<=max( smlnum, ulp*foo ) ) &
                           then
                    ! ==== deflatable ====
                    ns = ns - 2
                 else
                    ! ==== undeflatable. move them up out of the way.
                    ! .    fortunately, stdlib_${ri}$trexc does the right thing with
                    ! .    ilst in case of a rare exchange failure. ====
                    ifst = ns
                    call stdlib_${ri}$trexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    ilst = ilst + 2
                 end if
              end if
              ! ==== end deflation detection loop ====
              go to 20
           end if
              ! ==== return to hessenberg form ====
           if( ns==0 )s = zero
           if( ns<jw ) then
              ! ==== sorting diagonal blocks of t improves accuracy for
              ! .    graded matrices.  bubble sort deals well with
              ! .    exchange failures. ====
              sorted = .false.
              i = ns + 1
              30 continue
              if( sorted )go to 50
              sorted = .true.
              kend = i - 1
              i = infqr + 1
              if( i==ns ) then
                 k = i + 1
              else if( t( i+1, i )==zero ) then
                 k = i + 1
              else
                 k = i + 2
              end if
              40 continue
              if( k<=kend ) then
                 if( k==i+1 ) then
                    evi = abs( t( i, i ) )
                 else
                    evi = abs( t( i, i ) ) + sqrt( abs( t( i+1, i ) ) )*sqrt( abs( t( i, i+1 ) ) )
                              
                 end if
                 if( k==kend ) then
                    evk = abs( t( k, k ) )
                 else if( t( k+1, k )==zero ) then
                    evk = abs( t( k, k ) )
                 else
                    evk = abs( t( k, k ) ) + sqrt( abs( t( k+1, k ) ) )*sqrt( abs( t( k, k+1 ) ) )
                              
                 end if
                 if( evi>=evk ) then
                    i = k
                 else
                    sorted = .false.
                    ifst = i
                    ilst = k
                    call stdlib_${ri}$trexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    if( info==0 ) then
                       i = ilst
                    else
                       i = k
                    end if
                 end if
                 if( i==kend ) then
                    k = i + 1
                 else if( t( i+1, i )==zero ) then
                    k = i + 1
                 else
                    k = i + 2
                 end if
                 go to 40
              end if
              go to 30
              50 continue
           end if
           ! ==== restore shift/eigenvalue array from t ====
           i = jw
           60 continue
           if( i>=infqr+1 ) then
              if( i==infqr+1 ) then
                 sr( kwtop+i-1 ) = t( i, i )
                 si( kwtop+i-1 ) = zero
                 i = i - 1
              else if( t( i, i-1 )==zero ) then
                 sr( kwtop+i-1 ) = t( i, i )
                 si( kwtop+i-1 ) = zero
                 i = i - 1
              else
                 aa = t( i-1, i-1 )
                 cc = t( i, i-1 )
                 bb = t( i-1, i )
                 dd = t( i, i )
                 call stdlib_${ri}$lanv2( aa, bb, cc, dd, sr( kwtop+i-2 ),si( kwtop+i-2 ), sr( kwtop+i-&
                           1 ),si( kwtop+i-1 ), cs, sn )
                 i = i - 2
              end if
              go to 60
           end if
           if( ns<jw .or. s==zero ) then
              if( ns>1 .and. s/=zero ) then
                 ! ==== reflect spike back into lower triangle ====
                 call stdlib_${ri}$copy( ns, v, ldv, work, 1 )
                 beta = work( 1 )
                 call stdlib_${ri}$larfg( ns, beta, work( 2 ), 1, tau )
                 work( 1 ) = one
                 call stdlib_${ri}$laset( 'L', jw-2, jw-2, zero, zero, t( 3, 1 ), ldt )
                 call stdlib_${ri}$larf( 'L', ns, jw, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_${ri}$larf( 'R', ns, ns, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_${ri}$larf( 'R', jw, ns, work, 1, tau, v, ldv,work( jw+1 ) )
                 call stdlib_${ri}$gehrd( jw, 1, ns, t, ldt, work, work( jw+1 ),lwork-jw, info )
                           
              end if
              ! ==== copy updated reduced window into place ====
              if( kwtop>1 )h( kwtop, kwtop-1 ) = s*v( 1, 1 )
              call stdlib_${ri}$lacpy( 'U', jw, jw, t, ldt, h( kwtop, kwtop ), ldh )
              call stdlib_${ri}$copy( jw-1, t( 2, 1 ), ldt+1, h( kwtop+1, kwtop ),ldh+1 )
              ! ==== accumulate orthogonal matrix in order update
              ! .    h and z, if requested.  ====
              if( ns>1 .and. s/=zero )call stdlib_${ri}$ormhr( 'R', 'N', jw, ns, 1, ns, t, ldt, work, &
                        v, ldv,work( jw+1 ), lwork-jw, info )
              ! ==== update vertical slab in h ====
              if( wantt ) then
                 ltop = 1
              else
                 ltop = ktop
              end if
              do krow = ltop, kwtop - 1, nv
                 kln = min( nv, kwtop-krow )
                 call stdlib_${ri}$gemm( 'N', 'N', kln, jw, jw, one, h( krow, kwtop ),ldh, v, ldv, &
                           zero, wv, ldwv )
                 call stdlib_${ri}$lacpy( 'A', kln, jw, wv, ldwv, h( krow, kwtop ), ldh )
              end do
              ! ==== update horizontal slab in h ====
              if( wantt ) then
                 do kcol = kbot + 1, n, nh
                    kln = min( nh, n-kcol+1 )
                    call stdlib_${ri}$gemm( 'C', 'N', jw, kln, jw, one, v, ldv,h( kwtop, kcol ), ldh, &
                              zero, t, ldt )
                    call stdlib_${ri}$lacpy( 'A', jw, kln, t, ldt, h( kwtop, kcol ),ldh )
                 end do
              end if
              ! ==== update vertical slab in z ====
              if( wantz ) then
                 do krow = iloz, ihiz, nv
                    kln = min( nv, ihiz-krow+1 )
                    call stdlib_${ri}$gemm( 'N', 'N', kln, jw, jw, one, z( krow, kwtop ),ldz, v, ldv, &
                              zero, wv, ldwv )
                    call stdlib_${ri}$lacpy( 'A', kln, jw, wv, ldwv, z( krow, kwtop ),ldz )
                 end do
              end if
           end if
           ! ==== return the number of deflations ... ====
           nd = jw - ns
           ! ==== ... and the number of shifts. (subtracting
           ! .    infqr from the spike length takes care
           ! .    of the case of a rare qr failure while
           ! .    calculating eigenvalues of the deflation
           ! .    window.)  ====
           ns = ns - infqr
            ! ==== return optimal workspace. ====
           work( 1 ) = real( lwkopt,KIND=${rk}$)
     end subroutine stdlib_${ri}$laqr2

#:endif
#:endfor

     module pure subroutine stdlib_claqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
     !! CLAQR2 is identical to CLAQR3 except that it avoids
     !! recursion by calling CLAHQR instead of CLAQR4.
     !! Aggressive early deflation:
     !! This subroutine accepts as input an upper Hessenberg matrix
     !! H and performs an unitary similarity transformation
     !! designed to detect and deflate fully converged eigenvalues from
     !! a trailing principal submatrix.  On output H has been over-
     !! written by a new Hessenberg matrix that is a perturbation of
     !! an unitary similarity transformation of H.  It is to be
     !! hoped that the final version of H has many zero subdiagonal
     !! entries.
               ns, nd, sh, v, ldv, nh, t, ldt,nv, wv, ldwv, work, lwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(ilp), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: sh(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
        ! ================================================================
           ! Parameters 
           real(sp), parameter :: rzero = 0.0_sp
           real(sp), parameter :: rone = 1.0_sp
           
           
           ! Local Scalars 
           complex(sp) :: beta, cdum, s, tau
           real(sp) :: foo, safmax, safmin, smlnum, ulp
           integer(ilp) :: i, ifst, ilst, info, infqr, j, jw, kcol, kln, knt, krow, kwtop, ltop, &
                     lwk1, lwk2, lwkopt
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! ==== estimate optimal workspace. ====
           jw = min( nw, kbot-ktop+1 )
           if( jw<=2 ) then
              lwkopt = 1
           else
              ! ==== workspace query call to stdlib_cgehrd ====
              call stdlib_cgehrd( jw, 1, jw-1, t, ldt, work, work, -1, info )
              lwk1 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_cunmhr ====
              call stdlib_cunmhr( 'R', 'N', jw, jw, 1, jw-1, t, ldt, work, v, ldv,work, -1, info )
                        
              lwk2 = int( work( 1 ),KIND=ilp)
              ! ==== optimal workspace ====
              lwkopt = jw + max( lwk1, lwk2 )
           end if
           ! ==== quick return in case of workspace query. ====
           if( lwork==-1 ) then
              work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
              return
           end if
           ! ==== nothing to do ...
           ! ... for an empty active block ... ====
           ns = 0
           nd = 0
           work( 1 ) = cone
           if( ktop>kbot )return
           ! ... nor for an empty deflation window. ====
           if( nw<1 )return
           ! ==== machine constants ====
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=sp) / ulp )
           ! ==== setup deflation window ====
           jw = min( nw, kbot-ktop+1 )
           kwtop = kbot - jw + 1
           if( kwtop==ktop ) then
              s = czero
           else
              s = h( kwtop, kwtop-1 )
           end if
           if( kbot==kwtop ) then
              ! ==== 1-by-1 deflation window: not much to do ====
              sh( kwtop ) = h( kwtop, kwtop )
              ns = 1
              nd = 0
              if( cabs1( s )<=max( smlnum, ulp*cabs1( h( kwtop,kwtop ) ) ) ) then
                 ns = 0
                 nd = 1
                 if( kwtop>ktop )h( kwtop, kwtop-1 ) = czero
              end if
              work( 1 ) = cone
              return
           end if
           ! ==== convert to spike-triangular form.  (in case of a
           ! .    rare qr failure, this routine continues to do
           ! .    aggressive early deflation using that part of
           ! .    the deflation window that converged using infqr
           ! .    here and there to keep track.) ====
           call stdlib_clacpy( 'U', jw, jw, h( kwtop, kwtop ), ldh, t, ldt )
           call stdlib_ccopy( jw-1, h( kwtop+1, kwtop ), ldh+1, t( 2, 1 ), ldt+1 )
           call stdlib_claset( 'A', jw, jw, czero, cone, v, ldv )
           call stdlib_clahqr( .true., .true., jw, 1, jw, t, ldt, sh( kwtop ), 1,jw, v, ldv, &
                     infqr )
           ! ==== deflation detection loop ====
           ns = jw
           ilst = infqr + 1
           do knt = infqr + 1, jw
              ! ==== small spike tip deflation test ====
              foo = cabs1( t( ns, ns ) )
              if( foo==rzero )foo = cabs1( s )
              if( cabs1( s )*cabs1( v( 1, ns ) )<=max( smlnum, ulp*foo ) )then
                 ! ==== cone more converged eigenvalue ====
                 ns = ns - 1
              else
                 ! ==== cone undeflatable eigenvalue.  move it up out of the
                 ! .    way.   (stdlib_ctrexc can not fail in this case.) ====
                 ifst = ns
                 call stdlib_ctrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                 ilst = ilst + 1
              end if
           end do
              ! ==== return to hessenberg form ====
           if( ns==0 )s = czero
           if( ns<jw ) then
              ! ==== sorting the diagonal of t improves accuracy for
              ! .    graded matrices.  ====
              do i = infqr + 1, ns
                 ifst = i
                 do j = i + 1, ns
                    if( cabs1( t( j, j ) )>cabs1( t( ifst, ifst ) ) )ifst = j
                 end do
                 ilst = i
                 if( ifst/=ilst )call stdlib_ctrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                           
              end do
           end if
           ! ==== restore shift/eigenvalue array from t ====
           do i = infqr + 1, jw
              sh( kwtop+i-1 ) = t( i, i )
           end do
           if( ns<jw .or. s==czero ) then
              if( ns>1 .and. s/=czero ) then
                 ! ==== reflect spike back into lower triangle ====
                 call stdlib_ccopy( ns, v, ldv, work, 1 )
                 do i = 1, ns
                    work( i ) = conjg( work( i ) )
                 end do
                 beta = work( 1 )
                 call stdlib_clarfg( ns, beta, work( 2 ), 1, tau )
                 work( 1 ) = cone
                 call stdlib_claset( 'L', jw-2, jw-2, czero, czero, t( 3, 1 ), ldt )
                 call stdlib_clarf( 'L', ns, jw, work, 1, conjg( tau ), t, ldt,work( jw+1 ) )
                           
                 call stdlib_clarf( 'R', ns, ns, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_clarf( 'R', jw, ns, work, 1, tau, v, ldv,work( jw+1 ) )
                 call stdlib_cgehrd( jw, 1, ns, t, ldt, work, work( jw+1 ),lwork-jw, info )
                           
              end if
              ! ==== copy updated reduced window into place ====
              if( kwtop>1 )h( kwtop, kwtop-1 ) = s*conjg( v( 1, 1 ) )
              call stdlib_clacpy( 'U', jw, jw, t, ldt, h( kwtop, kwtop ), ldh )
              call stdlib_ccopy( jw-1, t( 2, 1 ), ldt+1, h( kwtop+1, kwtop ),ldh+1 )
              ! ==== accumulate orthogonal matrix in order update
              ! .    h and z, if requested.  ====
              if( ns>1 .and. s/=czero )call stdlib_cunmhr( 'R', 'N', jw, ns, 1, ns, t, ldt, work, &
                        v, ldv,work( jw+1 ), lwork-jw, info )
              ! ==== update vertical slab in h ====
              if( wantt ) then
                 ltop = 1
              else
                 ltop = ktop
              end if
              do krow = ltop, kwtop - 1, nv
                 kln = min( nv, kwtop-krow )
                 call stdlib_cgemm( 'N', 'N', kln, jw, jw, cone, h( krow, kwtop ),ldh, v, ldv, &
                           czero, wv, ldwv )
                 call stdlib_clacpy( 'A', kln, jw, wv, ldwv, h( krow, kwtop ), ldh )
              end do
              ! ==== update horizontal slab in h ====
              if( wantt ) then
                 do kcol = kbot + 1, n, nh
                    kln = min( nh, n-kcol+1 )
                    call stdlib_cgemm( 'C', 'N', jw, kln, jw, cone, v, ldv,h( kwtop, kcol ), ldh, &
                              czero, t, ldt )
                    call stdlib_clacpy( 'A', jw, kln, t, ldt, h( kwtop, kcol ),ldh )
                 end do
              end if
              ! ==== update vertical slab in z ====
              if( wantz ) then
                 do krow = iloz, ihiz, nv
                    kln = min( nv, ihiz-krow+1 )
                    call stdlib_cgemm( 'N', 'N', kln, jw, jw, cone, z( krow, kwtop ),ldz, v, ldv, &
                              czero, wv, ldwv )
                    call stdlib_clacpy( 'A', kln, jw, wv, ldwv, z( krow, kwtop ),ldz )
                 end do
              end if
           end if
           ! ==== return the number of deflations ... ====
           nd = jw - ns
           ! ==== ... and the number of shifts. (subtracting
           ! .    infqr from the spike length takes care
           ! .    of the case of a rare qr failure while
           ! .    calculating eigenvalues of the deflation
           ! .    window.)  ====
           ns = ns - infqr
            ! ==== return optimal workspace. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
     end subroutine stdlib_claqr2

     module pure subroutine stdlib_zlaqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
     !! ZLAQR2 is identical to ZLAQR3 except that it avoids
     !! recursion by calling ZLAHQR instead of ZLAQR4.
     !! Aggressive early deflation:
     !! ZLAQR2 accepts as input an upper Hessenberg matrix
     !! H and performs an unitary similarity transformation
     !! designed to detect and deflate fully converged eigenvalues from
     !! a trailing principal submatrix.  On output H has been over-
     !! written by a new Hessenberg matrix that is a perturbation of
     !! an unitary similarity transformation of H.  It is to be
     !! hoped that the final version of H has many zero subdiagonal
     !! entries.
               ns, nd, sh, v, ldv, nh, t, ldt,nv, wv, ldwv, work, lwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(ilp), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(dp), intent(out) :: sh(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
        ! ================================================================
           ! Parameters 
           real(dp), parameter :: rzero = 0.0_dp
           real(dp), parameter :: rone = 1.0_dp
           
           
           ! Local Scalars 
           complex(dp) :: beta, cdum, s, tau
           real(dp) :: foo, safmax, safmin, smlnum, ulp
           integer(ilp) :: i, ifst, ilst, info, infqr, j, jw, kcol, kln, knt, krow, kwtop, ltop, &
                     lwk1, lwk2, lwkopt
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! ==== estimate optimal workspace. ====
           jw = min( nw, kbot-ktop+1 )
           if( jw<=2 ) then
              lwkopt = 1
           else
              ! ==== workspace query call to stdlib_zgehrd ====
              call stdlib_zgehrd( jw, 1, jw-1, t, ldt, work, work, -1, info )
              lwk1 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_zunmhr ====
              call stdlib_zunmhr( 'R', 'N', jw, jw, 1, jw-1, t, ldt, work, v, ldv,work, -1, info )
                        
              lwk2 = int( work( 1 ),KIND=ilp)
              ! ==== optimal workspace ====
              lwkopt = jw + max( lwk1, lwk2 )
           end if
           ! ==== quick return in case of workspace query. ====
           if( lwork==-1 ) then
              work( 1 ) = cmplx( lwkopt, 0,KIND=dp)
              return
           end if
           ! ==== nothing to do ...
           ! ... for an empty active block ... ====
           ns = 0
           nd = 0
           work( 1 ) = cone
           if( ktop>kbot )return
           ! ... nor for an empty deflation window. ====
           if( nw<1 )return
           ! ==== machine constants ====
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_dlabad( safmin, safmax )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=dp) / ulp )
           ! ==== setup deflation window ====
           jw = min( nw, kbot-ktop+1 )
           kwtop = kbot - jw + 1
           if( kwtop==ktop ) then
              s = czero
           else
              s = h( kwtop, kwtop-1 )
           end if
           if( kbot==kwtop ) then
              ! ==== 1-by-1 deflation window: not much to do ====
              sh( kwtop ) = h( kwtop, kwtop )
              ns = 1
              nd = 0
              if( cabs1( s )<=max( smlnum, ulp*cabs1( h( kwtop,kwtop ) ) ) ) then
                 ns = 0
                 nd = 1
                 if( kwtop>ktop )h( kwtop, kwtop-1 ) = czero
              end if
              work( 1 ) = cone
              return
           end if
           ! ==== convert to spike-triangular form.  (in case of a
           ! .    rare qr failure, this routine continues to do
           ! .    aggressive early deflation using that part of
           ! .    the deflation window that converged using infqr
           ! .    here and there to keep track.) ====
           call stdlib_zlacpy( 'U', jw, jw, h( kwtop, kwtop ), ldh, t, ldt )
           call stdlib_zcopy( jw-1, h( kwtop+1, kwtop ), ldh+1, t( 2, 1 ), ldt+1 )
           call stdlib_zlaset( 'A', jw, jw, czero, cone, v, ldv )
           call stdlib_zlahqr( .true., .true., jw, 1, jw, t, ldt, sh( kwtop ), 1,jw, v, ldv, &
                     infqr )
           ! ==== deflation detection loop ====
           ns = jw
           ilst = infqr + 1
           do knt = infqr + 1, jw
              ! ==== small spike tip deflation test ====
              foo = cabs1( t( ns, ns ) )
              if( foo==rzero )foo = cabs1( s )
              if( cabs1( s )*cabs1( v( 1, ns ) )<=max( smlnum, ulp*foo ) )then
                 ! ==== cone more converged eigenvalue ====
                 ns = ns - 1
              else
                 ! ==== cone undeflatable eigenvalue.  move it up out of the
                 ! .    way.   (stdlib_ztrexc can not fail in this case.) ====
                 ifst = ns
                 call stdlib_ztrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                 ilst = ilst + 1
              end if
           end do
              ! ==== return to hessenberg form ====
           if( ns==0 )s = czero
           if( ns<jw ) then
              ! ==== sorting the diagonal of t improves accuracy for
              ! .    graded matrices.  ====
              do i = infqr + 1, ns
                 ifst = i
                 do j = i + 1, ns
                    if( cabs1( t( j, j ) )>cabs1( t( ifst, ifst ) ) )ifst = j
                 end do
                 ilst = i
                 if( ifst/=ilst )call stdlib_ztrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                           
              end do
           end if
           ! ==== restore shift/eigenvalue array from t ====
           do i = infqr + 1, jw
              sh( kwtop+i-1 ) = t( i, i )
           end do
           if( ns<jw .or. s==czero ) then
              if( ns>1 .and. s/=czero ) then
                 ! ==== reflect spike back into lower triangle ====
                 call stdlib_zcopy( ns, v, ldv, work, 1 )
                 do i = 1, ns
                    work( i ) = conjg( work( i ) )
                 end do
                 beta = work( 1 )
                 call stdlib_zlarfg( ns, beta, work( 2 ), 1, tau )
                 work( 1 ) = cone
                 call stdlib_zlaset( 'L', jw-2, jw-2, czero, czero, t( 3, 1 ), ldt )
                 call stdlib_zlarf( 'L', ns, jw, work, 1, conjg( tau ), t, ldt,work( jw+1 ) )
                           
                 call stdlib_zlarf( 'R', ns, ns, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_zlarf( 'R', jw, ns, work, 1, tau, v, ldv,work( jw+1 ) )
                 call stdlib_zgehrd( jw, 1, ns, t, ldt, work, work( jw+1 ),lwork-jw, info )
                           
              end if
              ! ==== copy updated reduced window into place ====
              if( kwtop>1 )h( kwtop, kwtop-1 ) = s*conjg( v( 1, 1 ) )
              call stdlib_zlacpy( 'U', jw, jw, t, ldt, h( kwtop, kwtop ), ldh )
              call stdlib_zcopy( jw-1, t( 2, 1 ), ldt+1, h( kwtop+1, kwtop ),ldh+1 )
              ! ==== accumulate orthogonal matrix in order update
              ! .    h and z, if requested.  ====
              if( ns>1 .and. s/=czero )call stdlib_zunmhr( 'R', 'N', jw, ns, 1, ns, t, ldt, work, &
                        v, ldv,work( jw+1 ), lwork-jw, info )
              ! ==== update vertical slab in h ====
              if( wantt ) then
                 ltop = 1
              else
                 ltop = ktop
              end if
              do krow = ltop, kwtop - 1, nv
                 kln = min( nv, kwtop-krow )
                 call stdlib_zgemm( 'N', 'N', kln, jw, jw, cone, h( krow, kwtop ),ldh, v, ldv, &
                           czero, wv, ldwv )
                 call stdlib_zlacpy( 'A', kln, jw, wv, ldwv, h( krow, kwtop ), ldh )
              end do
              ! ==== update horizontal slab in h ====
              if( wantt ) then
                 do kcol = kbot + 1, n, nh
                    kln = min( nh, n-kcol+1 )
                    call stdlib_zgemm( 'C', 'N', jw, kln, jw, cone, v, ldv,h( kwtop, kcol ), ldh, &
                              czero, t, ldt )
                    call stdlib_zlacpy( 'A', jw, kln, t, ldt, h( kwtop, kcol ),ldh )
                 end do
              end if
              ! ==== update vertical slab in z ====
              if( wantz ) then
                 do krow = iloz, ihiz, nv
                    kln = min( nv, ihiz-krow+1 )
                    call stdlib_zgemm( 'N', 'N', kln, jw, jw, cone, z( krow, kwtop ),ldz, v, ldv, &
                              czero, wv, ldwv )
                    call stdlib_zlacpy( 'A', kln, jw, wv, ldwv, z( krow, kwtop ),ldz )
                 end do
              end if
           end if
           ! ==== return the number of deflations ... ====
           nd = jw - ns
           ! ==== ... and the number of shifts. (subtracting
           ! .    infqr from the spike length takes care
           ! .    of the case of a rare qr failure while
           ! .    calculating eigenvalues of the deflation
           ! .    window.)  ====
           ns = ns - infqr
            ! ==== return optimal workspace. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=dp)
     end subroutine stdlib_zlaqr2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$laqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
     !! ZLAQR2: is identical to ZLAQR3 except that it avoids
     !! recursion by calling ZLAHQR instead of ZLAQR4.
     !! Aggressive early deflation:
     !! ZLAQR2 accepts as input an upper Hessenberg matrix
     !! H and performs an unitary similarity transformation
     !! designed to detect and deflate fully converged eigenvalues from
     !! a trailing principal submatrix.  On output H has been over-
     !! written by a new Hessenberg matrix that is a perturbation of
     !! an unitary similarity transformation of H.  It is to be
     !! hoped that the final version of H has many zero subdiagonal
     !! entries.
               ns, nd, sh, v, ldv, nh, t, ldt,nv, wv, ldwv, work, lwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(ilp), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(${ck}$), intent(out) :: sh(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
        ! ================================================================
           ! Parameters 
           real(${ck}$), parameter :: rzero = 0.0_${ck}$
           real(${ck}$), parameter :: rone = 1.0_${ck}$
           
           
           ! Local Scalars 
           complex(${ck}$) :: beta, cdum, s, tau
           real(${ck}$) :: foo, safmax, safmin, smlnum, ulp
           integer(ilp) :: i, ifst, ilst, info, infqr, j, jw, kcol, kln, knt, krow, kwtop, ltop, &
                     lwk1, lwk2, lwkopt
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! ==== estimate optimal workspace. ====
           jw = min( nw, kbot-ktop+1 )
           if( jw<=2 ) then
              lwkopt = 1
           else
              ! ==== workspace query call to stdlib_${ci}$gehrd ====
              call stdlib_${ci}$gehrd( jw, 1, jw-1, t, ldt, work, work, -1, info )
              lwk1 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_${ci}$unmhr ====
              call stdlib_${ci}$unmhr( 'R', 'N', jw, jw, 1, jw-1, t, ldt, work, v, ldv,work, -1, info )
                        
              lwk2 = int( work( 1 ),KIND=ilp)
              ! ==== optimal workspace ====
              lwkopt = jw + max( lwk1, lwk2 )
           end if
           ! ==== quick return in case of workspace query. ====
           if( lwork==-1 ) then
              work( 1 ) = cmplx( lwkopt, 0,KIND=${ck}$)
              return
           end if
           ! ==== nothing to do ...
           ! ... for an empty active block ... ====
           ns = 0
           nd = 0
           work( 1 ) = cone
           if( ktop>kbot )return
           ! ... nor for an empty deflation window. ====
           if( nw<1 )return
           ! ==== machine constants ====
           safmin = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_${c2ri(ci)}$labad( safmin, safmax )
           ulp = stdlib_${c2ri(ci)}$lamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=${ck}$) / ulp )
           ! ==== setup deflation window ====
           jw = min( nw, kbot-ktop+1 )
           kwtop = kbot - jw + 1
           if( kwtop==ktop ) then
              s = czero
           else
              s = h( kwtop, kwtop-1 )
           end if
           if( kbot==kwtop ) then
              ! ==== 1-by-1 deflation window: not much to do ====
              sh( kwtop ) = h( kwtop, kwtop )
              ns = 1
              nd = 0
              if( cabs1( s )<=max( smlnum, ulp*cabs1( h( kwtop,kwtop ) ) ) ) then
                 ns = 0
                 nd = 1
                 if( kwtop>ktop )h( kwtop, kwtop-1 ) = czero
              end if
              work( 1 ) = cone
              return
           end if
           ! ==== convert to spike-triangular form.  (in case of a
           ! .    rare qr failure, this routine continues to do
           ! .    aggressive early deflation using that part of
           ! .    the deflation window that converged using infqr
           ! .    here and there to keep track.) ====
           call stdlib_${ci}$lacpy( 'U', jw, jw, h( kwtop, kwtop ), ldh, t, ldt )
           call stdlib_${ci}$copy( jw-1, h( kwtop+1, kwtop ), ldh+1, t( 2, 1 ), ldt+1 )
           call stdlib_${ci}$laset( 'A', jw, jw, czero, cone, v, ldv )
           call stdlib_${ci}$lahqr( .true., .true., jw, 1, jw, t, ldt, sh( kwtop ), 1,jw, v, ldv, &
                     infqr )
           ! ==== deflation detection loop ====
           ns = jw
           ilst = infqr + 1
           do knt = infqr + 1, jw
              ! ==== small spike tip deflation test ====
              foo = cabs1( t( ns, ns ) )
              if( foo==rzero )foo = cabs1( s )
              if( cabs1( s )*cabs1( v( 1, ns ) )<=max( smlnum, ulp*foo ) )then
                 ! ==== cone more converged eigenvalue ====
                 ns = ns - 1
              else
                 ! ==== cone undeflatable eigenvalue.  move it up out of the
                 ! .    way.   (stdlib_${ci}$trexc can not fail in this case.) ====
                 ifst = ns
                 call stdlib_${ci}$trexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                 ilst = ilst + 1
              end if
           end do
              ! ==== return to hessenberg form ====
           if( ns==0 )s = czero
           if( ns<jw ) then
              ! ==== sorting the diagonal of t improves accuracy for
              ! .    graded matrices.  ====
              do i = infqr + 1, ns
                 ifst = i
                 do j = i + 1, ns
                    if( cabs1( t( j, j ) )>cabs1( t( ifst, ifst ) ) )ifst = j
                 end do
                 ilst = i
                 if( ifst/=ilst )call stdlib_${ci}$trexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                           
              end do
           end if
           ! ==== restore shift/eigenvalue array from t ====
           do i = infqr + 1, jw
              sh( kwtop+i-1 ) = t( i, i )
           end do
           if( ns<jw .or. s==czero ) then
              if( ns>1 .and. s/=czero ) then
                 ! ==== reflect spike back into lower triangle ====
                 call stdlib_${ci}$copy( ns, v, ldv, work, 1 )
                 do i = 1, ns
                    work( i ) = conjg( work( i ) )
                 end do
                 beta = work( 1 )
                 call stdlib_${ci}$larfg( ns, beta, work( 2 ), 1, tau )
                 work( 1 ) = cone
                 call stdlib_${ci}$laset( 'L', jw-2, jw-2, czero, czero, t( 3, 1 ), ldt )
                 call stdlib_${ci}$larf( 'L', ns, jw, work, 1, conjg( tau ), t, ldt,work( jw+1 ) )
                           
                 call stdlib_${ci}$larf( 'R', ns, ns, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_${ci}$larf( 'R', jw, ns, work, 1, tau, v, ldv,work( jw+1 ) )
                 call stdlib_${ci}$gehrd( jw, 1, ns, t, ldt, work, work( jw+1 ),lwork-jw, info )
                           
              end if
              ! ==== copy updated reduced window into place ====
              if( kwtop>1 )h( kwtop, kwtop-1 ) = s*conjg( v( 1, 1 ) )
              call stdlib_${ci}$lacpy( 'U', jw, jw, t, ldt, h( kwtop, kwtop ), ldh )
              call stdlib_${ci}$copy( jw-1, t( 2, 1 ), ldt+1, h( kwtop+1, kwtop ),ldh+1 )
              ! ==== accumulate orthogonal matrix in order update
              ! .    h and z, if requested.  ====
              if( ns>1 .and. s/=czero )call stdlib_${ci}$unmhr( 'R', 'N', jw, ns, 1, ns, t, ldt, work, &
                        v, ldv,work( jw+1 ), lwork-jw, info )
              ! ==== update vertical slab in h ====
              if( wantt ) then
                 ltop = 1
              else
                 ltop = ktop
              end if
              do krow = ltop, kwtop - 1, nv
                 kln = min( nv, kwtop-krow )
                 call stdlib_${ci}$gemm( 'N', 'N', kln, jw, jw, cone, h( krow, kwtop ),ldh, v, ldv, &
                           czero, wv, ldwv )
                 call stdlib_${ci}$lacpy( 'A', kln, jw, wv, ldwv, h( krow, kwtop ), ldh )
              end do
              ! ==== update horizontal slab in h ====
              if( wantt ) then
                 do kcol = kbot + 1, n, nh
                    kln = min( nh, n-kcol+1 )
                    call stdlib_${ci}$gemm( 'C', 'N', jw, kln, jw, cone, v, ldv,h( kwtop, kcol ), ldh, &
                              czero, t, ldt )
                    call stdlib_${ci}$lacpy( 'A', jw, kln, t, ldt, h( kwtop, kcol ),ldh )
                 end do
              end if
              ! ==== update vertical slab in z ====
              if( wantz ) then
                 do krow = iloz, ihiz, nv
                    kln = min( nv, ihiz-krow+1 )
                    call stdlib_${ci}$gemm( 'N', 'N', kln, jw, jw, cone, z( krow, kwtop ),ldz, v, ldv, &
                              czero, wv, ldwv )
                    call stdlib_${ci}$lacpy( 'A', kln, jw, wv, ldwv, z( krow, kwtop ),ldz )
                 end do
              end if
           end if
           ! ==== return the number of deflations ... ====
           nd = jw - ns
           ! ==== ... and the number of shifts. (subtracting
           ! .    infqr from the spike length takes care
           ! .    of the case of a rare qr failure while
           ! .    calculating eigenvalues of the deflation
           ! .    window.)  ====
           ns = ns - infqr
            ! ==== return optimal workspace. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=${ck}$)
     end subroutine stdlib_${ci}$laqr2

#:endif
#:endfor



     module recursive subroutine stdlib_slaqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, alphar, &
     !! SLAQZ0 computes the eigenvalues of a real matrix pair (H,T),
     !! where H is an upper Hessenberg matrix and T is upper triangular,
     !! using the double-shift QZ method.
     !! Matrix pairs of this type are produced by the reduction to
     !! generalized upper Hessenberg form of a real matrix pair (A,B):
     !! A = Q1*H*Z1**T,  B = Q1*T*Z1**T,
     !! as computed by SGGHRD.
     !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
     !! also reduced to generalized Schur form,
     !! H = Q*S*Z**T,  T = Q*P*Z**T,
     !! where Q and Z are orthogonal matrices, P is an upper triangular
     !! matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2
     !! diagonal blocks.
     !! The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
     !! (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of
     !! eigenvalues.
     !! Additionally, the 2-by-2 upper triangular diagonal blocks of P
     !! corresponding to 2-by-2 blocks of S are reduced to positive diagonal
     !! form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,
     !! P(j,j) > 0, and P(j+1,j+1) > 0.
     !! Optionally, the orthogonal matrix Q from the generalized Schur
     !! factorization may be postmultiplied into an input matrix Q1, and the
     !! orthogonal matrix Z may be postmultiplied into an input matrix Z1.
     !! If Q1 and Z1 are the orthogonal matrices from SGGHRD that reduced
     !! the matrix pair (A,B) to generalized upper Hessenberg form, then the
     !! output matrices Q1*Q and Z1*Z are the orthogonal factors from the
     !! generalized Schur factorization of (A,B):
     !! A = (Q1*Q)*S*(Z1*Z)**T,  B = (Q1*Q)*P*(Z1*Z)**T.
     !! To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
     !! of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
     !! complex and beta real.
     !! If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
     !! generalized nonsymmetric eigenvalue problem (GNEP)
     !! A*x = lambda*B*x
     !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     !! alternate form of the GNEP
     !! mu*A*y = B*y.
     !! Real eigenvalues can be read directly from the generalized Schur
     !! form:
     !! alpha = S(i,i), beta = P(i,i).
     !! Ref: C.B. Moler
     !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
     !! pp. 241--256.
     !! Ref: B. Kagstrom, D. Kressner, "Multishift Variants of the QZ
     !! Algorithm with Aggressive Early Deflation", SIAM J. Numer.
     !! Anal., 29(2006), pp. 199--227.
     !! Ref: T. Steel, D. Camps, K. Meerbergen, R. Vandebril "A multishift,
     !! multipole rational QZ method with agressive early deflation"
               alphai, beta,q, ldq, z, ldz, work, lwork, rec,info )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           character, intent( in ) :: wants, wantq, wantz
           integer(ilp), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,rec
           integer(ilp), intent( out ) :: info
           real(sp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq, * ),z( ldz, * ), alphar(&
                      * ), alphai( * ), beta( * ), work( * )
           ! ================================================================
           ! local scalars
           real(sp) :: smlnum, ulp, eshift, safmin, safmax, c1, s1, temp, swap
           integer(ilp) :: istart, istop, iiter, maxit, istart2, k, ld, nshifts, nblock, nw, nmin,&
            nibble, n_undeflated, n_deflated, ns, sweep_info, shiftpos, lworkreq, k2, istartm, &
            istopm, iwants, iwantq, iwantz, norm_info, aed_info, nwr, nbr, nsr, itemp1, itemp2, &
                      rcost, i
           logical(lk) :: ilschur, ilq, ilz
           character :: jbcmpz*3
           if( stdlib_lsame( wants, 'E' ) ) then
              ilschur = .false.
              iwants = 1
           else if( stdlib_lsame( wants, 'S' ) ) then
              ilschur = .true.
              iwants = 2
           else
              iwants = 0
           end if
           if( stdlib_lsame( wantq, 'N' ) ) then
              ilq = .false.
              iwantq = 1
           else if( stdlib_lsame( wantq, 'V' ) ) then
              ilq = .true.
              iwantq = 2
           else if( stdlib_lsame( wantq, 'I' ) ) then
              ilq = .true.
              iwantq = 3
           else
              iwantq = 0
           end if
           if( stdlib_lsame( wantz, 'N' ) ) then
              ilz = .false.
              iwantz = 1
           else if( stdlib_lsame( wantz, 'V' ) ) then
              ilz = .true.
              iwantz = 2
           else if( stdlib_lsame( wantz, 'I' ) ) then
              ilz = .true.
              iwantz = 3
           else
              iwantz = 0
           end if
           ! check argument values
           info = 0
           if( iwants==0 ) then
              info = -1
           else if( iwantq==0 ) then
              info = -2
           else if( iwantz==0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 ) then
              info = -5
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -6
           else if( lda<n ) then
              info = -8
           else if( ldb<n ) then
              info = -10
           else if( ldq<1 .or. ( ilq .and. ldq<n ) ) then
              info = -15
           else if( ldz<1 .or. ( ilz .and. ldz<n ) ) then
              info = -17
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SLAQZ0', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 ) then
              work( 1 ) = real( 1,KIND=sp)
              return
           end if
           ! get the parameters
           jbcmpz( 1:1 ) = wants
           jbcmpz( 2:2 ) = wantq
           jbcmpz( 3:3 ) = wantz
           nmin = stdlib_ilaenv( 12, 'SLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nwr = stdlib_ilaenv( 13, 'SLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nwr = max( 2, nwr )
           nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
           nibble = stdlib_ilaenv( 14, 'SLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nsr = stdlib_ilaenv( 15, 'SLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nsr = min( nsr, ( n+6 ) / 9, ihi-ilo )
           nsr = max( 2, nsr-mod( nsr, 2 ) )
           rcost = stdlib_ilaenv( 17, 'SLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           itemp1 = int( nsr/sqrt( 1+2*nsr/( real( rcost,KIND=sp)/100*n ) ),KIND=ilp)
           itemp1 = ( ( itemp1-1 )/4 )*4+4
           nbr = nsr+itemp1
           if( n < nmin .or. rec >= 2 ) then
              call stdlib_shgeqz( wants, wantq, wantz, n, ilo, ihi, a, lda, b, ldb,alphar, alphai,&
                         beta, q, ldq, z, ldz, work,lwork, info )
              return
           end if
           ! find out required workspace
           ! workspace query to stdlib_slaqz3
           nw = max( nwr, nmin )
           call stdlib_slaqz3( ilschur, ilq, ilz, n, ilo, ihi, nw, a, lda, b, ldb,q, ldq, z, ldz, &
           n_undeflated, n_deflated, alphar,alphai, beta, work, nw, work, nw, work, -1, rec,&
                     aed_info )
           itemp1 = int( work( 1 ),KIND=ilp)
           ! workspace query to stdlib_slaqz4
           call stdlib_slaqz4( ilschur, ilq, ilz, n, ilo, ihi, nsr, nbr, alphar,alphai, beta, a, &
                     lda, b, ldb, q, ldq, z, ldz, work,nbr, work, nbr, work, -1, sweep_info )
           itemp2 = int( work( 1 ),KIND=ilp)
           lworkreq = max( itemp1+2*nw**2, itemp2+2*nbr**2 )
           if ( lwork ==-1 ) then
              work( 1 ) = real( lworkreq,KIND=sp)
              return
           else if ( lwork < lworkreq ) then
              info = -19
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SLAQZ0', info )
              return
           end if
           ! initialize q and z
           if( iwantq==3 ) call stdlib_slaset( 'FULL', n, n, zero, one, q, ldq )
           if( iwantz==3 ) call stdlib_slaset( 'FULL', n, n, zero, one, z, ldz )
           ! get machine constants
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=sp)/ulp )
           istart = ilo
           istop = ihi
           maxit = 3*( ihi-ilo+1 )
           ld = 0
           do iiter = 1, maxit
              if( iiter >= maxit ) then
                 info = istop+1
                 goto 80
              end if
              if ( istart+1 >= istop ) then
                 istop = istart
                 exit
              end if
              ! check deflations at the end
              if ( abs( a( istop-1, istop-2 ) ) <= max( smlnum,ulp*( abs( a( istop-1, istop-1 ) )+&
                        abs( a( istop-2,istop-2 ) ) ) ) ) then
                 a( istop-1, istop-2 ) = zero
                 istop = istop-2
                 ld = 0
                 eshift = zero
              else if ( abs( a( istop, istop-1 ) ) <= max( smlnum,ulp*( abs( a( istop, istop ) )+&
                        abs( a( istop-1,istop-1 ) ) ) ) ) then
                 a( istop, istop-1 ) = zero
                 istop = istop-1
                 ld = 0
                 eshift = zero
              end if
              ! check deflations at the start
              if ( abs( a( istart+2, istart+1 ) ) <= max( smlnum,ulp*( abs( a( istart+1, istart+1 &
                        ) )+abs( a( istart+2,istart+2 ) ) ) ) ) then
                 a( istart+2, istart+1 ) = zero
                 istart = istart+2
                 ld = 0
                 eshift = zero
              else if ( abs( a( istart+1, istart ) ) <= max( smlnum,ulp*( abs( a( istart, istart )&
                         )+abs( a( istart+1,istart+1 ) ) ) ) ) then
                 a( istart+1, istart ) = zero
                 istart = istart+1
                 ld = 0
                 eshift = zero
              end if
              if ( istart+1 >= istop ) then
                 exit
              end if
              ! check interior deflations
              istart2 = istart
              do k = istop, istart+1, -1
                 if ( abs( a( k, k-1 ) ) <= max( smlnum, ulp*( abs( a( k,k ) )+abs( a( k-1, k-1 ) &
                           ) ) ) ) then
                    a( k, k-1 ) = zero
                    istart2 = k
                    exit
                 end if
              end do
              ! get range to apply rotations to
              if ( ilschur ) then
                 istartm = 1
                 istopm = n
              else
                 istartm = istart2
                 istopm = istop
              end if
              ! check infinite eigenvalues, this is done without blocking so might
              ! slow down the method when many infinite eigenvalues are present
              k = istop
              do while ( k>=istart2 )
                 temp = zero
                 if( k < istop ) then
                    temp = temp+abs( b( k, k+1 ) )
                 end if
                 if( k > istart2 ) then
                    temp = temp+abs( b( k-1, k ) )
                 end if
                 if( abs( b( k, k ) ) < max( smlnum, ulp*temp ) ) then
                    ! a diagonal element of b is negligable, move it
                    ! to the top and deflate it
                    do k2 = k, istart2+1, -1
                       call stdlib_slartg( b( k2-1, k2 ), b( k2-1, k2-1 ), c1, s1,temp )
                       b( k2-1, k2 ) = temp
                       b( k2-1, k2-1 ) = zero
                       call stdlib_srot( k2-2-istartm+1, b( istartm, k2 ), 1,b( istartm, k2-1 ), &
                                 1, c1, s1 )
                       call stdlib_srot( min( k2+1, istop )-istartm+1, a( istartm,k2 ), 1, a( &
                                 istartm, k2-1 ), 1, c1, s1 )
                       if ( ilz ) then
                          call stdlib_srot( n, z( 1, k2 ), 1, z( 1, k2-1 ), 1, c1,s1 )
                       end if
                       if( k2<istop ) then
                          call stdlib_slartg( a( k2, k2-1 ), a( k2+1, k2-1 ), c1,s1, temp )
                                    
                          a( k2, k2-1 ) = temp
                          a( k2+1, k2-1 ) = zero
                          call stdlib_srot( istopm-k2+1, a( k2, k2 ), lda, a( k2+1,k2 ), lda, c1, &
                                    s1 )
                          call stdlib_srot( istopm-k2+1, b( k2, k2 ), ldb, b( k2+1,k2 ), ldb, c1, &
                                    s1 )
                          if( ilq ) then
                             call stdlib_srot( n, q( 1, k2 ), 1, q( 1, k2+1 ), 1,c1, s1 )
                          end if
                       end if
                    end do
                    if( istart2<istop )then
                       call stdlib_slartg( a( istart2, istart2 ), a( istart2+1,istart2 ), c1, s1, &
                                 temp )
                       a( istart2, istart2 ) = temp
                       a( istart2+1, istart2 ) = zero
                       call stdlib_srot( istopm-( istart2+1 )+1, a( istart2,istart2+1 ), lda, a( &
                                 istart2+1,istart2+1 ), lda, c1, s1 )
                       call stdlib_srot( istopm-( istart2+1 )+1, b( istart2,istart2+1 ), ldb, b( &
                                 istart2+1,istart2+1 ), ldb, c1, s1 )
                       if( ilq ) then
                          call stdlib_srot( n, q( 1, istart2 ), 1, q( 1,istart2+1 ), 1, c1, s1 )
                                    
                       end if
                    end if
                    istart2 = istart2+1
                 end if
                 k = k-1
              end do
              ! istart2 now points to the top of the bottom right
              ! unreduced hessenberg block
              if ( istart2 >= istop ) then
                 istop = istart2-1
                 ld = 0
                 eshift = zero
                 cycle
              end if
              nw = nwr
              nshifts = nsr
              nblock = nbr
              if ( istop-istart2+1 < nmin ) then
                 ! setting nw to the size of the subblock will make aed deflate
                 ! all the eigenvalues. this is slightly more efficient than just
                 ! using qz_small because the off diagonal part gets updated via blas.
                 if ( istop-istart+1 < nmin ) then
                    nw = istop-istart+1
                    istart2 = istart
                 else
                    nw = istop-istart2+1
                 end if
              end if
              ! time for aed
              call stdlib_slaqz3( ilschur, ilq, ilz, n, istart2, istop, nw, a, lda,b, ldb, q, ldq,&
               z, ldz, n_undeflated, n_deflated,alphar, alphai, beta, work, nw, work( nw**2+1 ),&
                         nw, work( 2*nw**2+1 ), lwork-2*nw**2, rec,aed_info )
              if ( n_deflated > 0 ) then
                 istop = istop-n_deflated
                 ld = 0
                 eshift = zero
              end if
              if ( 100*n_deflated > nibble*( n_deflated+n_undeflated ) .or.istop-istart2+1 < nmin &
                        ) then
                 ! aed has uncovered many eigenvalues. skip a qz sweep and run
                 ! aed again.
                 cycle
              end if
              ld = ld+1
              ns = min( nshifts, istop-istart2 )
              ns = min( ns, n_undeflated )
              shiftpos = istop-n_deflated-n_undeflated+1
              ! shuffle shifts to put double shifts in front
              ! this ensures that we don't split up a double shift
              do i = shiftpos, shiftpos+n_undeflated-1, 2
                 if( alphai( i )/=-alphai( i+1 ) ) then
                    swap = alphar( i )
                    alphar( i ) = alphar( i+1 )
                    alphar( i+1 ) = alphar( i+2 )
                    alphar( i+2 ) = swap
                    swap = alphai( i )
                    alphai( i ) = alphai( i+1 )
                    alphai( i+1 ) = alphai( i+2 )
                    alphai( i+2 ) = swap
                    swap = beta( i )
                    beta( i ) = beta( i+1 )
                    beta( i+1 ) = beta( i+2 )
                    beta( i+2 ) = swap
                 end if
              end do
              if ( mod( ld, 6 ) == 0 ) then
                 ! exceptional shift.  chosen for no particularly good reason.
                 if( ( real( maxit,KIND=sp)*safmin )*abs( a( istop,istop-1 ) )<abs( a( istop-1, &
                           istop-1 ) ) ) then
                    eshift = a( istop, istop-1 )/b( istop-1, istop-1 )
                 else
                    eshift = eshift+one/( safmin*real( maxit,KIND=sp) )
                 end if
                 alphar( shiftpos ) = one
                 alphar( shiftpos+1 ) = zero
                 alphai( shiftpos ) = zero
                 alphai( shiftpos+1 ) = zero
                 beta( shiftpos ) = eshift
                 beta( shiftpos+1 ) = eshift
                 ns = 2
              end if
              ! time for a qz sweep
              call stdlib_slaqz4( ilschur, ilq, ilz, n, istart2, istop, ns, nblock,alphar( &
              shiftpos ), alphai( shiftpos ),beta( shiftpos ), a, lda, b, ldb, q, ldq, z, ldz,&
              work, nblock, work( nblock**2+1 ), nblock,work( 2*nblock**2+1 ), lwork-2*nblock**2,&
                        sweep_info )
           end do
           ! call stdlib_shgeqz to normalize the eigenvalue blocks and set the eigenvalues
           ! if all the eigenvalues have been found, stdlib_shgeqz will not do any iterations
           ! and only normalize the blocks. in case of a rare convergence failure,
           ! the single shift might perform better.
        80 call stdlib_shgeqz( wants, wantq, wantz, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                  beta, q, ldq, z, ldz, work, lwork,norm_info )
           info = norm_info
     end subroutine stdlib_slaqz0

     module recursive subroutine stdlib_dlaqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, alphar, &
     !! DLAQZ0 computes the eigenvalues of a real matrix pair (H,T),
     !! where H is an upper Hessenberg matrix and T is upper triangular,
     !! using the double-shift QZ method.
     !! Matrix pairs of this type are produced by the reduction to
     !! generalized upper Hessenberg form of a real matrix pair (A,B):
     !! A = Q1*H*Z1**T,  B = Q1*T*Z1**T,
     !! as computed by DGGHRD.
     !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
     !! also reduced to generalized Schur form,
     !! H = Q*S*Z**T,  T = Q*P*Z**T,
     !! where Q and Z are orthogonal matrices, P is an upper triangular
     !! matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2
     !! diagonal blocks.
     !! The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
     !! (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of
     !! eigenvalues.
     !! Additionally, the 2-by-2 upper triangular diagonal blocks of P
     !! corresponding to 2-by-2 blocks of S are reduced to positive diagonal
     !! form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,
     !! P(j,j) > 0, and P(j+1,j+1) > 0.
     !! Optionally, the orthogonal matrix Q from the generalized Schur
     !! factorization may be postmultiplied into an input matrix Q1, and the
     !! orthogonal matrix Z may be postmultiplied into an input matrix Z1.
     !! If Q1 and Z1 are the orthogonal matrices from DGGHRD that reduced
     !! the matrix pair (A,B) to generalized upper Hessenberg form, then the
     !! output matrices Q1*Q and Z1*Z are the orthogonal factors from the
     !! generalized Schur factorization of (A,B):
     !! A = (Q1*Q)*S*(Z1*Z)**T,  B = (Q1*Q)*P*(Z1*Z)**T.
     !! To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
     !! of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
     !! complex and beta real.
     !! If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
     !! generalized nonsymmetric eigenvalue problem (GNEP)
     !! A*x = lambda*B*x
     !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     !! alternate form of the GNEP
     !! mu*A*y = B*y.
     !! Real eigenvalues can be read directly from the generalized Schur
     !! form:
     !! alpha = S(i,i), beta = P(i,i).
     !! Ref: C.B. Moler
     !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
     !! pp. 241--256.
     !! Ref: B. Kagstrom, D. Kressner, "Multishift Variants of the QZ
     !! Algorithm with Aggressive Early Deflation", SIAM J. Numer.
     !! Anal., 29(2006), pp. 199--227.
     !! Ref: T. Steel, D. Camps, K. Meerbergen, R. Vandebril "A multishift,
     !! multipole rational QZ method with agressive early deflation"
               alphai, beta,q, ldq, z, ldz, work, lwork, rec,info )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           character, intent( in ) :: wants, wantq, wantz
           integer(ilp), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,rec
           integer(ilp), intent( out ) :: info
           real(dp), intent( inout ) :: a( lda, * ), b( ldb, * ),q( ldq, * ), z( ldz, * ), alphar(&
                      * ),alphai( * ), beta( * ), work( * )
           ! ================================================================
           ! local scalars
           real(dp) :: smlnum, ulp, eshift, safmin, safmax, c1, s1, temp, swap
           integer(ilp) :: istart, istop, iiter, maxit, istart2, k, ld, nshifts, nblock, nw, nmin,&
            nibble, n_undeflated, n_deflated, ns, sweep_info, shiftpos, lworkreq, k2, istartm, &
            istopm, iwants, iwantq, iwantz, norm_info, aed_info, nwr, nbr, nsr, itemp1, itemp2, &
                      rcost, i
           logical(lk) :: ilschur, ilq, ilz
           character :: jbcmpz*3
           if( stdlib_lsame( wants, 'E' ) ) then
              ilschur = .false.
              iwants = 1
           else if( stdlib_lsame( wants, 'S' ) ) then
              ilschur = .true.
              iwants = 2
           else
              iwants = 0
           end if
           if( stdlib_lsame( wantq, 'N' ) ) then
              ilq = .false.
              iwantq = 1
           else if( stdlib_lsame( wantq, 'V' ) ) then
              ilq = .true.
              iwantq = 2
           else if( stdlib_lsame( wantq, 'I' ) ) then
              ilq = .true.
              iwantq = 3
           else
              iwantq = 0
           end if
           if( stdlib_lsame( wantz, 'N' ) ) then
              ilz = .false.
              iwantz = 1
           else if( stdlib_lsame( wantz, 'V' ) ) then
              ilz = .true.
              iwantz = 2
           else if( stdlib_lsame( wantz, 'I' ) ) then
              ilz = .true.
              iwantz = 3
           else
              iwantz = 0
           end if
           ! check argument values
           info = 0
           if( iwants==0 ) then
              info = -1
           else if( iwantq==0 ) then
              info = -2
           else if( iwantz==0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 ) then
              info = -5
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -6
           else if( lda<n ) then
              info = -8
           else if( ldb<n ) then
              info = -10
           else if( ldq<1 .or. ( ilq .and. ldq<n ) ) then
              info = -15
           else if( ldz<1 .or. ( ilz .and. ldz<n ) ) then
              info = -17
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAQZ0', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 ) then
              work( 1 ) = real( 1,KIND=dp)
              return
           end if
           ! get the parameters
           jbcmpz( 1:1 ) = wants
           jbcmpz( 2:2 ) = wantq
           jbcmpz( 3:3 ) = wantz
           nmin = stdlib_ilaenv( 12, 'DLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nwr = stdlib_ilaenv( 13, 'DLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nwr = max( 2, nwr )
           nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
           nibble = stdlib_ilaenv( 14, 'DLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nsr = stdlib_ilaenv( 15, 'DLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nsr = min( nsr, ( n+6 ) / 9, ihi-ilo )
           nsr = max( 2, nsr-mod( nsr, 2 ) )
           rcost = stdlib_ilaenv( 17, 'DLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           itemp1 = int( nsr/sqrt( 1+2*nsr/( real( rcost,KIND=dp)/100*n ) ),KIND=ilp)
           itemp1 = ( ( itemp1-1 )/4 )*4+4
           nbr = nsr+itemp1
           if( n < nmin .or. rec >= 2 ) then
              call stdlib_dhgeqz( wants, wantq, wantz, n, ilo, ihi, a, lda, b, ldb,alphar, alphai,&
                         beta, q, ldq, z, ldz, work,lwork, info )
              return
           end if
           ! find out required workspace
           ! workspace query to stdlib_dlaqz3
           nw = max( nwr, nmin )
           call stdlib_dlaqz3( ilschur, ilq, ilz, n, ilo, ihi, nw, a, lda, b, ldb,q, ldq, z, ldz, &
           n_undeflated, n_deflated, alphar,alphai, beta, work, nw, work, nw, work, -1, rec,&
                     aed_info )
           itemp1 = int( work( 1 ),KIND=ilp)
           ! workspace query to stdlib_dlaqz4
           call stdlib_dlaqz4( ilschur, ilq, ilz, n, ilo, ihi, nsr, nbr, alphar,alphai, beta, a, &
                     lda, b, ldb, q, ldq, z, ldz, work,nbr, work, nbr, work, -1, sweep_info )
           itemp2 = int( work( 1 ),KIND=ilp)
           lworkreq = max( itemp1+2*nw**2, itemp2+2*nbr**2 )
           if ( lwork ==-1 ) then
              work( 1 ) = real( lworkreq,KIND=dp)
              return
           else if ( lwork < lworkreq ) then
              info = -19
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAQZ0', info )
              return
           end if
           ! initialize q and z
           if( iwantq==3 ) call stdlib_dlaset( 'FULL', n, n, zero, one, q, ldq )
           if( iwantz==3 ) call stdlib_dlaset( 'FULL', n, n, zero, one, z, ldz )
           ! get machine constants
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_dlabad( safmin, safmax )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=dp)/ulp )
           istart = ilo
           istop = ihi
           maxit = 3*( ihi-ilo+1 )
           ld = 0
           do iiter = 1, maxit
              if( iiter >= maxit ) then
                 info = istop+1
                 goto 80
              end if
              if ( istart+1 >= istop ) then
                 istop = istart
                 exit
              end if
              ! check deflations at the end
              if ( abs( a( istop-1, istop-2 ) ) <= max( smlnum,ulp*( abs( a( istop-1, istop-1 ) )+&
                        abs( a( istop-2,istop-2 ) ) ) ) ) then
                 a( istop-1, istop-2 ) = zero
                 istop = istop-2
                 ld = 0
                 eshift = zero
              else if ( abs( a( istop, istop-1 ) ) <= max( smlnum,ulp*( abs( a( istop, istop ) )+&
                        abs( a( istop-1,istop-1 ) ) ) ) ) then
                 a( istop, istop-1 ) = zero
                 istop = istop-1
                 ld = 0
                 eshift = zero
              end if
              ! check deflations at the start
              if ( abs( a( istart+2, istart+1 ) ) <= max( smlnum,ulp*( abs( a( istart+1, istart+1 &
                        ) )+abs( a( istart+2,istart+2 ) ) ) ) ) then
                 a( istart+2, istart+1 ) = zero
                 istart = istart+2
                 ld = 0
                 eshift = zero
              else if ( abs( a( istart+1, istart ) ) <= max( smlnum,ulp*( abs( a( istart, istart )&
                         )+abs( a( istart+1,istart+1 ) ) ) ) ) then
                 a( istart+1, istart ) = zero
                 istart = istart+1
                 ld = 0
                 eshift = zero
              end if
              if ( istart+1 >= istop ) then
                 exit
              end if
              ! check interior deflations
              istart2 = istart
              do k = istop, istart+1, -1
                 if ( abs( a( k, k-1 ) ) <= max( smlnum, ulp*( abs( a( k,k ) )+abs( a( k-1, k-1 ) &
                           ) ) ) ) then
                    a( k, k-1 ) = zero
                    istart2 = k
                    exit
                 end if
              end do
              ! get range to apply rotations to
              if ( ilschur ) then
                 istartm = 1
                 istopm = n
              else
                 istartm = istart2
                 istopm = istop
              end if
              ! check infinite eigenvalues, this is done without blocking so might
              ! slow down the method when many infinite eigenvalues are present
              k = istop
              do while ( k>=istart2 )
                 temp = zero
                 if( k < istop ) then
                    temp = temp+abs( b( k, k+1 ) )
                 end if
                 if( k > istart2 ) then
                    temp = temp+abs( b( k-1, k ) )
                 end if
                 if( abs( b( k, k ) ) < max( smlnum, ulp*temp ) ) then
                    ! a diagonal element of b is negligable, move it
                    ! to the top and deflate it
                    do k2 = k, istart2+1, -1
                       call stdlib_dlartg( b( k2-1, k2 ), b( k2-1, k2-1 ), c1, s1,temp )
                       b( k2-1, k2 ) = temp
                       b( k2-1, k2-1 ) = zero
                       call stdlib_drot( k2-2-istartm+1, b( istartm, k2 ), 1,b( istartm, k2-1 ), &
                                 1, c1, s1 )
                       call stdlib_drot( min( k2+1, istop )-istartm+1, a( istartm,k2 ), 1, a( &
                                 istartm, k2-1 ), 1, c1, s1 )
                       if ( ilz ) then
                          call stdlib_drot( n, z( 1, k2 ), 1, z( 1, k2-1 ), 1, c1,s1 )
                       end if
                       if( k2<istop ) then
                          call stdlib_dlartg( a( k2, k2-1 ), a( k2+1, k2-1 ), c1,s1, temp )
                                    
                          a( k2, k2-1 ) = temp
                          a( k2+1, k2-1 ) = zero
                          call stdlib_drot( istopm-k2+1, a( k2, k2 ), lda, a( k2+1,k2 ), lda, c1, &
                                    s1 )
                          call stdlib_drot( istopm-k2+1, b( k2, k2 ), ldb, b( k2+1,k2 ), ldb, c1, &
                                    s1 )
                          if( ilq ) then
                             call stdlib_drot( n, q( 1, k2 ), 1, q( 1, k2+1 ), 1,c1, s1 )
                          end if
                       end if
                    end do
                    if( istart2<istop )then
                       call stdlib_dlartg( a( istart2, istart2 ), a( istart2+1,istart2 ), c1, s1, &
                                 temp )
                       a( istart2, istart2 ) = temp
                       a( istart2+1, istart2 ) = zero
                       call stdlib_drot( istopm-( istart2+1 )+1, a( istart2,istart2+1 ), lda, a( &
                                 istart2+1,istart2+1 ), lda, c1, s1 )
                       call stdlib_drot( istopm-( istart2+1 )+1, b( istart2,istart2+1 ), ldb, b( &
                                 istart2+1,istart2+1 ), ldb, c1, s1 )
                       if( ilq ) then
                          call stdlib_drot( n, q( 1, istart2 ), 1, q( 1,istart2+1 ), 1, c1, s1 )
                                    
                       end if
                    end if
                    istart2 = istart2+1
                 end if
                 k = k-1
              end do
              ! istart2 now points to the top of the bottom right
              ! unreduced hessenberg block
              if ( istart2 >= istop ) then
                 istop = istart2-1
                 ld = 0
                 eshift = zero
                 cycle
              end if
              nw = nwr
              nshifts = nsr
              nblock = nbr
              if ( istop-istart2+1 < nmin ) then
                 ! setting nw to the size of the subblock will make aed deflate
                 ! all the eigenvalues. this is slightly more efficient than just
                 ! using stdlib_dhgeqz because the off diagonal part gets updated via blas.
                 if ( istop-istart+1 < nmin ) then
                    nw = istop-istart+1
                    istart2 = istart
                 else
                    nw = istop-istart2+1
                 end if
              end if
              ! time for aed
              call stdlib_dlaqz3( ilschur, ilq, ilz, n, istart2, istop, nw, a, lda,b, ldb, q, ldq,&
               z, ldz, n_undeflated, n_deflated,alphar, alphai, beta, work, nw, work( nw**2+1 ),&
                         nw, work( 2*nw**2+1 ), lwork-2*nw**2, rec,aed_info )
              if ( n_deflated > 0 ) then
                 istop = istop-n_deflated
                 ld = 0
                 eshift = zero
              end if
              if ( 100*n_deflated > nibble*( n_deflated+n_undeflated ) .or.istop-istart2+1 < nmin &
                        ) then
                 ! aed has uncovered many eigenvalues. skip a qz sweep and run
                 ! aed again.
                 cycle
              end if
              ld = ld+1
              ns = min( nshifts, istop-istart2 )
              ns = min( ns, n_undeflated )
              shiftpos = istop-n_deflated-n_undeflated+1
              ! shuffle shifts to put double shifts in front
              ! this ensures that we don't split up a double shift
              do i = shiftpos, shiftpos+n_undeflated-1, 2
                 if( alphai( i )/=-alphai( i+1 ) ) then
                    swap = alphar( i )
                    alphar( i ) = alphar( i+1 )
                    alphar( i+1 ) = alphar( i+2 )
                    alphar( i+2 ) = swap
                    swap = alphai( i )
                    alphai( i ) = alphai( i+1 )
                    alphai( i+1 ) = alphai( i+2 )
                    alphai( i+2 ) = swap
                    swap = beta( i )
                    beta( i ) = beta( i+1 )
                    beta( i+1 ) = beta( i+2 )
                    beta( i+2 ) = swap
                 end if
              end do
              if ( mod( ld, 6 ) == 0 ) then
                 ! exceptional shift.  chosen for no particularly good reason.
                 if( ( real( maxit,KIND=dp)*safmin )*abs( a( istop,istop-1 ) )<abs( a( istop-1, &
                           istop-1 ) ) ) then
                    eshift = a( istop, istop-1 )/b( istop-1, istop-1 )
                 else
                    eshift = eshift+one/( safmin*real( maxit,KIND=dp) )
                 end if
                 alphar( shiftpos ) = one
                 alphar( shiftpos+1 ) = zero
                 alphai( shiftpos ) = zero
                 alphai( shiftpos+1 ) = zero
                 beta( shiftpos ) = eshift
                 beta( shiftpos+1 ) = eshift
                 ns = 2
              end if
              ! time for a qz sweep
              call stdlib_dlaqz4( ilschur, ilq, ilz, n, istart2, istop, ns, nblock,alphar( &
              shiftpos ), alphai( shiftpos ),beta( shiftpos ), a, lda, b, ldb, q, ldq, z, ldz,&
              work, nblock, work( nblock**2+1 ), nblock,work( 2*nblock**2+1 ), lwork-2*nblock**2,&
                        sweep_info )
           end do
           ! call stdlib_dhgeqz to normalize the eigenvalue blocks and set the eigenvalues
           ! if all the eigenvalues have been found, stdlib_dhgeqz will not do any iterations
           ! and only normalize the blocks. in case of a rare convergence failure,
           ! the single shift might perform better.
        80 call stdlib_dhgeqz( wants, wantq, wantz, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                  beta, q, ldq, z, ldz, work, lwork,norm_info )
           info = norm_info
     end subroutine stdlib_dlaqz0

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module recursive subroutine stdlib_${ri}$laqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, alphar, &
     !! DLAQZ0: computes the eigenvalues of a real matrix pair (H,T),
     !! where H is an upper Hessenberg matrix and T is upper triangular,
     !! using the double-shift QZ method.
     !! Matrix pairs of this type are produced by the reduction to
     !! generalized upper Hessenberg form of a real matrix pair (A,B):
     !! A = Q1*H*Z1**T,  B = Q1*T*Z1**T,
     !! as computed by DGGHRD.
     !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
     !! also reduced to generalized Schur form,
     !! H = Q*S*Z**T,  T = Q*P*Z**T,
     !! where Q and Z are orthogonal matrices, P is an upper triangular
     !! matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2
     !! diagonal blocks.
     !! The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
     !! (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of
     !! eigenvalues.
     !! Additionally, the 2-by-2 upper triangular diagonal blocks of P
     !! corresponding to 2-by-2 blocks of S are reduced to positive diagonal
     !! form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,
     !! P(j,j) > 0, and P(j+1,j+1) > 0.
     !! Optionally, the orthogonal matrix Q from the generalized Schur
     !! factorization may be postmultiplied into an input matrix Q1, and the
     !! orthogonal matrix Z may be postmultiplied into an input matrix Z1.
     !! If Q1 and Z1 are the orthogonal matrices from DGGHRD that reduced
     !! the matrix pair (A,B) to generalized upper Hessenberg form, then the
     !! output matrices Q1*Q and Z1*Z are the orthogonal factors from the
     !! generalized Schur factorization of (A,B):
     !! A = (Q1*Q)*S*(Z1*Z)**T,  B = (Q1*Q)*P*(Z1*Z)**T.
     !! To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
     !! of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
     !! complex and beta real.
     !! If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
     !! generalized nonsymmetric eigenvalue problem (GNEP)
     !! A*x = lambda*B*x
     !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     !! alternate form of the GNEP
     !! mu*A*y = B*y.
     !! Real eigenvalues can be read directly from the generalized Schur
     !! form:
     !! alpha = S(i,i), beta = P(i,i).
     !! Ref: C.B. Moler
     !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
     !! pp. 241--256.
     !! Ref: B. Kagstrom, D. Kressner, "Multishift Variants of the QZ
     !! Algorithm with Aggressive Early Deflation", SIAM J. Numer.
     !! Anal., 29(2006), pp. 199--227.
     !! Ref: T. Steel, D. Camps, K. Meerbergen, R. Vandebril "A multishift,
     !! multipole rational QZ method with agressive early deflation"
               alphai, beta,q, ldq, z, ldz, work, lwork, rec,info )
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           character, intent( in ) :: wants, wantq, wantz
           integer(ilp), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,rec
           integer(ilp), intent( out ) :: info
           real(${rk}$), intent( inout ) :: a( lda, * ), b( ldb, * ),q( ldq, * ), z( ldz, * ), alphar(&
                      * ),alphai( * ), beta( * ), work( * )
           ! ================================================================
           ! local scalars
           real(${rk}$) :: smlnum, ulp, eshift, safmin, safmax, c1, s1, temp, swap
           integer(ilp) :: istart, istop, iiter, maxit, istart2, k, ld, nshifts, nblock, nw, nmin,&
            nibble, n_undeflated, n_qeflated, ns, sweep_info, shiftpos, lworkreq, k2, istartm, &
            istopm, iwants, iwantq, iwantz, norm_info, aed_info, nwr, nbr, nsr, itemp1, itemp2, &
                      rcost, i
           logical(lk) :: ilschur, ilq, ilz
           character :: jbcmpz*3
           if( stdlib_lsame( wants, 'E' ) ) then
              ilschur = .false.
              iwants = 1
           else if( stdlib_lsame( wants, 'S' ) ) then
              ilschur = .true.
              iwants = 2
           else
              iwants = 0
           end if
           if( stdlib_lsame( wantq, 'N' ) ) then
              ilq = .false.
              iwantq = 1
           else if( stdlib_lsame( wantq, 'V' ) ) then
              ilq = .true.
              iwantq = 2
           else if( stdlib_lsame( wantq, 'I' ) ) then
              ilq = .true.
              iwantq = 3
           else
              iwantq = 0
           end if
           if( stdlib_lsame( wantz, 'N' ) ) then
              ilz = .false.
              iwantz = 1
           else if( stdlib_lsame( wantz, 'V' ) ) then
              ilz = .true.
              iwantz = 2
           else if( stdlib_lsame( wantz, 'I' ) ) then
              ilz = .true.
              iwantz = 3
           else
              iwantz = 0
           end if
           ! check argument values
           info = 0
           if( iwants==0 ) then
              info = -1
           else if( iwantq==0 ) then
              info = -2
           else if( iwantz==0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 ) then
              info = -5
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -6
           else if( lda<n ) then
              info = -8
           else if( ldb<n ) then
              info = -10
           else if( ldq<1 .or. ( ilq .and. ldq<n ) ) then
              info = -15
           else if( ldz<1 .or. ( ilz .and. ldz<n ) ) then
              info = -17
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAQZ0', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 ) then
              work( 1 ) = real( 1,KIND=${rk}$)
              return
           end if
           ! get the parameters
           jbcmpz( 1:1 ) = wants
           jbcmpz( 2:2 ) = wantq
           jbcmpz( 3:3 ) = wantz
           nmin = stdlib_ilaenv( 12, 'DLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nwr = stdlib_ilaenv( 13, 'DLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nwr = max( 2, nwr )
           nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
           nibble = stdlib_ilaenv( 14, 'DLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nsr = stdlib_ilaenv( 15, 'DLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nsr = min( nsr, ( n+6 ) / 9, ihi-ilo )
           nsr = max( 2, nsr-mod( nsr, 2 ) )
           rcost = stdlib_ilaenv( 17, 'DLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           itemp1 = int( nsr/sqrt( 1+2*nsr/( real( rcost,KIND=${rk}$)/100*n ) ),KIND=ilp)
           itemp1 = ( ( itemp1-1 )/4 )*4+4
           nbr = nsr+itemp1
           if( n < nmin .or. rec >= 2 ) then
              call stdlib_${ri}$hgeqz( wants, wantq, wantz, n, ilo, ihi, a, lda, b, ldb,alphar, alphai,&
                         beta, q, ldq, z, ldz, work,lwork, info )
              return
           end if
           ! find out required workspace
           ! workspace query to stdlib_${ri}$laqz3
           nw = max( nwr, nmin )
           call stdlib_${ri}$laqz3( ilschur, ilq, ilz, n, ilo, ihi, nw, a, lda, b, ldb,q, ldq, z, ldz, &
           n_undeflated, n_qeflated, alphar,alphai, beta, work, nw, work, nw, work, -1, rec,&
                     aed_info )
           itemp1 = int( work( 1 ),KIND=ilp)
           ! workspace query to stdlib_${ri}$laqz4
           call stdlib_${ri}$laqz4( ilschur, ilq, ilz, n, ilo, ihi, nsr, nbr, alphar,alphai, beta, a, &
                     lda, b, ldb, q, ldq, z, ldz, work,nbr, work, nbr, work, -1, sweep_info )
           itemp2 = int( work( 1 ),KIND=ilp)
           lworkreq = max( itemp1+2*nw**2, itemp2+2*nbr**2 )
           if ( lwork ==-1 ) then
              work( 1 ) = real( lworkreq,KIND=${rk}$)
              return
           else if ( lwork < lworkreq ) then
              info = -19
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAQZ0', info )
              return
           end if
           ! initialize q and z
           if( iwantq==3 ) call stdlib_${ri}$laset( 'FULL', n, n, zero, one, q, ldq )
           if( iwantz==3 ) call stdlib_${ri}$laset( 'FULL', n, n, zero, one, z, ldz )
           ! get machine constants
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_${ri}$labad( safmin, safmax )
           ulp = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=${rk}$)/ulp )
           istart = ilo
           istop = ihi
           maxit = 3*( ihi-ilo+1 )
           ld = 0
           do iiter = 1, maxit
              if( iiter >= maxit ) then
                 info = istop+1
                 goto 80
              end if
              if ( istart+1 >= istop ) then
                 istop = istart
                 exit
              end if
              ! check deflations at the end
              if ( abs( a( istop-1, istop-2 ) ) <= max( smlnum,ulp*( abs( a( istop-1, istop-1 ) )+&
                        abs( a( istop-2,istop-2 ) ) ) ) ) then
                 a( istop-1, istop-2 ) = zero
                 istop = istop-2
                 ld = 0
                 eshift = zero
              else if ( abs( a( istop, istop-1 ) ) <= max( smlnum,ulp*( abs( a( istop, istop ) )+&
                        abs( a( istop-1,istop-1 ) ) ) ) ) then
                 a( istop, istop-1 ) = zero
                 istop = istop-1
                 ld = 0
                 eshift = zero
              end if
              ! check deflations at the start
              if ( abs( a( istart+2, istart+1 ) ) <= max( smlnum,ulp*( abs( a( istart+1, istart+1 &
                        ) )+abs( a( istart+2,istart+2 ) ) ) ) ) then
                 a( istart+2, istart+1 ) = zero
                 istart = istart+2
                 ld = 0
                 eshift = zero
              else if ( abs( a( istart+1, istart ) ) <= max( smlnum,ulp*( abs( a( istart, istart )&
                         )+abs( a( istart+1,istart+1 ) ) ) ) ) then
                 a( istart+1, istart ) = zero
                 istart = istart+1
                 ld = 0
                 eshift = zero
              end if
              if ( istart+1 >= istop ) then
                 exit
              end if
              ! check interior deflations
              istart2 = istart
              do k = istop, istart+1, -1
                 if ( abs( a( k, k-1 ) ) <= max( smlnum, ulp*( abs( a( k,k ) )+abs( a( k-1, k-1 ) &
                           ) ) ) ) then
                    a( k, k-1 ) = zero
                    istart2 = k
                    exit
                 end if
              end do
              ! get range to apply rotations to
              if ( ilschur ) then
                 istartm = 1
                 istopm = n
              else
                 istartm = istart2
                 istopm = istop
              end if
              ! check infinite eigenvalues, this is done without blocking so might
              ! slow down the method when many infinite eigenvalues are present
              k = istop
              do while ( k>=istart2 )
                 temp = zero
                 if( k < istop ) then
                    temp = temp+abs( b( k, k+1 ) )
                 end if
                 if( k > istart2 ) then
                    temp = temp+abs( b( k-1, k ) )
                 end if
                 if( abs( b( k, k ) ) < max( smlnum, ulp*temp ) ) then
                    ! a diagonal element of b is negligable, move it
                    ! to the top and deflate it
                    do k2 = k, istart2+1, -1
                       call stdlib_${ri}$lartg( b( k2-1, k2 ), b( k2-1, k2-1 ), c1, s1,temp )
                       b( k2-1, k2 ) = temp
                       b( k2-1, k2-1 ) = zero
                       call stdlib_${ri}$rot( k2-2-istartm+1, b( istartm, k2 ), 1,b( istartm, k2-1 ), &
                                 1, c1, s1 )
                       call stdlib_${ri}$rot( min( k2+1, istop )-istartm+1, a( istartm,k2 ), 1, a( &
                                 istartm, k2-1 ), 1, c1, s1 )
                       if ( ilz ) then
                          call stdlib_${ri}$rot( n, z( 1, k2 ), 1, z( 1, k2-1 ), 1, c1,s1 )
                       end if
                       if( k2<istop ) then
                          call stdlib_${ri}$lartg( a( k2, k2-1 ), a( k2+1, k2-1 ), c1,s1, temp )
                                    
                          a( k2, k2-1 ) = temp
                          a( k2+1, k2-1 ) = zero
                          call stdlib_${ri}$rot( istopm-k2+1, a( k2, k2 ), lda, a( k2+1,k2 ), lda, c1, &
                                    s1 )
                          call stdlib_${ri}$rot( istopm-k2+1, b( k2, k2 ), ldb, b( k2+1,k2 ), ldb, c1, &
                                    s1 )
                          if( ilq ) then
                             call stdlib_${ri}$rot( n, q( 1, k2 ), 1, q( 1, k2+1 ), 1,c1, s1 )
                          end if
                       end if
                    end do
                    if( istart2<istop )then
                       call stdlib_${ri}$lartg( a( istart2, istart2 ), a( istart2+1,istart2 ), c1, s1, &
                                 temp )
                       a( istart2, istart2 ) = temp
                       a( istart2+1, istart2 ) = zero
                       call stdlib_${ri}$rot( istopm-( istart2+1 )+1, a( istart2,istart2+1 ), lda, a( &
                                 istart2+1,istart2+1 ), lda, c1, s1 )
                       call stdlib_${ri}$rot( istopm-( istart2+1 )+1, b( istart2,istart2+1 ), ldb, b( &
                                 istart2+1,istart2+1 ), ldb, c1, s1 )
                       if( ilq ) then
                          call stdlib_${ri}$rot( n, q( 1, istart2 ), 1, q( 1,istart2+1 ), 1, c1, s1 )
                                    
                       end if
                    end if
                    istart2 = istart2+1
                 end if
                 k = k-1
              end do
              ! istart2 now points to the top of the bottom right
              ! unreduced hessenberg block
              if ( istart2 >= istop ) then
                 istop = istart2-1
                 ld = 0
                 eshift = zero
                 cycle
              end if
              nw = nwr
              nshifts = nsr
              nblock = nbr
              if ( istop-istart2+1 < nmin ) then
                 ! setting nw to the size of the subblock will make aed deflate
                 ! all the eigenvalues. this is slightly more efficient than just
                 ! using stdlib_${ri}$hgeqz because the off diagonal part gets updated via blas.
                 if ( istop-istart+1 < nmin ) then
                    nw = istop-istart+1
                    istart2 = istart
                 else
                    nw = istop-istart2+1
                 end if
              end if
              ! time for aed
              call stdlib_${ri}$laqz3( ilschur, ilq, ilz, n, istart2, istop, nw, a, lda,b, ldb, q, ldq,&
               z, ldz, n_undeflated, n_qeflated,alphar, alphai, beta, work, nw, work( nw**2+1 ),&
                         nw, work( 2*nw**2+1 ), lwork-2*nw**2, rec,aed_info )
              if ( n_qeflated > 0 ) then
                 istop = istop-n_qeflated
                 ld = 0
                 eshift = zero
              end if
              if ( 100*n_qeflated > nibble*( n_qeflated+n_undeflated ) .or.istop-istart2+1 < nmin &
                        ) then
                 ! aed has uncovered many eigenvalues. skip a qz sweep and run
                 ! aed again.
                 cycle
              end if
              ld = ld+1
              ns = min( nshifts, istop-istart2 )
              ns = min( ns, n_undeflated )
              shiftpos = istop-n_qeflated-n_undeflated+1
              ! shuffle shifts to put double shifts in front
              ! this ensures that we don't split up a double shift
              do i = shiftpos, shiftpos+n_undeflated-1, 2
                 if( alphai( i )/=-alphai( i+1 ) ) then
                    swap = alphar( i )
                    alphar( i ) = alphar( i+1 )
                    alphar( i+1 ) = alphar( i+2 )
                    alphar( i+2 ) = swap
                    swap = alphai( i )
                    alphai( i ) = alphai( i+1 )
                    alphai( i+1 ) = alphai( i+2 )
                    alphai( i+2 ) = swap
                    swap = beta( i )
                    beta( i ) = beta( i+1 )
                    beta( i+1 ) = beta( i+2 )
                    beta( i+2 ) = swap
                 end if
              end do
              if ( mod( ld, 6 ) == 0 ) then
                 ! exceptional shift.  chosen for no particularly good reason.
                 if( ( real( maxit,KIND=${rk}$)*safmin )*abs( a( istop,istop-1 ) )<abs( a( istop-1, &
                           istop-1 ) ) ) then
                    eshift = a( istop, istop-1 )/b( istop-1, istop-1 )
                 else
                    eshift = eshift+one/( safmin*real( maxit,KIND=${rk}$) )
                 end if
                 alphar( shiftpos ) = one
                 alphar( shiftpos+1 ) = zero
                 alphai( shiftpos ) = zero
                 alphai( shiftpos+1 ) = zero
                 beta( shiftpos ) = eshift
                 beta( shiftpos+1 ) = eshift
                 ns = 2
              end if
              ! time for a qz sweep
              call stdlib_${ri}$laqz4( ilschur, ilq, ilz, n, istart2, istop, ns, nblock,alphar( &
              shiftpos ), alphai( shiftpos ),beta( shiftpos ), a, lda, b, ldb, q, ldq, z, ldz,&
              work, nblock, work( nblock**2+1 ), nblock,work( 2*nblock**2+1 ), lwork-2*nblock**2,&
                        sweep_info )
           end do
           ! call stdlib_${ri}$hgeqz to normalize the eigenvalue blocks and set the eigenvalues
           ! if all the eigenvalues have been found, stdlib_${ri}$hgeqz will not do any iterations
           ! and only normalize the blocks. in case of a rare convergence failure,
           ! the single shift might perform better.
        80 call stdlib_${ri}$hgeqz( wants, wantq, wantz, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                  beta, q, ldq, z, ldz, work, lwork,norm_info )
           info = norm_info
     end subroutine stdlib_${ri}$laqz0

#:endif
#:endfor

     module recursive subroutine stdlib_claqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, alpha, &
     !! CLAQZ0 computes the eigenvalues of a matrix pair (H,T),
     !! where H is an upper Hessenberg matrix and T is upper triangular,
     !! using the double-shift QZ method.
     !! Matrix pairs of this type are produced by the reduction to
     !! generalized upper Hessenberg form of a matrix pair (A,B):
     !! A = Q1*H*Z1**H,  B = Q1*T*Z1**H,
     !! as computed by CGGHRD.
     !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
     !! also reduced to generalized Schur form,
     !! H = Q*S*Z**H,  T = Q*P*Z**H,
     !! where Q and Z are unitary matrices, P and S are an upper triangular
     !! matrices.
     !! Optionally, the unitary matrix Q from the generalized Schur
     !! factorization may be postmultiplied into an input matrix Q1, and the
     !! unitary matrix Z may be postmultiplied into an input matrix Z1.
     !! If Q1 and Z1 are the unitary matrices from CGGHRD that reduced
     !! the matrix pair (A,B) to generalized upper Hessenberg form, then the
     !! output matrices Q1*Q and Z1*Z are the unitary factors from the
     !! generalized Schur factorization of (A,B):
     !! A = (Q1*Q)*S*(Z1*Z)**H,  B = (Q1*Q)*P*(Z1*Z)**H.
     !! To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
     !! of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
     !! complex and beta real.
     !! If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
     !! generalized nonsymmetric eigenvalue problem (GNEP)
     !! A*x = lambda*B*x
     !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     !! alternate form of the GNEP
     !! mu*A*y = B*y.
     !! Eigenvalues can be read directly from the generalized Schur
     !! form:
     !! alpha = S(i,i), beta = P(i,i).
     !! Ref: C.B. Moler
     !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
     !! pp. 241--256.
     !! Ref: B. Kagstrom, D. Kressner, "Multishift Variants of the QZ
     !! Algorithm with Aggressive Early Deflation", SIAM J. Numer.
     !! Anal., 29(2006), pp. 199--227.
     !! Ref: T. Steel, D. Camps, K. Meerbergen, R. Vandebril "A multishift,
     !! multipole rational QZ method with agressive early deflation"
               beta, q, ldq, z,ldz, work, lwork, rwork, rec,info )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           character, intent( in ) :: wants, wantq, wantz
           integer(ilp), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,rec
           integer(ilp), intent( out ) :: info
           complex(sp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq, * ),z( ldz, * ), &
                     alpha( * ), beta( * ), work( * )
           real(sp), intent( out ) :: rwork( * )
           
           ! ================================================================
           ! local scalars
           real(sp) :: smlnum, ulp, safmin, safmax, c1, tempr
           complex(sp) :: eshift, s1, temp
           integer(ilp) :: istart, istop, iiter, maxit, istart2, k, ld, nshifts, nblock, nw, nmin,&
            nibble, n_undeflated, n_deflated, ns, sweep_info, shiftpos, lworkreq, k2, istartm, &
            istopm, iwants, iwantq, iwantz, norm_info, aed_info, nwr, nbr, nsr, itemp1, itemp2, &
                      rcost
           logical(lk) :: ilschur, ilq, ilz
           character :: jbcmpz*3
           if( stdlib_lsame( wants, 'E' ) ) then
              ilschur = .false.
              iwants = 1
           else if( stdlib_lsame( wants, 'S' ) ) then
              ilschur = .true.
              iwants = 2
           else
              iwants = 0
           end if
           if( stdlib_lsame( wantq, 'N' ) ) then
              ilq = .false.
              iwantq = 1
           else if( stdlib_lsame( wantq, 'V' ) ) then
              ilq = .true.
              iwantq = 2
           else if( stdlib_lsame( wantq, 'I' ) ) then
              ilq = .true.
              iwantq = 3
           else
              iwantq = 0
           end if
           if( stdlib_lsame( wantz, 'N' ) ) then
              ilz = .false.
              iwantz = 1
           else if( stdlib_lsame( wantz, 'V' ) ) then
              ilz = .true.
              iwantz = 2
           else if( stdlib_lsame( wantz, 'I' ) ) then
              ilz = .true.
              iwantz = 3
           else
              iwantz = 0
           end if
           ! check argument values
           info = 0
           if( iwants==0 ) then
              info = -1
           else if( iwantq==0 ) then
              info = -2
           else if( iwantz==0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 ) then
              info = -5
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -6
           else if( lda<n ) then
              info = -8
           else if( ldb<n ) then
              info = -10
           else if( ldq<1 .or. ( ilq .and. ldq<n ) ) then
              info = -15
           else if( ldz<1 .or. ( ilz .and. ldz<n ) ) then
              info = -17
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLAQZ0', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 ) then
              work( 1 ) = real( 1,KIND=sp)
              return
           end if
           ! get the parameters
           jbcmpz( 1:1 ) = wants
           jbcmpz( 2:2 ) = wantq
           jbcmpz( 3:3 ) = wantz
           nmin = stdlib_ilaenv( 12, 'CLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nwr = stdlib_ilaenv( 13, 'CLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nwr = max( 2, nwr )
           nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
           nibble = stdlib_ilaenv( 14, 'CLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nsr = stdlib_ilaenv( 15, 'CLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nsr = min( nsr, ( n+6 ) / 9, ihi-ilo )
           nsr = max( 2, nsr-mod( nsr, 2 ) )
           rcost = stdlib_ilaenv( 17, 'CLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           itemp1 = int( nsr/sqrt( 1+2*nsr/( real( rcost,KIND=sp)/100*n ) ),KIND=ilp)
           itemp1 = ( ( itemp1-1 )/4 )*4+4
           nbr = nsr+itemp1
           if( n < nmin .or. rec >= 2 ) then
              call stdlib_chgeqz( wants, wantq, wantz, n, ilo, ihi, a, lda, b, ldb,alpha, beta, q,&
                         ldq, z, ldz, work, lwork, rwork,info )
              return
           end if
           ! find out required workspace
           ! workspace query to stdlib_claqz2
           nw = max( nwr, nmin )
           call stdlib_claqz2( ilschur, ilq, ilz, n, ilo, ihi, nw, a, lda, b, ldb,q, ldq, z, ldz, &
           n_undeflated, n_deflated, alpha,beta, work, nw, work, nw, work, -1, rwork, rec,&
                     aed_info )
           itemp1 = int( work( 1 ),KIND=ilp)
           ! workspace query to stdlib_claqz3
           call stdlib_claqz3( ilschur, ilq, ilz, n, ilo, ihi, nsr, nbr, alpha,beta, a, lda, b, &
                     ldb, q, ldq, z, ldz, work, nbr,work, nbr, work, -1, sweep_info )
           itemp2 = int( work( 1 ),KIND=ilp)
           lworkreq = max( itemp1+2*nw**2, itemp2+2*nbr**2 )
           if ( lwork ==-1 ) then
              work( 1 ) = real( lworkreq,KIND=sp)
              return
           else if ( lwork < lworkreq ) then
              info = -19
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLAQZ0', info )
              return
           end if
           ! initialize q and z
           if( iwantq==3 ) call stdlib_claset( 'FULL', n, n, czero, cone, q,ldq )
           if( iwantz==3 ) call stdlib_claset( 'FULL', n, n, czero, cone, z,ldz )
           ! get machine constants
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=sp)/ulp )
           istart = ilo
           istop = ihi
           maxit = 30*( ihi-ilo+1 )
           ld = 0
           do iiter = 1, maxit
              if( iiter >= maxit ) then
                 info = istop+1
                 goto 80
              end if
              if ( istart+1 >= istop ) then
                 istop = istart
                 exit
              end if
              ! check deflations at the end
              if ( abs( a( istop, istop-1 ) ) <= max( smlnum,ulp*( abs( a( istop, istop ) )+abs( &
                        a( istop-1,istop-1 ) ) ) ) ) then
                 a( istop, istop-1 ) = czero
                 istop = istop-1
                 ld = 0
                 eshift = czero
              end if
              ! check deflations at the start
              if ( abs( a( istart+1, istart ) ) <= max( smlnum,ulp*( abs( a( istart, istart ) )+&
                        abs( a( istart+1,istart+1 ) ) ) ) ) then
                 a( istart+1, istart ) = czero
                 istart = istart+1
                 ld = 0
                 eshift = czero
              end if
              if ( istart+1 >= istop ) then
                 exit
              end if
              ! check interior deflations
              istart2 = istart
              do k = istop, istart+1, -1
                 if ( abs( a( k, k-1 ) ) <= max( smlnum, ulp*( abs( a( k,k ) )+abs( a( k-1, k-1 ) &
                           ) ) ) ) then
                    a( k, k-1 ) = czero
                    istart2 = k
                    exit
                 end if
              end do
              ! get range to apply rotations to
              if ( ilschur ) then
                 istartm = 1
                 istopm = n
              else
                 istartm = istart2
                 istopm = istop
              end if
              ! check infinite eigenvalues, this is done without blocking so might
              ! slow down the method when many infinite eigenvalues are present
              k = istop
              do while ( k>=istart2 )
                 tempr = zero
                 if( k < istop ) then
                    tempr = tempr+abs( b( k, k+1 ) )
                 end if
                 if( k > istart2 ) then
                    tempr = tempr+abs( b( k-1, k ) )
                 end if
                 if( abs( b( k, k ) ) < max( smlnum, ulp*tempr ) ) then
                    ! a diagonal element of b is negligable, move it
                    ! to the top and deflate it
                    do k2 = k, istart2+1, -1
                       call stdlib_clartg( b( k2-1, k2 ), b( k2-1, k2-1 ), c1, s1,temp )
                       b( k2-1, k2 ) = temp
                       b( k2-1, k2-1 ) = czero
                       call stdlib_crot( k2-2-istartm+1, b( istartm, k2 ), 1,b( istartm, k2-1 ), &
                                 1, c1, s1 )
                       call stdlib_crot( min( k2+1, istop )-istartm+1, a( istartm,k2 ), 1, a( &
                                 istartm, k2-1 ), 1, c1, s1 )
                       if ( ilz ) then
                          call stdlib_crot( n, z( 1, k2 ), 1, z( 1, k2-1 ), 1, c1,s1 )
                       end if
                       if( k2<istop ) then
                          call stdlib_clartg( a( k2, k2-1 ), a( k2+1, k2-1 ), c1,s1, temp )
                                    
                          a( k2, k2-1 ) = temp
                          a( k2+1, k2-1 ) = czero
                          call stdlib_crot( istopm-k2+1, a( k2, k2 ), lda, a( k2+1,k2 ), lda, c1, &
                                    s1 )
                          call stdlib_crot( istopm-k2+1, b( k2, k2 ), ldb, b( k2+1,k2 ), ldb, c1, &
                                    s1 )
                          if( ilq ) then
                             call stdlib_crot( n, q( 1, k2 ), 1, q( 1, k2+1 ), 1,c1, conjg( s1 ) )
                                       
                          end if
                       end if
                    end do
                    if( istart2<istop )then
                       call stdlib_clartg( a( istart2, istart2 ), a( istart2+1,istart2 ), c1, s1, &
                                 temp )
                       a( istart2, istart2 ) = temp
                       a( istart2+1, istart2 ) = czero
                       call stdlib_crot( istopm-( istart2+1 )+1, a( istart2,istart2+1 ), lda, a( &
                                 istart2+1,istart2+1 ), lda, c1, s1 )
                       call stdlib_crot( istopm-( istart2+1 )+1, b( istart2,istart2+1 ), ldb, b( &
                                 istart2+1,istart2+1 ), ldb, c1, s1 )
                       if( ilq ) then
                          call stdlib_crot( n, q( 1, istart2 ), 1, q( 1,istart2+1 ), 1, c1, conjg(&
                                     s1 ) )
                       end if
                    end if
                    istart2 = istart2+1
                 end if
                 k = k-1
              end do
              ! istart2 now points to the top of the bottom right
              ! unreduced hessenberg block
              if ( istart2 >= istop ) then
                 istop = istart2-1
                 ld = 0
                 eshift = czero
                 cycle
              end if
              nw = nwr
              nshifts = nsr
              nblock = nbr
              if ( istop-istart2+1 < nmin ) then
                 ! setting nw to the size of the subblock will make aed deflate
                 ! all the eigenvalues. this is slightly more efficient than just
                 ! using stdlib_chgeqz because the off diagonal part gets updated via blas.
                 if ( istop-istart+1 < nmin ) then
                    nw = istop-istart+1
                    istart2 = istart
                 else
                    nw = istop-istart2+1
                 end if
              end if
              ! time for aed
              call stdlib_claqz2( ilschur, ilq, ilz, n, istart2, istop, nw, a, lda,b, ldb, q, ldq,&
               z, ldz, n_undeflated, n_deflated,alpha, beta, work, nw, work( nw**2+1 ), nw,work( &
                         2*nw**2+1 ), lwork-2*nw**2, rwork, rec,aed_info )
              if ( n_deflated > 0 ) then
                 istop = istop-n_deflated
                 ld = 0
                 eshift = czero
              end if
              if ( 100*n_deflated > nibble*( n_deflated+n_undeflated ) .or.istop-istart2+1 < nmin &
                        ) then
                 ! aed has uncovered many eigenvalues. skip a qz sweep and run
                 ! aed again.
                 cycle
              end if
              ld = ld+1
              ns = min( nshifts, istop-istart2 )
              ns = min( ns, n_undeflated )
              shiftpos = istop-n_deflated-n_undeflated+1
              if ( mod( ld, 6 ) == 0 ) then
                 ! exceptional shift.  chosen for no particularly good reason.
                 if( ( real( maxit,KIND=sp)*safmin )*abs( a( istop,istop-1 ) )<abs( a( istop-1, &
                           istop-1 ) ) ) then
                    eshift = a( istop, istop-1 )/b( istop-1, istop-1 )
                 else
                    eshift = eshift+cone/( safmin*real( maxit,KIND=sp) )
                 end if
                 alpha( shiftpos ) = cone
                 beta( shiftpos ) = eshift
                 ns = 1
              end if
              ! time for a qz sweep
              call stdlib_claqz3( ilschur, ilq, ilz, n, istart2, istop, ns, nblock,alpha( &
              shiftpos ), beta( shiftpos ), a, lda, b,ldb, q, ldq, z, ldz, work, nblock, work( &
                        nblock**2+1 ), nblock, work( 2*nblock**2+1 ),lwork-2*nblock**2, sweep_info )
           end do
           ! call stdlib_chgeqz to normalize the eigenvalue blocks and set the eigenvalues
           ! if all the eigenvalues have been found, stdlib_chgeqz will not do any iterations
           ! and only normalize the blocks. in case of a rare convergence failure,
           ! the single shift might perform better.
        80 call stdlib_chgeqz( wants, wantq, wantz, n, ilo, ihi, a, lda, b, ldb,alpha, beta, q, &
                  ldq, z, ldz, work, lwork, rwork,norm_info )
           info = norm_info
     end subroutine stdlib_claqz0

     module recursive subroutine stdlib_zlaqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, alpha, &
     !! ZLAQZ0 computes the eigenvalues of a real matrix pair (H,T),
     !! where H is an upper Hessenberg matrix and T is upper triangular,
     !! using the double-shift QZ method.
     !! Matrix pairs of this type are produced by the reduction to
     !! generalized upper Hessenberg form of a real matrix pair (A,B):
     !! A = Q1*H*Z1**H,  B = Q1*T*Z1**H,
     !! as computed by ZGGHRD.
     !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
     !! also reduced to generalized Schur form,
     !! H = Q*S*Z**H,  T = Q*P*Z**H,
     !! where Q and Z are unitary matrices, P and S are an upper triangular
     !! matrices.
     !! Optionally, the unitary matrix Q from the generalized Schur
     !! factorization may be postmultiplied into an input matrix Q1, and the
     !! unitary matrix Z may be postmultiplied into an input matrix Z1.
     !! If Q1 and Z1 are the unitary matrices from ZGGHRD that reduced
     !! the matrix pair (A,B) to generalized upper Hessenberg form, then the
     !! output matrices Q1*Q and Z1*Z are the unitary factors from the
     !! generalized Schur factorization of (A,B):
     !! A = (Q1*Q)*S*(Z1*Z)**H,  B = (Q1*Q)*P*(Z1*Z)**H.
     !! To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
     !! of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
     !! complex and beta real.
     !! If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
     !! generalized nonsymmetric eigenvalue problem (GNEP)
     !! A*x = lambda*B*x
     !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     !! alternate form of the GNEP
     !! mu*A*y = B*y.
     !! Eigenvalues can be read directly from the generalized Schur
     !! form:
     !! alpha = S(i,i), beta = P(i,i).
     !! Ref: C.B. Moler
     !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
     !! pp. 241--256.
     !! Ref: B. Kagstrom, D. Kressner, "Multishift Variants of the QZ
     !! Algorithm with Aggressive Early Deflation", SIAM J. Numer.
     !! Anal., 29(2006), pp. 199--227.
     !! Ref: T. Steel, D. Camps, K. Meerbergen, R. Vandebril "A multishift,
     !! multipole rational QZ method with agressive early deflation"
               beta, q, ldq, z,ldz, work, lwork, rwork, rec,info )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           character, intent( in ) :: wants, wantq, wantz
           integer(ilp), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,rec
           integer(ilp), intent( out ) :: info
           complex(dp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq,* ), z( ldz, * ), &
                     alpha( * ), beta( * ), work( * )
           real(dp), intent( out ) :: rwork( * )
           
           ! ================================================================
           ! local scalars
           real(dp) :: smlnum, ulp, safmin, safmax, c1, tempr
           complex(dp) :: eshift, s1, temp
           integer(ilp) :: istart, istop, iiter, maxit, istart2, k, ld, nshifts, nblock, nw, nmin,&
            nibble, n_undeflated, n_deflated, ns, sweep_info, shiftpos, lworkreq, k2, istartm, &
            istopm, iwants, iwantq, iwantz, norm_info, aed_info, nwr, nbr, nsr, itemp1, itemp2, &
                      rcost
           logical(lk) :: ilschur, ilq, ilz
           character :: jbcmpz*3
           if( stdlib_lsame( wants, 'E' ) ) then
              ilschur = .false.
              iwants = 1
           else if( stdlib_lsame( wants, 'S' ) ) then
              ilschur = .true.
              iwants = 2
           else
              iwants = 0
           end if
           if( stdlib_lsame( wantq, 'N' ) ) then
              ilq = .false.
              iwantq = 1
           else if( stdlib_lsame( wantq, 'V' ) ) then
              ilq = .true.
              iwantq = 2
           else if( stdlib_lsame( wantq, 'I' ) ) then
              ilq = .true.
              iwantq = 3
           else
              iwantq = 0
           end if
           if( stdlib_lsame( wantz, 'N' ) ) then
              ilz = .false.
              iwantz = 1
           else if( stdlib_lsame( wantz, 'V' ) ) then
              ilz = .true.
              iwantz = 2
           else if( stdlib_lsame( wantz, 'I' ) ) then
              ilz = .true.
              iwantz = 3
           else
              iwantz = 0
           end if
           ! check argument values
           info = 0
           if( iwants==0 ) then
              info = -1
           else if( iwantq==0 ) then
              info = -2
           else if( iwantz==0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 ) then
              info = -5
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -6
           else if( lda<n ) then
              info = -8
           else if( ldb<n ) then
              info = -10
           else if( ldq<1 .or. ( ilq .and. ldq<n ) ) then
              info = -15
           else if( ldz<1 .or. ( ilz .and. ldz<n ) ) then
              info = -17
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZLAQZ0', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 ) then
              work( 1 ) = real( 1,KIND=dp)
              return
           end if
           ! get the parameters
           jbcmpz( 1:1 ) = wants
           jbcmpz( 2:2 ) = wantq
           jbcmpz( 3:3 ) = wantz
           nmin = stdlib_ilaenv( 12, 'ZLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nwr = stdlib_ilaenv( 13, 'ZLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nwr = max( 2, nwr )
           nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
           nibble = stdlib_ilaenv( 14, 'ZLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nsr = stdlib_ilaenv( 15, 'ZLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nsr = min( nsr, ( n+6 ) / 9, ihi-ilo )
           nsr = max( 2, nsr-mod( nsr, 2 ) )
           rcost = stdlib_ilaenv( 17, 'ZLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           itemp1 = int( nsr/sqrt( 1+2*nsr/( real( rcost,KIND=dp)/100*n ) ),KIND=ilp)
           itemp1 = ( ( itemp1-1 )/4 )*4+4
           nbr = nsr+itemp1
           if( n < nmin .or. rec >= 2 ) then
              call stdlib_zhgeqz( wants, wantq, wantz, n, ilo, ihi, a, lda, b, ldb,alpha, beta, q,&
                         ldq, z, ldz, work, lwork, rwork,info )
              return
           end if
           ! find out required workspace
           ! workspace query to stdlib_zlaqz2
           nw = max( nwr, nmin )
           call stdlib_zlaqz2( ilschur, ilq, ilz, n, ilo, ihi, nw, a, lda, b, ldb,q, ldq, z, ldz, &
           n_undeflated, n_deflated, alpha,beta, work, nw, work, nw, work, -1, rwork, rec,&
                     aed_info )
           itemp1 = int( work( 1 ),KIND=ilp)
           ! workspace query to stdlib_zlaqz3
           call stdlib_zlaqz3( ilschur, ilq, ilz, n, ilo, ihi, nsr, nbr, alpha,beta, a, lda, b, &
                     ldb, q, ldq, z, ldz, work, nbr,work, nbr, work, -1, sweep_info )
           itemp2 = int( work( 1 ),KIND=ilp)
           lworkreq = max( itemp1+2*nw**2, itemp2+2*nbr**2 )
           if ( lwork ==-1 ) then
              work( 1 ) = real( lworkreq,KIND=dp)
              return
           else if ( lwork < lworkreq ) then
              info = -19
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZLAQZ0', info )
              return
           end if
           ! initialize q and z
           if( iwantq==3 ) call stdlib_zlaset( 'FULL', n, n, czero, cone, q,ldq )
           if( iwantz==3 ) call stdlib_zlaset( 'FULL', n, n, czero, cone, z,ldz )
           ! get machine constants
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_dlabad( safmin, safmax )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=dp)/ulp )
           istart = ilo
           istop = ihi
           maxit = 30*( ihi-ilo+1 )
           ld = 0
           do iiter = 1, maxit
              if( iiter >= maxit ) then
                 info = istop+1
                 goto 80
              end if
              if ( istart+1 >= istop ) then
                 istop = istart
                 exit
              end if
              ! check deflations at the end
              if ( abs( a( istop, istop-1 ) ) <= max( smlnum,ulp*( abs( a( istop, istop ) )+abs( &
                        a( istop-1,istop-1 ) ) ) ) ) then
                 a( istop, istop-1 ) = czero
                 istop = istop-1
                 ld = 0
                 eshift = czero
              end if
              ! check deflations at the start
              if ( abs( a( istart+1, istart ) ) <= max( smlnum,ulp*( abs( a( istart, istart ) )+&
                        abs( a( istart+1,istart+1 ) ) ) ) ) then
                 a( istart+1, istart ) = czero
                 istart = istart+1
                 ld = 0
                 eshift = czero
              end if
              if ( istart+1 >= istop ) then
                 exit
              end if
              ! check interior deflations
              istart2 = istart
              do k = istop, istart+1, -1
                 if ( abs( a( k, k-1 ) ) <= max( smlnum, ulp*( abs( a( k,k ) )+abs( a( k-1, k-1 ) &
                           ) ) ) ) then
                    a( k, k-1 ) = czero
                    istart2 = k
                    exit
                 end if
              end do
              ! get range to apply rotations to
              if ( ilschur ) then
                 istartm = 1
                 istopm = n
              else
                 istartm = istart2
                 istopm = istop
              end if
              ! check infinite eigenvalues, this is done without blocking so might
              ! slow down the method when many infinite eigenvalues are present
              k = istop
              do while ( k>=istart2 )
                 tempr = zero
                 if( k < istop ) then
                    tempr = tempr+abs( b( k, k+1 ) )
                 end if
                 if( k > istart2 ) then
                    tempr = tempr+abs( b( k-1, k ) )
                 end if
                 if( abs( b( k, k ) ) < max( smlnum, ulp*tempr ) ) then
                    ! a diagonal element of b is negligable, move it
                    ! to the top and deflate it
                    do k2 = k, istart2+1, -1
                       call stdlib_zlartg( b( k2-1, k2 ), b( k2-1, k2-1 ), c1, s1,temp )
                       b( k2-1, k2 ) = temp
                       b( k2-1, k2-1 ) = czero
                       call stdlib_zrot( k2-2-istartm+1, b( istartm, k2 ), 1,b( istartm, k2-1 ), &
                                 1, c1, s1 )
                       call stdlib_zrot( min( k2+1, istop )-istartm+1, a( istartm,k2 ), 1, a( &
                                 istartm, k2-1 ), 1, c1, s1 )
                       if ( ilz ) then
                          call stdlib_zrot( n, z( 1, k2 ), 1, z( 1, k2-1 ), 1, c1,s1 )
                       end if
                       if( k2<istop ) then
                          call stdlib_zlartg( a( k2, k2-1 ), a( k2+1, k2-1 ), c1,s1, temp )
                                    
                          a( k2, k2-1 ) = temp
                          a( k2+1, k2-1 ) = czero
                          call stdlib_zrot( istopm-k2+1, a( k2, k2 ), lda, a( k2+1,k2 ), lda, c1, &
                                    s1 )
                          call stdlib_zrot( istopm-k2+1, b( k2, k2 ), ldb, b( k2+1,k2 ), ldb, c1, &
                                    s1 )
                          if( ilq ) then
                             call stdlib_zrot( n, q( 1, k2 ), 1, q( 1, k2+1 ), 1,c1, conjg( s1 ) )
                                       
                          end if
                       end if
                    end do
                    if( istart2<istop )then
                       call stdlib_zlartg( a( istart2, istart2 ), a( istart2+1,istart2 ), c1, s1, &
                                 temp )
                       a( istart2, istart2 ) = temp
                       a( istart2+1, istart2 ) = czero
                       call stdlib_zrot( istopm-( istart2+1 )+1, a( istart2,istart2+1 ), lda, a( &
                                 istart2+1,istart2+1 ), lda, c1, s1 )
                       call stdlib_zrot( istopm-( istart2+1 )+1, b( istart2,istart2+1 ), ldb, b( &
                                 istart2+1,istart2+1 ), ldb, c1, s1 )
                       if( ilq ) then
                          call stdlib_zrot( n, q( 1, istart2 ), 1, q( 1,istart2+1 ), 1, c1, conjg(&
                                     s1 ) )
                       end if
                    end if
                    istart2 = istart2+1
                 end if
                 k = k-1
              end do
              ! istart2 now points to the top of the bottom right
              ! unreduced hessenberg block
              if ( istart2 >= istop ) then
                 istop = istart2-1
                 ld = 0
                 eshift = czero
                 cycle
              end if
              nw = nwr
              nshifts = nsr
              nblock = nbr
              if ( istop-istart2+1 < nmin ) then
                 ! setting nw to the size of the subblock will make aed deflate
                 ! all the eigenvalues. this is slightly more efficient than just
                 ! using qz_small because the off diagonal part gets updated via blas.
                 if ( istop-istart+1 < nmin ) then
                    nw = istop-istart+1
                    istart2 = istart
                 else
                    nw = istop-istart2+1
                 end if
              end if
              ! time for aed
              call stdlib_zlaqz2( ilschur, ilq, ilz, n, istart2, istop, nw, a, lda,b, ldb, q, ldq,&
               z, ldz, n_undeflated, n_deflated,alpha, beta, work, nw, work( nw**2+1 ), nw,work( &
                         2*nw**2+1 ), lwork-2*nw**2, rwork, rec,aed_info )
              if ( n_deflated > 0 ) then
                 istop = istop-n_deflated
                 ld = 0
                 eshift = czero
              end if
              if ( 100*n_deflated > nibble*( n_deflated+n_undeflated ) .or.istop-istart2+1 < nmin &
                        ) then
                 ! aed has uncovered many eigenvalues. skip a qz sweep and run
                 ! aed again.
                 cycle
              end if
              ld = ld+1
              ns = min( nshifts, istop-istart2 )
              ns = min( ns, n_undeflated )
              shiftpos = istop-n_deflated-n_undeflated+1
              if ( mod( ld, 6 ) == 0 ) then
                 ! exceptional shift.  chosen for no particularly good reason.
                 if( ( real( maxit,KIND=dp)*safmin )*abs( a( istop,istop-1 ) )<abs( a( istop-1, &
                           istop-1 ) ) ) then
                    eshift = a( istop, istop-1 )/b( istop-1, istop-1 )
                 else
                    eshift = eshift+cone/( safmin*real( maxit,KIND=dp) )
                 end if
                 alpha( shiftpos ) = cone
                 beta( shiftpos ) = eshift
                 ns = 1
              end if
              ! time for a qz sweep
              call stdlib_zlaqz3( ilschur, ilq, ilz, n, istart2, istop, ns, nblock,alpha( &
              shiftpos ), beta( shiftpos ), a, lda, b,ldb, q, ldq, z, ldz, work, nblock, work( &
                        nblock**2+1 ), nblock, work( 2*nblock**2+1 ),lwork-2*nblock**2, sweep_info )
           end do
           ! call stdlib_zhgeqz to normalize the eigenvalue blocks and set the eigenvalues
           ! if all the eigenvalues have been found, stdlib_zhgeqz will not do any iterations
           ! and only normalize the blocks. in case of a rare convergence failure,
           ! the single shift might perform better.
        80 call stdlib_zhgeqz( wants, wantq, wantz, n, ilo, ihi, a, lda, b, ldb,alpha, beta, q, &
                  ldq, z, ldz, work, lwork, rwork,norm_info )
           info = norm_info
     end subroutine stdlib_zlaqz0

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module recursive subroutine stdlib_${ci}$laqz0( wants, wantq, wantz, n, ilo, ihi, a,lda, b, ldb, alpha, &
     !! ZLAQZ0: computes the eigenvalues of a real matrix pair (H,T),
     !! where H is an upper Hessenberg matrix and T is upper triangular,
     !! using the double-shift QZ method.
     !! Matrix pairs of this type are produced by the reduction to
     !! generalized upper Hessenberg form of a real matrix pair (A,B):
     !! A = Q1*H*Z1**H,  B = Q1*T*Z1**H,
     !! as computed by ZGGHRD.
     !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
     !! also reduced to generalized Schur form,
     !! H = Q*S*Z**H,  T = Q*P*Z**H,
     !! where Q and Z are unitary matrices, P and S are an upper triangular
     !! matrices.
     !! Optionally, the unitary matrix Q from the generalized Schur
     !! factorization may be postmultiplied into an input matrix Q1, and the
     !! unitary matrix Z may be postmultiplied into an input matrix Z1.
     !! If Q1 and Z1 are the unitary matrices from ZGGHRD that reduced
     !! the matrix pair (A,B) to generalized upper Hessenberg form, then the
     !! output matrices Q1*Q and Z1*Z are the unitary factors from the
     !! generalized Schur factorization of (A,B):
     !! A = (Q1*Q)*S*(Z1*Z)**H,  B = (Q1*Q)*P*(Z1*Z)**H.
     !! To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
     !! of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
     !! complex and beta real.
     !! If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
     !! generalized nonsymmetric eigenvalue problem (GNEP)
     !! A*x = lambda*B*x
     !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     !! alternate form of the GNEP
     !! mu*A*y = B*y.
     !! Eigenvalues can be read directly from the generalized Schur
     !! form:
     !! alpha = S(i,i), beta = P(i,i).
     !! Ref: C.B. Moler
     !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
     !! pp. 241--256.
     !! Ref: B. Kagstrom, D. Kressner, "Multishift Variants of the QZ
     !! Algorithm with Aggressive Early Deflation", SIAM J. Numer.
     !! Anal., 29(2006), pp. 199--227.
     !! Ref: T. Steel, D. Camps, K. Meerbergen, R. Vandebril "A multishift,
     !! multipole rational QZ method with agressive early deflation"
               beta, q, ldq, z,ldz, work, lwork, rwork, rec,info )
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           character, intent( in ) :: wants, wantq, wantz
           integer(ilp), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,rec
           integer(ilp), intent( out ) :: info
           complex(${ck}$), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq,* ), z( ldz, * ), &
                     alpha( * ), beta( * ), work( * )
           real(${ck}$), intent( out ) :: rwork( * )
           
           ! ================================================================
           ! local scalars
           real(${ck}$) :: smlnum, ulp, safmin, safmax, c1, tempr
           complex(${ck}$) :: eshift, s1, temp
           integer(ilp) :: istart, istop, iiter, maxit, istart2, k, ld, nshifts, nblock, nw, nmin,&
            nibble, n_undeflated, n_qeflated, ns, sweep_info, shiftpos, lworkreq, k2, istartm, &
            istopm, iwants, iwantq, iwantz, norm_info, aed_info, nwr, nbr, nsr, itemp1, itemp2, &
                      rcost
           logical(lk) :: ilschur, ilq, ilz
           character :: jbcmpz*3
           if( stdlib_lsame( wants, 'E' ) ) then
              ilschur = .false.
              iwants = 1
           else if( stdlib_lsame( wants, 'S' ) ) then
              ilschur = .true.
              iwants = 2
           else
              iwants = 0
           end if
           if( stdlib_lsame( wantq, 'N' ) ) then
              ilq = .false.
              iwantq = 1
           else if( stdlib_lsame( wantq, 'V' ) ) then
              ilq = .true.
              iwantq = 2
           else if( stdlib_lsame( wantq, 'I' ) ) then
              ilq = .true.
              iwantq = 3
           else
              iwantq = 0
           end if
           if( stdlib_lsame( wantz, 'N' ) ) then
              ilz = .false.
              iwantz = 1
           else if( stdlib_lsame( wantz, 'V' ) ) then
              ilz = .true.
              iwantz = 2
           else if( stdlib_lsame( wantz, 'I' ) ) then
              ilz = .true.
              iwantz = 3
           else
              iwantz = 0
           end if
           ! check argument values
           info = 0
           if( iwants==0 ) then
              info = -1
           else if( iwantq==0 ) then
              info = -2
           else if( iwantz==0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 ) then
              info = -5
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -6
           else if( lda<n ) then
              info = -8
           else if( ldb<n ) then
              info = -10
           else if( ldq<1 .or. ( ilq .and. ldq<n ) ) then
              info = -15
           else if( ldz<1 .or. ( ilz .and. ldz<n ) ) then
              info = -17
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZLAQZ0', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 ) then
              work( 1 ) = real( 1,KIND=${ck}$)
              return
           end if
           ! get the parameters
           jbcmpz( 1:1 ) = wants
           jbcmpz( 2:2 ) = wantq
           jbcmpz( 3:3 ) = wantz
           nmin = stdlib_ilaenv( 12, 'ZLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nwr = stdlib_ilaenv( 13, 'ZLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nwr = max( 2, nwr )
           nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
           nibble = stdlib_ilaenv( 14, 'ZLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nsr = stdlib_ilaenv( 15, 'ZLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           nsr = min( nsr, ( n+6 ) / 9, ihi-ilo )
           nsr = max( 2, nsr-mod( nsr, 2 ) )
           rcost = stdlib_ilaenv( 17, 'ZLAQZ0', jbcmpz, n, ilo, ihi, lwork )
           itemp1 = int( nsr/sqrt( 1+2*nsr/( real( rcost,KIND=${ck}$)/100*n ) ),KIND=ilp)
           itemp1 = ( ( itemp1-1 )/4 )*4+4
           nbr = nsr+itemp1
           if( n < nmin .or. rec >= 2 ) then
              call stdlib_${ci}$hgeqz( wants, wantq, wantz, n, ilo, ihi, a, lda, b, ldb,alpha, beta, q,&
                         ldq, z, ldz, work, lwork, rwork,info )
              return
           end if
           ! find out required workspace
           ! workspace query to stdlib_${ci}$laqz2
           nw = max( nwr, nmin )
           call stdlib_${ci}$laqz2( ilschur, ilq, ilz, n, ilo, ihi, nw, a, lda, b, ldb,q, ldq, z, ldz, &
           n_undeflated, n_qeflated, alpha,beta, work, nw, work, nw, work, -1, rwork, rec,&
                     aed_info )
           itemp1 = int( work( 1 ),KIND=ilp)
           ! workspace query to stdlib_${ci}$laqz3
           call stdlib_${ci}$laqz3( ilschur, ilq, ilz, n, ilo, ihi, nsr, nbr, alpha,beta, a, lda, b, &
                     ldb, q, ldq, z, ldz, work, nbr,work, nbr, work, -1, sweep_info )
           itemp2 = int( work( 1 ),KIND=ilp)
           lworkreq = max( itemp1+2*nw**2, itemp2+2*nbr**2 )
           if ( lwork ==-1 ) then
              work( 1 ) = real( lworkreq,KIND=${ck}$)
              return
           else if ( lwork < lworkreq ) then
              info = -19
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZLAQZ0', info )
              return
           end if
           ! initialize q and z
           if( iwantq==3 ) call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, q,ldq )
           if( iwantz==3 ) call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, z,ldz )
           ! get machine constants
           safmin = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_${c2ri(ci)}$labad( safmin, safmax )
           ulp = stdlib_${c2ri(ci)}$lamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=${ck}$)/ulp )
           istart = ilo
           istop = ihi
           maxit = 30*( ihi-ilo+1 )
           ld = 0
           do iiter = 1, maxit
              if( iiter >= maxit ) then
                 info = istop+1
                 goto 80
              end if
              if ( istart+1 >= istop ) then
                 istop = istart
                 exit
              end if
              ! check deflations at the end
              if ( abs( a( istop, istop-1 ) ) <= max( smlnum,ulp*( abs( a( istop, istop ) )+abs( &
                        a( istop-1,istop-1 ) ) ) ) ) then
                 a( istop, istop-1 ) = czero
                 istop = istop-1
                 ld = 0
                 eshift = czero
              end if
              ! check deflations at the start
              if ( abs( a( istart+1, istart ) ) <= max( smlnum,ulp*( abs( a( istart, istart ) )+&
                        abs( a( istart+1,istart+1 ) ) ) ) ) then
                 a( istart+1, istart ) = czero
                 istart = istart+1
                 ld = 0
                 eshift = czero
              end if
              if ( istart+1 >= istop ) then
                 exit
              end if
              ! check interior deflations
              istart2 = istart
              do k = istop, istart+1, -1
                 if ( abs( a( k, k-1 ) ) <= max( smlnum, ulp*( abs( a( k,k ) )+abs( a( k-1, k-1 ) &
                           ) ) ) ) then
                    a( k, k-1 ) = czero
                    istart2 = k
                    exit
                 end if
              end do
              ! get range to apply rotations to
              if ( ilschur ) then
                 istartm = 1
                 istopm = n
              else
                 istartm = istart2
                 istopm = istop
              end if
              ! check infinite eigenvalues, this is done without blocking so might
              ! slow down the method when many infinite eigenvalues are present
              k = istop
              do while ( k>=istart2 )
                 tempr = zero
                 if( k < istop ) then
                    tempr = tempr+abs( b( k, k+1 ) )
                 end if
                 if( k > istart2 ) then
                    tempr = tempr+abs( b( k-1, k ) )
                 end if
                 if( abs( b( k, k ) ) < max( smlnum, ulp*tempr ) ) then
                    ! a diagonal element of b is negligable, move it
                    ! to the top and deflate it
                    do k2 = k, istart2+1, -1
                       call stdlib_${ci}$lartg( b( k2-1, k2 ), b( k2-1, k2-1 ), c1, s1,temp )
                       b( k2-1, k2 ) = temp
                       b( k2-1, k2-1 ) = czero
                       call stdlib_${ci}$rot( k2-2-istartm+1, b( istartm, k2 ), 1,b( istartm, k2-1 ), &
                                 1, c1, s1 )
                       call stdlib_${ci}$rot( min( k2+1, istop )-istartm+1, a( istartm,k2 ), 1, a( &
                                 istartm, k2-1 ), 1, c1, s1 )
                       if ( ilz ) then
                          call stdlib_${ci}$rot( n, z( 1, k2 ), 1, z( 1, k2-1 ), 1, c1,s1 )
                       end if
                       if( k2<istop ) then
                          call stdlib_${ci}$lartg( a( k2, k2-1 ), a( k2+1, k2-1 ), c1,s1, temp )
                                    
                          a( k2, k2-1 ) = temp
                          a( k2+1, k2-1 ) = czero
                          call stdlib_${ci}$rot( istopm-k2+1, a( k2, k2 ), lda, a( k2+1,k2 ), lda, c1, &
                                    s1 )
                          call stdlib_${ci}$rot( istopm-k2+1, b( k2, k2 ), ldb, b( k2+1,k2 ), ldb, c1, &
                                    s1 )
                          if( ilq ) then
                             call stdlib_${ci}$rot( n, q( 1, k2 ), 1, q( 1, k2+1 ), 1,c1, conjg( s1 ) )
                                       
                          end if
                       end if
                    end do
                    if( istart2<istop )then
                       call stdlib_${ci}$lartg( a( istart2, istart2 ), a( istart2+1,istart2 ), c1, s1, &
                                 temp )
                       a( istart2, istart2 ) = temp
                       a( istart2+1, istart2 ) = czero
                       call stdlib_${ci}$rot( istopm-( istart2+1 )+1, a( istart2,istart2+1 ), lda, a( &
                                 istart2+1,istart2+1 ), lda, c1, s1 )
                       call stdlib_${ci}$rot( istopm-( istart2+1 )+1, b( istart2,istart2+1 ), ldb, b( &
                                 istart2+1,istart2+1 ), ldb, c1, s1 )
                       if( ilq ) then
                          call stdlib_${ci}$rot( n, q( 1, istart2 ), 1, q( 1,istart2+1 ), 1, c1, conjg(&
                                     s1 ) )
                       end if
                    end if
                    istart2 = istart2+1
                 end if
                 k = k-1
              end do
              ! istart2 now points to the top of the bottom right
              ! unreduced hessenberg block
              if ( istart2 >= istop ) then
                 istop = istart2-1
                 ld = 0
                 eshift = czero
                 cycle
              end if
              nw = nwr
              nshifts = nsr
              nblock = nbr
              if ( istop-istart2+1 < nmin ) then
                 ! setting nw to the size of the subblock will make aed deflate
                 ! all the eigenvalues. this is slightly more efficient than just
                 ! using qz_small because the off diagonal part gets updated via blas.
                 if ( istop-istart+1 < nmin ) then
                    nw = istop-istart+1
                    istart2 = istart
                 else
                    nw = istop-istart2+1
                 end if
              end if
              ! time for aed
              call stdlib_${ci}$laqz2( ilschur, ilq, ilz, n, istart2, istop, nw, a, lda,b, ldb, q, ldq,&
               z, ldz, n_undeflated, n_qeflated,alpha, beta, work, nw, work( nw**2+1 ), nw,work( &
                         2*nw**2+1 ), lwork-2*nw**2, rwork, rec,aed_info )
              if ( n_qeflated > 0 ) then
                 istop = istop-n_qeflated
                 ld = 0
                 eshift = czero
              end if
              if ( 100*n_qeflated > nibble*( n_qeflated+n_undeflated ) .or.istop-istart2+1 < nmin &
                        ) then
                 ! aed has uncovered many eigenvalues. skip a qz sweep and run
                 ! aed again.
                 cycle
              end if
              ld = ld+1
              ns = min( nshifts, istop-istart2 )
              ns = min( ns, n_undeflated )
              shiftpos = istop-n_qeflated-n_undeflated+1
              if ( mod( ld, 6 ) == 0 ) then
                 ! exceptional shift.  chosen for no particularly good reason.
                 if( ( real( maxit,KIND=${ck}$)*safmin )*abs( a( istop,istop-1 ) )<abs( a( istop-1, &
                           istop-1 ) ) ) then
                    eshift = a( istop, istop-1 )/b( istop-1, istop-1 )
                 else
                    eshift = eshift+cone/( safmin*real( maxit,KIND=${ck}$) )
                 end if
                 alpha( shiftpos ) = cone
                 beta( shiftpos ) = eshift
                 ns = 1
              end if
              ! time for a qz sweep
              call stdlib_${ci}$laqz3( ilschur, ilq, ilz, n, istart2, istop, ns, nblock,alpha( &
              shiftpos ), beta( shiftpos ), a, lda, b,ldb, q, ldq, z, ldz, work, nblock, work( &
                        nblock**2+1 ), nblock, work( 2*nblock**2+1 ),lwork-2*nblock**2, sweep_info )
           end do
           ! call stdlib_${ci}$hgeqz to normalize the eigenvalue blocks and set the eigenvalues
           ! if all the eigenvalues have been found, stdlib_${ci}$hgeqz will not do any iterations
           ! and only normalize the blocks. in case of a rare convergence failure,
           ! the single shift might perform better.
        80 call stdlib_${ci}$hgeqz( wants, wantq, wantz, n, ilo, ihi, a, lda, b, ldb,alpha, beta, q, &
                  ldq, z, ldz, work, lwork, rwork,norm_info )
           info = norm_info
     end subroutine stdlib_${ci}$laqz0

#:endif
#:endfor



     module subroutine stdlib_slaqr4( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, work, lwork, info )
     !! SLAQR4 implements one level of recursion for SLAQR0.
     !! It is a complete implementation of the small bulge multi-shift
     !! QR algorithm.  It may be called by SLAQR0 and, for large enough
     !! deflation window size, it may be called by SLAQR3.  This
     !! subroutine is identical to SLAQR0 except that it calls SLAQR2
     !! instead of SLAQR3.
     !! SLAQR4 computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**T, where T is an upper quasi-triangular matrix (the
     !! Schur form), and Z is the orthogonal matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input orthogonal
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
                
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(sp), intent(out) :: wi(*), work(*), wr(*)
        ! ================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: kexnw = 5
           integer(ilp), parameter :: kexsh = 6
           real(sp), parameter :: wilk1 = 0.75_sp
           real(sp), parameter :: wilk2 = -0.4375_sp
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_slahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== exceptional deflation windows:  try to cure rare
           ! .    slow convergence by varying the size of the
           ! .    deflation window after kexnw iterations. ====
           
           ! ==== exceptional shifts: try to cure rare slow convergence
           ! .    with ad-hoc exceptional shifts every kexsh iterations.
           ! .    ====
           
           ! ==== the constants wilk1 and wilk2 are used to form the
           ! .    exceptional shifts. ====
           
           
           ! Local Scalars 
           real(sp) :: aa, bb, cc, cs, dd, sn, ss, swap
           integer(ilp) :: i, inf, it, itmax, k, kacc22, kbot, kdu, ks, kt, ktop, ku, kv, kwh, &
           kwtop, kwv, ld, ls, lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns, nsmax, nsr, nve, nw,&
                      nwmax, nwr, nwupbd
           logical(lk) :: sorted
           character :: jbcmpz*2
           ! Local Arrays 
           real(sp) :: zdum(1,1)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! ==== quick return for n = 0: nothing to do. ====
           if( n==0 ) then
              work( 1 ) = one
              return
           end if
           if( n<=ntiny ) then
              ! ==== tiny matrices must use stdlib_slahqr. ====
              lwkopt = 1
              if( lwork/=-1 )call stdlib_slahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, &
                        ihiz, z, ldz, info )
           else
              ! ==== use small bulge multi-shift qr with aggressive early
              ! .    deflation on larger-than-tiny matrices. ====
              ! ==== hope for the best. ====
              info = 0
              ! ==== set up job flags for stdlib_ilaenv. ====
              if( wantt ) then
                 jbcmpz( 1: 1 ) = 'S'
              else
                 jbcmpz( 1: 1 ) = 'E'
              end if
              if( wantz ) then
                 jbcmpz( 2: 2 ) = 'V'
              else
                 jbcmpz( 2: 2 ) = 'N'
              end if
              ! ==== nwr = recommended deflation window size.  at this
              ! .    point,  n > ntiny = 15, so there is enough
              ! .    subdiagonal workspace for nwr>=2 as required.
              ! .    (in fact, there is enough subdiagonal space for
              ! .    nwr>=4.) ====
              nwr = stdlib_ilaenv( 13, 'SLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nwr = max( 2, nwr )
              nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
              ! ==== nsr = recommended number of simultaneous shifts.
              ! .    at this point n > ntiny = 15, so there is at
              ! .    enough subdiagonal workspace for nsr to be even
              ! .    and greater than or equal to two as required. ====
              nsr = stdlib_ilaenv( 15, 'SLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nsr = min( nsr, ( n-3 ) / 6, ihi-ilo )
              nsr = max( 2, nsr-mod( nsr, 2 ) )
              ! ==== estimate optimal workspace ====
              ! ==== workspace query call to stdlib_slaqr2 ====
              call stdlib_slaqr2( wantt, wantz, n, ilo, ihi, nwr+1, h, ldh, iloz,ihiz, z, ldz, ls,&
                         ld, wr, wi, h, ldh, n, h, ldh,n, h, ldh, work, -1 )
              ! ==== optimal workspace = max(stdlib_slaqr5, stdlib_slaqr2) ====
              lwkopt = max( 3*nsr / 2, int( work( 1 ),KIND=ilp) )
              ! ==== quick return in case of workspace query. ====
              if( lwork==-1 ) then
                 work( 1 ) = real( lwkopt,KIND=sp)
                 return
              end if
              ! ==== stdlib_slahqr/stdlib_slaqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'SLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nmin = max( ntiny, nmin )
              ! ==== nibble crossover point ====
              nibble = stdlib_ilaenv( 14, 'SLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nibble = max( 0, nibble )
              ! ==== accumulate reflections during ttswp?  use block
              ! .    2-by-2 structure during matrix-matrix multiply? ====
              kacc22 = stdlib_ilaenv( 16, 'SLAQR4', jbcmpz, n, ilo, ihi, lwork )
              kacc22 = max( 0, kacc22 )
              kacc22 = min( 2, kacc22 )
              ! ==== nwmax = the largest possible deflation window for
              ! .    which there is sufficient workspace. ====
              nwmax = min( ( n-1 ) / 3, lwork / 2 )
              nw = nwmax
              ! ==== nsmax = the largest number of simultaneous shifts
              ! .    for which there is sufficient workspace. ====
              nsmax = min( ( n-3 ) / 6, 2*lwork / 3 )
              nsmax = nsmax - mod( nsmax, 2 )
              ! ==== ndfl: an iteration count restarted at deflation. ====
              ndfl = 1
              ! ==== itmax = iteration limit ====
              itmax = max( 30, 2*kexsh )*max( 10, ( ihi-ilo+1 ) )
              ! ==== last row and column in the active block ====
              kbot = ihi
              ! ==== main loop ====
              loop_80: do it = 1, itmax
                 ! ==== done when kbot falls below ilo ====
                 if( kbot<ilo )go to 90
                 ! ==== locate active block ====
                 do k = kbot, ilo + 1, -1
                    if( h( k, k-1 )==zero )go to 20
                 end do
                 k = ilo
                 20 continue
                 ktop = k
                 ! ==== select deflation window size:
                 ! .    typical case:
                 ! .      if possible and advisable, nibble the entire
                 ! .      active block.  if not, use size min(nwr,nwmax)
                 ! .      or min(nwr+1,nwmax) depending upon which has
                 ! .      the smaller corresponding subdiagonal entry
                 ! .      (a heuristic).
                 ! .    exceptional case:
                 ! .      if there have been no deflations in kexnw or
                 ! .      more iterations, then vary the deflation window
                 ! .      size.   at first, because, larger windows are,
                 ! .      in general, more powerful than smaller ones,
                 ! .      rapidly increase the window to the maximum possible.
                 ! .      then, gradually reduce the window size. ====
                 nh = kbot - ktop + 1
                 nwupbd = min( nh, nwmax )
                 if( ndfl<kexnw ) then
                    nw = min( nwupbd, nwr )
                 else
                    nw = min( nwupbd, 2*nw )
                 end if
                 if( nw<nwmax ) then
                    if( nw>=nh-1 ) then
                       nw = nh
                    else
                       kwtop = kbot - nw + 1
                       if( abs( h( kwtop, kwtop-1 ) )>abs( h( kwtop-1, kwtop-2 ) ) )nw = nw + &
                                 1
                    end if
                 end if
                 if( ndfl<kexnw ) then
                    ndec = -1
                 else if( ndec>=0 .or. nw>=nwupbd ) then
                    ndec = ndec + 1
                    if( nw-ndec<2 )ndec = 0
                    nw = nw - ndec
                 end if
                 ! ==== aggressive early deflation:
                 ! .    split workspace under the subdiagonal into
                 ! .      - an nw-by-nw work array v in the lower
                 ! .        left-hand-corner,
                 ! .      - an nw-by-at-least-nw-but-more-is-better
                 ! .        (nw-by-nho) horizontal work array along
                 ! .        the bottom edge,
                 ! .      - an at-least-nw-but-more-is-better (nhv-by-nw)
                 ! .        vertical work array along the left-hand-edge.
                 ! .        ====
                 kv = n - nw + 1
                 kt = nw + 1
                 nho = ( n-nw-1 ) - kt + 1
                 kwv = nw + 2
                 nve = ( n-nw ) - kwv + 1
                 ! ==== aggressive early deflation ====
                 call stdlib_slaqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
                 ls, ld, wr, wi, h( kv, 1 ), ldh,nho, h( kv, kt ), ldh, nve, h( kwv, 1 ), ldh,&
                           work, lwork )
                 ! ==== adjust kbot accounting for new deflations. ====
                 kbot = kbot - ld
                 ! ==== ks points to the shifts. ====
                 ks = kbot - ls + 1
                 ! ==== skip an expensive qr sweep if there is a (partly
                 ! .    heuristic) reason to expect that many eigenvalues
                 ! .    will deflate without it.  here, the qr sweep is
                 ! .    skipped if many eigenvalues have just been deflated
                 ! .    or if the remaining active block is small.
                 if( ( ld==0 ) .or. ( ( 100*ld<=nw*nibble ) .and. ( kbot-ktop+1>min( nmin, nwmax )&
                            ) ) ) then
                    ! ==== ns = nominal number of simultaneous shifts.
                    ! .    this may be lowered (slightly) if stdlib_slaqr2
                    ! .    did not provide that many shifts. ====
                    ns = min( nsmax, nsr, max( 2, kbot-ktop ) )
                    ns = ns - mod( ns, 2 )
                    ! ==== if there have been no deflations
                    ! .    in a multiple of kexsh iterations,
                    ! .    then try exceptional shifts.
                    ! .    otherwise use shifts provided by
                    ! .    stdlib_slaqr2 above or from the eigenvalues
                    ! .    of a trailing principal submatrix. ====
                    if( mod( ndfl, kexsh )==0 ) then
                       ks = kbot - ns + 1
                       do i = kbot, max( ks+1, ktop+2 ), -2
                          ss = abs( h( i, i-1 ) ) + abs( h( i-1, i-2 ) )
                          aa = wilk1*ss + h( i, i )
                          bb = ss
                          cc = wilk2*ss
                          dd = aa
                          call stdlib_slanv2( aa, bb, cc, dd, wr( i-1 ), wi( i-1 ),wr( i ), wi( i &
                                    ), cs, sn )
                       end do
                       if( ks==ktop ) then
                          wr( ks+1 ) = h( ks+1, ks+1 )
                          wi( ks+1 ) = zero
                          wr( ks ) = wr( ks+1 )
                          wi( ks ) = wi( ks+1 )
                       end if
                    else
                       ! ==== got ns/2 or fewer shifts? use stdlib_slahqr
                       ! .    on a trailing principal submatrix to
                       ! .    get more. (since ns<=nsmax<=(n-3)/6,
                       ! .    there is enough space below the subdiagonal
                       ! .    to fit an ns-by-ns scratch array.) ====
                       if( kbot-ks+1<=ns / 2 ) then
                          ks = kbot - ns + 1
                          kt = n - ns + 1
                          call stdlib_slacpy( 'A', ns, ns, h( ks, ks ), ldh,h( kt, 1 ), ldh )
                                    
                          call stdlib_slahqr( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, wr( ks &
                                    ), wi( ks ),1, 1, zdum, 1, inf )
                          ks = ks + inf
                          ! ==== in case of a rare qr failure use
                          ! .    eigenvalues of the trailing 2-by-2
                          ! .    principal submatrix.  ====
                          if( ks>=kbot ) then
                             aa = h( kbot-1, kbot-1 )
                             cc = h( kbot, kbot-1 )
                             bb = h( kbot-1, kbot )
                             dd = h( kbot, kbot )
                             call stdlib_slanv2( aa, bb, cc, dd, wr( kbot-1 ),wi( kbot-1 ), wr( &
                                       kbot ),wi( kbot ), cs, sn )
                             ks = kbot - 1
                          end if
                       end if
                       if( kbot-ks+1>ns ) then
                          ! ==== sort the shifts (helps a little)
                          ! .    bubble sort keeps complex conjugate
                          ! .    pairs together. ====
                          sorted = .false.
                          do k = kbot, ks + 1, -1
                             if( sorted )go to 60
                             sorted = .true.
                             do i = ks, k - 1
                                if( abs( wr( i ) )+abs( wi( i ) )<abs( wr( i+1 ) )+abs( wi( i+1 ) &
                                          ) ) then
                                   sorted = .false.
                                   swap = wr( i )
                                   wr( i ) = wr( i+1 )
                                   wr( i+1 ) = swap
                                   swap = wi( i )
                                   wi( i ) = wi( i+1 )
                                   wi( i+1 ) = swap
                                end if
                             end do
                          end do
                          60 continue
                       end if
                       ! ==== shuffle shifts into pairs of real shifts
                       ! .    and pairs of complex conjugate shifts
                       ! .    assuming complex conjugate shifts are
                       ! .    already adjacent to one another. (yes,
                       ! .    they are.)  ====
                       do i = kbot, ks + 2, -2
                          if( wi( i )/=-wi( i-1 ) ) then
                             swap = wr( i )
                             wr( i ) = wr( i-1 )
                             wr( i-1 ) = wr( i-2 )
                             wr( i-2 ) = swap
                             swap = wi( i )
                             wi( i ) = wi( i-1 )
                             wi( i-1 ) = wi( i-2 )
                             wi( i-2 ) = swap
                          end if
                       end do
                    end if
                    ! ==== if there are only two shifts and both are
                    ! .    real, then use only one.  ====
                    if( kbot-ks+1==2 ) then
                       if( wi( kbot )==zero ) then
                          if( abs( wr( kbot )-h( kbot, kbot ) )<abs( wr( kbot-1 )-h( kbot, kbot ) &
                                    ) ) then
                             wr( kbot-1 ) = wr( kbot )
                          else
                             wr( kbot ) = wr( kbot-1 )
                          end if
                       end if
                    end if
                    ! ==== use up to ns of the the smallest magnitude
                    ! .    shifts.  if there aren't ns shifts available,
                    ! .    then use them all, possibly dropping one to
                    ! .    make the number of shifts even. ====
                    ns = min( ns, kbot-ks+1 )
                    ns = ns - mod( ns, 2 )
                    ks = kbot - ns + 1
                    ! ==== small-bulge multi-shift qr sweep:
                    ! .    split workspace under the subdiagonal into
                    ! .    - a kdu-by-kdu work array u in the lower
                    ! .      left-hand-corner,
                    ! .    - a kdu-by-at-least-kdu-but-more-is-better
                    ! .      (kdu-by-nho) horizontal work array wh along
                    ! .      the bottom edge,
                    ! .    - and an at-least-kdu-but-more-is-better-by-kdu
                    ! .      (nve-by-kdu) vertical work wv arrow along
                    ! .      the left-hand-edge. ====
                    kdu = 2*ns
                    ku = n - kdu + 1
                    kwh = kdu + 1
                    nho = ( n-kdu+1-4 ) - ( kdu+1 ) + 1
                    kwv = kdu + 4
                    nve = n - kdu - kwv + 1
                    ! ==== small-bulge multi-shift qr sweep ====
                    call stdlib_slaqr5( wantt, wantz, kacc22, n, ktop, kbot, ns,wr( ks ), wi( ks )&
                    , h, ldh, iloz, ihiz, z,ldz, work, 3, h( ku, 1 ), ldh, nve,h( kwv, 1 ), ldh, &
                              nho, h( ku, kwh ), ldh )
                 end if
                 ! ==== note progress (or the lack of it). ====
                 if( ld>0 ) then
                    ndfl = 1
                 else
                    ndfl = ndfl + 1
                 end if
                 ! ==== end of main loop ====
              end do loop_80
              ! ==== iteration limit exceeded.  set info to show where
              ! .    the problem occurred and exit. ====
              info = kbot
              90 continue
           end if
           ! ==== return the optimal value of lwork. ====
           work( 1 ) = real( lwkopt,KIND=sp)
     end subroutine stdlib_slaqr4

     module subroutine stdlib_dlaqr4( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, work, lwork, info )
     !! DLAQR4 implements one level of recursion for DLAQR0.
     !! It is a complete implementation of the small bulge multi-shift
     !! QR algorithm.  It may be called by DLAQR0 and, for large enough
     !! deflation window size, it may be called by DLAQR3.  This
     !! subroutine is identical to DLAQR0 except that it calls DLAQR2
     !! instead of DLAQR3.
     !! DLAQR4 computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**T, where T is an upper quasi-triangular matrix (the
     !! Schur form), and Z is the orthogonal matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input orthogonal
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
                
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(dp), intent(out) :: wi(*), work(*), wr(*)
        ! ================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: kexnw = 5
           integer(ilp), parameter :: kexsh = 6
           real(dp), parameter :: wilk1 = 0.75_dp
           real(dp), parameter :: wilk2 = -0.4375_dp
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_dlahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== exceptional deflation windows:  try to cure rare
           ! .    slow convergence by varying the size of the
           ! .    deflation window after kexnw iterations. ====
           
           ! ==== exceptional shifts: try to cure rare slow convergence
           ! .    with ad-hoc exceptional shifts every kexsh iterations.
           ! .    ====
           
           ! ==== the constants wilk1 and wilk2 are used to form the
           ! .    exceptional shifts. ====
           
           
           ! Local Scalars 
           real(dp) :: aa, bb, cc, cs, dd, sn, ss, swap
           integer(ilp) :: i, inf, it, itmax, k, kacc22, kbot, kdu, ks, kt, ktop, ku, kv, kwh, &
           kwtop, kwv, ld, ls, lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns, nsmax, nsr, nve, nw,&
                      nwmax, nwr, nwupbd
           logical(lk) :: sorted
           character :: jbcmpz*2
           ! Local Arrays 
           real(dp) :: zdum(1,1)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! ==== quick return for n = 0: nothing to do. ====
           if( n==0 ) then
              work( 1 ) = one
              return
           end if
           if( n<=ntiny ) then
              ! ==== tiny matrices must use stdlib_dlahqr. ====
              lwkopt = 1
              if( lwork/=-1 )call stdlib_dlahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, &
                        ihiz, z, ldz, info )
           else
              ! ==== use small bulge multi-shift qr with aggressive early
              ! .    deflation on larger-than-tiny matrices. ====
              ! ==== hope for the best. ====
              info = 0
              ! ==== set up job flags for stdlib_ilaenv. ====
              if( wantt ) then
                 jbcmpz( 1: 1 ) = 'S'
              else
                 jbcmpz( 1: 1 ) = 'E'
              end if
              if( wantz ) then
                 jbcmpz( 2: 2 ) = 'V'
              else
                 jbcmpz( 2: 2 ) = 'N'
              end if
              ! ==== nwr = recommended deflation window size.  at this
              ! .    point,  n > ntiny = 15, so there is enough
              ! .    subdiagonal workspace for nwr>=2 as required.
              ! .    (in fact, there is enough subdiagonal space for
              ! .    nwr>=4.) ====
              nwr = stdlib_ilaenv( 13, 'DLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nwr = max( 2, nwr )
              nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
              ! ==== nsr = recommended number of simultaneous shifts.
              ! .    at this point n > ntiny = 15, so there is at
              ! .    enough subdiagonal workspace for nsr to be even
              ! .    and greater than or equal to two as required. ====
              nsr = stdlib_ilaenv( 15, 'DLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nsr = min( nsr, ( n-3 ) / 6, ihi-ilo )
              nsr = max( 2, nsr-mod( nsr, 2 ) )
              ! ==== estimate optimal workspace ====
              ! ==== workspace query call to stdlib_dlaqr2 ====
              call stdlib_dlaqr2( wantt, wantz, n, ilo, ihi, nwr+1, h, ldh, iloz,ihiz, z, ldz, ls,&
                         ld, wr, wi, h, ldh, n, h, ldh,n, h, ldh, work, -1 )
              ! ==== optimal workspace = max(stdlib_dlaqr5, stdlib_dlaqr2) ====
              lwkopt = max( 3*nsr / 2, int( work( 1 ),KIND=ilp) )
              ! ==== quick return in case of workspace query. ====
              if( lwork==-1 ) then
                 work( 1 ) = real( lwkopt,KIND=dp)
                 return
              end if
              ! ==== stdlib_dlahqr/stdlib_dlaqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'DLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nmin = max( ntiny, nmin )
              ! ==== nibble crossover point ====
              nibble = stdlib_ilaenv( 14, 'DLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nibble = max( 0, nibble )
              ! ==== accumulate reflections during ttswp?  use block
              ! .    2-by-2 structure during matrix-matrix multiply? ====
              kacc22 = stdlib_ilaenv( 16, 'DLAQR4', jbcmpz, n, ilo, ihi, lwork )
              kacc22 = max( 0, kacc22 )
              kacc22 = min( 2, kacc22 )
              ! ==== nwmax = the largest possible deflation window for
              ! .    which there is sufficient workspace. ====
              nwmax = min( ( n-1 ) / 3, lwork / 2 )
              nw = nwmax
              ! ==== nsmax = the largest number of simultaneous shifts
              ! .    for which there is sufficient workspace. ====
              nsmax = min( ( n-3 ) / 6, 2*lwork / 3 )
              nsmax = nsmax - mod( nsmax, 2 )
              ! ==== ndfl: an iteration count restarted at deflation. ====
              ndfl = 1
              ! ==== itmax = iteration limit ====
              itmax = max( 30, 2*kexsh )*max( 10, ( ihi-ilo+1 ) )
              ! ==== last row and column in the active block ====
              kbot = ihi
              ! ==== main loop ====
              loop_80: do it = 1, itmax
                 ! ==== done when kbot falls below ilo ====
                 if( kbot<ilo )go to 90
                 ! ==== locate active block ====
                 do k = kbot, ilo + 1, -1
                    if( h( k, k-1 )==zero )go to 20
                 end do
                 k = ilo
                 20 continue
                 ktop = k
                 ! ==== select deflation window size:
                 ! .    typical case:
                 ! .      if possible and advisable, nibble the entire
                 ! .      active block.  if not, use size min(nwr,nwmax)
                 ! .      or min(nwr+1,nwmax) depending upon which has
                 ! .      the smaller corresponding subdiagonal entry
                 ! .      (a heuristic).
                 ! .    exceptional case:
                 ! .      if there have been no deflations in kexnw or
                 ! .      more iterations, then vary the deflation window
                 ! .      size.   at first, because, larger windows are,
                 ! .      in general, more powerful than smaller ones,
                 ! .      rapidly increase the window to the maximum possible.
                 ! .      then, gradually reduce the window size. ====
                 nh = kbot - ktop + 1
                 nwupbd = min( nh, nwmax )
                 if( ndfl<kexnw ) then
                    nw = min( nwupbd, nwr )
                 else
                    nw = min( nwupbd, 2*nw )
                 end if
                 if( nw<nwmax ) then
                    if( nw>=nh-1 ) then
                       nw = nh
                    else
                       kwtop = kbot - nw + 1
                       if( abs( h( kwtop, kwtop-1 ) )>abs( h( kwtop-1, kwtop-2 ) ) )nw = nw + &
                                 1
                    end if
                 end if
                 if( ndfl<kexnw ) then
                    ndec = -1
                 else if( ndec>=0 .or. nw>=nwupbd ) then
                    ndec = ndec + 1
                    if( nw-ndec<2 )ndec = 0
                    nw = nw - ndec
                 end if
                 ! ==== aggressive early deflation:
                 ! .    split workspace under the subdiagonal into
                 ! .      - an nw-by-nw work array v in the lower
                 ! .        left-hand-corner,
                 ! .      - an nw-by-at-least-nw-but-more-is-better
                 ! .        (nw-by-nho) horizontal work array along
                 ! .        the bottom edge,
                 ! .      - an at-least-nw-but-more-is-better (nhv-by-nw)
                 ! .        vertical work array along the left-hand-edge.
                 ! .        ====
                 kv = n - nw + 1
                 kt = nw + 1
                 nho = ( n-nw-1 ) - kt + 1
                 kwv = nw + 2
                 nve = ( n-nw ) - kwv + 1
                 ! ==== aggressive early deflation ====
                 call stdlib_dlaqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
                 ls, ld, wr, wi, h( kv, 1 ), ldh,nho, h( kv, kt ), ldh, nve, h( kwv, 1 ), ldh,&
                           work, lwork )
                 ! ==== adjust kbot accounting for new deflations. ====
                 kbot = kbot - ld
                 ! ==== ks points to the shifts. ====
                 ks = kbot - ls + 1
                 ! ==== skip an expensive qr sweep if there is a (partly
                 ! .    heuristic) reason to expect that many eigenvalues
                 ! .    will deflate without it.  here, the qr sweep is
                 ! .    skipped if many eigenvalues have just been deflated
                 ! .    or if the remaining active block is small.
                 if( ( ld==0 ) .or. ( ( 100*ld<=nw*nibble ) .and. ( kbot-ktop+1>min( nmin, nwmax )&
                            ) ) ) then
                    ! ==== ns = nominal number of simultaneous shifts.
                    ! .    this may be lowered (slightly) if stdlib_dlaqr2
                    ! .    did not provide that many shifts. ====
                    ns = min( nsmax, nsr, max( 2, kbot-ktop ) )
                    ns = ns - mod( ns, 2 )
                    ! ==== if there have been no deflations
                    ! .    in a multiple of kexsh iterations,
                    ! .    then try exceptional shifts.
                    ! .    otherwise use shifts provided by
                    ! .    stdlib_dlaqr2 above or from the eigenvalues
                    ! .    of a trailing principal submatrix. ====
                    if( mod( ndfl, kexsh )==0 ) then
                       ks = kbot - ns + 1
                       do i = kbot, max( ks+1, ktop+2 ), -2
                          ss = abs( h( i, i-1 ) ) + abs( h( i-1, i-2 ) )
                          aa = wilk1*ss + h( i, i )
                          bb = ss
                          cc = wilk2*ss
                          dd = aa
                          call stdlib_dlanv2( aa, bb, cc, dd, wr( i-1 ), wi( i-1 ),wr( i ), wi( i &
                                    ), cs, sn )
                       end do
                       if( ks==ktop ) then
                          wr( ks+1 ) = h( ks+1, ks+1 )
                          wi( ks+1 ) = zero
                          wr( ks ) = wr( ks+1 )
                          wi( ks ) = wi( ks+1 )
                       end if
                    else
                       ! ==== got ns/2 or fewer shifts? use stdlib_dlahqr
                       ! .    on a trailing principal submatrix to
                       ! .    get more. (since ns<=nsmax<=(n-3)/6,
                       ! .    there is enough space below the subdiagonal
                       ! .    to fit an ns-by-ns scratch array.) ====
                       if( kbot-ks+1<=ns / 2 ) then
                          ks = kbot - ns + 1
                          kt = n - ns + 1
                          call stdlib_dlacpy( 'A', ns, ns, h( ks, ks ), ldh,h( kt, 1 ), ldh )
                                    
                          call stdlib_dlahqr( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, wr( ks &
                                    ), wi( ks ),1, 1, zdum, 1, inf )
                          ks = ks + inf
                          ! ==== in case of a rare qr failure use
                          ! .    eigenvalues of the trailing 2-by-2
                          ! .    principal submatrix.  ====
                          if( ks>=kbot ) then
                             aa = h( kbot-1, kbot-1 )
                             cc = h( kbot, kbot-1 )
                             bb = h( kbot-1, kbot )
                             dd = h( kbot, kbot )
                             call stdlib_dlanv2( aa, bb, cc, dd, wr( kbot-1 ),wi( kbot-1 ), wr( &
                                       kbot ),wi( kbot ), cs, sn )
                             ks = kbot - 1
                          end if
                       end if
                       if( kbot-ks+1>ns ) then
                          ! ==== sort the shifts (helps a little)
                          ! .    bubble sort keeps complex conjugate
                          ! .    pairs together. ====
                          sorted = .false.
                          do k = kbot, ks + 1, -1
                             if( sorted )go to 60
                             sorted = .true.
                             do i = ks, k - 1
                                if( abs( wr( i ) )+abs( wi( i ) )<abs( wr( i+1 ) )+abs( wi( i+1 ) &
                                          ) ) then
                                   sorted = .false.
                                   swap = wr( i )
                                   wr( i ) = wr( i+1 )
                                   wr( i+1 ) = swap
                                   swap = wi( i )
                                   wi( i ) = wi( i+1 )
                                   wi( i+1 ) = swap
                                end if
                             end do
                          end do
                          60 continue
                       end if
                       ! ==== shuffle shifts into pairs of real shifts
                       ! .    and pairs of complex conjugate shifts
                       ! .    assuming complex conjugate shifts are
                       ! .    already adjacent to one another. (yes,
                       ! .    they are.)  ====
                       do i = kbot, ks + 2, -2
                          if( wi( i )/=-wi( i-1 ) ) then
                             swap = wr( i )
                             wr( i ) = wr( i-1 )
                             wr( i-1 ) = wr( i-2 )
                             wr( i-2 ) = swap
                             swap = wi( i )
                             wi( i ) = wi( i-1 )
                             wi( i-1 ) = wi( i-2 )
                             wi( i-2 ) = swap
                          end if
                       end do
                    end if
                    ! ==== if there are only two shifts and both are
                    ! .    real, then use only one.  ====
                    if( kbot-ks+1==2 ) then
                       if( wi( kbot )==zero ) then
                          if( abs( wr( kbot )-h( kbot, kbot ) )<abs( wr( kbot-1 )-h( kbot, kbot ) &
                                    ) ) then
                             wr( kbot-1 ) = wr( kbot )
                          else
                             wr( kbot ) = wr( kbot-1 )
                          end if
                       end if
                    end if
                    ! ==== use up to ns of the the smallest magnitude
                    ! .    shifts.  if there aren't ns shifts available,
                    ! .    then use them all, possibly dropping one to
                    ! .    make the number of shifts even. ====
                    ns = min( ns, kbot-ks+1 )
                    ns = ns - mod( ns, 2 )
                    ks = kbot - ns + 1
                    ! ==== small-bulge multi-shift qr sweep:
                    ! .    split workspace under the subdiagonal into
                    ! .    - a kdu-by-kdu work array u in the lower
                    ! .      left-hand-corner,
                    ! .    - a kdu-by-at-least-kdu-but-more-is-better
                    ! .      (kdu-by-nho) horizontal work array wh along
                    ! .      the bottom edge,
                    ! .    - and an at-least-kdu-but-more-is-better-by-kdu
                    ! .      (nve-by-kdu) vertical work wv arrow along
                    ! .      the left-hand-edge. ====
                    kdu = 2*ns
                    ku = n - kdu + 1
                    kwh = kdu + 1
                    nho = ( n-kdu+1-4 ) - ( kdu+1 ) + 1
                    kwv = kdu + 4
                    nve = n - kdu - kwv + 1
                    ! ==== small-bulge multi-shift qr sweep ====
                    call stdlib_dlaqr5( wantt, wantz, kacc22, n, ktop, kbot, ns,wr( ks ), wi( ks )&
                    , h, ldh, iloz, ihiz, z,ldz, work, 3, h( ku, 1 ), ldh, nve,h( kwv, 1 ), ldh, &
                              nho, h( ku, kwh ), ldh )
                 end if
                 ! ==== note progress (or the lack of it). ====
                 if( ld>0 ) then
                    ndfl = 1
                 else
                    ndfl = ndfl + 1
                 end if
                 ! ==== end of main loop ====
              end do loop_80
              ! ==== iteration limit exceeded.  set info to show where
              ! .    the problem occurred and exit. ====
              info = kbot
              90 continue
           end if
           ! ==== return the optimal value of lwork. ====
           work( 1 ) = real( lwkopt,KIND=dp)
     end subroutine stdlib_dlaqr4

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$laqr4( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, work, lwork, info )
     !! DLAQR4: implements one level of recursion for DLAQR0.
     !! It is a complete implementation of the small bulge multi-shift
     !! QR algorithm.  It may be called by DLAQR0 and, for large enough
     !! deflation window size, it may be called by DLAQR3.  This
     !! subroutine is identical to DLAQR0 except that it calls DLAQR2
     !! instead of DLAQR3.
     !! DLAQR4 computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**T, where T is an upper quasi-triangular matrix (the
     !! Schur form), and Z is the orthogonal matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input orthogonal
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
                
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(${rk}$), intent(inout) :: h(ldh,*), z(ldz,*)
           real(${rk}$), intent(out) :: wi(*), work(*), wr(*)
        ! ================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: kexnw = 5
           integer(ilp), parameter :: kexsh = 6
           real(${rk}$), parameter :: wilk1 = 0.75_${rk}$
           real(${rk}$), parameter :: wilk2 = -0.4375_${rk}$
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_${ri}$lahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== exceptional deflation windows:  try to cure rare
           ! .    slow convergence by varying the size of the
           ! .    deflation window after kexnw iterations. ====
           
           ! ==== exceptional shifts: try to cure rare slow convergence
           ! .    with ad-hoc exceptional shifts every kexsh iterations.
           ! .    ====
           
           ! ==== the constants wilk1 and wilk2 are used to form the
           ! .    exceptional shifts. ====
           
           
           ! Local Scalars 
           real(${rk}$) :: aa, bb, cc, cs, dd, sn, ss, swap
           integer(ilp) :: i, inf, it, itmax, k, kacc22, kbot, kdu, ks, kt, ktop, ku, kv, kwh, &
           kwtop, kwv, ld, ls, lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns, nsmax, nsr, nve, nw,&
                      nwmax, nwr, nwupbd
           logical(lk) :: sorted
           character :: jbcmpz*2
           ! Local Arrays 
           real(${rk}$) :: zdum(1,1)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! ==== quick return for n = 0: nothing to do. ====
           if( n==0 ) then
              work( 1 ) = one
              return
           end if
           if( n<=ntiny ) then
              ! ==== tiny matrices must use stdlib_${ri}$lahqr. ====
              lwkopt = 1
              if( lwork/=-1 )call stdlib_${ri}$lahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, &
                        ihiz, z, ldz, info )
           else
              ! ==== use small bulge multi-shift qr with aggressive early
              ! .    deflation on larger-than-tiny matrices. ====
              ! ==== hope for the best. ====
              info = 0
              ! ==== set up job flags for stdlib_ilaenv. ====
              if( wantt ) then
                 jbcmpz( 1: 1 ) = 'S'
              else
                 jbcmpz( 1: 1 ) = 'E'
              end if
              if( wantz ) then
                 jbcmpz( 2: 2 ) = 'V'
              else
                 jbcmpz( 2: 2 ) = 'N'
              end if
              ! ==== nwr = recommended deflation window size.  at this
              ! .    point,  n > ntiny = 15, so there is enough
              ! .    subdiagonal workspace for nwr>=2 as required.
              ! .    (in fact, there is enough subdiagonal space for
              ! .    nwr>=4.) ====
              nwr = stdlib_ilaenv( 13, 'DLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nwr = max( 2, nwr )
              nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
              ! ==== nsr = recommended number of simultaneous shifts.
              ! .    at this point n > ntiny = 15, so there is at
              ! .    enough subdiagonal workspace for nsr to be even
              ! .    and greater than or equal to two as required. ====
              nsr = stdlib_ilaenv( 15, 'DLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nsr = min( nsr, ( n-3 ) / 6, ihi-ilo )
              nsr = max( 2, nsr-mod( nsr, 2 ) )
              ! ==== estimate optimal workspace ====
              ! ==== workspace query call to stdlib_${ri}$laqr2 ====
              call stdlib_${ri}$laqr2( wantt, wantz, n, ilo, ihi, nwr+1, h, ldh, iloz,ihiz, z, ldz, ls,&
                         ld, wr, wi, h, ldh, n, h, ldh,n, h, ldh, work, -1 )
              ! ==== optimal workspace = max(stdlib_${ri}$laqr5, stdlib_${ri}$laqr2) ====
              lwkopt = max( 3*nsr / 2, int( work( 1 ),KIND=ilp) )
              ! ==== quick return in case of workspace query. ====
              if( lwork==-1 ) then
                 work( 1 ) = real( lwkopt,KIND=${rk}$)
                 return
              end if
              ! ==== stdlib_${ri}$lahqr/stdlib_${ri}$laqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'DLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nmin = max( ntiny, nmin )
              ! ==== nibble crossover point ====
              nibble = stdlib_ilaenv( 14, 'DLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nibble = max( 0, nibble )
              ! ==== accumulate reflections during ttswp?  use block
              ! .    2-by-2 structure during matrix-matrix multiply? ====
              kacc22 = stdlib_ilaenv( 16, 'DLAQR4', jbcmpz, n, ilo, ihi, lwork )
              kacc22 = max( 0, kacc22 )
              kacc22 = min( 2, kacc22 )
              ! ==== nwmax = the largest possible deflation window for
              ! .    which there is sufficient workspace. ====
              nwmax = min( ( n-1 ) / 3, lwork / 2 )
              nw = nwmax
              ! ==== nsmax = the largest number of simultaneous shifts
              ! .    for which there is sufficient workspace. ====
              nsmax = min( ( n-3 ) / 6, 2*lwork / 3 )
              nsmax = nsmax - mod( nsmax, 2 )
              ! ==== ndfl: an iteration count restarted at deflation. ====
              ndfl = 1
              ! ==== itmax = iteration limit ====
              itmax = max( 30, 2*kexsh )*max( 10, ( ihi-ilo+1 ) )
              ! ==== last row and column in the active block ====
              kbot = ihi
              ! ==== main loop ====
              loop_80: do it = 1, itmax
                 ! ==== done when kbot falls below ilo ====
                 if( kbot<ilo )go to 90
                 ! ==== locate active block ====
                 do k = kbot, ilo + 1, -1
                    if( h( k, k-1 )==zero )go to 20
                 end do
                 k = ilo
                 20 continue
                 ktop = k
                 ! ==== select deflation window size:
                 ! .    typical case:
                 ! .      if possible and advisable, nibble the entire
                 ! .      active block.  if not, use size min(nwr,nwmax)
                 ! .      or min(nwr+1,nwmax) depending upon which has
                 ! .      the smaller corresponding subdiagonal entry
                 ! .      (a heuristic).
                 ! .    exceptional case:
                 ! .      if there have been no deflations in kexnw or
                 ! .      more iterations, then vary the deflation window
                 ! .      size.   at first, because, larger windows are,
                 ! .      in general, more powerful than smaller ones,
                 ! .      rapidly increase the window to the maximum possible.
                 ! .      then, gradually reduce the window size. ====
                 nh = kbot - ktop + 1
                 nwupbd = min( nh, nwmax )
                 if( ndfl<kexnw ) then
                    nw = min( nwupbd, nwr )
                 else
                    nw = min( nwupbd, 2*nw )
                 end if
                 if( nw<nwmax ) then
                    if( nw>=nh-1 ) then
                       nw = nh
                    else
                       kwtop = kbot - nw + 1
                       if( abs( h( kwtop, kwtop-1 ) )>abs( h( kwtop-1, kwtop-2 ) ) )nw = nw + &
                                 1
                    end if
                 end if
                 if( ndfl<kexnw ) then
                    ndec = -1
                 else if( ndec>=0 .or. nw>=nwupbd ) then
                    ndec = ndec + 1
                    if( nw-ndec<2 )ndec = 0
                    nw = nw - ndec
                 end if
                 ! ==== aggressive early deflation:
                 ! .    split workspace under the subdiagonal into
                 ! .      - an nw-by-nw work array v in the lower
                 ! .        left-hand-corner,
                 ! .      - an nw-by-at-least-nw-but-more-is-better
                 ! .        (nw-by-nho) horizontal work array along
                 ! .        the bottom edge,
                 ! .      - an at-least-nw-but-more-is-better (nhv-by-nw)
                 ! .        vertical work array along the left-hand-edge.
                 ! .        ====
                 kv = n - nw + 1
                 kt = nw + 1
                 nho = ( n-nw-1 ) - kt + 1
                 kwv = nw + 2
                 nve = ( n-nw ) - kwv + 1
                 ! ==== aggressive early deflation ====
                 call stdlib_${ri}$laqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
                 ls, ld, wr, wi, h( kv, 1 ), ldh,nho, h( kv, kt ), ldh, nve, h( kwv, 1 ), ldh,&
                           work, lwork )
                 ! ==== adjust kbot accounting for new deflations. ====
                 kbot = kbot - ld
                 ! ==== ks points to the shifts. ====
                 ks = kbot - ls + 1
                 ! ==== skip an expensive qr sweep if there is a (partly
                 ! .    heuristic) reason to expect that many eigenvalues
                 ! .    will deflate without it.  here, the qr sweep is
                 ! .    skipped if many eigenvalues have just been deflated
                 ! .    or if the remaining active block is small.
                 if( ( ld==0 ) .or. ( ( 100*ld<=nw*nibble ) .and. ( kbot-ktop+1>min( nmin, nwmax )&
                            ) ) ) then
                    ! ==== ns = nominal number of simultaneous shifts.
                    ! .    this may be lowered (slightly) if stdlib_${ri}$laqr2
                    ! .    did not provide that many shifts. ====
                    ns = min( nsmax, nsr, max( 2, kbot-ktop ) )
                    ns = ns - mod( ns, 2 )
                    ! ==== if there have been no deflations
                    ! .    in a multiple of kexsh iterations,
                    ! .    then try exceptional shifts.
                    ! .    otherwise use shifts provided by
                    ! .    stdlib_${ri}$laqr2 above or from the eigenvalues
                    ! .    of a trailing principal submatrix. ====
                    if( mod( ndfl, kexsh )==0 ) then
                       ks = kbot - ns + 1
                       do i = kbot, max( ks+1, ktop+2 ), -2
                          ss = abs( h( i, i-1 ) ) + abs( h( i-1, i-2 ) )
                          aa = wilk1*ss + h( i, i )
                          bb = ss
                          cc = wilk2*ss
                          dd = aa
                          call stdlib_${ri}$lanv2( aa, bb, cc, dd, wr( i-1 ), wi( i-1 ),wr( i ), wi( i &
                                    ), cs, sn )
                       end do
                       if( ks==ktop ) then
                          wr( ks+1 ) = h( ks+1, ks+1 )
                          wi( ks+1 ) = zero
                          wr( ks ) = wr( ks+1 )
                          wi( ks ) = wi( ks+1 )
                       end if
                    else
                       ! ==== got ns/2 or fewer shifts? use stdlib_${ri}$lahqr
                       ! .    on a trailing principal submatrix to
                       ! .    get more. (since ns<=nsmax<=(n-3)/6,
                       ! .    there is enough space below the subdiagonal
                       ! .    to fit an ns-by-ns scratch array.) ====
                       if( kbot-ks+1<=ns / 2 ) then
                          ks = kbot - ns + 1
                          kt = n - ns + 1
                          call stdlib_${ri}$lacpy( 'A', ns, ns, h( ks, ks ), ldh,h( kt, 1 ), ldh )
                                    
                          call stdlib_${ri}$lahqr( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, wr( ks &
                                    ), wi( ks ),1, 1, zdum, 1, inf )
                          ks = ks + inf
                          ! ==== in case of a rare qr failure use
                          ! .    eigenvalues of the trailing 2-by-2
                          ! .    principal submatrix.  ====
                          if( ks>=kbot ) then
                             aa = h( kbot-1, kbot-1 )
                             cc = h( kbot, kbot-1 )
                             bb = h( kbot-1, kbot )
                             dd = h( kbot, kbot )
                             call stdlib_${ri}$lanv2( aa, bb, cc, dd, wr( kbot-1 ),wi( kbot-1 ), wr( &
                                       kbot ),wi( kbot ), cs, sn )
                             ks = kbot - 1
                          end if
                       end if
                       if( kbot-ks+1>ns ) then
                          ! ==== sort the shifts (helps a little)
                          ! .    bubble sort keeps complex conjugate
                          ! .    pairs together. ====
                          sorted = .false.
                          do k = kbot, ks + 1, -1
                             if( sorted )go to 60
                             sorted = .true.
                             do i = ks, k - 1
                                if( abs( wr( i ) )+abs( wi( i ) )<abs( wr( i+1 ) )+abs( wi( i+1 ) &
                                          ) ) then
                                   sorted = .false.
                                   swap = wr( i )
                                   wr( i ) = wr( i+1 )
                                   wr( i+1 ) = swap
                                   swap = wi( i )
                                   wi( i ) = wi( i+1 )
                                   wi( i+1 ) = swap
                                end if
                             end do
                          end do
                          60 continue
                       end if
                       ! ==== shuffle shifts into pairs of real shifts
                       ! .    and pairs of complex conjugate shifts
                       ! .    assuming complex conjugate shifts are
                       ! .    already adjacent to one another. (yes,
                       ! .    they are.)  ====
                       do i = kbot, ks + 2, -2
                          if( wi( i )/=-wi( i-1 ) ) then
                             swap = wr( i )
                             wr( i ) = wr( i-1 )
                             wr( i-1 ) = wr( i-2 )
                             wr( i-2 ) = swap
                             swap = wi( i )
                             wi( i ) = wi( i-1 )
                             wi( i-1 ) = wi( i-2 )
                             wi( i-2 ) = swap
                          end if
                       end do
                    end if
                    ! ==== if there are only two shifts and both are
                    ! .    real, then use only one.  ====
                    if( kbot-ks+1==2 ) then
                       if( wi( kbot )==zero ) then
                          if( abs( wr( kbot )-h( kbot, kbot ) )<abs( wr( kbot-1 )-h( kbot, kbot ) &
                                    ) ) then
                             wr( kbot-1 ) = wr( kbot )
                          else
                             wr( kbot ) = wr( kbot-1 )
                          end if
                       end if
                    end if
                    ! ==== use up to ns of the the smallest magnitude
                    ! .    shifts.  if there aren't ns shifts available,
                    ! .    then use them all, possibly dropping one to
                    ! .    make the number of shifts even. ====
                    ns = min( ns, kbot-ks+1 )
                    ns = ns - mod( ns, 2 )
                    ks = kbot - ns + 1
                    ! ==== small-bulge multi-shift qr sweep:
                    ! .    split workspace under the subdiagonal into
                    ! .    - a kdu-by-kdu work array u in the lower
                    ! .      left-hand-corner,
                    ! .    - a kdu-by-at-least-kdu-but-more-is-better
                    ! .      (kdu-by-nho) horizontal work array wh along
                    ! .      the bottom edge,
                    ! .    - and an at-least-kdu-but-more-is-better-by-kdu
                    ! .      (nve-by-kdu) vertical work wv arrow along
                    ! .      the left-hand-edge. ====
                    kdu = 2*ns
                    ku = n - kdu + 1
                    kwh = kdu + 1
                    nho = ( n-kdu+1-4 ) - ( kdu+1 ) + 1
                    kwv = kdu + 4
                    nve = n - kdu - kwv + 1
                    ! ==== small-bulge multi-shift qr sweep ====
                    call stdlib_${ri}$laqr5( wantt, wantz, kacc22, n, ktop, kbot, ns,wr( ks ), wi( ks )&
                    , h, ldh, iloz, ihiz, z,ldz, work, 3, h( ku, 1 ), ldh, nve,h( kwv, 1 ), ldh, &
                              nho, h( ku, kwh ), ldh )
                 end if
                 ! ==== note progress (or the lack of it). ====
                 if( ld>0 ) then
                    ndfl = 1
                 else
                    ndfl = ndfl + 1
                 end if
                 ! ==== end of main loop ====
              end do loop_80
              ! ==== iteration limit exceeded.  set info to show where
              ! .    the problem occurred and exit. ====
              info = kbot
              90 continue
           end if
           ! ==== return the optimal value of lwork. ====
           work( 1 ) = real( lwkopt,KIND=${rk}$)
     end subroutine stdlib_${ri}$laqr4

#:endif
#:endfor

     module pure subroutine stdlib_claqr4( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, work, lwork, info )
     !! CLAQR4 implements one level of recursion for CLAQR0.
     !! It is a complete implementation of the small bulge multi-shift
     !! QR algorithm.  It may be called by CLAQR0 and, for large enough
     !! deflation window size, it may be called by CLAQR3.  This
     !! subroutine is identical to CLAQR0 except that it calls CLAQR2
     !! instead of CLAQR3.
     !! CLAQR4 computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**H, where T is an upper triangular matrix (the
     !! Schur form), and Z is the unitary matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input unitary
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
                
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: w(*), work(*)
        ! ================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: kexnw = 5
           integer(ilp), parameter :: kexsh = 6
           real(sp), parameter :: wilk1 = 0.75_sp
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_clahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== exceptional deflation windows:  try to cure rare
           ! .    slow convergence by varying the size of the
           ! .    deflation window after kexnw iterations. ====
           
           ! ==== exceptional shifts: try to cure rare slow convergence
           ! .    with ad-hoc exceptional shifts every kexsh iterations.
           ! .    ====
           
           ! ==== the constant wilk1 is used to form the exceptional
           ! .    shifts. ====
           
           
           
           ! Local Scalars 
           complex(sp) :: aa, bb, cc, cdum, dd, det, rtdisc, swap, tr2
           real(sp) :: s
           integer(ilp) :: i, inf, it, itmax, k, kacc22, kbot, kdu, ks, kt, ktop, ku, kv, kwh, &
           kwtop, kwv, ld, ls, lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns, nsmax, nsr, nve, nw,&
                      nwmax, nwr, nwupbd
           logical(lk) :: sorted
           character :: jbcmpz*2
           ! Local Arrays 
           complex(sp) :: zdum(1,1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! ==== quick return for n = 0: nothing to do. ====
           if( n==0 ) then
              work( 1 ) = cone
              return
           end if
           if( n<=ntiny ) then
              ! ==== tiny matrices must use stdlib_clahqr. ====
              lwkopt = 1
              if( lwork/=-1 )call stdlib_clahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, &
                        z, ldz, info )
           else
              ! ==== use small bulge multi-shift qr with aggressive early
              ! .    deflation on larger-than-tiny matrices. ====
              ! ==== hope for the best. ====
              info = 0
              ! ==== set up job flags for stdlib_ilaenv. ====
              if( wantt ) then
                 jbcmpz( 1: 1 ) = 'S'
              else
                 jbcmpz( 1: 1 ) = 'E'
              end if
              if( wantz ) then
                 jbcmpz( 2: 2 ) = 'V'
              else
                 jbcmpz( 2: 2 ) = 'N'
              end if
              ! ==== nwr = recommended deflation window size.  at this
              ! .    point,  n > ntiny = 15, so there is enough
              ! .    subdiagonal workspace for nwr>=2 as required.
              ! .    (in fact, there is enough subdiagonal space for
              ! .    nwr>=4.) ====
              nwr = stdlib_ilaenv( 13, 'CLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nwr = max( 2, nwr )
              nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
              ! ==== nsr = recommended number of simultaneous shifts.
              ! .    at this point n > ntiny = 15, so there is at
              ! .    enough subdiagonal workspace for nsr to be even
              ! .    and greater than or equal to two as required. ====
              nsr = stdlib_ilaenv( 15, 'CLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nsr = min( nsr, ( n-3 ) / 6, ihi-ilo )
              nsr = max( 2, nsr-mod( nsr, 2 ) )
              ! ==== estimate optimal workspace ====
              ! ==== workspace query call to stdlib_claqr2 ====
              call stdlib_claqr2( wantt, wantz, n, ilo, ihi, nwr+1, h, ldh, iloz,ihiz, z, ldz, ls,&
                         ld, w, h, ldh, n, h, ldh, n, h,ldh, work, -1 )
              ! ==== optimal workspace = max(stdlib_claqr5, stdlib_claqr2) ====
              lwkopt = max( 3*nsr / 2, int( work( 1 ),KIND=ilp) )
              ! ==== quick return in case of workspace query. ====
              if( lwork==-1 ) then
                 work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
                 return
              end if
              ! ==== stdlib_clahqr/stdlib_claqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'CLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nmin = max( ntiny, nmin )
              ! ==== nibble crossover point ====
              nibble = stdlib_ilaenv( 14, 'CLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nibble = max( 0, nibble )
              ! ==== accumulate reflections during ttswp?  use block
              ! .    2-by-2 structure during matrix-matrix multiply? ====
              kacc22 = stdlib_ilaenv( 16, 'CLAQR4', jbcmpz, n, ilo, ihi, lwork )
              kacc22 = max( 0, kacc22 )
              kacc22 = min( 2, kacc22 )
              ! ==== nwmax = the largest possible deflation window for
              ! .    which there is sufficient workspace. ====
              nwmax = min( ( n-1 ) / 3, lwork / 2 )
              nw = nwmax
              ! ==== nsmax = the largest number of simultaneous shifts
              ! .    for which there is sufficient workspace. ====
              nsmax = min( ( n-3 ) / 6, 2*lwork / 3 )
              nsmax = nsmax - mod( nsmax, 2 )
              ! ==== ndfl: an iteration count restarted at deflation. ====
              ndfl = 1
              ! ==== itmax = iteration limit ====
              itmax = max( 30, 2*kexsh )*max( 10, ( ihi-ilo+1 ) )
              ! ==== last row and column in the active block ====
              kbot = ihi
              ! ==== main loop ====
              loop_70: do it = 1, itmax
                 ! ==== done when kbot falls below ilo ====
                 if( kbot<ilo )go to 80
                 ! ==== locate active block ====
                 do k = kbot, ilo + 1, -1
                    if( h( k, k-1 )==czero )go to 20
                 end do
                 k = ilo
                 20 continue
                 ktop = k
                 ! ==== select deflation window size:
                 ! .    typical case:
                 ! .      if possible and advisable, nibble the entire
                 ! .      active block.  if not, use size min(nwr,nwmax)
                 ! .      or min(nwr+1,nwmax) depending upon which has
                 ! .      the smaller corresponding subdiagonal entry
                 ! .      (a heuristic).
                 ! .    exceptional case:
                 ! .      if there have been no deflations in kexnw or
                 ! .      more iterations, then vary the deflation window
                 ! .      size.   at first, because, larger windows are,
                 ! .      in general, more powerful than smaller ones,
                 ! .      rapidly increase the window to the maximum possible.
                 ! .      then, gradually reduce the window size. ====
                 nh = kbot - ktop + 1
                 nwupbd = min( nh, nwmax )
                 if( ndfl<kexnw ) then
                    nw = min( nwupbd, nwr )
                 else
                    nw = min( nwupbd, 2*nw )
                 end if
                 if( nw<nwmax ) then
                    if( nw>=nh-1 ) then
                       nw = nh
                    else
                       kwtop = kbot - nw + 1
                       if( cabs1( h( kwtop, kwtop-1 ) )>cabs1( h( kwtop-1, kwtop-2 ) ) )nw = nw + &
                                 1
                    end if
                 end if
                 if( ndfl<kexnw ) then
                    ndec = -1
                 else if( ndec>=0 .or. nw>=nwupbd ) then
                    ndec = ndec + 1
                    if( nw-ndec<2 )ndec = 0
                    nw = nw - ndec
                 end if
                 ! ==== aggressive early deflation:
                 ! .    split workspace under the subdiagonal into
                 ! .      - an nw-by-nw work array v in the lower
                 ! .        left-hand-corner,
                 ! .      - an nw-by-at-least-nw-but-more-is-better
                 ! .        (nw-by-nho) horizontal work array along
                 ! .        the bottom edge,
                 ! .      - an at-least-nw-but-more-is-better (nhv-by-nw)
                 ! .        vertical work array along the left-hand-edge.
                 ! .        ====
                 kv = n - nw + 1
                 kt = nw + 1
                 nho = ( n-nw-1 ) - kt + 1
                 kwv = nw + 2
                 nve = ( n-nw ) - kwv + 1
                 ! ==== aggressive early deflation ====
                 call stdlib_claqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
                 ls, ld, w, h( kv, 1 ), ldh, nho,h( kv, kt ), ldh, nve, h( kwv, 1 ), ldh, work,&
                           lwork )
                 ! ==== adjust kbot accounting for new deflations. ====
                 kbot = kbot - ld
                 ! ==== ks points to the shifts. ====
                 ks = kbot - ls + 1
                 ! ==== skip an expensive qr sweep if there is a (partly
                 ! .    heuristic) reason to expect that many eigenvalues
                 ! .    will deflate without it.  here, the qr sweep is
                 ! .    skipped if many eigenvalues have just been deflated
                 ! .    or if the remaining active block is small.
                 if( ( ld==0 ) .or. ( ( 100*ld<=nw*nibble ) .and. ( kbot-ktop+1>min( nmin, nwmax )&
                            ) ) ) then
                    ! ==== ns = nominal number of simultaneous shifts.
                    ! .    this may be lowered (slightly) if stdlib_claqr2
                    ! .    did not provide that many shifts. ====
                    ns = min( nsmax, nsr, max( 2, kbot-ktop ) )
                    ns = ns - mod( ns, 2 )
                    ! ==== if there have been no deflations
                    ! .    in a multiple of kexsh iterations,
                    ! .    then try exceptional shifts.
                    ! .    otherwise use shifts provided by
                    ! .    stdlib_claqr2 above or from the eigenvalues
                    ! .    of a trailing principal submatrix. ====
                    if( mod( ndfl, kexsh )==0 ) then
                       ks = kbot - ns + 1
                       do i = kbot, ks + 1, -2
                          w( i ) = h( i, i ) + wilk1*cabs1( h( i, i-1 ) )
                          w( i-1 ) = w( i )
                       end do
                    else
                       ! ==== got ns/2 or fewer shifts? use stdlib_clahqr
                       ! .    on a trailing principal submatrix to
                       ! .    get more. (since ns<=nsmax<=(n-3)/6,
                       ! .    there is enough space below the subdiagonal
                       ! .    to fit an ns-by-ns scratch array.) ====
                       if( kbot-ks+1<=ns / 2 ) then
                          ks = kbot - ns + 1
                          kt = n - ns + 1
                          call stdlib_clacpy( 'A', ns, ns, h( ks, ks ), ldh,h( kt, 1 ), ldh )
                                    
                          call stdlib_clahqr( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, w( ks )&
                                    , 1, 1, zdum,1, inf )
                          ks = ks + inf
                          ! ==== in case of a rare qr failure use
                          ! .    eigenvalues of the trailing 2-by-2
                          ! .    principal submatrix.  scale to avoid
                          ! .    overflows, underflows and subnormals.
                          ! .    (the scale factor s can not be czero,
                          ! .    because h(kbot,kbot-1) is nonzero.) ====
                          if( ks>=kbot ) then
                             s = cabs1( h( kbot-1, kbot-1 ) ) +cabs1( h( kbot, kbot-1 ) ) +cabs1( &
                                       h( kbot-1, kbot ) ) +cabs1( h( kbot, kbot ) )
                             aa = h( kbot-1, kbot-1 ) / s
                             cc = h( kbot, kbot-1 ) / s
                             bb = h( kbot-1, kbot ) / s
                             dd = h( kbot, kbot ) / s
                             tr2 = ( aa+dd ) / two
                             det = ( aa-tr2 )*( dd-tr2 ) - bb*cc
                             rtdisc = sqrt( -det )
                             w( kbot-1 ) = ( tr2+rtdisc )*s
                             w( kbot ) = ( tr2-rtdisc )*s
                             ks = kbot - 1
                          end if
                       end if
                       if( kbot-ks+1>ns ) then
                          ! ==== sort the shifts (helps a little) ====
                          sorted = .false.
                          do k = kbot, ks + 1, -1
                             if( sorted )go to 60
                             sorted = .true.
                             do i = ks, k - 1
                                if( cabs1( w( i ) )<cabs1( w( i+1 ) ) )then
                                   sorted = .false.
                                   swap = w( i )
                                   w( i ) = w( i+1 )
                                   w( i+1 ) = swap
                                end if
                             end do
                          end do
                          60 continue
                       end if
                    end if
                    ! ==== if there are only two shifts, then use
                    ! .    only cone.  ====
                    if( kbot-ks+1==2 ) then
                       if( cabs1( w( kbot )-h( kbot, kbot ) )<cabs1( w( kbot-1 )-h( kbot, kbot ) )&
                                  ) then
                          w( kbot-1 ) = w( kbot )
                       else
                          w( kbot ) = w( kbot-1 )
                       end if
                    end if
                    ! ==== use up to ns of the the smallest magnitude
                    ! .    shifts.  if there aren't ns shifts available,
                    ! .    then use them all, possibly dropping cone to
                    ! .    make the number of shifts even. ====
                    ns = min( ns, kbot-ks+1 )
                    ns = ns - mod( ns, 2 )
                    ks = kbot - ns + 1
                    ! ==== small-bulge multi-shift qr sweep:
                    ! .    split workspace under the subdiagonal into
                    ! .    - a kdu-by-kdu work array u in the lower
                    ! .      left-hand-corner,
                    ! .    - a kdu-by-at-least-kdu-but-more-is-better
                    ! .      (kdu-by-nho) horizontal work array wh along
                    ! .      the bottom edge,
                    ! .    - and an at-least-kdu-but-more-is-better-by-kdu
                    ! .      (nve-by-kdu) vertical work wv arrow along
                    ! .      the left-hand-edge. ====
                    kdu = 2*ns
                    ku = n - kdu + 1
                    kwh = kdu + 1
                    nho = ( n-kdu+1-4 ) - ( kdu+1 ) + 1
                    kwv = kdu + 4
                    nve = n - kdu - kwv + 1
                    ! ==== small-bulge multi-shift qr sweep ====
                    call stdlib_claqr5( wantt, wantz, kacc22, n, ktop, kbot, ns,w( ks ), h, ldh, &
                    iloz, ihiz, z, ldz, work,3, h( ku, 1 ), ldh, nve, h( kwv, 1 ), ldh,nho, h( ku,&
                               kwh ), ldh )
                 end if
                 ! ==== note progress (or the lack of it). ====
                 if( ld>0 ) then
                    ndfl = 1
                 else
                    ndfl = ndfl + 1
                 end if
                 ! ==== end of main loop ====
              end do loop_70
              ! ==== iteration limit exceeded.  set info to show where
              ! .    the problem occurred and exit. ====
              info = kbot
              80 continue
           end if
           ! ==== return the optimal value of lwork. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
     end subroutine stdlib_claqr4

     module pure subroutine stdlib_zlaqr4( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, work,lwork, info )
     !! ZLAQR4 implements one level of recursion for ZLAQR0.
     !! It is a complete implementation of the small bulge multi-shift
     !! QR algorithm.  It may be called by ZLAQR0 and, for large enough
     !! deflation window size, it may be called by ZLAQR3.  This
     !! subroutine is identical to ZLAQR0 except that it calls ZLAQR2
     !! instead of ZLAQR3.
     !! ZLAQR4 computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**H, where T is an upper triangular matrix (the
     !! Schur form), and Z is the unitary matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input unitary
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
                
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(dp), intent(out) :: w(*), work(*)
        ! ================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: kexnw = 5
           integer(ilp), parameter :: kexsh = 6
           real(dp), parameter :: wilk1 = 0.75_dp
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_zlahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== exceptional deflation windows:  try to cure rare
           ! .    slow convergence by varying the size of the
           ! .    deflation window after kexnw iterations. ====
           
           ! ==== exceptional shifts: try to cure rare slow convergence
           ! .    with ad-hoc exceptional shifts every kexsh iterations.
           ! .    ====
           
           ! ==== the constant wilk1 is used to form the exceptional
           ! .    shifts. ====
           
           
           
           ! Local Scalars 
           complex(dp) :: aa, bb, cc, cdum, dd, det, rtdisc, swap, tr2
           real(dp) :: s
           integer(ilp) :: i, inf, it, itmax, k, kacc22, kbot, kdu, ks, kt, ktop, ku, kv, kwh, &
           kwtop, kwv, ld, ls, lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns, nsmax, nsr, nve, nw,&
                      nwmax, nwr, nwupbd
           logical(lk) :: sorted
           character :: jbcmpz*2
           ! Local Arrays 
           complex(dp) :: zdum(1,1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! ==== quick return for n = 0: nothing to do. ====
           if( n==0 ) then
              work( 1 ) = cone
              return
           end if
           if( n<=ntiny ) then
              ! ==== tiny matrices must use stdlib_zlahqr. ====
              lwkopt = 1
              if( lwork/=-1 )call stdlib_zlahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, &
                        z, ldz, info )
           else
              ! ==== use small bulge multi-shift qr with aggressive early
              ! .    deflation on larger-than-tiny matrices. ====
              ! ==== hope for the best. ====
              info = 0
              ! ==== set up job flags for stdlib_ilaenv. ====
              if( wantt ) then
                 jbcmpz( 1: 1 ) = 'S'
              else
                 jbcmpz( 1: 1 ) = 'E'
              end if
              if( wantz ) then
                 jbcmpz( 2: 2 ) = 'V'
              else
                 jbcmpz( 2: 2 ) = 'N'
              end if
              ! ==== nwr = recommended deflation window size.  at this
              ! .    point,  n > ntiny = 15, so there is enough
              ! .    subdiagonal workspace for nwr>=2 as required.
              ! .    (in fact, there is enough subdiagonal space for
              ! .    nwr>=4.) ====
              nwr = stdlib_ilaenv( 13, 'ZLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nwr = max( 2, nwr )
              nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
              ! ==== nsr = recommended number of simultaneous shifts.
              ! .    at this point n > ntiny = 15, so there is at
              ! .    enough subdiagonal workspace for nsr to be even
              ! .    and greater than or equal to two as required. ====
              nsr = stdlib_ilaenv( 15, 'ZLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nsr = min( nsr, ( n-3 ) / 6, ihi-ilo )
              nsr = max( 2, nsr-mod( nsr, 2 ) )
              ! ==== estimate optimal workspace ====
              ! ==== workspace query call to stdlib_zlaqr2 ====
              call stdlib_zlaqr2( wantt, wantz, n, ilo, ihi, nwr+1, h, ldh, iloz,ihiz, z, ldz, ls,&
                         ld, w, h, ldh, n, h, ldh, n, h,ldh, work, -1 )
              ! ==== optimal workspace = max(stdlib_zlaqr5, stdlib_zlaqr2) ====
              lwkopt = max( 3*nsr / 2, int( work( 1 ),KIND=ilp) )
              ! ==== quick return in case of workspace query. ====
              if( lwork==-1 ) then
                 work( 1 ) = cmplx( lwkopt, 0,KIND=dp)
                 return
              end if
              ! ==== stdlib_zlahqr/stdlib_zlaqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'ZLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nmin = max( ntiny, nmin )
              ! ==== nibble crossover point ====
              nibble = stdlib_ilaenv( 14, 'ZLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nibble = max( 0, nibble )
              ! ==== accumulate reflections during ttswp?  use block
              ! .    2-by-2 structure during matrix-matrix multiply? ====
              kacc22 = stdlib_ilaenv( 16, 'ZLAQR4', jbcmpz, n, ilo, ihi, lwork )
              kacc22 = max( 0, kacc22 )
              kacc22 = min( 2, kacc22 )
              ! ==== nwmax = the largest possible deflation window for
              ! .    which there is sufficient workspace. ====
              nwmax = min( ( n-1 ) / 3, lwork / 2 )
              nw = nwmax
              ! ==== nsmax = the largest number of simultaneous shifts
              ! .    for which there is sufficient workspace. ====
              nsmax = min( ( n-3 ) / 6, 2*lwork / 3 )
              nsmax = nsmax - mod( nsmax, 2 )
              ! ==== ndfl: an iteration count restarted at deflation. ====
              ndfl = 1
              ! ==== itmax = iteration limit ====
              itmax = max( 30, 2*kexsh )*max( 10, ( ihi-ilo+1 ) )
              ! ==== last row and column in the active block ====
              kbot = ihi
              ! ==== main loop ====
              loop_70: do it = 1, itmax
                 ! ==== done when kbot falls below ilo ====
                 if( kbot<ilo )go to 80
                 ! ==== locate active block ====
                 do k = kbot, ilo + 1, -1
                    if( h( k, k-1 )==czero )go to 20
                 end do
                 k = ilo
                 20 continue
                 ktop = k
                 ! ==== select deflation window size:
                 ! .    typical case:
                 ! .      if possible and advisable, nibble the entire
                 ! .      active block.  if not, use size min(nwr,nwmax)
                 ! .      or min(nwr+1,nwmax) depending upon which has
                 ! .      the smaller corresponding subdiagonal entry
                 ! .      (a heuristic).
                 ! .    exceptional case:
                 ! .      if there have been no deflations in kexnw or
                 ! .      more iterations, then vary the deflation window
                 ! .      size.   at first, because, larger windows are,
                 ! .      in general, more powerful than smaller ones,
                 ! .      rapidly increase the window to the maximum possible.
                 ! .      then, gradually reduce the window size. ====
                 nh = kbot - ktop + 1
                 nwupbd = min( nh, nwmax )
                 if( ndfl<kexnw ) then
                    nw = min( nwupbd, nwr )
                 else
                    nw = min( nwupbd, 2*nw )
                 end if
                 if( nw<nwmax ) then
                    if( nw>=nh-1 ) then
                       nw = nh
                    else
                       kwtop = kbot - nw + 1
                       if( cabs1( h( kwtop, kwtop-1 ) )>cabs1( h( kwtop-1, kwtop-2 ) ) )nw = nw + &
                                 1
                    end if
                 end if
                 if( ndfl<kexnw ) then
                    ndec = -1
                 else if( ndec>=0 .or. nw>=nwupbd ) then
                    ndec = ndec + 1
                    if( nw-ndec<2 )ndec = 0
                    nw = nw - ndec
                 end if
                 ! ==== aggressive early deflation:
                 ! .    split workspace under the subdiagonal into
                 ! .      - an nw-by-nw work array v in the lower
                 ! .        left-hand-corner,
                 ! .      - an nw-by-at-least-nw-but-more-is-better
                 ! .        (nw-by-nho) horizontal work array along
                 ! .        the bottom edge,
                 ! .      - an at-least-nw-but-more-is-better (nhv-by-nw)
                 ! .        vertical work array along the left-hand-edge.
                 ! .        ====
                 kv = n - nw + 1
                 kt = nw + 1
                 nho = ( n-nw-1 ) - kt + 1
                 kwv = nw + 2
                 nve = ( n-nw ) - kwv + 1
                 ! ==== aggressive early deflation ====
                 call stdlib_zlaqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
                 ls, ld, w, h( kv, 1 ), ldh, nho,h( kv, kt ), ldh, nve, h( kwv, 1 ), ldh, work,&
                           lwork )
                 ! ==== adjust kbot accounting for new deflations. ====
                 kbot = kbot - ld
                 ! ==== ks points to the shifts. ====
                 ks = kbot - ls + 1
                 ! ==== skip an expensive qr sweep if there is a (partly
                 ! .    heuristic) reason to expect that many eigenvalues
                 ! .    will deflate without it.  here, the qr sweep is
                 ! .    skipped if many eigenvalues have just been deflated
                 ! .    or if the remaining active block is small.
                 if( ( ld==0 ) .or. ( ( 100*ld<=nw*nibble ) .and. ( kbot-ktop+1>min( nmin, nwmax )&
                            ) ) ) then
                    ! ==== ns = nominal number of simultaneous shifts.
                    ! .    this may be lowered (slightly) if stdlib_zlaqr2
                    ! .    did not provide that many shifts. ====
                    ns = min( nsmax, nsr, max( 2, kbot-ktop ) )
                    ns = ns - mod( ns, 2 )
                    ! ==== if there have been no deflations
                    ! .    in a multiple of kexsh iterations,
                    ! .    then try exceptional shifts.
                    ! .    otherwise use shifts provided by
                    ! .    stdlib_zlaqr2 above or from the eigenvalues
                    ! .    of a trailing principal submatrix. ====
                    if( mod( ndfl, kexsh )==0 ) then
                       ks = kbot - ns + 1
                       do i = kbot, ks + 1, -2
                          w( i ) = h( i, i ) + wilk1*cabs1( h( i, i-1 ) )
                          w( i-1 ) = w( i )
                       end do
                    else
                       ! ==== got ns/2 or fewer shifts? use stdlib_zlahqr
                       ! .    on a trailing principal submatrix to
                       ! .    get more. (since ns<=nsmax<=(n-3)/6,
                       ! .    there is enough space below the subdiagonal
                       ! .    to fit an ns-by-ns scratch array.) ====
                       if( kbot-ks+1<=ns / 2 ) then
                          ks = kbot - ns + 1
                          kt = n - ns + 1
                          call stdlib_zlacpy( 'A', ns, ns, h( ks, ks ), ldh,h( kt, 1 ), ldh )
                                    
                          call stdlib_zlahqr( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, w( ks )&
                                    , 1, 1, zdum,1, inf )
                          ks = ks + inf
                          ! ==== in case of a rare qr failure use
                          ! .    eigenvalues of the trailing 2-by-2
                          ! .    principal submatrix.  scale to avoid
                          ! .    overflows, underflows and subnormals.
                          ! .    (the scale factor s can not be czero,
                          ! .    because h(kbot,kbot-1) is nonzero.) ====
                          if( ks>=kbot ) then
                             s = cabs1( h( kbot-1, kbot-1 ) ) +cabs1( h( kbot, kbot-1 ) ) +cabs1( &
                                       h( kbot-1, kbot ) ) +cabs1( h( kbot, kbot ) )
                             aa = h( kbot-1, kbot-1 ) / s
                             cc = h( kbot, kbot-1 ) / s
                             bb = h( kbot-1, kbot ) / s
                             dd = h( kbot, kbot ) / s
                             tr2 = ( aa+dd ) / two
                             det = ( aa-tr2 )*( dd-tr2 ) - bb*cc
                             rtdisc = sqrt( -det )
                             w( kbot-1 ) = ( tr2+rtdisc )*s
                             w( kbot ) = ( tr2-rtdisc )*s
                             ks = kbot - 1
                          end if
                       end if
                       if( kbot-ks+1>ns ) then
                          ! ==== sort the shifts (helps a little) ====
                          sorted = .false.
                          do k = kbot, ks + 1, -1
                             if( sorted )go to 60
                             sorted = .true.
                             do i = ks, k - 1
                                if( cabs1( w( i ) )<cabs1( w( i+1 ) ) )then
                                   sorted = .false.
                                   swap = w( i )
                                   w( i ) = w( i+1 )
                                   w( i+1 ) = swap
                                end if
                             end do
                          end do
                          60 continue
                       end if
                    end if
                    ! ==== if there are only two shifts, then use
                    ! .    only cone.  ====
                    if( kbot-ks+1==2 ) then
                       if( cabs1( w( kbot )-h( kbot, kbot ) )<cabs1( w( kbot-1 )-h( kbot, kbot ) )&
                                  ) then
                          w( kbot-1 ) = w( kbot )
                       else
                          w( kbot ) = w( kbot-1 )
                       end if
                    end if
                    ! ==== use up to ns of the the smallest magnitude
                    ! .    shifts.  if there aren't ns shifts available,
                    ! .    then use them all, possibly dropping cone to
                    ! .    make the number of shifts even. ====
                    ns = min( ns, kbot-ks+1 )
                    ns = ns - mod( ns, 2 )
                    ks = kbot - ns + 1
                    ! ==== small-bulge multi-shift qr sweep:
                    ! .    split workspace under the subdiagonal into
                    ! .    - a kdu-by-kdu work array u in the lower
                    ! .      left-hand-corner,
                    ! .    - a kdu-by-at-least-kdu-but-more-is-better
                    ! .      (kdu-by-nho) horizontal work array wh along
                    ! .      the bottom edge,
                    ! .    - and an at-least-kdu-but-more-is-better-by-kdu
                    ! .      (nve-by-kdu) vertical work wv arrow along
                    ! .      the left-hand-edge. ====
                    kdu = 2*ns
                    ku = n - kdu + 1
                    kwh = kdu + 1
                    nho = ( n-kdu+1-4 ) - ( kdu+1 ) + 1
                    kwv = kdu + 4
                    nve = n - kdu - kwv + 1
                    ! ==== small-bulge multi-shift qr sweep ====
                    call stdlib_zlaqr5( wantt, wantz, kacc22, n, ktop, kbot, ns,w( ks ), h, ldh, &
                    iloz, ihiz, z, ldz, work,3, h( ku, 1 ), ldh, nve, h( kwv, 1 ), ldh,nho, h( ku,&
                               kwh ), ldh )
                 end if
                 ! ==== note progress (or the lack of it). ====
                 if( ld>0 ) then
                    ndfl = 1
                 else
                    ndfl = ndfl + 1
                 end if
                 ! ==== end of main loop ====
              end do loop_70
              ! ==== iteration limit exceeded.  set info to show where
              ! .    the problem occurred and exit. ====
              info = kbot
              80 continue
           end if
           ! ==== return the optimal value of lwork. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=dp)
     end subroutine stdlib_zlaqr4

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$laqr4( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, work, lwork, info )
     !! ZLAQR4: implements one level of recursion for ZLAQR0.
     !! It is a complete implementation of the small bulge multi-shift
     !! QR algorithm.  It may be called by ZLAQR0 and, for large enough
     !! deflation window size, it may be called by ZLAQR3.  This
     !! subroutine is identical to ZLAQR0 except that it calls ZLAQR2
     !! instead of ZLAQR3.
     !! ZLAQR4 computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**H, where T is an upper triangular matrix (the
     !! Schur form), and Z is the unitary matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input unitary
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
                
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(${ck}$), intent(out) :: w(*), work(*)
        ! ================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: kexnw = 5
           integer(ilp), parameter :: kexsh = 6
           real(${ck}$), parameter :: wilk1 = 0.75_${ck}$
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_${ci}$lahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== exceptional deflation windows:  try to cure rare
           ! .    slow convergence by varying the size of the
           ! .    deflation window after kexnw iterations. ====
           
           ! ==== exceptional shifts: try to cure rare slow convergence
           ! .    with ad-hoc exceptional shifts every kexsh iterations.
           ! .    ====
           
           ! ==== the constant wilk1 is used to form the exceptional
           ! .    shifts. ====
           
           
           
           ! Local Scalars 
           complex(${ck}$) :: aa, bb, cc, cdum, dd, det, rtdisc, swap, tr2
           real(${ck}$) :: s
           integer(ilp) :: i, inf, it, itmax, k, kacc22, kbot, kdu, ks, kt, ktop, ku, kv, kwh, &
           kwtop, kwv, ld, ls, lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns, nsmax, nsr, nve, nw,&
                      nwmax, nwr, nwupbd
           logical(lk) :: sorted
           character :: jbcmpz*2
           ! Local Arrays 
           complex(${ck}$) :: zdum(1,1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! ==== quick return for n = 0: nothing to do. ====
           if( n==0 ) then
              work( 1 ) = cone
              return
           end if
           if( n<=ntiny ) then
              ! ==== tiny matrices must use stdlib_${ci}$lahqr. ====
              lwkopt = 1
              if( lwork/=-1 )call stdlib_${ci}$lahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, &
                        z, ldz, info )
           else
              ! ==== use small bulge multi-shift qr with aggressive early
              ! .    deflation on larger-than-tiny matrices. ====
              ! ==== hope for the best. ====
              info = 0
              ! ==== set up job flags for stdlib_ilaenv. ====
              if( wantt ) then
                 jbcmpz( 1: 1 ) = 'S'
              else
                 jbcmpz( 1: 1 ) = 'E'
              end if
              if( wantz ) then
                 jbcmpz( 2: 2 ) = 'V'
              else
                 jbcmpz( 2: 2 ) = 'N'
              end if
              ! ==== nwr = recommended deflation window size.  at this
              ! .    point,  n > ntiny = 15, so there is enough
              ! .    subdiagonal workspace for nwr>=2 as required.
              ! .    (in fact, there is enough subdiagonal space for
              ! .    nwr>=4.) ====
              nwr = stdlib_ilaenv( 13, 'ZLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nwr = max( 2, nwr )
              nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
              ! ==== nsr = recommended number of simultaneous shifts.
              ! .    at this point n > ntiny = 15, so there is at
              ! .    enough subdiagonal workspace for nsr to be even
              ! .    and greater than or equal to two as required. ====
              nsr = stdlib_ilaenv( 15, 'ZLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nsr = min( nsr, ( n-3 ) / 6, ihi-ilo )
              nsr = max( 2, nsr-mod( nsr, 2 ) )
              ! ==== estimate optimal workspace ====
              ! ==== workspace query call to stdlib_${ci}$laqr2 ====
              call stdlib_${ci}$laqr2( wantt, wantz, n, ilo, ihi, nwr+1, h, ldh, iloz,ihiz, z, ldz, ls,&
                         ld, w, h, ldh, n, h, ldh, n, h,ldh, work, -1 )
              ! ==== optimal workspace = max(stdlib_${ci}$laqr5, stdlib_${ci}$laqr2) ====
              lwkopt = max( 3*nsr / 2, int( work( 1 ),KIND=ilp) )
              ! ==== quick return in case of workspace query. ====
              if( lwork==-1 ) then
                 work( 1 ) = cmplx( lwkopt, 0,KIND=${ck}$)
                 return
              end if
              ! ==== stdlib_${ci}$lahqr/stdlib_${ci}$laqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'ZLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nmin = max( ntiny, nmin )
              ! ==== nibble crossover point ====
              nibble = stdlib_ilaenv( 14, 'ZLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nibble = max( 0, nibble )
              ! ==== accumulate reflections during ttswp?  use block
              ! .    2-by-2 structure during matrix-matrix multiply? ====
              kacc22 = stdlib_ilaenv( 16, 'ZLAQR4', jbcmpz, n, ilo, ihi, lwork )
              kacc22 = max( 0, kacc22 )
              kacc22 = min( 2, kacc22 )
              ! ==== nwmax = the largest possible deflation window for
              ! .    which there is sufficient workspace. ====
              nwmax = min( ( n-1 ) / 3, lwork / 2 )
              nw = nwmax
              ! ==== nsmax = the largest number of simultaneous shifts
              ! .    for which there is sufficient workspace. ====
              nsmax = min( ( n-3 ) / 6, 2*lwork / 3 )
              nsmax = nsmax - mod( nsmax, 2 )
              ! ==== ndfl: an iteration count restarted at deflation. ====
              ndfl = 1
              ! ==== itmax = iteration limit ====
              itmax = max( 30, 2*kexsh )*max( 10, ( ihi-ilo+1 ) )
              ! ==== last row and column in the active block ====
              kbot = ihi
              ! ==== main loop ====
              loop_70: do it = 1, itmax
                 ! ==== done when kbot falls below ilo ====
                 if( kbot<ilo )go to 80
                 ! ==== locate active block ====
                 do k = kbot, ilo + 1, -1
                    if( h( k, k-1 )==czero )go to 20
                 end do
                 k = ilo
                 20 continue
                 ktop = k
                 ! ==== select deflation window size:
                 ! .    typical case:
                 ! .      if possible and advisable, nibble the entire
                 ! .      active block.  if not, use size min(nwr,nwmax)
                 ! .      or min(nwr+1,nwmax) depending upon which has
                 ! .      the smaller corresponding subdiagonal entry
                 ! .      (a heuristic).
                 ! .    exceptional case:
                 ! .      if there have been no deflations in kexnw or
                 ! .      more iterations, then vary the deflation window
                 ! .      size.   at first, because, larger windows are,
                 ! .      in general, more powerful than smaller ones,
                 ! .      rapidly increase the window to the maximum possible.
                 ! .      then, gradually reduce the window size. ====
                 nh = kbot - ktop + 1
                 nwupbd = min( nh, nwmax )
                 if( ndfl<kexnw ) then
                    nw = min( nwupbd, nwr )
                 else
                    nw = min( nwupbd, 2*nw )
                 end if
                 if( nw<nwmax ) then
                    if( nw>=nh-1 ) then
                       nw = nh
                    else
                       kwtop = kbot - nw + 1
                       if( cabs1( h( kwtop, kwtop-1 ) )>cabs1( h( kwtop-1, kwtop-2 ) ) )nw = nw + &
                                 1
                    end if
                 end if
                 if( ndfl<kexnw ) then
                    ndec = -1
                 else if( ndec>=0 .or. nw>=nwupbd ) then
                    ndec = ndec + 1
                    if( nw-ndec<2 )ndec = 0
                    nw = nw - ndec
                 end if
                 ! ==== aggressive early deflation:
                 ! .    split workspace under the subdiagonal into
                 ! .      - an nw-by-nw work array v in the lower
                 ! .        left-hand-corner,
                 ! .      - an nw-by-at-least-nw-but-more-is-better
                 ! .        (nw-by-nho) horizontal work array along
                 ! .        the bottom edge,
                 ! .      - an at-least-nw-but-more-is-better (nhv-by-nw)
                 ! .        vertical work array along the left-hand-edge.
                 ! .        ====
                 kv = n - nw + 1
                 kt = nw + 1
                 nho = ( n-nw-1 ) - kt + 1
                 kwv = nw + 2
                 nve = ( n-nw ) - kwv + 1
                 ! ==== aggressive early deflation ====
                 call stdlib_${ci}$laqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
                 ls, ld, w, h( kv, 1 ), ldh, nho,h( kv, kt ), ldh, nve, h( kwv, 1 ), ldh, work,&
                           lwork )
                 ! ==== adjust kbot accounting for new deflations. ====
                 kbot = kbot - ld
                 ! ==== ks points to the shifts. ====
                 ks = kbot - ls + 1
                 ! ==== skip an expensive qr sweep if there is a (partly
                 ! .    heuristic) reason to expect that many eigenvalues
                 ! .    will deflate without it.  here, the qr sweep is
                 ! .    skipped if many eigenvalues have just been deflated
                 ! .    or if the remaining active block is small.
                 if( ( ld==0 ) .or. ( ( 100*ld<=nw*nibble ) .and. ( kbot-ktop+1>min( nmin, nwmax )&
                            ) ) ) then
                    ! ==== ns = nominal number of simultaneous shifts.
                    ! .    this may be lowered (slightly) if stdlib_${ci}$laqr2
                    ! .    did not provide that many shifts. ====
                    ns = min( nsmax, nsr, max( 2, kbot-ktop ) )
                    ns = ns - mod( ns, 2 )
                    ! ==== if there have been no deflations
                    ! .    in a multiple of kexsh iterations,
                    ! .    then try exceptional shifts.
                    ! .    otherwise use shifts provided by
                    ! .    stdlib_${ci}$laqr2 above or from the eigenvalues
                    ! .    of a trailing principal submatrix. ====
                    if( mod( ndfl, kexsh )==0 ) then
                       ks = kbot - ns + 1
                       do i = kbot, ks + 1, -2
                          w( i ) = h( i, i ) + wilk1*cabs1( h( i, i-1 ) )
                          w( i-1 ) = w( i )
                       end do
                    else
                       ! ==== got ns/2 or fewer shifts? use stdlib_${ci}$lahqr
                       ! .    on a trailing principal submatrix to
                       ! .    get more. (since ns<=nsmax<=(n-3)/6,
                       ! .    there is enough space below the subdiagonal
                       ! .    to fit an ns-by-ns scratch array.) ====
                       if( kbot-ks+1<=ns / 2 ) then
                          ks = kbot - ns + 1
                          kt = n - ns + 1
                          call stdlib_${ci}$lacpy( 'A', ns, ns, h( ks, ks ), ldh,h( kt, 1 ), ldh )
                                    
                          call stdlib_${ci}$lahqr( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, w( ks )&
                                    , 1, 1, zdum,1, inf )
                          ks = ks + inf
                          ! ==== in case of a rare qr failure use
                          ! .    eigenvalues of the trailing 2-by-2
                          ! .    principal submatrix.  scale to avoid
                          ! .    overflows, underflows and subnormals.
                          ! .    (the scale factor s can not be czero,
                          ! .    because h(kbot,kbot-1) is nonzero.) ====
                          if( ks>=kbot ) then
                             s = cabs1( h( kbot-1, kbot-1 ) ) +cabs1( h( kbot, kbot-1 ) ) +cabs1( &
                                       h( kbot-1, kbot ) ) +cabs1( h( kbot, kbot ) )
                             aa = h( kbot-1, kbot-1 ) / s
                             cc = h( kbot, kbot-1 ) / s
                             bb = h( kbot-1, kbot ) / s
                             dd = h( kbot, kbot ) / s
                             tr2 = ( aa+dd ) / two
                             det = ( aa-tr2 )*( dd-tr2 ) - bb*cc
                             rtdisc = sqrt( -det )
                             w( kbot-1 ) = ( tr2+rtdisc )*s
                             w( kbot ) = ( tr2-rtdisc )*s
                             ks = kbot - 1
                          end if
                       end if
                       if( kbot-ks+1>ns ) then
                          ! ==== sort the shifts (helps a little) ====
                          sorted = .false.
                          do k = kbot, ks + 1, -1
                             if( sorted )go to 60
                             sorted = .true.
                             do i = ks, k - 1
                                if( cabs1( w( i ) )<cabs1( w( i+1 ) ) )then
                                   sorted = .false.
                                   swap = w( i )
                                   w( i ) = w( i+1 )
                                   w( i+1 ) = swap
                                end if
                             end do
                          end do
                          60 continue
                       end if
                    end if
                    ! ==== if there are only two shifts, then use
                    ! .    only cone.  ====
                    if( kbot-ks+1==2 ) then
                       if( cabs1( w( kbot )-h( kbot, kbot ) )<cabs1( w( kbot-1 )-h( kbot, kbot ) )&
                                  ) then
                          w( kbot-1 ) = w( kbot )
                       else
                          w( kbot ) = w( kbot-1 )
                       end if
                    end if
                    ! ==== use up to ns of the the smallest magnitude
                    ! .    shifts.  if there aren't ns shifts available,
                    ! .    then use them all, possibly dropping cone to
                    ! .    make the number of shifts even. ====
                    ns = min( ns, kbot-ks+1 )
                    ns = ns - mod( ns, 2 )
                    ks = kbot - ns + 1
                    ! ==== small-bulge multi-shift qr sweep:
                    ! .    split workspace under the subdiagonal into
                    ! .    - a kdu-by-kdu work array u in the lower
                    ! .      left-hand-corner,
                    ! .    - a kdu-by-at-least-kdu-but-more-is-better
                    ! .      (kdu-by-nho) horizontal work array wh along
                    ! .      the bottom edge,
                    ! .    - and an at-least-kdu-but-more-is-better-by-kdu
                    ! .      (nve-by-kdu) vertical work wv arrow along
                    ! .      the left-hand-edge. ====
                    kdu = 2*ns
                    ku = n - kdu + 1
                    kwh = kdu + 1
                    nho = ( n-kdu+1-4 ) - ( kdu+1 ) + 1
                    kwv = kdu + 4
                    nve = n - kdu - kwv + 1
                    ! ==== small-bulge multi-shift qr sweep ====
                    call stdlib_${ci}$laqr5( wantt, wantz, kacc22, n, ktop, kbot, ns,w( ks ), h, ldh, &
                    iloz, ihiz, z, ldz, work,3, h( ku, 1 ), ldh, nve, h( kwv, 1 ), ldh,nho, h( ku,&
                               kwh ), ldh )
                 end if
                 ! ==== note progress (or the lack of it). ====
                 if( ld>0 ) then
                    ndfl = 1
                 else
                    ndfl = ndfl + 1
                 end if
                 ! ==== end of main loop ====
              end do loop_70
              ! ==== iteration limit exceeded.  set info to show where
              ! .    the problem occurred and exit. ====
              info = kbot
              80 continue
           end if
           ! ==== return the optimal value of lwork. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=${ck}$)
     end subroutine stdlib_${ci}$laqr4

#:endif
#:endfor



     module subroutine stdlib_strsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )
     !! STRSYL solves the real Sylvester matrix equation:
     !! op(A)*X + X*op(B) = scale*C or
     !! op(A)*X - X*op(B) = scale*C,
     !! where op(A) = A or A**T, and  A and B are both upper quasi-
     !! triangular. A is M-by-M and B is N-by-N; the right hand side C and
     !! the solution X are M-by-N; and scale is an output scale factor, set
     !! <= 1 to avoid overflow in X.
     !! A and B must be in Schur canonical form (as returned by SHSEQR), that
     !! is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks;
     !! each 2-by-2 diagonal block has its diagonal elements equal and its
     !! off-diagonal elements of opposite sign.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trana, tranb
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: isgn, lda, ldb, ldc, m, n
           real(sp), intent(out) :: scale
           ! Array Arguments 
           real(sp), intent(in) :: a(lda,*), b(ldb,*)
           real(sp), intent(inout) :: c(ldc,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: notrna, notrnb
           integer(ilp) :: ierr, j, k, k1, k2, knext, l, l1, l2, lnext
           real(sp) :: a11, bignum, da11, db, eps, scaloc, sgn, smin, smlnum, suml, sumr, &
                     xnorm
           ! Local Arrays 
           real(sp) :: dum(1), vec(2,2), x(2,2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           notrna = stdlib_lsame( trana, 'N' )
           notrnb = stdlib_lsame( tranb, 'N' )
           info = 0
           if( .not.notrna .and. .not.stdlib_lsame( trana, 'T' ) .and. .not.stdlib_lsame( trana, &
                     'C' ) ) then
              info = -1
           else if( .not.notrnb .and. .not.stdlib_lsame( tranb, 'T' ) .and. .not.stdlib_lsame( &
                     tranb, 'C' ) ) then
              info = -2
           else if( isgn/=1 .and. isgn/=-1 ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, m ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldc<max( 1, m ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STRSYL', -info )
              return
           end if
           ! quick return if possible
           scale = one
           if( m==0 .or. n==0 )return
           ! set constants to control overflow
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = smlnum*real( m*n,KIND=sp) / eps
           bignum = one / smlnum
           smin = max( smlnum, eps*stdlib_slange( 'M', m, m, a, lda, dum ),eps*stdlib_slange( 'M',&
                      n, n, b, ldb, dum ) )
           sgn = isgn
           if( notrna .and. notrnb ) then
              ! solve    a*x + isgn*x*b = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! bottom-left corner column by column by
               ! a(k,k)*x(k,l) + isgn*x(k,l)*b(l,l) = c(k,l) - r(k,l)
              ! where
                        ! m                         l-1
              ! r(k,l) = sum [a(k,i)*x(i,l)] + isgn*sum [x(k,j)*b(j,l)].
                      ! i=k+1                       j=1
              ! start column loop (index = l)
              ! l1 (l2) : column index of the first (first) row of x(k,l).
              lnext = 1
              loop_70: do l = 1, n
                 if( l<lnext )cycle loop_70
                 if( l==n ) then
                    l1 = l
                    l2 = l
                 else
                    if( b( l+1, l )/=zero ) then
                       l1 = l
                       l2 = l + 1
                       lnext = l + 2
                    else
                       l1 = l
                       l2 = l
                       lnext = l + 1
                    end if
                 end if
                 ! start row loop (index = k)
                 ! k1 (k2): row index of the first (last) row of x(k,l).
                 knext = m
                 loop_60: do k = m, 1, -1
                    if( k>knext )cycle loop_60
                    if( k==1 ) then
                       k1 = k
                       k2 = k
                    else
                       if( a( k, k-1 )/=zero ) then
                          k1 = k - 1
                          k2 = k
                          knext = k - 2
                       else
                          k1 = k
                          k2 = k
                          knext = k - 1
                       end if
                    end if
                    if( l1==l2 .and. k1==k2 ) then
                       suml = stdlib_sdot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_sdot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       scaloc = one
                       a11 = a( k1, k1 ) + sgn*b( l1, l1 )
                       da11 = abs( a11 )
                       if( da11<=smin ) then
                          a11 = smin
                          da11 = smin
                          info = 1
                       end if
                       db = abs( vec( 1, 1 ) )
                       if( da11<one .and. db>one ) then
                          if( db>bignum*da11 )scaloc = one / db
                       end if
                       x( 1, 1 ) = ( vec( 1, 1 )*scaloc ) / a11
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                    else if( l1==l2 .and. k1/=k2 ) then
                       suml = stdlib_sdot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_sdot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_sdot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_sdot( l1-1, c( k2, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       call stdlib_slaln2( .false., 2, 1, smin, one, a( k1, k1 ),lda, one, one, &
                                 vec, 2, -sgn*b( l1, l1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k2, l1 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1==k2 ) then
                       suml = stdlib_sdot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_sdot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = sgn*( c( k1, l1 )-( suml+sgn*sumr ) )
                       suml = stdlib_sdot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_sdot( l1-1, c( k1, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 2, 1 ) = sgn*( c( k1, l2 )-( suml+sgn*sumr ) )
                       call stdlib_slaln2( .true., 2, 1, smin, one, b( l1, l1 ),ldb, one, one, &
                                 vec, 2, -sgn*a( k1, k1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1/=k2 ) then
                       suml = stdlib_sdot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_sdot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_sdot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_sdot( l1-1, c( k1, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 1, 2 ) = c( k1, l2 ) - ( suml+sgn*sumr )
                       suml = stdlib_sdot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_sdot( l1-1, c( k2, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_sdot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_sdot( l1-1, c( k2, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 2, 2 ) = c( k2, l2 ) - ( suml+sgn*sumr )
                       call stdlib_slasy2( .false., .false., isgn, 2, 2,a( k1, k1 ), lda, b( l1, &
                                 l1 ), ldb, vec,2, scaloc, x, 2, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 1, 2 )
                       c( k2, l1 ) = x( 2, 1 )
                       c( k2, l2 ) = x( 2, 2 )
                    end if
                 end do loop_60
              end do loop_70
           else if( .not.notrna .and. notrnb ) then
              ! solve    a**t *x + isgn*x*b = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! upper-left corner column by column by
                ! a(k,k)**t*x(k,l) + isgn*x(k,l)*b(l,l) = c(k,l) - r(k,l)
              ! where
                         ! k-1                          l-1
                ! r(k,l) = sum [a(i,k)**t*x(i,l)] +isgn*sum [x(k,j)*b(j,l)]
                         ! i=1                          j=1
              ! start column loop (index = l)
              ! l1 (l2): column index of the first (last) row of x(k,l)
              lnext = 1
              loop_130: do l = 1, n
                 if( l<lnext )cycle loop_130
                 if( l==n ) then
                    l1 = l
                    l2 = l
                 else
                    if( b( l+1, l )/=zero ) then
                       l1 = l
                       l2 = l + 1
                       lnext = l + 2
                    else
                       l1 = l
                       l2 = l
                       lnext = l + 1
                    end if
                 end if
                 ! start row loop (index = k)
                 ! k1 (k2): row index of the first (last) row of x(k,l)
                 knext = 1
                 loop_120: do k = 1, m
                    if( k<knext )cycle loop_120
                    if( k==m ) then
                       k1 = k
                       k2 = k
                    else
                       if( a( k+1, k )/=zero ) then
                          k1 = k
                          k2 = k + 1
                          knext = k + 2
                       else
                          k1 = k
                          k2 = k
                          knext = k + 1
                       end if
                    end if
                    if( l1==l2 .and. k1==k2 ) then
                       suml = stdlib_sdot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_sdot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       scaloc = one
                       a11 = a( k1, k1 ) + sgn*b( l1, l1 )
                       da11 = abs( a11 )
                       if( da11<=smin ) then
                          a11 = smin
                          da11 = smin
                          info = 1
                       end if
                       db = abs( vec( 1, 1 ) )
                       if( da11<one .and. db>one ) then
                          if( db>bignum*da11 )scaloc = one / db
                       end if
                       x( 1, 1 ) = ( vec( 1, 1 )*scaloc ) / a11
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                    else if( l1==l2 .and. k1/=k2 ) then
                       suml = stdlib_sdot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_sdot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_sdot( k1-1, a( 1, k2 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_sdot( l1-1, c( k2, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       call stdlib_slaln2( .true., 2, 1, smin, one, a( k1, k1 ),lda, one, one, &
                                 vec, 2, -sgn*b( l1, l1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k2, l1 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1==k2 ) then
                       suml = stdlib_sdot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_sdot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = sgn*( c( k1, l1 )-( suml+sgn*sumr ) )
                       suml = stdlib_sdot( k1-1, a( 1, k1 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_sdot( l1-1, c( k1, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 2, 1 ) = sgn*( c( k1, l2 )-( suml+sgn*sumr ) )
                       call stdlib_slaln2( .true., 2, 1, smin, one, b( l1, l1 ),ldb, one, one, &
                                 vec, 2, -sgn*a( k1, k1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1/=k2 ) then
                       suml = stdlib_sdot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_sdot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_sdot( k1-1, a( 1, k1 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_sdot( l1-1, c( k1, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 1, 2 ) = c( k1, l2 ) - ( suml+sgn*sumr )
                       suml = stdlib_sdot( k1-1, a( 1, k2 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_sdot( l1-1, c( k2, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_sdot( k1-1, a( 1, k2 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_sdot( l1-1, c( k2, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 2, 2 ) = c( k2, l2 ) - ( suml+sgn*sumr )
                       call stdlib_slasy2( .true., .false., isgn, 2, 2, a( k1, k1 ),lda, b( l1, &
                                 l1 ), ldb, vec, 2, scaloc, x,2, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 1, 2 )
                       c( k2, l1 ) = x( 2, 1 )
                       c( k2, l2 ) = x( 2, 2 )
                    end if
                 end do loop_120
              end do loop_130
           else if( .not.notrna .and. .not.notrnb ) then
              ! solve    a**t*x + isgn*x*b**t = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! top-right corner column by column by
                 ! a(k,k)**t*x(k,l) + isgn*x(k,l)*b(l,l)**t = c(k,l) - r(k,l)
              ! where
                           ! k-1                            n
                  ! r(k,l) = sum [a(i,k)**t*x(i,l)] + isgn*sum [x(k,j)*b(l,j)**t].
                           ! i=1                          j=l+1
              ! start column loop (index = l)
              ! l1 (l2): column index of the first (last) row of x(k,l)
              lnext = n
              loop_190: do l = n, 1, -1
                 if( l>lnext )cycle loop_190
                 if( l==1 ) then
                    l1 = l
                    l2 = l
                 else
                    if( b( l, l-1 )/=zero ) then
                       l1 = l - 1
                       l2 = l
                       lnext = l - 2
                    else
                       l1 = l
                       l2 = l
                       lnext = l - 1
                    end if
                 end if
                 ! start row loop (index = k)
                 ! k1 (k2): row index of the first (last) row of x(k,l)
                 knext = 1
                 loop_180: do k = 1, m
                    if( k<knext )cycle loop_180
                    if( k==m ) then
                       k1 = k
                       k2 = k
                    else
                       if( a( k+1, k )/=zero ) then
                          k1 = k
                          k2 = k + 1
                          knext = k + 2
                       else
                          k1 = k
                          k2 = k
                          knext = k + 1
                       end if
                    end if
                    if( l1==l2 .and. k1==k2 ) then
                       suml = stdlib_sdot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_sdot( n-l1, c( k1, min( l1+1, n ) ), ldc,b( l1, min( l1+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       scaloc = one
                       a11 = a( k1, k1 ) + sgn*b( l1, l1 )
                       da11 = abs( a11 )
                       if( da11<=smin ) then
                          a11 = smin
                          da11 = smin
                          info = 1
                       end if
                       db = abs( vec( 1, 1 ) )
                       if( da11<one .and. db>one ) then
                          if( db>bignum*da11 )scaloc = one / db
                       end if
                       x( 1, 1 ) = ( vec( 1, 1 )*scaloc ) / a11
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                    else if( l1==l2 .and. k1/=k2 ) then
                       suml = stdlib_sdot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_sdot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_sdot( k1-1, a( 1, k2 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_sdot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       call stdlib_slaln2( .true., 2, 1, smin, one, a( k1, k1 ),lda, one, one, &
                                 vec, 2, -sgn*b( l1, l1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k2, l1 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1==k2 ) then
                       suml = stdlib_sdot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_sdot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = sgn*( c( k1, l1 )-( suml+sgn*sumr ) )
                       suml = stdlib_sdot( k1-1, a( 1, k1 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_sdot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = sgn*( c( k1, l2 )-( suml+sgn*sumr ) )
                       call stdlib_slaln2( .false., 2, 1, smin, one, b( l1, l1 ),ldb, one, one, &
                                 vec, 2, -sgn*a( k1, k1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1/=k2 ) then
                       suml = stdlib_sdot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_sdot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_sdot( k1-1, a( 1, k1 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_sdot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 2 ) = c( k1, l2 ) - ( suml+sgn*sumr )
                       suml = stdlib_sdot( k1-1, a( 1, k2 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_sdot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_sdot( k1-1, a( 1, k2 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_sdot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l2, min(l2+1, n )&
                                  ), ldb )
                       vec( 2, 2 ) = c( k2, l2 ) - ( suml+sgn*sumr )
                       call stdlib_slasy2( .true., .true., isgn, 2, 2, a( k1, k1 ),lda, b( l1, l1 &
                                 ), ldb, vec, 2, scaloc, x,2, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 1, 2 )
                       c( k2, l1 ) = x( 2, 1 )
                       c( k2, l2 ) = x( 2, 2 )
                    end if
                 end do loop_180
              end do loop_190
           else if( notrna .and. .not.notrnb ) then
              ! solve    a*x + isgn*x*b**t = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! bottom-right corner column by column by
                  ! a(k,k)*x(k,l) + isgn*x(k,l)*b(l,l)**t = c(k,l) - r(k,l)
              ! where
                            ! m                          n
                  ! r(k,l) = sum [a(k,i)*x(i,l)] + isgn*sum [x(k,j)*b(l,j)**t].
                          ! i=k+1                      j=l+1
              ! start column loop (index = l)
              ! l1 (l2): column index of the first (last) row of x(k,l)
              lnext = n
              loop_250: do l = n, 1, -1
                 if( l>lnext )cycle loop_250
                 if( l==1 ) then
                    l1 = l
                    l2 = l
                 else
                    if( b( l, l-1 )/=zero ) then
                       l1 = l - 1
                       l2 = l
                       lnext = l - 2
                    else
                       l1 = l
                       l2 = l
                       lnext = l - 1
                    end if
                 end if
                 ! start row loop (index = k)
                 ! k1 (k2): row index of the first (last) row of x(k,l)
                 knext = m
                 loop_240: do k = m, 1, -1
                    if( k>knext )cycle loop_240
                    if( k==1 ) then
                       k1 = k
                       k2 = k
                    else
                       if( a( k, k-1 )/=zero ) then
                          k1 = k - 1
                          k2 = k
                          knext = k - 2
                       else
                          k1 = k
                          k2 = k
                          knext = k - 1
                       end if
                    end if
                    if( l1==l2 .and. k1==k2 ) then
                       suml = stdlib_sdot( m-k1, a( k1, min(k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_sdot( n-l1, c( k1, min( l1+1, n ) ), ldc,b( l1, min( l1+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       scaloc = one
                       a11 = a( k1, k1 ) + sgn*b( l1, l1 )
                       da11 = abs( a11 )
                       if( da11<=smin ) then
                          a11 = smin
                          da11 = smin
                          info = 1
                       end if
                       db = abs( vec( 1, 1 ) )
                       if( da11<one .and. db>one ) then
                          if( db>bignum*da11 )scaloc = one / db
                       end if
                       x( 1, 1 ) = ( vec( 1, 1 )*scaloc ) / a11
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                    else if( l1==l2 .and. k1/=k2 ) then
                       suml = stdlib_sdot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_sdot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_sdot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_sdot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       call stdlib_slaln2( .false., 2, 1, smin, one, a( k1, k1 ),lda, one, one, &
                                 vec, 2, -sgn*b( l1, l1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k2, l1 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1==k2 ) then
                       suml = stdlib_sdot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_sdot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = sgn*( c( k1, l1 )-( suml+sgn*sumr ) )
                       suml = stdlib_sdot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_sdot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = sgn*( c( k1, l2 )-( suml+sgn*sumr ) )
                       call stdlib_slaln2( .false., 2, 1, smin, one, b( l1, l1 ),ldb, one, one, &
                                 vec, 2, -sgn*a( k1, k1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1/=k2 ) then
                       suml = stdlib_sdot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_sdot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_sdot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_sdot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 2 ) = c( k1, l2 ) - ( suml+sgn*sumr )
                       suml = stdlib_sdot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_sdot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_sdot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_sdot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 2 ) = c( k2, l2 ) - ( suml+sgn*sumr )
                       call stdlib_slasy2( .false., .true., isgn, 2, 2, a( k1, k1 ),lda, b( l1, &
                                 l1 ), ldb, vec, 2, scaloc, x,2, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 1, 2 )
                       c( k2, l1 ) = x( 2, 1 )
                       c( k2, l2 ) = x( 2, 2 )
                    end if
                 end do loop_240
              end do loop_250
           end if
           return
     end subroutine stdlib_strsyl

     module subroutine stdlib_dtrsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )
     !! DTRSYL solves the real Sylvester matrix equation:
     !! op(A)*X + X*op(B) = scale*C or
     !! op(A)*X - X*op(B) = scale*C,
     !! where op(A) = A or A**T, and  A and B are both upper quasi-
     !! triangular. A is M-by-M and B is N-by-N; the right hand side C and
     !! the solution X are M-by-N; and scale is an output scale factor, set
     !! <= 1 to avoid overflow in X.
     !! A and B must be in Schur canonical form (as returned by DHSEQR), that
     !! is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks;
     !! each 2-by-2 diagonal block has its diagonal elements equal and its
     !! off-diagonal elements of opposite sign.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trana, tranb
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: isgn, lda, ldb, ldc, m, n
           real(dp), intent(out) :: scale
           ! Array Arguments 
           real(dp), intent(in) :: a(lda,*), b(ldb,*)
           real(dp), intent(inout) :: c(ldc,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: notrna, notrnb
           integer(ilp) :: ierr, j, k, k1, k2, knext, l, l1, l2, lnext
           real(dp) :: a11, bignum, da11, db, eps, scaloc, sgn, smin, smlnum, suml, sumr, &
                     xnorm
           ! Local Arrays 
           real(dp) :: dum(1), vec(2,2), x(2,2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           notrna = stdlib_lsame( trana, 'N' )
           notrnb = stdlib_lsame( tranb, 'N' )
           info = 0
           if( .not.notrna .and. .not.stdlib_lsame( trana, 'T' ) .and. .not.stdlib_lsame( trana, &
                     'C' ) ) then
              info = -1
           else if( .not.notrnb .and. .not.stdlib_lsame( tranb, 'T' ) .and. .not.stdlib_lsame( &
                     tranb, 'C' ) ) then
              info = -2
           else if( isgn/=1 .and. isgn/=-1 ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, m ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldc<max( 1, m ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTRSYL', -info )
              return
           end if
           ! quick return if possible
           scale = one
           if( m==0 .or. n==0 )return
           ! set constants to control overflow
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' )
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           smlnum = smlnum*real( m*n,KIND=dp) / eps
           bignum = one / smlnum
           smin = max( smlnum, eps*stdlib_dlange( 'M', m, m, a, lda, dum ),eps*stdlib_dlange( 'M',&
                      n, n, b, ldb, dum ) )
           sgn = isgn
           if( notrna .and. notrnb ) then
              ! solve    a*x + isgn*x*b = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! bottom-left corner column by column by
               ! a(k,k)*x(k,l) + isgn*x(k,l)*b(l,l) = c(k,l) - r(k,l)
              ! where
                        ! m                         l-1
              ! r(k,l) = sum [a(k,i)*x(i,l)] + isgn*sum [x(k,j)*b(j,l)].
                      ! i=k+1                       j=1
              ! start column loop (index = l)
              ! l1 (l2) : column index of the first (first) row of x(k,l).
              lnext = 1
              loop_60: do l = 1, n
                 if( l<lnext )cycle loop_60
                 if( l==n ) then
                    l1 = l
                    l2 = l
                 else
                    if( b( l+1, l )/=zero ) then
                       l1 = l
                       l2 = l + 1
                       lnext = l + 2
                    else
                       l1 = l
                       l2 = l
                       lnext = l + 1
                    end if
                 end if
                 ! start row loop (index = k)
                 ! k1 (k2): row index of the first (last) row of x(k,l).
                 knext = m
                 loop_50: do k = m, 1, -1
                    if( k>knext )cycle loop_50
                    if( k==1 ) then
                       k1 = k
                       k2 = k
                    else
                       if( a( k, k-1 )/=zero ) then
                          k1 = k - 1
                          k2 = k
                          knext = k - 2
                       else
                          k1 = k
                          k2 = k
                          knext = k - 1
                       end if
                    end if
                    if( l1==l2 .and. k1==k2 ) then
                       suml = stdlib_ddot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_ddot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       scaloc = one
                       a11 = a( k1, k1 ) + sgn*b( l1, l1 )
                       da11 = abs( a11 )
                       if( da11<=smin ) then
                          a11 = smin
                          da11 = smin
                          info = 1
                       end if
                       db = abs( vec( 1, 1 ) )
                       if( da11<one .and. db>one ) then
                          if( db>bignum*da11 )scaloc = one / db
                       end if
                       x( 1, 1 ) = ( vec( 1, 1 )*scaloc ) / a11
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                    else if( l1==l2 .and. k1/=k2 ) then
                       suml = stdlib_ddot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_ddot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_ddot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_ddot( l1-1, c( k2, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       call stdlib_dlaln2( .false., 2, 1, smin, one, a( k1, k1 ),lda, one, one, &
                                 vec, 2, -sgn*b( l1, l1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k2, l1 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1==k2 ) then
                       suml = stdlib_ddot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_ddot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = sgn*( c( k1, l1 )-( suml+sgn*sumr ) )
                       suml = stdlib_ddot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_ddot( l1-1, c( k1, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 2, 1 ) = sgn*( c( k1, l2 )-( suml+sgn*sumr ) )
                       call stdlib_dlaln2( .true., 2, 1, smin, one, b( l1, l1 ),ldb, one, one, &
                                 vec, 2, -sgn*a( k1, k1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1/=k2 ) then
                       suml = stdlib_ddot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_ddot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_ddot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_ddot( l1-1, c( k1, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 1, 2 ) = c( k1, l2 ) - ( suml+sgn*sumr )
                       suml = stdlib_ddot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_ddot( l1-1, c( k2, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_ddot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_ddot( l1-1, c( k2, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 2, 2 ) = c( k2, l2 ) - ( suml+sgn*sumr )
                       call stdlib_dlasy2( .false., .false., isgn, 2, 2,a( k1, k1 ), lda, b( l1, &
                                 l1 ), ldb, vec,2, scaloc, x, 2, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 1, 2 )
                       c( k2, l1 ) = x( 2, 1 )
                       c( k2, l2 ) = x( 2, 2 )
                    end if
                 end do loop_50
              end do loop_60
           else if( .not.notrna .and. notrnb ) then
              ! solve    a**t *x + isgn*x*b = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! upper-left corner column by column by
                ! a(k,k)**t*x(k,l) + isgn*x(k,l)*b(l,l) = c(k,l) - r(k,l)
              ! where
                         ! k-1        t                    l-1
                ! r(k,l) = sum [a(i,k)**t*x(i,l)] +isgn*sum [x(k,j)*b(j,l)]
                         ! i=1                          j=1
              ! start column loop (index = l)
              ! l1 (l2): column index of the first (last) row of x(k,l)
              lnext = 1
              loop_120: do l = 1, n
                 if( l<lnext )cycle loop_120
                 if( l==n ) then
                    l1 = l
                    l2 = l
                 else
                    if( b( l+1, l )/=zero ) then
                       l1 = l
                       l2 = l + 1
                       lnext = l + 2
                    else
                       l1 = l
                       l2 = l
                       lnext = l + 1
                    end if
                 end if
                 ! start row loop (index = k)
                 ! k1 (k2): row index of the first (last) row of x(k,l)
                 knext = 1
                 loop_110: do k = 1, m
                    if( k<knext )cycle loop_110
                    if( k==m ) then
                       k1 = k
                       k2 = k
                    else
                       if( a( k+1, k )/=zero ) then
                          k1 = k
                          k2 = k + 1
                          knext = k + 2
                       else
                          k1 = k
                          k2 = k
                          knext = k + 1
                       end if
                    end if
                    if( l1==l2 .and. k1==k2 ) then
                       suml = stdlib_ddot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_ddot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       scaloc = one
                       a11 = a( k1, k1 ) + sgn*b( l1, l1 )
                       da11 = abs( a11 )
                       if( da11<=smin ) then
                          a11 = smin
                          da11 = smin
                          info = 1
                       end if
                       db = abs( vec( 1, 1 ) )
                       if( da11<one .and. db>one ) then
                          if( db>bignum*da11 )scaloc = one / db
                       end if
                       x( 1, 1 ) = ( vec( 1, 1 )*scaloc ) / a11
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                    else if( l1==l2 .and. k1/=k2 ) then
                       suml = stdlib_ddot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_ddot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_ddot( k1-1, a( 1, k2 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_ddot( l1-1, c( k2, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       call stdlib_dlaln2( .true., 2, 1, smin, one, a( k1, k1 ),lda, one, one, &
                                 vec, 2, -sgn*b( l1, l1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k2, l1 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1==k2 ) then
                       suml = stdlib_ddot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_ddot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = sgn*( c( k1, l1 )-( suml+sgn*sumr ) )
                       suml = stdlib_ddot( k1-1, a( 1, k1 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_ddot( l1-1, c( k1, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 2, 1 ) = sgn*( c( k1, l2 )-( suml+sgn*sumr ) )
                       call stdlib_dlaln2( .true., 2, 1, smin, one, b( l1, l1 ),ldb, one, one, &
                                 vec, 2, -sgn*a( k1, k1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1/=k2 ) then
                       suml = stdlib_ddot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_ddot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_ddot( k1-1, a( 1, k1 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_ddot( l1-1, c( k1, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 1, 2 ) = c( k1, l2 ) - ( suml+sgn*sumr )
                       suml = stdlib_ddot( k1-1, a( 1, k2 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_ddot( l1-1, c( k2, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_ddot( k1-1, a( 1, k2 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_ddot( l1-1, c( k2, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 2, 2 ) = c( k2, l2 ) - ( suml+sgn*sumr )
                       call stdlib_dlasy2( .true., .false., isgn, 2, 2, a( k1, k1 ),lda, b( l1, &
                                 l1 ), ldb, vec, 2, scaloc, x,2, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 1, 2 )
                       c( k2, l1 ) = x( 2, 1 )
                       c( k2, l2 ) = x( 2, 2 )
                    end if
                 end do loop_110
              end do loop_120
           else if( .not.notrna .and. .not.notrnb ) then
              ! solve    a**t*x + isgn*x*b**t = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! top-right corner column by column by
                 ! a(k,k)**t*x(k,l) + isgn*x(k,l)*b(l,l)**t = c(k,l) - r(k,l)
              ! where
                           ! k-1                            n
                  ! r(k,l) = sum [a(i,k)**t*x(i,l)] + isgn*sum [x(k,j)*b(l,j)**t].
                           ! i=1                          j=l+1
              ! start column loop (index = l)
              ! l1 (l2): column index of the first (last) row of x(k,l)
              lnext = n
              loop_180: do l = n, 1, -1
                 if( l>lnext )cycle loop_180
                 if( l==1 ) then
                    l1 = l
                    l2 = l
                 else
                    if( b( l, l-1 )/=zero ) then
                       l1 = l - 1
                       l2 = l
                       lnext = l - 2
                    else
                       l1 = l
                       l2 = l
                       lnext = l - 1
                    end if
                 end if
                 ! start row loop (index = k)
                 ! k1 (k2): row index of the first (last) row of x(k,l)
                 knext = 1
                 loop_170: do k = 1, m
                    if( k<knext )cycle loop_170
                    if( k==m ) then
                       k1 = k
                       k2 = k
                    else
                       if( a( k+1, k )/=zero ) then
                          k1 = k
                          k2 = k + 1
                          knext = k + 2
                       else
                          k1 = k
                          k2 = k
                          knext = k + 1
                       end if
                    end if
                    if( l1==l2 .and. k1==k2 ) then
                       suml = stdlib_ddot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_ddot( n-l1, c( k1, min( l1+1, n ) ), ldc,b( l1, min( l1+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       scaloc = one
                       a11 = a( k1, k1 ) + sgn*b( l1, l1 )
                       da11 = abs( a11 )
                       if( da11<=smin ) then
                          a11 = smin
                          da11 = smin
                          info = 1
                       end if
                       db = abs( vec( 1, 1 ) )
                       if( da11<one .and. db>one ) then
                          if( db>bignum*da11 )scaloc = one / db
                       end if
                       x( 1, 1 ) = ( vec( 1, 1 )*scaloc ) / a11
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                    else if( l1==l2 .and. k1/=k2 ) then
                       suml = stdlib_ddot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_ddot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_ddot( k1-1, a( 1, k2 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_ddot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       call stdlib_dlaln2( .true., 2, 1, smin, one, a( k1, k1 ),lda, one, one, &
                                 vec, 2, -sgn*b( l1, l1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k2, l1 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1==k2 ) then
                       suml = stdlib_ddot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_ddot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = sgn*( c( k1, l1 )-( suml+sgn*sumr ) )
                       suml = stdlib_ddot( k1-1, a( 1, k1 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_ddot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = sgn*( c( k1, l2 )-( suml+sgn*sumr ) )
                       call stdlib_dlaln2( .false., 2, 1, smin, one, b( l1, l1 ),ldb, one, one, &
                                 vec, 2, -sgn*a( k1, k1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1/=k2 ) then
                       suml = stdlib_ddot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_ddot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_ddot( k1-1, a( 1, k1 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_ddot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 2 ) = c( k1, l2 ) - ( suml+sgn*sumr )
                       suml = stdlib_ddot( k1-1, a( 1, k2 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_ddot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_ddot( k1-1, a( 1, k2 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_ddot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 2 ) = c( k2, l2 ) - ( suml+sgn*sumr )
                       call stdlib_dlasy2( .true., .true., isgn, 2, 2, a( k1, k1 ),lda, b( l1, l1 &
                                 ), ldb, vec, 2, scaloc, x,2, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 1, 2 )
                       c( k2, l1 ) = x( 2, 1 )
                       c( k2, l2 ) = x( 2, 2 )
                    end if
                 end do loop_170
              end do loop_180
           else if( notrna .and. .not.notrnb ) then
              ! solve    a*x + isgn*x*b**t = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! bottom-right corner column by column by
                  ! a(k,k)*x(k,l) + isgn*x(k,l)*b(l,l)**t = c(k,l) - r(k,l)
              ! where
                            ! m                          n
                  ! r(k,l) = sum [a(k,i)*x(i,l)] + isgn*sum [x(k,j)*b(l,j)**t].
                          ! i=k+1                      j=l+1
              ! start column loop (index = l)
              ! l1 (l2): column index of the first (last) row of x(k,l)
              lnext = n
              loop_240: do l = n, 1, -1
                 if( l>lnext )cycle loop_240
                 if( l==1 ) then
                    l1 = l
                    l2 = l
                 else
                    if( b( l, l-1 )/=zero ) then
                       l1 = l - 1
                       l2 = l
                       lnext = l - 2
                    else
                       l1 = l
                       l2 = l
                       lnext = l - 1
                    end if
                 end if
                 ! start row loop (index = k)
                 ! k1 (k2): row index of the first (last) row of x(k,l)
                 knext = m
                 loop_230: do k = m, 1, -1
                    if( k>knext )cycle loop_230
                    if( k==1 ) then
                       k1 = k
                       k2 = k
                    else
                       if( a( k, k-1 )/=zero ) then
                          k1 = k - 1
                          k2 = k
                          knext = k - 2
                       else
                          k1 = k
                          k2 = k
                          knext = k - 1
                       end if
                    end if
                    if( l1==l2 .and. k1==k2 ) then
                       suml = stdlib_ddot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_ddot( n-l1, c( k1, min( l1+1, n ) ), ldc,b( l1, min( l1+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       scaloc = one
                       a11 = a( k1, k1 ) + sgn*b( l1, l1 )
                       da11 = abs( a11 )
                       if( da11<=smin ) then
                          a11 = smin
                          da11 = smin
                          info = 1
                       end if
                       db = abs( vec( 1, 1 ) )
                       if( da11<one .and. db>one ) then
                          if( db>bignum*da11 )scaloc = one / db
                       end if
                       x( 1, 1 ) = ( vec( 1, 1 )*scaloc ) / a11
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                    else if( l1==l2 .and. k1/=k2 ) then
                       suml = stdlib_ddot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_ddot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_ddot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_ddot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       call stdlib_dlaln2( .false., 2, 1, smin, one, a( k1, k1 ),lda, one, one, &
                                 vec, 2, -sgn*b( l1, l1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k2, l1 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1==k2 ) then
                       suml = stdlib_ddot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_ddot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = sgn*( c( k1, l1 )-( suml+sgn*sumr ) )
                       suml = stdlib_ddot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_ddot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = sgn*( c( k1, l2 )-( suml+sgn*sumr ) )
                       call stdlib_dlaln2( .false., 2, 1, smin, one, b( l1, l1 ),ldb, one, one, &
                                 vec, 2, -sgn*a( k1, k1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1/=k2 ) then
                       suml = stdlib_ddot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_ddot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_ddot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_ddot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 2 ) = c( k1, l2 ) - ( suml+sgn*sumr )
                       suml = stdlib_ddot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_ddot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_ddot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_ddot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 2 ) = c( k2, l2 ) - ( suml+sgn*sumr )
                       call stdlib_dlasy2( .false., .true., isgn, 2, 2, a( k1, k1 ),lda, b( l1, &
                                 l1 ), ldb, vec, 2, scaloc, x,2, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 1, 2 )
                       c( k2, l1 ) = x( 2, 1 )
                       c( k2, l2 ) = x( 2, 2 )
                    end if
                 end do loop_230
              end do loop_240
           end if
           return
     end subroutine stdlib_dtrsyl

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$trsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )
     !! DTRSYL: solves the real Sylvester matrix equation:
     !! op(A)*X + X*op(B) = scale*C or
     !! op(A)*X - X*op(B) = scale*C,
     !! where op(A) = A or A**T, and  A and B are both upper quasi-
     !! triangular. A is M-by-M and B is N-by-N; the right hand side C and
     !! the solution X are M-by-N; and scale is an output scale factor, set
     !! <= 1 to avoid overflow in X.
     !! A and B must be in Schur canonical form (as returned by DHSEQR), that
     !! is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks;
     !! each 2-by-2 diagonal block has its diagonal elements equal and its
     !! off-diagonal elements of opposite sign.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trana, tranb
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: isgn, lda, ldb, ldc, m, n
           real(${rk}$), intent(out) :: scale
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(inout) :: c(ldc,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: notrna, notrnb
           integer(ilp) :: ierr, j, k, k1, k2, knext, l, l1, l2, lnext
           real(${rk}$) :: a11, bignum, da11, db, eps, scaloc, sgn, smin, smlnum, suml, sumr, &
                     xnorm
           ! Local Arrays 
           real(${rk}$) :: dum(1), vec(2,2), x(2,2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           notrna = stdlib_lsame( trana, 'N' )
           notrnb = stdlib_lsame( tranb, 'N' )
           info = 0
           if( .not.notrna .and. .not.stdlib_lsame( trana, 'T' ) .and. .not.stdlib_lsame( trana, &
                     'C' ) ) then
              info = -1
           else if( .not.notrnb .and. .not.stdlib_lsame( tranb, 'T' ) .and. .not.stdlib_lsame( &
                     tranb, 'C' ) ) then
              info = -2
           else if( isgn/=1 .and. isgn/=-1 ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, m ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldc<max( 1, m ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTRSYL', -info )
              return
           end if
           ! quick return if possible
           scale = one
           if( m==0 .or. n==0 )return
           ! set constants to control overflow
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           smlnum = smlnum*real( m*n,KIND=${rk}$) / eps
           bignum = one / smlnum
           smin = max( smlnum, eps*stdlib_${ri}$lange( 'M', m, m, a, lda, dum ),eps*stdlib_${ri}$lange( 'M',&
                      n, n, b, ldb, dum ) )
           sgn = isgn
           if( notrna .and. notrnb ) then
              ! solve    a*x + isgn*x*b = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! bottom-left corner column by column by
               ! a(k,k)*x(k,l) + isgn*x(k,l)*b(l,l) = c(k,l) - r(k,l)
              ! where
                        ! m                         l-1
              ! r(k,l) = sum [a(k,i)*x(i,l)] + isgn*sum [x(k,j)*b(j,l)].
                      ! i=k+1                       j=1
              ! start column loop (index = l)
              ! l1 (l2) : column index of the first (first) row of x(k,l).
              lnext = 1
              loop_60: do l = 1, n
                 if( l<lnext )cycle loop_60
                 if( l==n ) then
                    l1 = l
                    l2 = l
                 else
                    if( b( l+1, l )/=zero ) then
                       l1 = l
                       l2 = l + 1
                       lnext = l + 2
                    else
                       l1 = l
                       l2 = l
                       lnext = l + 1
                    end if
                 end if
                 ! start row loop (index = k)
                 ! k1 (k2): row index of the first (last) row of x(k,l).
                 knext = m
                 loop_50: do k = m, 1, -1
                    if( k>knext )cycle loop_50
                    if( k==1 ) then
                       k1 = k
                       k2 = k
                    else
                       if( a( k, k-1 )/=zero ) then
                          k1 = k - 1
                          k2 = k
                          knext = k - 2
                       else
                          k1 = k
                          k2 = k
                          knext = k - 1
                       end if
                    end if
                    if( l1==l2 .and. k1==k2 ) then
                       suml = stdlib_${ri}$dot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       scaloc = one
                       a11 = a( k1, k1 ) + sgn*b( l1, l1 )
                       da11 = abs( a11 )
                       if( da11<=smin ) then
                          a11 = smin
                          da11 = smin
                          info = 1
                       end if
                       db = abs( vec( 1, 1 ) )
                       if( da11<one .and. db>one ) then
                          if( db>bignum*da11 )scaloc = one / db
                       end if
                       x( 1, 1 ) = ( vec( 1, 1 )*scaloc ) / a11
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                    else if( l1==l2 .and. k1/=k2 ) then
                       suml = stdlib_${ri}$dot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k2, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       call stdlib_${ri}$laln2( .false., 2, 1, smin, one, a( k1, k1 ),lda, one, one, &
                                 vec, 2, -sgn*b( l1, l1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k2, l1 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1==k2 ) then
                       suml = stdlib_${ri}$dot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = sgn*( c( k1, l1 )-( suml+sgn*sumr ) )
                       suml = stdlib_${ri}$dot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 2, 1 ) = sgn*( c( k1, l2 )-( suml+sgn*sumr ) )
                       call stdlib_${ri}$laln2( .true., 2, 1, smin, one, b( l1, l1 ),ldb, one, one, &
                                 vec, 2, -sgn*a( k1, k1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1/=k2 ) then
                       suml = stdlib_${ri}$dot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 1, 2 ) = c( k1, l2 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k2, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k2, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 2, 2 ) = c( k2, l2 ) - ( suml+sgn*sumr )
                       call stdlib_${ri}$lasy2( .false., .false., isgn, 2, 2,a( k1, k1 ), lda, b( l1, &
                                 l1 ), ldb, vec,2, scaloc, x, 2, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 1, 2 )
                       c( k2, l1 ) = x( 2, 1 )
                       c( k2, l2 ) = x( 2, 2 )
                    end if
                 end do loop_50
              end do loop_60
           else if( .not.notrna .and. notrnb ) then
              ! solve    a**t *x + isgn*x*b = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! upper-left corner column by column by
                ! a(k,k)**t*x(k,l) + isgn*x(k,l)*b(l,l) = c(k,l) - r(k,l)
              ! where
                         ! k-1        t                    l-1
                ! r(k,l) = sum [a(i,k)**t*x(i,l)] +isgn*sum [x(k,j)*b(j,l)]
                         ! i=1                          j=1
              ! start column loop (index = l)
              ! l1 (l2): column index of the first (last) row of x(k,l)
              lnext = 1
              loop_120: do l = 1, n
                 if( l<lnext )cycle loop_120
                 if( l==n ) then
                    l1 = l
                    l2 = l
                 else
                    if( b( l+1, l )/=zero ) then
                       l1 = l
                       l2 = l + 1
                       lnext = l + 2
                    else
                       l1 = l
                       l2 = l
                       lnext = l + 1
                    end if
                 end if
                 ! start row loop (index = k)
                 ! k1 (k2): row index of the first (last) row of x(k,l)
                 knext = 1
                 loop_110: do k = 1, m
                    if( k<knext )cycle loop_110
                    if( k==m ) then
                       k1 = k
                       k2 = k
                    else
                       if( a( k+1, k )/=zero ) then
                          k1 = k
                          k2 = k + 1
                          knext = k + 2
                       else
                          k1 = k
                          k2 = k
                          knext = k + 1
                       end if
                    end if
                    if( l1==l2 .and. k1==k2 ) then
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       scaloc = one
                       a11 = a( k1, k1 ) + sgn*b( l1, l1 )
                       da11 = abs( a11 )
                       if( da11<=smin ) then
                          a11 = smin
                          da11 = smin
                          info = 1
                       end if
                       db = abs( vec( 1, 1 ) )
                       if( da11<one .and. db>one ) then
                          if( db>bignum*da11 )scaloc = one / db
                       end if
                       x( 1, 1 ) = ( vec( 1, 1 )*scaloc ) / a11
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                    else if( l1==l2 .and. k1/=k2 ) then
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k2 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k2, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       call stdlib_${ri}$laln2( .true., 2, 1, smin, one, a( k1, k1 ),lda, one, one, &
                                 vec, 2, -sgn*b( l1, l1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k2, l1 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1==k2 ) then
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = sgn*( c( k1, l1 )-( suml+sgn*sumr ) )
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 2, 1 ) = sgn*( c( k1, l2 )-( suml+sgn*sumr ) )
                       call stdlib_${ri}$laln2( .true., 2, 1, smin, one, b( l1, l1 ),ldb, one, one, &
                                 vec, 2, -sgn*a( k1, k1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1/=k2 ) then
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k1, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 1, 2 ) = c( k1, l2 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k2 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k2, 1 ), ldc, b( 1, l1 ), 1 )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k2 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_${ri}$dot( l1-1, c( k2, 1 ), ldc, b( 1, l2 ), 1 )
                       vec( 2, 2 ) = c( k2, l2 ) - ( suml+sgn*sumr )
                       call stdlib_${ri}$lasy2( .true., .false., isgn, 2, 2, a( k1, k1 ),lda, b( l1, &
                                 l1 ), ldb, vec, 2, scaloc, x,2, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 1, 2 )
                       c( k2, l1 ) = x( 2, 1 )
                       c( k2, l2 ) = x( 2, 2 )
                    end if
                 end do loop_110
              end do loop_120
           else if( .not.notrna .and. .not.notrnb ) then
              ! solve    a**t*x + isgn*x*b**t = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! top-right corner column by column by
                 ! a(k,k)**t*x(k,l) + isgn*x(k,l)*b(l,l)**t = c(k,l) - r(k,l)
              ! where
                           ! k-1                            n
                  ! r(k,l) = sum [a(i,k)**t*x(i,l)] + isgn*sum [x(k,j)*b(l,j)**t].
                           ! i=1                          j=l+1
              ! start column loop (index = l)
              ! l1 (l2): column index of the first (last) row of x(k,l)
              lnext = n
              loop_180: do l = n, 1, -1
                 if( l>lnext )cycle loop_180
                 if( l==1 ) then
                    l1 = l
                    l2 = l
                 else
                    if( b( l, l-1 )/=zero ) then
                       l1 = l - 1
                       l2 = l
                       lnext = l - 2
                    else
                       l1 = l
                       l2 = l
                       lnext = l - 1
                    end if
                 end if
                 ! start row loop (index = k)
                 ! k1 (k2): row index of the first (last) row of x(k,l)
                 knext = 1
                 loop_170: do k = 1, m
                    if( k<knext )cycle loop_170
                    if( k==m ) then
                       k1 = k
                       k2 = k
                    else
                       if( a( k+1, k )/=zero ) then
                          k1 = k
                          k2 = k + 1
                          knext = k + 2
                       else
                          k1 = k
                          k2 = k
                          knext = k + 1
                       end if
                    end if
                    if( l1==l2 .and. k1==k2 ) then
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l1, c( k1, min( l1+1, n ) ), ldc,b( l1, min( l1+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       scaloc = one
                       a11 = a( k1, k1 ) + sgn*b( l1, l1 )
                       da11 = abs( a11 )
                       if( da11<=smin ) then
                          a11 = smin
                          da11 = smin
                          info = 1
                       end if
                       db = abs( vec( 1, 1 ) )
                       if( da11<one .and. db>one ) then
                          if( db>bignum*da11 )scaloc = one / db
                       end if
                       x( 1, 1 ) = ( vec( 1, 1 )*scaloc ) / a11
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                    else if( l1==l2 .and. k1/=k2 ) then
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k2 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       call stdlib_${ri}$laln2( .true., 2, 1, smin, one, a( k1, k1 ),lda, one, one, &
                                 vec, 2, -sgn*b( l1, l1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k2, l1 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1==k2 ) then
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = sgn*( c( k1, l1 )-( suml+sgn*sumr ) )
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = sgn*( c( k1, l2 )-( suml+sgn*sumr ) )
                       call stdlib_${ri}$laln2( .false., 2, 1, smin, one, b( l1, l1 ),ldb, one, one, &
                                 vec, 2, -sgn*a( k1, k1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1/=k2 ) then
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k1 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 2 ) = c( k1, l2 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k2 ), 1, c( 1, l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( k1-1, a( 1, k2 ), 1, c( 1, l2 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 2 ) = c( k2, l2 ) - ( suml+sgn*sumr )
                       call stdlib_${ri}$lasy2( .true., .true., isgn, 2, 2, a( k1, k1 ),lda, b( l1, l1 &
                                 ), ldb, vec, 2, scaloc, x,2, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 1, 2 )
                       c( k2, l1 ) = x( 2, 1 )
                       c( k2, l2 ) = x( 2, 2 )
                    end if
                 end do loop_170
              end do loop_180
           else if( notrna .and. .not.notrnb ) then
              ! solve    a*x + isgn*x*b**t = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! bottom-right corner column by column by
                  ! a(k,k)*x(k,l) + isgn*x(k,l)*b(l,l)**t = c(k,l) - r(k,l)
              ! where
                            ! m                          n
                  ! r(k,l) = sum [a(k,i)*x(i,l)] + isgn*sum [x(k,j)*b(l,j)**t].
                          ! i=k+1                      j=l+1
              ! start column loop (index = l)
              ! l1 (l2): column index of the first (last) row of x(k,l)
              lnext = n
              loop_240: do l = n, 1, -1
                 if( l>lnext )cycle loop_240
                 if( l==1 ) then
                    l1 = l
                    l2 = l
                 else
                    if( b( l, l-1 )/=zero ) then
                       l1 = l - 1
                       l2 = l
                       lnext = l - 2
                    else
                       l1 = l
                       l2 = l
                       lnext = l - 1
                    end if
                 end if
                 ! start row loop (index = k)
                 ! k1 (k2): row index of the first (last) row of x(k,l)
                 knext = m
                 loop_230: do k = m, 1, -1
                    if( k>knext )cycle loop_230
                    if( k==1 ) then
                       k1 = k
                       k2 = k
                    else
                       if( a( k, k-1 )/=zero ) then
                          k1 = k - 1
                          k2 = k
                          knext = k - 2
                       else
                          k1 = k
                          k2 = k
                          knext = k - 1
                       end if
                    end if
                    if( l1==l2 .and. k1==k2 ) then
                       suml = stdlib_${ri}$dot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l1, c( k1, min( l1+1, n ) ), ldc,b( l1, min( l1+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       scaloc = one
                       a11 = a( k1, k1 ) + sgn*b( l1, l1 )
                       da11 = abs( a11 )
                       if( da11<=smin ) then
                          a11 = smin
                          da11 = smin
                          info = 1
                       end if
                       db = abs( vec( 1, 1 ) )
                       if( da11<one .and. db>one ) then
                          if( db>bignum*da11 )scaloc = one / db
                       end if
                       x( 1, 1 ) = ( vec( 1, 1 )*scaloc ) / a11
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                    else if( l1==l2 .and. k1/=k2 ) then
                       suml = stdlib_${ri}$dot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       call stdlib_${ri}$laln2( .false., 2, 1, smin, one, a( k1, k1 ),lda, one, one, &
                                 vec, 2, -sgn*b( l1, l1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k2, l1 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1==k2 ) then
                       suml = stdlib_${ri}$dot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = sgn*( c( k1, l1 )-( suml+sgn*sumr ) )
                       suml = stdlib_${ri}$dot( m-k1, a( k1, min( k1+1, m ) ), lda,c( min( k1+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = sgn*( c( k1, l2 )-( suml+sgn*sumr ) )
                       call stdlib_${ri}$laln2( .false., 2, 1, smin, one, b( l1, l1 ),ldb, one, one, &
                                 vec, 2, -sgn*a( k1, k1 ),zero, x, 2, scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 2, 1 )
                    else if( l1/=l2 .and. k1/=k2 ) then
                       suml = stdlib_${ri}$dot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 1 ) = c( k1, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( m-k2, a( k1, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k1, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 1, 2 ) = c( k1, l2 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l1 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l1, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 1 ) = c( k2, l1 ) - ( suml+sgn*sumr )
                       suml = stdlib_${ri}$dot( m-k2, a( k2, min( k2+1, m ) ), lda,c( min( k2+1, m ), &
                                 l2 ), 1 )
                       sumr = stdlib_${ri}$dot( n-l2, c( k2, min( l2+1, n ) ), ldc,b( l2, min( l2+1, n &
                                 ) ), ldb )
                       vec( 2, 2 ) = c( k2, l2 ) - ( suml+sgn*sumr )
                       call stdlib_${ri}$lasy2( .false., .true., isgn, 2, 2, a( k1, k1 ),lda, b( l1, &
                                 l1 ), ldb, vec, 2, scaloc, x,2, xnorm, ierr )
                       if( ierr/=0 )info = 1
                       if( scaloc/=one ) then
                          do j = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, j ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       c( k1, l1 ) = x( 1, 1 )
                       c( k1, l2 ) = x( 1, 2 )
                       c( k2, l1 ) = x( 2, 1 )
                       c( k2, l2 ) = x( 2, 2 )
                    end if
                 end do loop_230
              end do loop_240
           end if
           return
     end subroutine stdlib_${ri}$trsyl

#:endif
#:endfor

     module subroutine stdlib_ctrsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )
     !! CTRSYL solves the complex Sylvester matrix equation:
     !! op(A)*X + X*op(B) = scale*C or
     !! op(A)*X - X*op(B) = scale*C,
     !! where op(A) = A or A**H, and A and B are both upper triangular. A is
     !! M-by-M and B is N-by-N; the right hand side C and the solution X are
     !! M-by-N; and scale is an output scale factor, set <= 1 to avoid
     !! overflow in X.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trana, tranb
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: isgn, lda, ldb, ldc, m, n
           real(sp), intent(out) :: scale
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*), b(ldb,*)
           complex(sp), intent(inout) :: c(ldc,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: notrna, notrnb
           integer(ilp) :: j, k, l
           real(sp) :: bignum, da11, db, eps, scaloc, sgn, smin, smlnum
           complex(sp) :: a11, suml, sumr, vec, x11
           ! Local Arrays 
           real(sp) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           notrna = stdlib_lsame( trana, 'N' )
           notrnb = stdlib_lsame( tranb, 'N' )
           info = 0
           if( .not.notrna .and. .not.stdlib_lsame( trana, 'C' ) ) then
              info = -1
           else if( .not.notrnb .and. .not.stdlib_lsame( tranb, 'C' ) ) then
              info = -2
           else if( isgn/=1 .and. isgn/=-1 ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, m ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldc<max( 1, m ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTRSYL', -info )
              return
           end if
           ! quick return if possible
           scale = one
           if( m==0 .or. n==0 )return
           ! set constants to control overflow
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = smlnum*real( m*n,KIND=sp) / eps
           bignum = one / smlnum
           smin = max( smlnum, eps*stdlib_clange( 'M', m, m, a, lda, dum ),eps*stdlib_clange( 'M',&
                      n, n, b, ldb, dum ) )
           sgn = isgn
           if( notrna .and. notrnb ) then
              ! solve    a*x + isgn*x*b = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! bottom-left corner column by column by
                  ! a(k,k)*x(k,l) + isgn*x(k,l)*b(l,l) = c(k,l) - r(k,l)
              ! where
                          ! m                        l-1
                ! r(k,l) = sum [a(k,i)*x(i,l)] +isgn*sum [x(k,j)*b(j,l)].
                        ! i=k+1                      j=1
              loop_30: do l = 1, n
                 do k = m, 1, -1
                    suml = stdlib_cdotu( m-k, a( k, min( k+1, m ) ), lda,c( min( k+1, m ), l ), 1 &
                              )
                    sumr = stdlib_cdotu( l-1, c( k, 1 ), ldc, b( 1, l ), 1 )
                    vec = c( k, l ) - ( suml+sgn*sumr )
                    scaloc = one
                    a11 = a( k, k ) + sgn*b( l, l )
                    da11 = abs( real( a11,KIND=sp) ) + abs( aimag( a11 ) )
                    if( da11<=smin ) then
                       a11 = smin
                       da11 = smin
                       info = 1
                    end if
                    db = abs( real( vec,KIND=sp) ) + abs( aimag( vec ) )
                    if( da11<one .and. db>one ) then
                       if( db>bignum*da11 )scaloc = one / db
                    end if
                    x11 = stdlib_cladiv( vec*cmplx( scaloc,KIND=sp), a11 )
                    if( scaloc/=one ) then
                       do j = 1, n
                          call stdlib_csscal( m, scaloc, c( 1, j ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    c( k, l ) = x11
                 end do
              end do loop_30
           else if( .not.notrna .and. notrnb ) then
              ! solve    a**h *x + isgn*x*b = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! upper-left corner column by column by
                  ! a**h(k,k)*x(k,l) + isgn*x(k,l)*b(l,l) = c(k,l) - r(k,l)
              ! where
                         ! k-1                           l-1
                ! r(k,l) = sum [a**h(i,k)*x(i,l)] + isgn*sum [x(k,j)*b(j,l)]
                         ! i=1                           j=1
              loop_60: do l = 1, n
                 do k = 1, m
                    suml = stdlib_cdotc( k-1, a( 1, k ), 1, c( 1, l ), 1 )
                    sumr = stdlib_cdotu( l-1, c( k, 1 ), ldc, b( 1, l ), 1 )
                    vec = c( k, l ) - ( suml+sgn*sumr )
                    scaloc = one
                    a11 = conjg( a( k, k ) ) + sgn*b( l, l )
                    da11 = abs( real( a11,KIND=sp) ) + abs( aimag( a11 ) )
                    if( da11<=smin ) then
                       a11 = smin
                       da11 = smin
                       info = 1
                    end if
                    db = abs( real( vec,KIND=sp) ) + abs( aimag( vec ) )
                    if( da11<one .and. db>one ) then
                       if( db>bignum*da11 )scaloc = one / db
                    end if
                    x11 = stdlib_cladiv( vec*cmplx( scaloc,KIND=sp), a11 )
                    if( scaloc/=one ) then
                       do j = 1, n
                          call stdlib_csscal( m, scaloc, c( 1, j ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    c( k, l ) = x11
                 end do
              end do loop_60
           else if( .not.notrna .and. .not.notrnb ) then
              ! solve    a**h*x + isgn*x*b**h = c.
              ! the (k,l)th block of x is determined starting from
              ! upper-right corner column by column by
                  ! a**h(k,k)*x(k,l) + isgn*x(k,l)*b**h(l,l) = c(k,l) - r(k,l)
              ! where
                          ! k-1
                 ! r(k,l) = sum [a**h(i,k)*x(i,l)] +
                          ! i=1
                                 ! n
                           ! isgn*sum [x(k,j)*b**h(l,j)].
                                ! j=l+1
              loop_90: do l = n, 1, -1
                 do k = 1, m
                    suml = stdlib_cdotc( k-1, a( 1, k ), 1, c( 1, l ), 1 )
                    sumr = stdlib_cdotc( n-l, c( k, min( l+1, n ) ), ldc,b( l, min( l+1, n ) ), &
                              ldb )
                    vec = c( k, l ) - ( suml+sgn*conjg( sumr ) )
                    scaloc = one
                    a11 = conjg( a( k, k )+sgn*b( l, l ) )
                    da11 = abs( real( a11,KIND=sp) ) + abs( aimag( a11 ) )
                    if( da11<=smin ) then
                       a11 = smin
                       da11 = smin
                       info = 1
                    end if
                    db = abs( real( vec,KIND=sp) ) + abs( aimag( vec ) )
                    if( da11<one .and. db>one ) then
                       if( db>bignum*da11 )scaloc = one / db
                    end if
                    x11 = stdlib_cladiv( vec*cmplx( scaloc,KIND=sp), a11 )
                    if( scaloc/=one ) then
                       do j = 1, n
                          call stdlib_csscal( m, scaloc, c( 1, j ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    c( k, l ) = x11
                 end do
              end do loop_90
           else if( notrna .and. .not.notrnb ) then
              ! solve    a*x + isgn*x*b**h = c.
              ! the (k,l)th block of x is determined starting from
              ! bottom-left corner column by column by
                 ! a(k,k)*x(k,l) + isgn*x(k,l)*b**h(l,l) = c(k,l) - r(k,l)
              ! where
                          ! m                          n
                ! r(k,l) = sum [a(k,i)*x(i,l)] + isgn*sum [x(k,j)*b**h(l,j)]
                        ! i=k+1                      j=l+1
              loop_120: do l = n, 1, -1
                 do k = m, 1, -1
                    suml = stdlib_cdotu( m-k, a( k, min( k+1, m ) ), lda,c( min( k+1, m ), l ), 1 &
                              )
                    sumr = stdlib_cdotc( n-l, c( k, min( l+1, n ) ), ldc,b( l, min( l+1, n ) ), &
                              ldb )
                    vec = c( k, l ) - ( suml+sgn*conjg( sumr ) )
                    scaloc = one
                    a11 = a( k, k ) + sgn*conjg( b( l, l ) )
                    da11 = abs( real( a11,KIND=sp) ) + abs( aimag( a11 ) )
                    if( da11<=smin ) then
                       a11 = smin
                       da11 = smin
                       info = 1
                    end if
                    db = abs( real( vec,KIND=sp) ) + abs( aimag( vec ) )
                    if( da11<one .and. db>one ) then
                       if( db>bignum*da11 )scaloc = one / db
                    end if
                    x11 = stdlib_cladiv( vec*cmplx( scaloc,KIND=sp), a11 )
                    if( scaloc/=one ) then
                       do j = 1, n
                          call stdlib_csscal( m, scaloc, c( 1, j ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    c( k, l ) = x11
                 end do
              end do loop_120
           end if
           return
     end subroutine stdlib_ctrsyl

     module subroutine stdlib_ztrsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )
     !! ZTRSYL solves the complex Sylvester matrix equation:
     !! op(A)*X + X*op(B) = scale*C or
     !! op(A)*X - X*op(B) = scale*C,
     !! where op(A) = A or A**H, and A and B are both upper triangular. A is
     !! M-by-M and B is N-by-N; the right hand side C and the solution X are
     !! M-by-N; and scale is an output scale factor, set <= 1 to avoid
     !! overflow in X.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trana, tranb
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: isgn, lda, ldb, ldc, m, n
           real(dp), intent(out) :: scale
           ! Array Arguments 
           complex(dp), intent(in) :: a(lda,*), b(ldb,*)
           complex(dp), intent(inout) :: c(ldc,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: notrna, notrnb
           integer(ilp) :: j, k, l
           real(dp) :: bignum, da11, db, eps, scaloc, sgn, smin, smlnum
           complex(dp) :: a11, suml, sumr, vec, x11
           ! Local Arrays 
           real(dp) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           notrna = stdlib_lsame( trana, 'N' )
           notrnb = stdlib_lsame( tranb, 'N' )
           info = 0
           if( .not.notrna .and. .not.stdlib_lsame( trana, 'C' ) ) then
              info = -1
           else if( .not.notrnb .and. .not.stdlib_lsame( tranb, 'C' ) ) then
              info = -2
           else if( isgn/=1 .and. isgn/=-1 ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, m ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldc<max( 1, m ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTRSYL', -info )
              return
           end if
           ! quick return if possible
           scale = one
           if( m==0 .or. n==0 )return
           ! set constants to control overflow
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' )
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           smlnum = smlnum*real( m*n,KIND=dp) / eps
           bignum = one / smlnum
           smin = max( smlnum, eps*stdlib_zlange( 'M', m, m, a, lda, dum ),eps*stdlib_zlange( 'M',&
                      n, n, b, ldb, dum ) )
           sgn = isgn
           if( notrna .and. notrnb ) then
              ! solve    a*x + isgn*x*b = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! bottom-left corner column by column by
                  ! a(k,k)*x(k,l) + isgn*x(k,l)*b(l,l) = c(k,l) - r(k,l)
              ! where
                          ! m                        l-1
                ! r(k,l) = sum [a(k,i)*x(i,l)] +isgn*sum [x(k,j)*b(j,l)].
                        ! i=k+1                      j=1
              loop_30: do l = 1, n
                 do k = m, 1, -1
                    suml = stdlib_zdotu( m-k, a( k, min( k+1, m ) ), lda,c( min( k+1, m ), l ), 1 &
                              )
                    sumr = stdlib_zdotu( l-1, c( k, 1 ), ldc, b( 1, l ), 1 )
                    vec = c( k, l ) - ( suml+sgn*sumr )
                    scaloc = one
                    a11 = a( k, k ) + sgn*b( l, l )
                    da11 = abs( real( a11,KIND=dp) ) + abs( aimag( a11 ) )
                    if( da11<=smin ) then
                       a11 = smin
                       da11 = smin
                       info = 1
                    end if
                    db = abs( real( vec,KIND=dp) ) + abs( aimag( vec ) )
                    if( da11<one .and. db>one ) then
                       if( db>bignum*da11 )scaloc = one / db
                    end if
                    x11 = stdlib_zladiv( vec*cmplx( scaloc,KIND=dp), a11 )
                    if( scaloc/=one ) then
                       do j = 1, n
                          call stdlib_zdscal( m, scaloc, c( 1, j ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    c( k, l ) = x11
                 end do
              end do loop_30
           else if( .not.notrna .and. notrnb ) then
              ! solve    a**h *x + isgn*x*b = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! upper-left corner column by column by
                  ! a**h(k,k)*x(k,l) + isgn*x(k,l)*b(l,l) = c(k,l) - r(k,l)
              ! where
                         ! k-1                           l-1
                ! r(k,l) = sum [a**h(i,k)*x(i,l)] + isgn*sum [x(k,j)*b(j,l)]
                         ! i=1                           j=1
              loop_60: do l = 1, n
                 do k = 1, m
                    suml = stdlib_zdotc( k-1, a( 1, k ), 1, c( 1, l ), 1 )
                    sumr = stdlib_zdotu( l-1, c( k, 1 ), ldc, b( 1, l ), 1 )
                    vec = c( k, l ) - ( suml+sgn*sumr )
                    scaloc = one
                    a11 = conjg( a( k, k ) ) + sgn*b( l, l )
                    da11 = abs( real( a11,KIND=dp) ) + abs( aimag( a11 ) )
                    if( da11<=smin ) then
                       a11 = smin
                       da11 = smin
                       info = 1
                    end if
                    db = abs( real( vec,KIND=dp) ) + abs( aimag( vec ) )
                    if( da11<one .and. db>one ) then
                       if( db>bignum*da11 )scaloc = one / db
                    end if
                    x11 = stdlib_zladiv( vec*cmplx( scaloc,KIND=dp), a11 )
                    if( scaloc/=one ) then
                       do j = 1, n
                          call stdlib_zdscal( m, scaloc, c( 1, j ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    c( k, l ) = x11
                 end do
              end do loop_60
           else if( .not.notrna .and. .not.notrnb ) then
              ! solve    a**h*x + isgn*x*b**h = c.
              ! the (k,l)th block of x is determined starting from
              ! upper-right corner column by column by
                  ! a**h(k,k)*x(k,l) + isgn*x(k,l)*b**h(l,l) = c(k,l) - r(k,l)
              ! where
                          ! k-1
                 ! r(k,l) = sum [a**h(i,k)*x(i,l)] +
                          ! i=1
                                 ! n
                           ! isgn*sum [x(k,j)*b**h(l,j)].
                                ! j=l+1
              loop_90: do l = n, 1, -1
                 do k = 1, m
                    suml = stdlib_zdotc( k-1, a( 1, k ), 1, c( 1, l ), 1 )
                    sumr = stdlib_zdotc( n-l, c( k, min( l+1, n ) ), ldc,b( l, min( l+1, n ) ), &
                              ldb )
                    vec = c( k, l ) - ( suml+sgn*conjg( sumr ) )
                    scaloc = one
                    a11 = conjg( a( k, k )+sgn*b( l, l ) )
                    da11 = abs( real( a11,KIND=dp) ) + abs( aimag( a11 ) )
                    if( da11<=smin ) then
                       a11 = smin
                       da11 = smin
                       info = 1
                    end if
                    db = abs( real( vec,KIND=dp) ) + abs( aimag( vec ) )
                    if( da11<one .and. db>one ) then
                       if( db>bignum*da11 )scaloc = one / db
                    end if
                    x11 = stdlib_zladiv( vec*cmplx( scaloc,KIND=dp), a11 )
                    if( scaloc/=one ) then
                       do j = 1, n
                          call stdlib_zdscal( m, scaloc, c( 1, j ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    c( k, l ) = x11
                 end do
              end do loop_90
           else if( notrna .and. .not.notrnb ) then
              ! solve    a*x + isgn*x*b**h = c.
              ! the (k,l)th block of x is determined starting from
              ! bottom-left corner column by column by
                 ! a(k,k)*x(k,l) + isgn*x(k,l)*b**h(l,l) = c(k,l) - r(k,l)
              ! where
                          ! m                          n
                ! r(k,l) = sum [a(k,i)*x(i,l)] + isgn*sum [x(k,j)*b**h(l,j)]
                        ! i=k+1                      j=l+1
              loop_120: do l = n, 1, -1
                 do k = m, 1, -1
                    suml = stdlib_zdotu( m-k, a( k, min( k+1, m ) ), lda,c( min( k+1, m ), l ), 1 &
                              )
                    sumr = stdlib_zdotc( n-l, c( k, min( l+1, n ) ), ldc,b( l, min( l+1, n ) ), &
                              ldb )
                    vec = c( k, l ) - ( suml+sgn*conjg( sumr ) )
                    scaloc = one
                    a11 = a( k, k ) + sgn*conjg( b( l, l ) )
                    da11 = abs( real( a11,KIND=dp) ) + abs( aimag( a11 ) )
                    if( da11<=smin ) then
                       a11 = smin
                       da11 = smin
                       info = 1
                    end if
                    db = abs( real( vec,KIND=dp) ) + abs( aimag( vec ) )
                    if( da11<one .and. db>one ) then
                       if( db>bignum*da11 )scaloc = one / db
                    end if
                    x11 = stdlib_zladiv( vec*cmplx( scaloc,KIND=dp), a11 )
                    if( scaloc/=one ) then
                       do j = 1, n
                          call stdlib_zdscal( m, scaloc, c( 1, j ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    c( k, l ) = x11
                 end do
              end do loop_120
           end if
           return
     end subroutine stdlib_ztrsyl

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$trsyl( trana, tranb, isgn, m, n, a, lda, b, ldb, c,ldc, scale, info )
     !! ZTRSYL: solves the complex Sylvester matrix equation:
     !! op(A)*X + X*op(B) = scale*C or
     !! op(A)*X - X*op(B) = scale*C,
     !! where op(A) = A or A**H, and A and B are both upper triangular. A is
     !! M-by-M and B is N-by-N; the right hand side C and the solution X are
     !! M-by-N; and scale is an output scale factor, set <= 1 to avoid
     !! overflow in X.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trana, tranb
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: isgn, lda, ldb, ldc, m, n
           real(${ck}$), intent(out) :: scale
           ! Array Arguments 
           complex(${ck}$), intent(in) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(inout) :: c(ldc,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: notrna, notrnb
           integer(ilp) :: j, k, l
           real(${ck}$) :: bignum, da11, db, eps, scaloc, sgn, smin, smlnum
           complex(${ck}$) :: a11, suml, sumr, vec, x11
           ! Local Arrays 
           real(${ck}$) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           notrna = stdlib_lsame( trana, 'N' )
           notrnb = stdlib_lsame( tranb, 'N' )
           info = 0
           if( .not.notrna .and. .not.stdlib_lsame( trana, 'C' ) ) then
              info = -1
           else if( .not.notrnb .and. .not.stdlib_lsame( tranb, 'C' ) ) then
              info = -2
           else if( isgn/=1 .and. isgn/=-1 ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, m ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldc<max( 1, m ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTRSYL', -info )
              return
           end if
           ! quick return if possible
           scale = one
           if( m==0 .or. n==0 )return
           ! set constants to control overflow
           eps = stdlib_${c2ri(ci)}$lamch( 'P' )
           smlnum = stdlib_${c2ri(ci)}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${c2ri(ci)}$labad( smlnum, bignum )
           smlnum = smlnum*real( m*n,KIND=${ck}$) / eps
           bignum = one / smlnum
           smin = max( smlnum, eps*stdlib_${ci}$lange( 'M', m, m, a, lda, dum ),eps*stdlib_${ci}$lange( 'M',&
                      n, n, b, ldb, dum ) )
           sgn = isgn
           if( notrna .and. notrnb ) then
              ! solve    a*x + isgn*x*b = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! bottom-left corner column by column by
                  ! a(k,k)*x(k,l) + isgn*x(k,l)*b(l,l) = c(k,l) - r(k,l)
              ! where
                          ! m                        l-1
                ! r(k,l) = sum [a(k,i)*x(i,l)] +isgn*sum [x(k,j)*b(j,l)].
                        ! i=k+1                      j=1
              loop_30: do l = 1, n
                 do k = m, 1, -1
                    suml = stdlib_${ci}$dotu( m-k, a( k, min( k+1, m ) ), lda,c( min( k+1, m ), l ), 1 &
                              )
                    sumr = stdlib_${ci}$dotu( l-1, c( k, 1 ), ldc, b( 1, l ), 1 )
                    vec = c( k, l ) - ( suml+sgn*sumr )
                    scaloc = one
                    a11 = a( k, k ) + sgn*b( l, l )
                    da11 = abs( real( a11,KIND=${ck}$) ) + abs( aimag( a11 ) )
                    if( da11<=smin ) then
                       a11 = smin
                       da11 = smin
                       info = 1
                    end if
                    db = abs( real( vec,KIND=${ck}$) ) + abs( aimag( vec ) )
                    if( da11<one .and. db>one ) then
                       if( db>bignum*da11 )scaloc = one / db
                    end if
                    x11 = stdlib_${ci}$ladiv( vec*cmplx( scaloc,KIND=${ck}$), a11 )
                    if( scaloc/=one ) then
                       do j = 1, n
                          call stdlib_${ci}$dscal( m, scaloc, c( 1, j ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    c( k, l ) = x11
                 end do
              end do loop_30
           else if( .not.notrna .and. notrnb ) then
              ! solve    a**h *x + isgn*x*b = scale*c.
              ! the (k,l)th block of x is determined starting from
              ! upper-left corner column by column by
                  ! a**h(k,k)*x(k,l) + isgn*x(k,l)*b(l,l) = c(k,l) - r(k,l)
              ! where
                         ! k-1                           l-1
                ! r(k,l) = sum [a**h(i,k)*x(i,l)] + isgn*sum [x(k,j)*b(j,l)]
                         ! i=1                           j=1
              loop_60: do l = 1, n
                 do k = 1, m
                    suml = stdlib_${ci}$dotc( k-1, a( 1, k ), 1, c( 1, l ), 1 )
                    sumr = stdlib_${ci}$dotu( l-1, c( k, 1 ), ldc, b( 1, l ), 1 )
                    vec = c( k, l ) - ( suml+sgn*sumr )
                    scaloc = one
                    a11 = conjg( a( k, k ) ) + sgn*b( l, l )
                    da11 = abs( real( a11,KIND=${ck}$) ) + abs( aimag( a11 ) )
                    if( da11<=smin ) then
                       a11 = smin
                       da11 = smin
                       info = 1
                    end if
                    db = abs( real( vec,KIND=${ck}$) ) + abs( aimag( vec ) )
                    if( da11<one .and. db>one ) then
                       if( db>bignum*da11 )scaloc = one / db
                    end if
                    x11 = stdlib_${ci}$ladiv( vec*cmplx( scaloc,KIND=${ck}$), a11 )
                    if( scaloc/=one ) then
                       do j = 1, n
                          call stdlib_${ci}$dscal( m, scaloc, c( 1, j ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    c( k, l ) = x11
                 end do
              end do loop_60
           else if( .not.notrna .and. .not.notrnb ) then
              ! solve    a**h*x + isgn*x*b**h = c.
              ! the (k,l)th block of x is determined starting from
              ! upper-right corner column by column by
                  ! a**h(k,k)*x(k,l) + isgn*x(k,l)*b**h(l,l) = c(k,l) - r(k,l)
              ! where
                          ! k-1
                 ! r(k,l) = sum [a**h(i,k)*x(i,l)] +
                          ! i=1
                                 ! n
                           ! isgn*sum [x(k,j)*b**h(l,j)].
                                ! j=l+1
              loop_90: do l = n, 1, -1
                 do k = 1, m
                    suml = stdlib_${ci}$dotc( k-1, a( 1, k ), 1, c( 1, l ), 1 )
                    sumr = stdlib_${ci}$dotc( n-l, c( k, min( l+1, n ) ), ldc,b( l, min( l+1, n ) ), &
                              ldb )
                    vec = c( k, l ) - ( suml+sgn*conjg( sumr ) )
                    scaloc = one
                    a11 = conjg( a( k, k )+sgn*b( l, l ) )
                    da11 = abs( real( a11,KIND=${ck}$) ) + abs( aimag( a11 ) )
                    if( da11<=smin ) then
                       a11 = smin
                       da11 = smin
                       info = 1
                    end if
                    db = abs( real( vec,KIND=${ck}$) ) + abs( aimag( vec ) )
                    if( da11<one .and. db>one ) then
                       if( db>bignum*da11 )scaloc = one / db
                    end if
                    x11 = stdlib_${ci}$ladiv( vec*cmplx( scaloc,KIND=${ck}$), a11 )
                    if( scaloc/=one ) then
                       do j = 1, n
                          call stdlib_${ci}$dscal( m, scaloc, c( 1, j ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    c( k, l ) = x11
                 end do
              end do loop_90
           else if( notrna .and. .not.notrnb ) then
              ! solve    a*x + isgn*x*b**h = c.
              ! the (k,l)th block of x is determined starting from
              ! bottom-left corner column by column by
                 ! a(k,k)*x(k,l) + isgn*x(k,l)*b**h(l,l) = c(k,l) - r(k,l)
              ! where
                          ! m                          n
                ! r(k,l) = sum [a(k,i)*x(i,l)] + isgn*sum [x(k,j)*b**h(l,j)]
                        ! i=k+1                      j=l+1
              loop_120: do l = n, 1, -1
                 do k = m, 1, -1
                    suml = stdlib_${ci}$dotu( m-k, a( k, min( k+1, m ) ), lda,c( min( k+1, m ), l ), 1 &
                              )
                    sumr = stdlib_${ci}$dotc( n-l, c( k, min( l+1, n ) ), ldc,b( l, min( l+1, n ) ), &
                              ldb )
                    vec = c( k, l ) - ( suml+sgn*conjg( sumr ) )
                    scaloc = one
                    a11 = a( k, k ) + sgn*conjg( b( l, l ) )
                    da11 = abs( real( a11,KIND=${ck}$) ) + abs( aimag( a11 ) )
                    if( da11<=smin ) then
                       a11 = smin
                       da11 = smin
                       info = 1
                    end if
                    db = abs( real( vec,KIND=${ck}$) ) + abs( aimag( vec ) )
                    if( da11<one .and. db>one ) then
                       if( db>bignum*da11 )scaloc = one / db
                    end if
                    x11 = stdlib_${ci}$ladiv( vec*cmplx( scaloc,KIND=${ck}$), a11 )
                    if( scaloc/=one ) then
                       do j = 1, n
                          call stdlib_${ci}$dscal( m, scaloc, c( 1, j ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    c( k, l ) = x11
                 end do
              end do loop_120
           end if
           return
     end subroutine stdlib_${ci}$trsyl

#:endif
#:endfor



     module subroutine stdlib_strexc( compq, n, t, ldt, q, ldq, ifst, ilst, work,info )
     !! STREXC reorders the real Schur factorization of a real matrix
     !! A = Q*T*Q**T, so that the diagonal block of T with row index IFST is
     !! moved to row ILST.
     !! The real Schur form T is reordered by an orthogonal similarity
     !! transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors
     !! is updated by postmultiplying it with Z.
     !! T must be in Schur canonical form (as returned by SHSEQR), that is,
     !! block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
     !! 2-by-2 diagonal block has its diagonal elements equal and its
     !! off-diagonal elements of opposite sign.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq
           integer(ilp), intent(inout) :: ifst, ilst
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldq, ldt, n
           ! Array Arguments 
           real(sp), intent(inout) :: q(ldq,*), t(ldt,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: wantq
           integer(ilp) :: here, nbf, nbl, nbnext
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input arguments.
           info = 0
           wantq = stdlib_lsame( compq, 'V' )
           if( .not.wantq .and. .not.stdlib_lsame( compq, 'N' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldt<max( 1, n ) ) then
              info = -4
           else if( ldq<1 .or. ( wantq .and. ldq<max( 1, n ) ) ) then
              info = -6
           else if(( ifst<1 .or. ifst>n ).and.( n>0 )) then
              info = -7
           else if(( ilst<1 .or. ilst>n ).and.( n>0 )) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STREXC', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 )return
           ! determine the first row of specified block
           ! and find out it is 1 by 1 or 2 by 2.
           if( ifst>1 ) then
              if( t( ifst, ifst-1 )/=zero )ifst = ifst - 1
           end if
           nbf = 1
           if( ifst<n ) then
              if( t( ifst+1, ifst )/=zero )nbf = 2
           end if
           ! determine the first row of the final block
           ! and find out it is 1 by 1 or 2 by 2.
           if( ilst>1 ) then
              if( t( ilst, ilst-1 )/=zero )ilst = ilst - 1
           end if
           nbl = 1
           if( ilst<n ) then
              if( t( ilst+1, ilst )/=zero )nbl = 2
           end if
           if( ifst==ilst )return
           if( ifst<ilst ) then
              ! update ilst
              if( nbf==2 .and. nbl==1 )ilst = ilst - 1
              if( nbf==1 .and. nbl==2 )ilst = ilst + 1
              here = ifst
              10 continue
              ! swap block with next one below
              if( nbf==1 .or. nbf==2 ) then
                 ! current block either 1 by 1 or 2 by 2
                 nbnext = 1
                 if( here+nbf+1<=n ) then
                    if( t( here+nbf+1, here+nbf )/=zero )nbnext = 2
                 end if
                 call stdlib_slaexc( wantq, n, t, ldt, q, ldq, here, nbf, nbnext,work, info )
                           
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 here = here + nbnext
                 ! test if 2 by 2 block breaks into two 1 by 1 blocks
                 if( nbf==2 ) then
                    if( t( here+1, here )==zero )nbf = 3
                 end if
              else
                 ! current block consists of two 1 by 1 blocks each of which
                 ! must be swapped individually
                 nbnext = 1
                 if( here+3<=n ) then
                    if( t( here+3, here+2 )/=zero )nbnext = 2
                 end if
                 call stdlib_slaexc( wantq, n, t, ldt, q, ldq, here+1, 1, nbnext,work, info )
                           
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 if( nbnext==1 ) then
                    ! swap two 1 by 1 blocks, no problems possible
                    call stdlib_slaexc( wantq, n, t, ldt, q, ldq, here, 1, nbnext,work, info )
                              
                    here = here + 1
                 else
                    ! recompute nbnext in case 2 by 2 split
                    if( t( here+2, here+1 )==zero )nbnext = 1
                    if( nbnext==2 ) then
                       ! 2 by 2 block did not split
                       call stdlib_slaexc( wantq, n, t, ldt, q, ldq, here, 1,nbnext, work, info )
                                 
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 2
                    else
                       ! 2 by 2 block did split
                       call stdlib_slaexc( wantq, n, t, ldt, q, ldq, here, 1, 1,work, info )
                                 
                       call stdlib_slaexc( wantq, n, t, ldt, q, ldq, here+1, 1, 1,work, info )
                                 
                       here = here + 2
                    end if
                 end if
              end if
              if( here<ilst )go to 10
           else
              here = ifst
              20 continue
              ! swap block with next one above
              if( nbf==1 .or. nbf==2 ) then
                 ! current block either 1 by 1 or 2 by 2
                 nbnext = 1
                 if( here>=3 ) then
                    if( t( here-1, here-2 )/=zero )nbnext = 2
                 end if
                 call stdlib_slaexc( wantq, n, t, ldt, q, ldq, here-nbnext, nbnext,nbf, work, &
                           info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 here = here - nbnext
                 ! test if 2 by 2 block breaks into two 1 by 1 blocks
                 if( nbf==2 ) then
                    if( t( here+1, here )==zero )nbf = 3
                 end if
              else
                 ! current block consists of two 1 by 1 blocks each of which
                 ! must be swapped individually
                 nbnext = 1
                 if( here>=3 ) then
                    if( t( here-1, here-2 )/=zero )nbnext = 2
                 end if
                 call stdlib_slaexc( wantq, n, t, ldt, q, ldq, here-nbnext, nbnext,1, work, info )
                           
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 if( nbnext==1 ) then
                    ! swap two 1 by 1 blocks, no problems possible
                    call stdlib_slaexc( wantq, n, t, ldt, q, ldq, here, nbnext, 1,work, info )
                              
                    here = here - 1
                 else
                    ! recompute nbnext in case 2 by 2 split
                    if( t( here, here-1 )==zero )nbnext = 1
                    if( nbnext==2 ) then
                       ! 2 by 2 block did not split
                       call stdlib_slaexc( wantq, n, t, ldt, q, ldq, here-1, 2, 1,work, info )
                                 
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 2
                    else
                       ! 2 by 2 block did split
                       call stdlib_slaexc( wantq, n, t, ldt, q, ldq, here, 1, 1,work, info )
                                 
                       call stdlib_slaexc( wantq, n, t, ldt, q, ldq, here-1, 1, 1,work, info )
                                 
                       here = here - 2
                    end if
                 end if
              end if
              if( here>ilst )go to 20
           end if
           ilst = here
           return
     end subroutine stdlib_strexc

     module subroutine stdlib_dtrexc( compq, n, t, ldt, q, ldq, ifst, ilst, work,info )
     !! DTREXC reorders the real Schur factorization of a real matrix
     !! A = Q*T*Q**T, so that the diagonal block of T with row index IFST is
     !! moved to row ILST.
     !! The real Schur form T is reordered by an orthogonal similarity
     !! transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors
     !! is updated by postmultiplying it with Z.
     !! T must be in Schur canonical form (as returned by DHSEQR), that is,
     !! block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
     !! 2-by-2 diagonal block has its diagonal elements equal and its
     !! off-diagonal elements of opposite sign.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq
           integer(ilp), intent(inout) :: ifst, ilst
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldq, ldt, n
           ! Array Arguments 
           real(dp), intent(inout) :: q(ldq,*), t(ldt,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: wantq
           integer(ilp) :: here, nbf, nbl, nbnext
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input arguments.
           info = 0
           wantq = stdlib_lsame( compq, 'V' )
           if( .not.wantq .and. .not.stdlib_lsame( compq, 'N' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldt<max( 1, n ) ) then
              info = -4
           else if( ldq<1 .or. ( wantq .and. ldq<max( 1, n ) ) ) then
              info = -6
           else if(( ifst<1 .or. ifst>n ).and.( n>0 )) then
              info = -7
           else if(( ilst<1 .or. ilst>n ).and.( n>0 )) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTREXC', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 )return
           ! determine the first row of specified block
           ! and find out it is 1 by 1 or 2 by 2.
           if( ifst>1 ) then
              if( t( ifst, ifst-1 )/=zero )ifst = ifst - 1
           end if
           nbf = 1
           if( ifst<n ) then
              if( t( ifst+1, ifst )/=zero )nbf = 2
           end if
           ! determine the first row of the final block
           ! and find out it is 1 by 1 or 2 by 2.
           if( ilst>1 ) then
              if( t( ilst, ilst-1 )/=zero )ilst = ilst - 1
           end if
           nbl = 1
           if( ilst<n ) then
              if( t( ilst+1, ilst )/=zero )nbl = 2
           end if
           if( ifst==ilst )return
           if( ifst<ilst ) then
              ! update ilst
              if( nbf==2 .and. nbl==1 )ilst = ilst - 1
              if( nbf==1 .and. nbl==2 )ilst = ilst + 1
              here = ifst
              10 continue
              ! swap block with next one below
              if( nbf==1 .or. nbf==2 ) then
                 ! current block either 1 by 1 or 2 by 2
                 nbnext = 1
                 if( here+nbf+1<=n ) then
                    if( t( here+nbf+1, here+nbf )/=zero )nbnext = 2
                 end if
                 call stdlib_dlaexc( wantq, n, t, ldt, q, ldq, here, nbf, nbnext,work, info )
                           
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 here = here + nbnext
                 ! test if 2 by 2 block breaks into two 1 by 1 blocks
                 if( nbf==2 ) then
                    if( t( here+1, here )==zero )nbf = 3
                 end if
              else
                 ! current block consists of two 1 by 1 blocks each of which
                 ! must be swapped individually
                 nbnext = 1
                 if( here+3<=n ) then
                    if( t( here+3, here+2 )/=zero )nbnext = 2
                 end if
                 call stdlib_dlaexc( wantq, n, t, ldt, q, ldq, here+1, 1, nbnext,work, info )
                           
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 if( nbnext==1 ) then
                    ! swap two 1 by 1 blocks, no problems possible
                    call stdlib_dlaexc( wantq, n, t, ldt, q, ldq, here, 1, nbnext,work, info )
                              
                    here = here + 1
                 else
                    ! recompute nbnext in case 2 by 2 split
                    if( t( here+2, here+1 )==zero )nbnext = 1
                    if( nbnext==2 ) then
                       ! 2 by 2 block did not split
                       call stdlib_dlaexc( wantq, n, t, ldt, q, ldq, here, 1,nbnext, work, info )
                                 
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 2
                    else
                       ! 2 by 2 block did split
                       call stdlib_dlaexc( wantq, n, t, ldt, q, ldq, here, 1, 1,work, info )
                                 
                       call stdlib_dlaexc( wantq, n, t, ldt, q, ldq, here+1, 1, 1,work, info )
                                 
                       here = here + 2
                    end if
                 end if
              end if
              if( here<ilst )go to 10
           else
              here = ifst
              20 continue
              ! swap block with next one above
              if( nbf==1 .or. nbf==2 ) then
                 ! current block either 1 by 1 or 2 by 2
                 nbnext = 1
                 if( here>=3 ) then
                    if( t( here-1, here-2 )/=zero )nbnext = 2
                 end if
                 call stdlib_dlaexc( wantq, n, t, ldt, q, ldq, here-nbnext, nbnext,nbf, work, &
                           info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 here = here - nbnext
                 ! test if 2 by 2 block breaks into two 1 by 1 blocks
                 if( nbf==2 ) then
                    if( t( here+1, here )==zero )nbf = 3
                 end if
              else
                 ! current block consists of two 1 by 1 blocks each of which
                 ! must be swapped individually
                 nbnext = 1
                 if( here>=3 ) then
                    if( t( here-1, here-2 )/=zero )nbnext = 2
                 end if
                 call stdlib_dlaexc( wantq, n, t, ldt, q, ldq, here-nbnext, nbnext,1, work, info )
                           
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 if( nbnext==1 ) then
                    ! swap two 1 by 1 blocks, no problems possible
                    call stdlib_dlaexc( wantq, n, t, ldt, q, ldq, here, nbnext, 1,work, info )
                              
                    here = here - 1
                 else
                    ! recompute nbnext in case 2 by 2 split
                    if( t( here, here-1 )==zero )nbnext = 1
                    if( nbnext==2 ) then
                       ! 2 by 2 block did not split
                       call stdlib_dlaexc( wantq, n, t, ldt, q, ldq, here-1, 2, 1,work, info )
                                 
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 2
                    else
                       ! 2 by 2 block did split
                       call stdlib_dlaexc( wantq, n, t, ldt, q, ldq, here, 1, 1,work, info )
                                 
                       call stdlib_dlaexc( wantq, n, t, ldt, q, ldq, here-1, 1, 1,work, info )
                                 
                       here = here - 2
                    end if
                 end if
              end if
              if( here>ilst )go to 20
           end if
           ilst = here
           return
     end subroutine stdlib_dtrexc

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$trexc( compq, n, t, ldt, q, ldq, ifst, ilst, work,info )
     !! DTREXC: reorders the real Schur factorization of a real matrix
     !! A = Q*T*Q**T, so that the diagonal block of T with row index IFST is
     !! moved to row ILST.
     !! The real Schur form T is reordered by an orthogonal similarity
     !! transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors
     !! is updated by postmultiplying it with Z.
     !! T must be in Schur canonical form (as returned by DHSEQR), that is,
     !! block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
     !! 2-by-2 diagonal block has its diagonal elements equal and its
     !! off-diagonal elements of opposite sign.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq
           integer(ilp), intent(inout) :: ifst, ilst
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldq, ldt, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: q(ldq,*), t(ldt,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: wantq
           integer(ilp) :: here, nbf, nbl, nbnext
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input arguments.
           info = 0
           wantq = stdlib_lsame( compq, 'V' )
           if( .not.wantq .and. .not.stdlib_lsame( compq, 'N' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldt<max( 1, n ) ) then
              info = -4
           else if( ldq<1 .or. ( wantq .and. ldq<max( 1, n ) ) ) then
              info = -6
           else if(( ifst<1 .or. ifst>n ).and.( n>0 )) then
              info = -7
           else if(( ilst<1 .or. ilst>n ).and.( n>0 )) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTREXC', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 )return
           ! determine the first row of specified block
           ! and find out it is 1 by 1 or 2 by 2.
           if( ifst>1 ) then
              if( t( ifst, ifst-1 )/=zero )ifst = ifst - 1
           end if
           nbf = 1
           if( ifst<n ) then
              if( t( ifst+1, ifst )/=zero )nbf = 2
           end if
           ! determine the first row of the final block
           ! and find out it is 1 by 1 or 2 by 2.
           if( ilst>1 ) then
              if( t( ilst, ilst-1 )/=zero )ilst = ilst - 1
           end if
           nbl = 1
           if( ilst<n ) then
              if( t( ilst+1, ilst )/=zero )nbl = 2
           end if
           if( ifst==ilst )return
           if( ifst<ilst ) then
              ! update ilst
              if( nbf==2 .and. nbl==1 )ilst = ilst - 1
              if( nbf==1 .and. nbl==2 )ilst = ilst + 1
              here = ifst
              10 continue
              ! swap block with next one below
              if( nbf==1 .or. nbf==2 ) then
                 ! current block either 1 by 1 or 2 by 2
                 nbnext = 1
                 if( here+nbf+1<=n ) then
                    if( t( here+nbf+1, here+nbf )/=zero )nbnext = 2
                 end if
                 call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here, nbf, nbnext,work, info )
                           
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 here = here + nbnext
                 ! test if 2 by 2 block breaks into two 1 by 1 blocks
                 if( nbf==2 ) then
                    if( t( here+1, here )==zero )nbf = 3
                 end if
              else
                 ! current block consists of two 1 by 1 blocks each of which
                 ! must be swapped individually
                 nbnext = 1
                 if( here+3<=n ) then
                    if( t( here+3, here+2 )/=zero )nbnext = 2
                 end if
                 call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here+1, 1, nbnext,work, info )
                           
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 if( nbnext==1 ) then
                    ! swap two 1 by 1 blocks, no problems possible
                    call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here, 1, nbnext,work, info )
                              
                    here = here + 1
                 else
                    ! recompute nbnext in case 2 by 2 split
                    if( t( here+2, here+1 )==zero )nbnext = 1
                    if( nbnext==2 ) then
                       ! 2 by 2 block did not split
                       call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here, 1,nbnext, work, info )
                                 
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 2
                    else
                       ! 2 by 2 block did split
                       call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here, 1, 1,work, info )
                                 
                       call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here+1, 1, 1,work, info )
                                 
                       here = here + 2
                    end if
                 end if
              end if
              if( here<ilst )go to 10
           else
              here = ifst
              20 continue
              ! swap block with next one above
              if( nbf==1 .or. nbf==2 ) then
                 ! current block either 1 by 1 or 2 by 2
                 nbnext = 1
                 if( here>=3 ) then
                    if( t( here-1, here-2 )/=zero )nbnext = 2
                 end if
                 call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here-nbnext, nbnext,nbf, work, &
                           info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 here = here - nbnext
                 ! test if 2 by 2 block breaks into two 1 by 1 blocks
                 if( nbf==2 ) then
                    if( t( here+1, here )==zero )nbf = 3
                 end if
              else
                 ! current block consists of two 1 by 1 blocks each of which
                 ! must be swapped individually
                 nbnext = 1
                 if( here>=3 ) then
                    if( t( here-1, here-2 )/=zero )nbnext = 2
                 end if
                 call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here-nbnext, nbnext,1, work, info )
                           
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 if( nbnext==1 ) then
                    ! swap two 1 by 1 blocks, no problems possible
                    call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here, nbnext, 1,work, info )
                              
                    here = here - 1
                 else
                    ! recompute nbnext in case 2 by 2 split
                    if( t( here, here-1 )==zero )nbnext = 1
                    if( nbnext==2 ) then
                       ! 2 by 2 block did not split
                       call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here-1, 2, 1,work, info )
                                 
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 2
                    else
                       ! 2 by 2 block did split
                       call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here, 1, 1,work, info )
                                 
                       call stdlib_${ri}$laexc( wantq, n, t, ldt, q, ldq, here-1, 1, 1,work, info )
                                 
                       here = here - 2
                    end if
                 end if
              end if
              if( here>ilst )go to 20
           end if
           ilst = here
           return
     end subroutine stdlib_${ri}$trexc

#:endif
#:endfor

     module pure subroutine stdlib_ctrexc( compq, n, t, ldt, q, ldq, ifst, ilst, info )
     !! CTREXC reorders the Schur factorization of a complex matrix
     !! A = Q*T*Q**H, so that the diagonal element of T with row index IFST
     !! is moved to row ILST.
     !! The Schur form T is reordered by a unitary similarity transformation
     !! Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by
     !! postmultplying it with Z.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq
           integer(ilp), intent(in) :: ifst, ilst, ldq, ldt, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: q(ldq,*), t(ldt,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: wantq
           integer(ilp) :: k, m1, m2, m3
           real(sp) :: cs
           complex(sp) :: sn, t11, t22, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           info = 0
           wantq = stdlib_lsame( compq, 'V' )
           if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldt<max( 1, n ) ) then
              info = -4
           else if( ldq<1 .or. ( wantq .and. ldq<max( 1, n ) ) ) then
              info = -6
           else if(( ifst<1 .or. ifst>n ).and.( n>0 )) then
              info = -7
           else if(( ilst<1 .or. ilst>n ).and.( n>0 )) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTREXC', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 .or. ifst==ilst )return
           if( ifst<ilst ) then
              ! move the ifst-th diagonal element forward down the diagonal.
              m1 = 0
              m2 = -1
              m3 = 1
           else
              ! move the ifst-th diagonal element backward up the diagonal.
              m1 = -1
              m2 = 0
              m3 = -1
           end if
           do k = ifst + m1, ilst + m2, m3
              ! interchange the k-th and (k+1)-th diagonal elements.
              t11 = t( k, k )
              t22 = t( k+1, k+1 )
              ! determine the transformation to perform the interchange.
              call stdlib_clartg( t( k, k+1 ), t22-t11, cs, sn, temp )
              ! apply transformation to the matrix t.
              if( k+2<=n )call stdlib_crot( n-k-1, t( k, k+2 ), ldt, t( k+1, k+2 ), ldt, cs,sn )
                        
              call stdlib_crot( k-1, t( 1, k ), 1, t( 1, k+1 ), 1, cs, conjg( sn ) )
              t( k, k ) = t22
              t( k+1, k+1 ) = t11
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_crot( n, q( 1, k ), 1, q( 1, k+1 ), 1, cs,conjg( sn ) )
              end if
           end do
           return
     end subroutine stdlib_ctrexc

     module pure subroutine stdlib_ztrexc( compq, n, t, ldt, q, ldq, ifst, ilst, info )
     !! ZTREXC reorders the Schur factorization of a complex matrix
     !! A = Q*T*Q**H, so that the diagonal element of T with row index IFST
     !! is moved to row ILST.
     !! The Schur form T is reordered by a unitary similarity transformation
     !! Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by
     !! postmultplying it with Z.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq
           integer(ilp), intent(in) :: ifst, ilst, ldq, ldt, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(dp), intent(inout) :: q(ldq,*), t(ldt,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: wantq
           integer(ilp) :: k, m1, m2, m3
           real(dp) :: cs
           complex(dp) :: sn, t11, t22, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           info = 0
           wantq = stdlib_lsame( compq, 'V' )
           if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldt<max( 1, n ) ) then
              info = -4
           else if( ldq<1 .or. ( wantq .and. ldq<max( 1, n ) ) ) then
              info = -6
           else if(( ifst<1 .or. ifst>n ).and.( n>0 )) then
              info = -7
           else if(( ilst<1 .or. ilst>n ).and.( n>0 )) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTREXC', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 .or. ifst==ilst )return
           if( ifst<ilst ) then
              ! move the ifst-th diagonal element forward down the diagonal.
              m1 = 0
              m2 = -1
              m3 = 1
           else
              ! move the ifst-th diagonal element backward up the diagonal.
              m1 = -1
              m2 = 0
              m3 = -1
           end if
           do k = ifst + m1, ilst + m2, m3
              ! interchange the k-th and (k+1)-th diagonal elements.
              t11 = t( k, k )
              t22 = t( k+1, k+1 )
              ! determine the transformation to perform the interchange.
              call stdlib_zlartg( t( k, k+1 ), t22-t11, cs, sn, temp )
              ! apply transformation to the matrix t.
              if( k+2<=n )call stdlib_zrot( n-k-1, t( k, k+2 ), ldt, t( k+1, k+2 ), ldt, cs,sn )
                        
              call stdlib_zrot( k-1, t( 1, k ), 1, t( 1, k+1 ), 1, cs,conjg( sn ) )
              t( k, k ) = t22
              t( k+1, k+1 ) = t11
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_zrot( n, q( 1, k ), 1, q( 1, k+1 ), 1, cs,conjg( sn ) )
              end if
           end do
           return
     end subroutine stdlib_ztrexc

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$trexc( compq, n, t, ldt, q, ldq, ifst, ilst, info )
     !! ZTREXC: reorders the Schur factorization of a complex matrix
     !! A = Q*T*Q**H, so that the diagonal element of T with row index IFST
     !! is moved to row ILST.
     !! The Schur form T is reordered by a unitary similarity transformation
     !! Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by
     !! postmultplying it with Z.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq
           integer(ilp), intent(in) :: ifst, ilst, ldq, ldt, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: q(ldq,*), t(ldt,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: wantq
           integer(ilp) :: k, m1, m2, m3
           real(${ck}$) :: cs
           complex(${ck}$) :: sn, t11, t22, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           info = 0
           wantq = stdlib_lsame( compq, 'V' )
           if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldt<max( 1, n ) ) then
              info = -4
           else if( ldq<1 .or. ( wantq .and. ldq<max( 1, n ) ) ) then
              info = -6
           else if(( ifst<1 .or. ifst>n ).and.( n>0 )) then
              info = -7
           else if(( ilst<1 .or. ilst>n ).and.( n>0 )) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTREXC', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 .or. ifst==ilst )return
           if( ifst<ilst ) then
              ! move the ifst-th diagonal element forward down the diagonal.
              m1 = 0
              m2 = -1
              m3 = 1
           else
              ! move the ifst-th diagonal element backward up the diagonal.
              m1 = -1
              m2 = 0
              m3 = -1
           end if
           do k = ifst + m1, ilst + m2, m3
              ! interchange the k-th and (k+1)-th diagonal elements.
              t11 = t( k, k )
              t22 = t( k+1, k+1 )
              ! determine the transformation to perform the interchange.
              call stdlib_${ci}$lartg( t( k, k+1 ), t22-t11, cs, sn, temp )
              ! apply transformation to the matrix t.
              if( k+2<=n )call stdlib_${ci}$rot( n-k-1, t( k, k+2 ), ldt, t( k+1, k+2 ), ldt, cs,sn )
                        
              call stdlib_${ci}$rot( k-1, t( 1, k ), 1, t( 1, k+1 ), 1, cs,conjg( sn ) )
              t( k, k ) = t22
              t( k+1, k+1 ) = t11
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_${ci}$rot( n, q( 1, k ), 1, q( 1, k+1 ), 1, cs,conjg( sn ) )
              end if
           end do
           return
     end subroutine stdlib_${ci}$trexc

#:endif
#:endfor





     module subroutine stdlib_slaqtr( ltran, lreal, n, t, ldt, b, w, scale, x, work,info )
     !! SLAQTR solves the real quasi-triangular system
     !! op(T)*p = scale*c,               if LREAL = .TRUE.
     !! or the complex quasi-triangular systems
     !! op(T + iB)*(p+iq) = scale*(c+id),  if LREAL = .FALSE.
     !! in real arithmetic, where T is upper quasi-triangular.
     !! If LREAL = .FALSE., then the first diagonal block of T must be
     !! 1 by 1, B is the specially structured matrix
     !! B = [ b(1) b(2) ... b(n) ]
     !! [       w            ]
     !! [           w        ]
     !! [              .     ]
     !! [                 w  ]
     !! op(A) = A or A**T, A**T denotes the transpose of
     !! matrix A.
     !! On input, X = [ c ].  On output, X = [ p ].
     !! [ d ]                  [ q ]
     !! This subroutine is designed for the condition number estimation
     !! in routine STRSNA.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: lreal, ltran
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldt, n
           real(sp), intent(out) :: scale
           real(sp), intent(in) :: w
           ! Array Arguments 
           real(sp), intent(in) :: b(*), t(ldt,*)
           real(sp), intent(out) :: work(*)
           real(sp), intent(inout) :: x(*)
       ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: notran
           integer(ilp) :: i, ierr, j, j1, j2, jnext, k, n1, n2
           real(sp) :: bignum, eps, rec, scaloc, si, smin, sminw, smlnum, sr, tjj, tmp, xj, xmax, &
                     xnorm, z
           ! Local Arrays 
           real(sp) :: d(2,2), v(2,2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! do not test the input parameters for errors
           notran = .not.ltran
           info = 0
           ! quick return if possible
           if( n==0 )return
           ! set constants to control overflow
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' ) / eps
           bignum = one / smlnum
           xnorm = stdlib_slange( 'M', n, n, t, ldt, d )
           if( .not.lreal )xnorm = max( xnorm, abs( w ), stdlib_slange( 'M', n, 1, b, n, d ) )
                     
           smin = max( smlnum, eps*xnorm )
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           work( 1 ) = zero
           do j = 2, n
              work( j ) = stdlib_sasum( j-1, t( 1, j ), 1 )
           end do
           if( .not.lreal ) then
              do i = 2, n
                 work( i ) = work( i ) + abs( b( i ) )
              end do
           end if
           n2 = 2*n
           n1 = n
           if( .not.lreal )n1 = n2
           k = stdlib_isamax( n1, x, 1 )
           xmax = abs( x( k ) )
           scale = one
           if( xmax>bignum ) then
              scale = bignum / xmax
              call stdlib_sscal( n1, scale, x, 1 )
              xmax = bignum
           end if
           if( lreal ) then
              if( notran ) then
                 ! solve t*p = scale*c
                 jnext = n
                 loop_30: do j = n, 1, -1
                    if( j>jnext )cycle loop_30
                    j1 = j
                    j2 = j
                    jnext = j - 1
                    if( j>1 ) then
                       if( t( j, j-1 )/=zero ) then
                          j1 = j - 1
                          jnext = j - 2
                       end if
                    end if
                    if( j1==j2 ) then
                       ! meet 1 by 1 diagonal block
                       ! scale to avoid overflow when computing
                           ! x(j) = b(j)/t(j,j)
                       xj = abs( x( j1 ) )
                       tjj = abs( t( j1, j1 ) )
                       tmp = t( j1, j1 )
                       if( tjj<smin ) then
                          tmp = smin
                          tjj = smin
                          info = 1
                       end if
                       if( xj==zero )cycle loop_30
                       if( tjj<one ) then
                          if( xj>bignum*tjj ) then
                             rec = one / xj
                             call stdlib_sscal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       x( j1 ) = x( j1 ) / tmp
                       xj = abs( x( j1 ) )
                       ! scale x if necessary to avoid overflow when adding a
                       ! multiple of column j1 of t.
                       if( xj>one ) then
                          rec = one / xj
                          if( work( j1 )>( bignum-xmax )*rec ) then
                             call stdlib_sscal( n, rec, x, 1 )
                             scale = scale*rec
                          end if
                       end if
                       if( j1>1 ) then
                          call stdlib_saxpy( j1-1, -x( j1 ), t( 1, j1 ), 1, x, 1 )
                          k = stdlib_isamax( j1-1, x, 1 )
                          xmax = abs( x( k ) )
                       end if
                    else
                       ! meet 2 by 2 diagonal block
                       ! call 2 by 2 linear system solve, to take
                       ! care of possible overflow by scaling factor.
                       d( 1, 1 ) = x( j1 )
                       d( 2, 1 ) = x( j2 )
                       call stdlib_slaln2( .false., 2, 1, smin, one, t( j1, j1 ),ldt, one, one, d,&
                                  2, zero, zero, v, 2,scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 2
                       if( scaloc/=one ) then
                          call stdlib_sscal( n, scaloc, x, 1 )
                          scale = scale*scaloc
                       end if
                       x( j1 ) = v( 1, 1 )
                       x( j2 ) = v( 2, 1 )
                       ! scale v(1,1) (= x(j1)) and/or v(2,1) (=x(j2))
                       ! to avoid overflow in updating right-hand side.
                       xj = max( abs( v( 1, 1 ) ), abs( v( 2, 1 ) ) )
                       if( xj>one ) then
                          rec = one / xj
                          if( max( work( j1 ), work( j2 ) )>( bignum-xmax )*rec ) then
                             call stdlib_sscal( n, rec, x, 1 )
                             scale = scale*rec
                          end if
                       end if
                       ! update right-hand side
                       if( j1>1 ) then
                          call stdlib_saxpy( j1-1, -x( j1 ), t( 1, j1 ), 1, x, 1 )
                          call stdlib_saxpy( j1-1, -x( j2 ), t( 1, j2 ), 1, x, 1 )
                          k = stdlib_isamax( j1-1, x, 1 )
                          xmax = abs( x( k ) )
                       end if
                    end if
                 end do loop_30
              else
                 ! solve t**t*p = scale*c
                 jnext = 1
                 loop_40: do j = 1, n
                    if( j<jnext )cycle loop_40
                    j1 = j
                    j2 = j
                    jnext = j + 1
                    if( j<n ) then
                       if( t( j+1, j )/=zero ) then
                          j2 = j + 1
                          jnext = j + 2
                       end if
                    end if
                    if( j1==j2 ) then
                       ! 1 by 1 diagonal block
                       ! scale if necessary to avoid overflow in forming the
                       ! right-hand side element by inner product.
                       xj = abs( x( j1 ) )
                       if( xmax>one ) then
                          rec = one / xmax
                          if( work( j1 )>( bignum-xj )*rec ) then
                             call stdlib_sscal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       x( j1 ) = x( j1 ) - stdlib_sdot( j1-1, t( 1, j1 ), 1, x, 1 )
                       xj = abs( x( j1 ) )
                       tjj = abs( t( j1, j1 ) )
                       tmp = t( j1, j1 )
                       if( tjj<smin ) then
                          tmp = smin
                          tjj = smin
                          info = 1
                       end if
                       if( tjj<one ) then
                          if( xj>bignum*tjj ) then
                             rec = one / xj
                             call stdlib_sscal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       x( j1 ) = x( j1 ) / tmp
                       xmax = max( xmax, abs( x( j1 ) ) )
                    else
                       ! 2 by 2 diagonal block
                       ! scale if necessary to avoid overflow in forming the
                       ! right-hand side elements by inner product.
                       xj = max( abs( x( j1 ) ), abs( x( j2 ) ) )
                       if( xmax>one ) then
                          rec = one / xmax
                          if( max( work( j2 ), work( j1 ) )>( bignum-xj )*rec ) then
                             call stdlib_sscal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       d( 1, 1 ) = x( j1 ) - stdlib_sdot( j1-1, t( 1, j1 ), 1, x,1 )
                       d( 2, 1 ) = x( j2 ) - stdlib_sdot( j1-1, t( 1, j2 ), 1, x,1 )
                       call stdlib_slaln2( .true., 2, 1, smin, one, t( j1, j1 ),ldt, one, one, d, &
                                 2, zero, zero, v, 2,scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 2
                       if( scaloc/=one ) then
                          call stdlib_sscal( n, scaloc, x, 1 )
                          scale = scale*scaloc
                       end if
                       x( j1 ) = v( 1, 1 )
                       x( j2 ) = v( 2, 1 )
                       xmax = max( abs( x( j1 ) ), abs( x( j2 ) ), xmax )
                    end if
                 end do loop_40
              end if
           else
              sminw = max( eps*abs( w ), smin )
              if( notran ) then
                 ! solve (t + ib)*(p+iq) = c+id
                 jnext = n
                 loop_70: do j = n, 1, -1
                    if( j>jnext )cycle loop_70
                    j1 = j
                    j2 = j
                    jnext = j - 1
                    if( j>1 ) then
                       if( t( j, j-1 )/=zero ) then
                          j1 = j - 1
                          jnext = j - 2
                       end if
                    end if
                    if( j1==j2 ) then
                       ! 1 by 1 diagonal block
                       ! scale if necessary to avoid overflow in division
                       z = w
                       if( j1==1 )z = b( 1 )
                       xj = abs( x( j1 ) ) + abs( x( n+j1 ) )
                       tjj = abs( t( j1, j1 ) ) + abs( z )
                       tmp = t( j1, j1 )
                       if( tjj<sminw ) then
                          tmp = sminw
                          tjj = sminw
                          info = 1
                       end if
                       if( xj==zero )cycle loop_70
                       if( tjj<one ) then
                          if( xj>bignum*tjj ) then
                             rec = one / xj
                             call stdlib_sscal( n2, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       call stdlib_sladiv( x( j1 ), x( n+j1 ), tmp, z, sr, si )
                       x( j1 ) = sr
                       x( n+j1 ) = si
                       xj = abs( x( j1 ) ) + abs( x( n+j1 ) )
                       ! scale x if necessary to avoid overflow when adding a
                       ! multiple of column j1 of t.
                       if( xj>one ) then
                          rec = one / xj
                          if( work( j1 )>( bignum-xmax )*rec ) then
                             call stdlib_sscal( n2, rec, x, 1 )
                             scale = scale*rec
                          end if
                       end if
                       if( j1>1 ) then
                          call stdlib_saxpy( j1-1, -x( j1 ), t( 1, j1 ), 1, x, 1 )
                          call stdlib_saxpy( j1-1, -x( n+j1 ), t( 1, j1 ), 1,x( n+1 ), 1 )
                          x( 1 ) = x( 1 ) + b( j1 )*x( n+j1 )
                          x( n+1 ) = x( n+1 ) - b( j1 )*x( j1 )
                          xmax = zero
                          do k = 1, j1 - 1
                             xmax = max( xmax, abs( x( k ) )+abs( x( k+n ) ) )
                          end do
                       end if
                    else
                       ! meet 2 by 2 diagonal block
                       d( 1, 1 ) = x( j1 )
                       d( 2, 1 ) = x( j2 )
                       d( 1, 2 ) = x( n+j1 )
                       d( 2, 2 ) = x( n+j2 )
                       call stdlib_slaln2( .false., 2, 2, sminw, one, t( j1, j1 ),ldt, one, one, &
                                 d, 2, zero, -w, v, 2,scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 2
                       if( scaloc/=one ) then
                          call stdlib_sscal( 2*n, scaloc, x, 1 )
                          scale = scaloc*scale
                       end if
                       x( j1 ) = v( 1, 1 )
                       x( j2 ) = v( 2, 1 )
                       x( n+j1 ) = v( 1, 2 )
                       x( n+j2 ) = v( 2, 2 )
                       ! scale x(j1), .... to avoid overflow in
                       ! updating right hand side.
                       xj = max( abs( v( 1, 1 ) )+abs( v( 1, 2 ) ),abs( v( 2, 1 ) )+abs( v( 2, 2 )&
                                  ) )
                       if( xj>one ) then
                          rec = one / xj
                          if( max( work( j1 ), work( j2 ) )>( bignum-xmax )*rec ) then
                             call stdlib_sscal( n2, rec, x, 1 )
                             scale = scale*rec
                          end if
                       end if
                       ! update the right-hand side.
                       if( j1>1 ) then
                          call stdlib_saxpy( j1-1, -x( j1 ), t( 1, j1 ), 1, x, 1 )
                          call stdlib_saxpy( j1-1, -x( j2 ), t( 1, j2 ), 1, x, 1 )
                          call stdlib_saxpy( j1-1, -x( n+j1 ), t( 1, j1 ), 1,x( n+1 ), 1 )
                          call stdlib_saxpy( j1-1, -x( n+j2 ), t( 1, j2 ), 1,x( n+1 ), 1 )
                          x( 1 ) = x( 1 ) + b( j1 )*x( n+j1 ) +b( j2 )*x( n+j2 )
                          x( n+1 ) = x( n+1 ) - b( j1 )*x( j1 ) -b( j2 )*x( j2 )
                          xmax = zero
                          do k = 1, j1 - 1
                             xmax = max( abs( x( k ) )+abs( x( k+n ) ),xmax )
                          end do
                       end if
                    end if
                 end do loop_70
              else
                 ! solve (t + ib)**t*(p+iq) = c+id
                 jnext = 1
                 loop_80: do j = 1, n
                    if( j<jnext )cycle loop_80
                    j1 = j
                    j2 = j
                    jnext = j + 1
                    if( j<n ) then
                       if( t( j+1, j )/=zero ) then
                          j2 = j + 1
                          jnext = j + 2
                       end if
                    end if
                    if( j1==j2 ) then
                       ! 1 by 1 diagonal block
                       ! scale if necessary to avoid overflow in forming the
                       ! right-hand side element by inner product.
                       xj = abs( x( j1 ) ) + abs( x( j1+n ) )
                       if( xmax>one ) then
                          rec = one / xmax
                          if( work( j1 )>( bignum-xj )*rec ) then
                             call stdlib_sscal( n2, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       x( j1 ) = x( j1 ) - stdlib_sdot( j1-1, t( 1, j1 ), 1, x, 1 )
                       x( n+j1 ) = x( n+j1 ) - stdlib_sdot( j1-1, t( 1, j1 ), 1,x( n+1 ), 1 )
                                 
                       if( j1>1 ) then
                          x( j1 ) = x( j1 ) - b( j1 )*x( n+1 )
                          x( n+j1 ) = x( n+j1 ) + b( j1 )*x( 1 )
                       end if
                       xj = abs( x( j1 ) ) + abs( x( j1+n ) )
                       z = w
                       if( j1==1 )z = b( 1 )
                       ! scale if necessary to avoid overflow in
                       ! complex division
                       tjj = abs( t( j1, j1 ) ) + abs( z )
                       tmp = t( j1, j1 )
                       if( tjj<sminw ) then
                          tmp = sminw
                          tjj = sminw
                          info = 1
                       end if
                       if( tjj<one ) then
                          if( xj>bignum*tjj ) then
                             rec = one / xj
                             call stdlib_sscal( n2, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       call stdlib_sladiv( x( j1 ), x( n+j1 ), tmp, -z, sr, si )
                       x( j1 ) = sr
                       x( j1+n ) = si
                       xmax = max( abs( x( j1 ) )+abs( x( j1+n ) ), xmax )
                    else
                       ! 2 by 2 diagonal block
                       ! scale if necessary to avoid overflow in forming the
                       ! right-hand side element by inner product.
                       xj = max( abs( x( j1 ) )+abs( x( n+j1 ) ),abs( x( j2 ) )+abs( x( n+j2 ) ) )
                                 
                       if( xmax>one ) then
                          rec = one / xmax
                          if( max( work( j1 ), work( j2 ) )>( bignum-xj ) / xmax ) then
                             call stdlib_sscal( n2, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       d( 1, 1 ) = x( j1 ) - stdlib_sdot( j1-1, t( 1, j1 ), 1, x,1 )
                       d( 2, 1 ) = x( j2 ) - stdlib_sdot( j1-1, t( 1, j2 ), 1, x,1 )
                       d( 1, 2 ) = x( n+j1 ) - stdlib_sdot( j1-1, t( 1, j1 ), 1,x( n+1 ), 1 )
                                 
                       d( 2, 2 ) = x( n+j2 ) - stdlib_sdot( j1-1, t( 1, j2 ), 1,x( n+1 ), 1 )
                                 
                       d( 1, 1 ) = d( 1, 1 ) - b( j1 )*x( n+1 )
                       d( 2, 1 ) = d( 2, 1 ) - b( j2 )*x( n+1 )
                       d( 1, 2 ) = d( 1, 2 ) + b( j1 )*x( 1 )
                       d( 2, 2 ) = d( 2, 2 ) + b( j2 )*x( 1 )
                       call stdlib_slaln2( .true., 2, 2, sminw, one, t( j1, j1 ),ldt, one, one, d,&
                                  2, zero, w, v, 2,scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 2
                       if( scaloc/=one ) then
                          call stdlib_sscal( n2, scaloc, x, 1 )
                          scale = scaloc*scale
                       end if
                       x( j1 ) = v( 1, 1 )
                       x( j2 ) = v( 2, 1 )
                       x( n+j1 ) = v( 1, 2 )
                       x( n+j2 ) = v( 2, 2 )
                       xmax = max( abs( x( j1 ) )+abs( x( n+j1 ) ),abs( x( j2 ) )+abs( x( n+j2 ) )&
                                 , xmax )
                    end if
                 end do loop_80
              end if
           end if
           return
     end subroutine stdlib_slaqtr

     module subroutine stdlib_dlaqtr( ltran, lreal, n, t, ldt, b, w, scale, x, work,info )
     !! DLAQTR solves the real quasi-triangular system
     !! op(T)*p = scale*c,               if LREAL = .TRUE.
     !! or the complex quasi-triangular systems
     !! op(T + iB)*(p+iq) = scale*(c+id),  if LREAL = .FALSE.
     !! in real arithmetic, where T is upper quasi-triangular.
     !! If LREAL = .FALSE., then the first diagonal block of T must be
     !! 1 by 1, B is the specially structured matrix
     !! B = [ b(1) b(2) ... b(n) ]
     !! [       w            ]
     !! [           w        ]
     !! [              .     ]
     !! [                 w  ]
     !! op(A) = A or A**T, A**T denotes the transpose of
     !! matrix A.
     !! On input, X = [ c ].  On output, X = [ p ].
     !! [ d ]                  [ q ]
     !! This subroutine is designed for the condition number estimation
     !! in routine DTRSNA.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: lreal, ltran
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldt, n
           real(dp), intent(out) :: scale
           real(dp), intent(in) :: w
           ! Array Arguments 
           real(dp), intent(in) :: b(*), t(ldt,*)
           real(dp), intent(out) :: work(*)
           real(dp), intent(inout) :: x(*)
       ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: notran
           integer(ilp) :: i, ierr, j, j1, j2, jnext, k, n1, n2
           real(dp) :: bignum, eps, rec, scaloc, si, smin, sminw, smlnum, sr, tjj, tmp, xj, xmax, &
                     xnorm, z
           ! Local Arrays 
           real(dp) :: d(2,2), v(2,2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! do not test the input parameters for errors
           notran = .not.ltran
           info = 0
           ! quick return if possible
           if( n==0 )return
           ! set constants to control overflow
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' ) / eps
           bignum = one / smlnum
           xnorm = stdlib_dlange( 'M', n, n, t, ldt, d )
           if( .not.lreal )xnorm = max( xnorm, abs( w ), stdlib_dlange( 'M', n, 1, b, n, d ) )
                     
           smin = max( smlnum, eps*xnorm )
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           work( 1 ) = zero
           do j = 2, n
              work( j ) = stdlib_dasum( j-1, t( 1, j ), 1 )
           end do
           if( .not.lreal ) then
              do i = 2, n
                 work( i ) = work( i ) + abs( b( i ) )
              end do
           end if
           n2 = 2*n
           n1 = n
           if( .not.lreal )n1 = n2
           k = stdlib_idamax( n1, x, 1 )
           xmax = abs( x( k ) )
           scale = one
           if( xmax>bignum ) then
              scale = bignum / xmax
              call stdlib_dscal( n1, scale, x, 1 )
              xmax = bignum
           end if
           if( lreal ) then
              if( notran ) then
                 ! solve t*p = scale*c
                 jnext = n
                 loop_30: do j = n, 1, -1
                    if( j>jnext )cycle loop_30
                    j1 = j
                    j2 = j
                    jnext = j - 1
                    if( j>1 ) then
                       if( t( j, j-1 )/=zero ) then
                          j1 = j - 1
                          jnext = j - 2
                       end if
                    end if
                    if( j1==j2 ) then
                       ! meet 1 by 1 diagonal block
                       ! scale to avoid overflow when computing
                           ! x(j) = b(j)/t(j,j)
                       xj = abs( x( j1 ) )
                       tjj = abs( t( j1, j1 ) )
                       tmp = t( j1, j1 )
                       if( tjj<smin ) then
                          tmp = smin
                          tjj = smin
                          info = 1
                       end if
                       if( xj==zero )cycle loop_30
                       if( tjj<one ) then
                          if( xj>bignum*tjj ) then
                             rec = one / xj
                             call stdlib_dscal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       x( j1 ) = x( j1 ) / tmp
                       xj = abs( x( j1 ) )
                       ! scale x if necessary to avoid overflow when adding a
                       ! multiple of column j1 of t.
                       if( xj>one ) then
                          rec = one / xj
                          if( work( j1 )>( bignum-xmax )*rec ) then
                             call stdlib_dscal( n, rec, x, 1 )
                             scale = scale*rec
                          end if
                       end if
                       if( j1>1 ) then
                          call stdlib_daxpy( j1-1, -x( j1 ), t( 1, j1 ), 1, x, 1 )
                          k = stdlib_idamax( j1-1, x, 1 )
                          xmax = abs( x( k ) )
                       end if
                    else
                       ! meet 2 by 2 diagonal block
                       ! call 2 by 2 linear system solve, to take
                       ! care of possible overflow by scaling factor.
                       d( 1, 1 ) = x( j1 )
                       d( 2, 1 ) = x( j2 )
                       call stdlib_dlaln2( .false., 2, 1, smin, one, t( j1, j1 ),ldt, one, one, d,&
                                  2, zero, zero, v, 2,scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 2
                       if( scaloc/=one ) then
                          call stdlib_dscal( n, scaloc, x, 1 )
                          scale = scale*scaloc
                       end if
                       x( j1 ) = v( 1, 1 )
                       x( j2 ) = v( 2, 1 )
                       ! scale v(1,1) (= x(j1)) and/or v(2,1) (=x(j2))
                       ! to avoid overflow in updating right-hand side.
                       xj = max( abs( v( 1, 1 ) ), abs( v( 2, 1 ) ) )
                       if( xj>one ) then
                          rec = one / xj
                          if( max( work( j1 ), work( j2 ) )>( bignum-xmax )*rec ) then
                             call stdlib_dscal( n, rec, x, 1 )
                             scale = scale*rec
                          end if
                       end if
                       ! update right-hand side
                       if( j1>1 ) then
                          call stdlib_daxpy( j1-1, -x( j1 ), t( 1, j1 ), 1, x, 1 )
                          call stdlib_daxpy( j1-1, -x( j2 ), t( 1, j2 ), 1, x, 1 )
                          k = stdlib_idamax( j1-1, x, 1 )
                          xmax = abs( x( k ) )
                       end if
                    end if
                 end do loop_30
              else
                 ! solve t**t*p = scale*c
                 jnext = 1
                 loop_40: do j = 1, n
                    if( j<jnext )cycle loop_40
                    j1 = j
                    j2 = j
                    jnext = j + 1
                    if( j<n ) then
                       if( t( j+1, j )/=zero ) then
                          j2 = j + 1
                          jnext = j + 2
                       end if
                    end if
                    if( j1==j2 ) then
                       ! 1 by 1 diagonal block
                       ! scale if necessary to avoid overflow in forming the
                       ! right-hand side element by inner product.
                       xj = abs( x( j1 ) )
                       if( xmax>one ) then
                          rec = one / xmax
                          if( work( j1 )>( bignum-xj )*rec ) then
                             call stdlib_dscal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       x( j1 ) = x( j1 ) - stdlib_ddot( j1-1, t( 1, j1 ), 1, x, 1 )
                       xj = abs( x( j1 ) )
                       tjj = abs( t( j1, j1 ) )
                       tmp = t( j1, j1 )
                       if( tjj<smin ) then
                          tmp = smin
                          tjj = smin
                          info = 1
                       end if
                       if( tjj<one ) then
                          if( xj>bignum*tjj ) then
                             rec = one / xj
                             call stdlib_dscal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       x( j1 ) = x( j1 ) / tmp
                       xmax = max( xmax, abs( x( j1 ) ) )
                    else
                       ! 2 by 2 diagonal block
                       ! scale if necessary to avoid overflow in forming the
                       ! right-hand side elements by inner product.
                       xj = max( abs( x( j1 ) ), abs( x( j2 ) ) )
                       if( xmax>one ) then
                          rec = one / xmax
                          if( max( work( j2 ), work( j1 ) )>( bignum-xj )*rec ) then
                             call stdlib_dscal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       d( 1, 1 ) = x( j1 ) - stdlib_ddot( j1-1, t( 1, j1 ), 1, x,1 )
                       d( 2, 1 ) = x( j2 ) - stdlib_ddot( j1-1, t( 1, j2 ), 1, x,1 )
                       call stdlib_dlaln2( .true., 2, 1, smin, one, t( j1, j1 ),ldt, one, one, d, &
                                 2, zero, zero, v, 2,scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 2
                       if( scaloc/=one ) then
                          call stdlib_dscal( n, scaloc, x, 1 )
                          scale = scale*scaloc
                       end if
                       x( j1 ) = v( 1, 1 )
                       x( j2 ) = v( 2, 1 )
                       xmax = max( abs( x( j1 ) ), abs( x( j2 ) ), xmax )
                    end if
                 end do loop_40
              end if
           else
              sminw = max( eps*abs( w ), smin )
              if( notran ) then
                 ! solve (t + ib)*(p+iq) = c+id
                 jnext = n
                 loop_70: do j = n, 1, -1
                    if( j>jnext )cycle loop_70
                    j1 = j
                    j2 = j
                    jnext = j - 1
                    if( j>1 ) then
                       if( t( j, j-1 )/=zero ) then
                          j1 = j - 1
                          jnext = j - 2
                       end if
                    end if
                    if( j1==j2 ) then
                       ! 1 by 1 diagonal block
                       ! scale if necessary to avoid overflow in division
                       z = w
                       if( j1==1 )z = b( 1 )
                       xj = abs( x( j1 ) ) + abs( x( n+j1 ) )
                       tjj = abs( t( j1, j1 ) ) + abs( z )
                       tmp = t( j1, j1 )
                       if( tjj<sminw ) then
                          tmp = sminw
                          tjj = sminw
                          info = 1
                       end if
                       if( xj==zero )cycle loop_70
                       if( tjj<one ) then
                          if( xj>bignum*tjj ) then
                             rec = one / xj
                             call stdlib_dscal( n2, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       call stdlib_dladiv( x( j1 ), x( n+j1 ), tmp, z, sr, si )
                       x( j1 ) = sr
                       x( n+j1 ) = si
                       xj = abs( x( j1 ) ) + abs( x( n+j1 ) )
                       ! scale x if necessary to avoid overflow when adding a
                       ! multiple of column j1 of t.
                       if( xj>one ) then
                          rec = one / xj
                          if( work( j1 )>( bignum-xmax )*rec ) then
                             call stdlib_dscal( n2, rec, x, 1 )
                             scale = scale*rec
                          end if
                       end if
                       if( j1>1 ) then
                          call stdlib_daxpy( j1-1, -x( j1 ), t( 1, j1 ), 1, x, 1 )
                          call stdlib_daxpy( j1-1, -x( n+j1 ), t( 1, j1 ), 1,x( n+1 ), 1 )
                          x( 1 ) = x( 1 ) + b( j1 )*x( n+j1 )
                          x( n+1 ) = x( n+1 ) - b( j1 )*x( j1 )
                          xmax = zero
                          do k = 1, j1 - 1
                             xmax = max( xmax, abs( x( k ) )+abs( x( k+n ) ) )
                          end do
                       end if
                    else
                       ! meet 2 by 2 diagonal block
                       d( 1, 1 ) = x( j1 )
                       d( 2, 1 ) = x( j2 )
                       d( 1, 2 ) = x( n+j1 )
                       d( 2, 2 ) = x( n+j2 )
                       call stdlib_dlaln2( .false., 2, 2, sminw, one, t( j1, j1 ),ldt, one, one, &
                                 d, 2, zero, -w, v, 2,scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 2
                       if( scaloc/=one ) then
                          call stdlib_dscal( 2*n, scaloc, x, 1 )
                          scale = scaloc*scale
                       end if
                       x( j1 ) = v( 1, 1 )
                       x( j2 ) = v( 2, 1 )
                       x( n+j1 ) = v( 1, 2 )
                       x( n+j2 ) = v( 2, 2 )
                       ! scale x(j1), .... to avoid overflow in
                       ! updating right hand side.
                       xj = max( abs( v( 1, 1 ) )+abs( v( 1, 2 ) ),abs( v( 2, 1 ) )+abs( v( 2, 2 )&
                                  ) )
                       if( xj>one ) then
                          rec = one / xj
                          if( max( work( j1 ), work( j2 ) )>( bignum-xmax )*rec ) then
                             call stdlib_dscal( n2, rec, x, 1 )
                             scale = scale*rec
                          end if
                       end if
                       ! update the right-hand side.
                       if( j1>1 ) then
                          call stdlib_daxpy( j1-1, -x( j1 ), t( 1, j1 ), 1, x, 1 )
                          call stdlib_daxpy( j1-1, -x( j2 ), t( 1, j2 ), 1, x, 1 )
                          call stdlib_daxpy( j1-1, -x( n+j1 ), t( 1, j1 ), 1,x( n+1 ), 1 )
                          call stdlib_daxpy( j1-1, -x( n+j2 ), t( 1, j2 ), 1,x( n+1 ), 1 )
                          x( 1 ) = x( 1 ) + b( j1 )*x( n+j1 ) +b( j2 )*x( n+j2 )
                          x( n+1 ) = x( n+1 ) - b( j1 )*x( j1 ) -b( j2 )*x( j2 )
                          xmax = zero
                          do k = 1, j1 - 1
                             xmax = max( abs( x( k ) )+abs( x( k+n ) ),xmax )
                          end do
                       end if
                    end if
                 end do loop_70
              else
                 ! solve (t + ib)**t*(p+iq) = c+id
                 jnext = 1
                 loop_80: do j = 1, n
                    if( j<jnext )cycle loop_80
                    j1 = j
                    j2 = j
                    jnext = j + 1
                    if( j<n ) then
                       if( t( j+1, j )/=zero ) then
                          j2 = j + 1
                          jnext = j + 2
                       end if
                    end if
                    if( j1==j2 ) then
                       ! 1 by 1 diagonal block
                       ! scale if necessary to avoid overflow in forming the
                       ! right-hand side element by inner product.
                       xj = abs( x( j1 ) ) + abs( x( j1+n ) )
                       if( xmax>one ) then
                          rec = one / xmax
                          if( work( j1 )>( bignum-xj )*rec ) then
                             call stdlib_dscal( n2, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       x( j1 ) = x( j1 ) - stdlib_ddot( j1-1, t( 1, j1 ), 1, x, 1 )
                       x( n+j1 ) = x( n+j1 ) - stdlib_ddot( j1-1, t( 1, j1 ), 1,x( n+1 ), 1 )
                                 
                       if( j1>1 ) then
                          x( j1 ) = x( j1 ) - b( j1 )*x( n+1 )
                          x( n+j1 ) = x( n+j1 ) + b( j1 )*x( 1 )
                       end if
                       xj = abs( x( j1 ) ) + abs( x( j1+n ) )
                       z = w
                       if( j1==1 )z = b( 1 )
                       ! scale if necessary to avoid overflow in
                       ! complex division
                       tjj = abs( t( j1, j1 ) ) + abs( z )
                       tmp = t( j1, j1 )
                       if( tjj<sminw ) then
                          tmp = sminw
                          tjj = sminw
                          info = 1
                       end if
                       if( tjj<one ) then
                          if( xj>bignum*tjj ) then
                             rec = one / xj
                             call stdlib_dscal( n2, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       call stdlib_dladiv( x( j1 ), x( n+j1 ), tmp, -z, sr, si )
                       x( j1 ) = sr
                       x( j1+n ) = si
                       xmax = max( abs( x( j1 ) )+abs( x( j1+n ) ), xmax )
                    else
                       ! 2 by 2 diagonal block
                       ! scale if necessary to avoid overflow in forming the
                       ! right-hand side element by inner product.
                       xj = max( abs( x( j1 ) )+abs( x( n+j1 ) ),abs( x( j2 ) )+abs( x( n+j2 ) ) )
                                 
                       if( xmax>one ) then
                          rec = one / xmax
                          if( max( work( j1 ), work( j2 ) )>( bignum-xj ) / xmax ) then
                             call stdlib_dscal( n2, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       d( 1, 1 ) = x( j1 ) - stdlib_ddot( j1-1, t( 1, j1 ), 1, x,1 )
                       d( 2, 1 ) = x( j2 ) - stdlib_ddot( j1-1, t( 1, j2 ), 1, x,1 )
                       d( 1, 2 ) = x( n+j1 ) - stdlib_ddot( j1-1, t( 1, j1 ), 1,x( n+1 ), 1 )
                                 
                       d( 2, 2 ) = x( n+j2 ) - stdlib_ddot( j1-1, t( 1, j2 ), 1,x( n+1 ), 1 )
                                 
                       d( 1, 1 ) = d( 1, 1 ) - b( j1 )*x( n+1 )
                       d( 2, 1 ) = d( 2, 1 ) - b( j2 )*x( n+1 )
                       d( 1, 2 ) = d( 1, 2 ) + b( j1 )*x( 1 )
                       d( 2, 2 ) = d( 2, 2 ) + b( j2 )*x( 1 )
                       call stdlib_dlaln2( .true., 2, 2, sminw, one, t( j1, j1 ),ldt, one, one, d,&
                                  2, zero, w, v, 2,scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 2
                       if( scaloc/=one ) then
                          call stdlib_dscal( n2, scaloc, x, 1 )
                          scale = scaloc*scale
                       end if
                       x( j1 ) = v( 1, 1 )
                       x( j2 ) = v( 2, 1 )
                       x( n+j1 ) = v( 1, 2 )
                       x( n+j2 ) = v( 2, 2 )
                       xmax = max( abs( x( j1 ) )+abs( x( n+j1 ) ),abs( x( j2 ) )+abs( x( n+j2 ) )&
                                 , xmax )
                    end if
                 end do loop_80
              end if
           end if
           return
     end subroutine stdlib_dlaqtr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$laqtr( ltran, lreal, n, t, ldt, b, w, scale, x, work,info )
     !! DLAQTR: solves the real quasi-triangular system
     !! op(T)*p = scale*c,               if LREAL = .TRUE.
     !! or the complex quasi-triangular systems
     !! op(T + iB)*(p+iq) = scale*(c+id),  if LREAL = .FALSE.
     !! in real arithmetic, where T is upper quasi-triangular.
     !! If LREAL = .FALSE., then the first diagonal block of T must be
     !! 1 by 1, B is the specially structured matrix
     !! B = [ b(1) b(2) ... b(n) ]
     !! [       w            ]
     !! [           w        ]
     !! [              .     ]
     !! [                 w  ]
     !! op(A) = A or A**T, A**T denotes the transpose of
     !! matrix A.
     !! On input, X = [ c ].  On output, X = [ p ].
     !! [ d ]                  [ q ]
     !! This subroutine is designed for the condition number estimation
     !! in routine DTRSNA.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: lreal, ltran
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldt, n
           real(${rk}$), intent(out) :: scale
           real(${rk}$), intent(in) :: w
           ! Array Arguments 
           real(${rk}$), intent(in) :: b(*), t(ldt,*)
           real(${rk}$), intent(out) :: work(*)
           real(${rk}$), intent(inout) :: x(*)
       ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: notran
           integer(ilp) :: i, ierr, j, j1, j2, jnext, k, n1, n2
           real(${rk}$) :: bignum, eps, rec, scaloc, si, smin, sminw, smlnum, sr, tjj, tmp, xj, xmax, &
                     xnorm, z
           ! Local Arrays 
           real(${rk}$) :: d(2,2), v(2,2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! do not test the input parameters for errors
           notran = .not.ltran
           info = 0
           ! quick return if possible
           if( n==0 )return
           ! set constants to control overflow
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' ) / eps
           bignum = one / smlnum
           xnorm = stdlib_${ri}$lange( 'M', n, n, t, ldt, d )
           if( .not.lreal )xnorm = max( xnorm, abs( w ), stdlib_${ri}$lange( 'M', n, 1, b, n, d ) )
                     
           smin = max( smlnum, eps*xnorm )
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           work( 1 ) = zero
           do j = 2, n
              work( j ) = stdlib_${ri}$asum( j-1, t( 1, j ), 1 )
           end do
           if( .not.lreal ) then
              do i = 2, n
                 work( i ) = work( i ) + abs( b( i ) )
              end do
           end if
           n2 = 2*n
           n1 = n
           if( .not.lreal )n1 = n2
           k = stdlib_i${ri}$amax( n1, x, 1 )
           xmax = abs( x( k ) )
           scale = one
           if( xmax>bignum ) then
              scale = bignum / xmax
              call stdlib_${ri}$scal( n1, scale, x, 1 )
              xmax = bignum
           end if
           if( lreal ) then
              if( notran ) then
                 ! solve t*p = scale*c
                 jnext = n
                 loop_30: do j = n, 1, -1
                    if( j>jnext )cycle loop_30
                    j1 = j
                    j2 = j
                    jnext = j - 1
                    if( j>1 ) then
                       if( t( j, j-1 )/=zero ) then
                          j1 = j - 1
                          jnext = j - 2
                       end if
                    end if
                    if( j1==j2 ) then
                       ! meet 1 by 1 diagonal block
                       ! scale to avoid overflow when computing
                           ! x(j) = b(j)/t(j,j)
                       xj = abs( x( j1 ) )
                       tjj = abs( t( j1, j1 ) )
                       tmp = t( j1, j1 )
                       if( tjj<smin ) then
                          tmp = smin
                          tjj = smin
                          info = 1
                       end if
                       if( xj==zero )cycle loop_30
                       if( tjj<one ) then
                          if( xj>bignum*tjj ) then
                             rec = one / xj
                             call stdlib_${ri}$scal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       x( j1 ) = x( j1 ) / tmp
                       xj = abs( x( j1 ) )
                       ! scale x if necessary to avoid overflow when adding a
                       ! multiple of column j1 of t.
                       if( xj>one ) then
                          rec = one / xj
                          if( work( j1 )>( bignum-xmax )*rec ) then
                             call stdlib_${ri}$scal( n, rec, x, 1 )
                             scale = scale*rec
                          end if
                       end if
                       if( j1>1 ) then
                          call stdlib_${ri}$axpy( j1-1, -x( j1 ), t( 1, j1 ), 1, x, 1 )
                          k = stdlib_i${ri}$amax( j1-1, x, 1 )
                          xmax = abs( x( k ) )
                       end if
                    else
                       ! meet 2 by 2 diagonal block
                       ! call 2 by 2 linear system solve, to take
                       ! care of possible overflow by scaling factor.
                       d( 1, 1 ) = x( j1 )
                       d( 2, 1 ) = x( j2 )
                       call stdlib_${ri}$laln2( .false., 2, 1, smin, one, t( j1, j1 ),ldt, one, one, d,&
                                  2, zero, zero, v, 2,scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 2
                       if( scaloc/=one ) then
                          call stdlib_${ri}$scal( n, scaloc, x, 1 )
                          scale = scale*scaloc
                       end if
                       x( j1 ) = v( 1, 1 )
                       x( j2 ) = v( 2, 1 )
                       ! scale v(1,1) (= x(j1)) and/or v(2,1) (=x(j2))
                       ! to avoid overflow in updating right-hand side.
                       xj = max( abs( v( 1, 1 ) ), abs( v( 2, 1 ) ) )
                       if( xj>one ) then
                          rec = one / xj
                          if( max( work( j1 ), work( j2 ) )>( bignum-xmax )*rec ) then
                             call stdlib_${ri}$scal( n, rec, x, 1 )
                             scale = scale*rec
                          end if
                       end if
                       ! update right-hand side
                       if( j1>1 ) then
                          call stdlib_${ri}$axpy( j1-1, -x( j1 ), t( 1, j1 ), 1, x, 1 )
                          call stdlib_${ri}$axpy( j1-1, -x( j2 ), t( 1, j2 ), 1, x, 1 )
                          k = stdlib_i${ri}$amax( j1-1, x, 1 )
                          xmax = abs( x( k ) )
                       end if
                    end if
                 end do loop_30
              else
                 ! solve t**t*p = scale*c
                 jnext = 1
                 loop_40: do j = 1, n
                    if( j<jnext )cycle loop_40
                    j1 = j
                    j2 = j
                    jnext = j + 1
                    if( j<n ) then
                       if( t( j+1, j )/=zero ) then
                          j2 = j + 1
                          jnext = j + 2
                       end if
                    end if
                    if( j1==j2 ) then
                       ! 1 by 1 diagonal block
                       ! scale if necessary to avoid overflow in forming the
                       ! right-hand side element by inner product.
                       xj = abs( x( j1 ) )
                       if( xmax>one ) then
                          rec = one / xmax
                          if( work( j1 )>( bignum-xj )*rec ) then
                             call stdlib_${ri}$scal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       x( j1 ) = x( j1 ) - stdlib_${ri}$dot( j1-1, t( 1, j1 ), 1, x, 1 )
                       xj = abs( x( j1 ) )
                       tjj = abs( t( j1, j1 ) )
                       tmp = t( j1, j1 )
                       if( tjj<smin ) then
                          tmp = smin
                          tjj = smin
                          info = 1
                       end if
                       if( tjj<one ) then
                          if( xj>bignum*tjj ) then
                             rec = one / xj
                             call stdlib_${ri}$scal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       x( j1 ) = x( j1 ) / tmp
                       xmax = max( xmax, abs( x( j1 ) ) )
                    else
                       ! 2 by 2 diagonal block
                       ! scale if necessary to avoid overflow in forming the
                       ! right-hand side elements by inner product.
                       xj = max( abs( x( j1 ) ), abs( x( j2 ) ) )
                       if( xmax>one ) then
                          rec = one / xmax
                          if( max( work( j2 ), work( j1 ) )>( bignum-xj )*rec ) then
                             call stdlib_${ri}$scal( n, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       d( 1, 1 ) = x( j1 ) - stdlib_${ri}$dot( j1-1, t( 1, j1 ), 1, x,1 )
                       d( 2, 1 ) = x( j2 ) - stdlib_${ri}$dot( j1-1, t( 1, j2 ), 1, x,1 )
                       call stdlib_${ri}$laln2( .true., 2, 1, smin, one, t( j1, j1 ),ldt, one, one, d, &
                                 2, zero, zero, v, 2,scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 2
                       if( scaloc/=one ) then
                          call stdlib_${ri}$scal( n, scaloc, x, 1 )
                          scale = scale*scaloc
                       end if
                       x( j1 ) = v( 1, 1 )
                       x( j2 ) = v( 2, 1 )
                       xmax = max( abs( x( j1 ) ), abs( x( j2 ) ), xmax )
                    end if
                 end do loop_40
              end if
           else
              sminw = max( eps*abs( w ), smin )
              if( notran ) then
                 ! solve (t + ib)*(p+iq) = c+id
                 jnext = n
                 loop_70: do j = n, 1, -1
                    if( j>jnext )cycle loop_70
                    j1 = j
                    j2 = j
                    jnext = j - 1
                    if( j>1 ) then
                       if( t( j, j-1 )/=zero ) then
                          j1 = j - 1
                          jnext = j - 2
                       end if
                    end if
                    if( j1==j2 ) then
                       ! 1 by 1 diagonal block
                       ! scale if necessary to avoid overflow in division
                       z = w
                       if( j1==1 )z = b( 1 )
                       xj = abs( x( j1 ) ) + abs( x( n+j1 ) )
                       tjj = abs( t( j1, j1 ) ) + abs( z )
                       tmp = t( j1, j1 )
                       if( tjj<sminw ) then
                          tmp = sminw
                          tjj = sminw
                          info = 1
                       end if
                       if( xj==zero )cycle loop_70
                       if( tjj<one ) then
                          if( xj>bignum*tjj ) then
                             rec = one / xj
                             call stdlib_${ri}$scal( n2, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       call stdlib_${ri}$ladiv( x( j1 ), x( n+j1 ), tmp, z, sr, si )
                       x( j1 ) = sr
                       x( n+j1 ) = si
                       xj = abs( x( j1 ) ) + abs( x( n+j1 ) )
                       ! scale x if necessary to avoid overflow when adding a
                       ! multiple of column j1 of t.
                       if( xj>one ) then
                          rec = one / xj
                          if( work( j1 )>( bignum-xmax )*rec ) then
                             call stdlib_${ri}$scal( n2, rec, x, 1 )
                             scale = scale*rec
                          end if
                       end if
                       if( j1>1 ) then
                          call stdlib_${ri}$axpy( j1-1, -x( j1 ), t( 1, j1 ), 1, x, 1 )
                          call stdlib_${ri}$axpy( j1-1, -x( n+j1 ), t( 1, j1 ), 1,x( n+1 ), 1 )
                          x( 1 ) = x( 1 ) + b( j1 )*x( n+j1 )
                          x( n+1 ) = x( n+1 ) - b( j1 )*x( j1 )
                          xmax = zero
                          do k = 1, j1 - 1
                             xmax = max( xmax, abs( x( k ) )+abs( x( k+n ) ) )
                          end do
                       end if
                    else
                       ! meet 2 by 2 diagonal block
                       d( 1, 1 ) = x( j1 )
                       d( 2, 1 ) = x( j2 )
                       d( 1, 2 ) = x( n+j1 )
                       d( 2, 2 ) = x( n+j2 )
                       call stdlib_${ri}$laln2( .false., 2, 2, sminw, one, t( j1, j1 ),ldt, one, one, &
                                 d, 2, zero, -w, v, 2,scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 2
                       if( scaloc/=one ) then
                          call stdlib_${ri}$scal( 2*n, scaloc, x, 1 )
                          scale = scaloc*scale
                       end if
                       x( j1 ) = v( 1, 1 )
                       x( j2 ) = v( 2, 1 )
                       x( n+j1 ) = v( 1, 2 )
                       x( n+j2 ) = v( 2, 2 )
                       ! scale x(j1), .... to avoid overflow in
                       ! updating right hand side.
                       xj = max( abs( v( 1, 1 ) )+abs( v( 1, 2 ) ),abs( v( 2, 1 ) )+abs( v( 2, 2 )&
                                  ) )
                       if( xj>one ) then
                          rec = one / xj
                          if( max( work( j1 ), work( j2 ) )>( bignum-xmax )*rec ) then
                             call stdlib_${ri}$scal( n2, rec, x, 1 )
                             scale = scale*rec
                          end if
                       end if
                       ! update the right-hand side.
                       if( j1>1 ) then
                          call stdlib_${ri}$axpy( j1-1, -x( j1 ), t( 1, j1 ), 1, x, 1 )
                          call stdlib_${ri}$axpy( j1-1, -x( j2 ), t( 1, j2 ), 1, x, 1 )
                          call stdlib_${ri}$axpy( j1-1, -x( n+j1 ), t( 1, j1 ), 1,x( n+1 ), 1 )
                          call stdlib_${ri}$axpy( j1-1, -x( n+j2 ), t( 1, j2 ), 1,x( n+1 ), 1 )
                          x( 1 ) = x( 1 ) + b( j1 )*x( n+j1 ) +b( j2 )*x( n+j2 )
                          x( n+1 ) = x( n+1 ) - b( j1 )*x( j1 ) -b( j2 )*x( j2 )
                          xmax = zero
                          do k = 1, j1 - 1
                             xmax = max( abs( x( k ) )+abs( x( k+n ) ),xmax )
                          end do
                       end if
                    end if
                 end do loop_70
              else
                 ! solve (t + ib)**t*(p+iq) = c+id
                 jnext = 1
                 loop_80: do j = 1, n
                    if( j<jnext )cycle loop_80
                    j1 = j
                    j2 = j
                    jnext = j + 1
                    if( j<n ) then
                       if( t( j+1, j )/=zero ) then
                          j2 = j + 1
                          jnext = j + 2
                       end if
                    end if
                    if( j1==j2 ) then
                       ! 1 by 1 diagonal block
                       ! scale if necessary to avoid overflow in forming the
                       ! right-hand side element by inner product.
                       xj = abs( x( j1 ) ) + abs( x( j1+n ) )
                       if( xmax>one ) then
                          rec = one / xmax
                          if( work( j1 )>( bignum-xj )*rec ) then
                             call stdlib_${ri}$scal( n2, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       x( j1 ) = x( j1 ) - stdlib_${ri}$dot( j1-1, t( 1, j1 ), 1, x, 1 )
                       x( n+j1 ) = x( n+j1 ) - stdlib_${ri}$dot( j1-1, t( 1, j1 ), 1,x( n+1 ), 1 )
                                 
                       if( j1>1 ) then
                          x( j1 ) = x( j1 ) - b( j1 )*x( n+1 )
                          x( n+j1 ) = x( n+j1 ) + b( j1 )*x( 1 )
                       end if
                       xj = abs( x( j1 ) ) + abs( x( j1+n ) )
                       z = w
                       if( j1==1 )z = b( 1 )
                       ! scale if necessary to avoid overflow in
                       ! complex division
                       tjj = abs( t( j1, j1 ) ) + abs( z )
                       tmp = t( j1, j1 )
                       if( tjj<sminw ) then
                          tmp = sminw
                          tjj = sminw
                          info = 1
                       end if
                       if( tjj<one ) then
                          if( xj>bignum*tjj ) then
                             rec = one / xj
                             call stdlib_${ri}$scal( n2, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       call stdlib_${ri}$ladiv( x( j1 ), x( n+j1 ), tmp, -z, sr, si )
                       x( j1 ) = sr
                       x( j1+n ) = si
                       xmax = max( abs( x( j1 ) )+abs( x( j1+n ) ), xmax )
                    else
                       ! 2 by 2 diagonal block
                       ! scale if necessary to avoid overflow in forming the
                       ! right-hand side element by inner product.
                       xj = max( abs( x( j1 ) )+abs( x( n+j1 ) ),abs( x( j2 ) )+abs( x( n+j2 ) ) )
                                 
                       if( xmax>one ) then
                          rec = one / xmax
                          if( max( work( j1 ), work( j2 ) )>( bignum-xj ) / xmax ) then
                             call stdlib_${ri}$scal( n2, rec, x, 1 )
                             scale = scale*rec
                             xmax = xmax*rec
                          end if
                       end if
                       d( 1, 1 ) = x( j1 ) - stdlib_${ri}$dot( j1-1, t( 1, j1 ), 1, x,1 )
                       d( 2, 1 ) = x( j2 ) - stdlib_${ri}$dot( j1-1, t( 1, j2 ), 1, x,1 )
                       d( 1, 2 ) = x( n+j1 ) - stdlib_${ri}$dot( j1-1, t( 1, j1 ), 1,x( n+1 ), 1 )
                                 
                       d( 2, 2 ) = x( n+j2 ) - stdlib_${ri}$dot( j1-1, t( 1, j2 ), 1,x( n+1 ), 1 )
                                 
                       d( 1, 1 ) = d( 1, 1 ) - b( j1 )*x( n+1 )
                       d( 2, 1 ) = d( 2, 1 ) - b( j2 )*x( n+1 )
                       d( 1, 2 ) = d( 1, 2 ) + b( j1 )*x( 1 )
                       d( 2, 2 ) = d( 2, 2 ) + b( j2 )*x( 1 )
                       call stdlib_${ri}$laln2( .true., 2, 2, sminw, one, t( j1, j1 ),ldt, one, one, d,&
                                  2, zero, w, v, 2,scaloc, xnorm, ierr )
                       if( ierr/=0 )info = 2
                       if( scaloc/=one ) then
                          call stdlib_${ri}$scal( n2, scaloc, x, 1 )
                          scale = scaloc*scale
                       end if
                       x( j1 ) = v( 1, 1 )
                       x( j2 ) = v( 2, 1 )
                       x( n+j1 ) = v( 1, 2 )
                       x( n+j2 ) = v( 2, 2 )
                       xmax = max( abs( x( j1 ) )+abs( x( n+j1 ) ),abs( x( j2 ) )+abs( x( n+j2 ) )&
                                 , xmax )
                    end if
                 end do loop_80
              end if
           end if
           return
     end subroutine stdlib_${ri}$laqtr

#:endif
#:endfor



     module subroutine stdlib_shseqr( job, compz, n, ilo, ihi, h, ldh, wr, wi, z,ldz, work, lwork, info )
     !! SHSEQR computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**T, where T is an upper quasi-triangular matrix (the
     !! Schur form), and Z is the orthogonal matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input orthogonal
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           character, intent(in) :: compz, job
           ! Array Arguments 
           real(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(sp), intent(out) :: wi(*), work(*), wr(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: nl = 49
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_slahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== nl allocates some local workspace to help small matrices
           ! .    through a rare stdlib_slahqr failure.  nl > ntiny = 15 is
           ! .    required and nl <= nmin = stdlib_ilaenv(ispec=12,...) is recom-
           ! .    mended.  (the default value of nmin is 75.)  using nl = 49
           ! .    allows up to six simultaneous shifts and a 16-by-16
           ! .    deflation window.  ====
           
           
           ! Local Arrays 
           real(sp) :: hl(nl,nl), workl(nl)
           ! Local Scalars 
           integer(ilp) :: i, kbot, nmin
           logical(lk) :: initz, lquery, wantt, wantz
           ! Intrinsic Functions 
           ! Executable Statements 
           ! ==== decode and check the input parameters. ====
           wantt = stdlib_lsame( job, 'S' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           work( 1 ) = real( max( 1, n ),KIND=sp)
           lquery = lwork==-1
           info = 0
           if( .not.stdlib_lsame( job, 'E' ) .and. .not.wantt ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( ldh<max( 1, n ) ) then
              info = -7
           else if( ldz<1 .or. ( wantz .and. ldz<max( 1, n ) ) ) then
              info = -11
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -13
           end if
           if( info/=0 ) then
              ! ==== quick return in case of invalid argument. ====
              call stdlib_xerbla( 'SHSEQR', -info )
              return
           else if( n==0 ) then
              ! ==== quick return in case n = 0; nothing to do. ====
              return
           else if( lquery ) then
              ! ==== quick return in case of a workspace query ====
              call stdlib_slaqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, ilo,ihi, z, ldz, &
                        work, lwork, info )
              ! ==== ensure reported workspace size is backward-compatible with
              ! .    previous lapack versions. ====
              work( 1 ) = max( real( max( 1, n ),KIND=sp), work( 1 ) )
              return
           else
              ! ==== copy eigenvalues isolated by stdlib_sgebal ====
              do i = 1, ilo - 1
                 wr( i ) = h( i, i )
                 wi( i ) = zero
              end do
              do i = ihi + 1, n
                 wr( i ) = h( i, i )
                 wi( i ) = zero
              end do
              ! ==== initialize z, if requested ====
              if( initz )call stdlib_slaset( 'A', n, n, zero, one, z, ldz )
              ! ==== quick return if possible ====
              if( ilo==ihi ) then
                 wr( ilo ) = h( ilo, ilo )
                 wi( ilo ) = zero
                 return
              end if
              ! ==== stdlib_slahqr/stdlib_slaqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'SHSEQR', job( : 1 ) // compz( : 1 ), n,ilo, ihi, lwork )
                        
              nmin = max( ntiny, nmin )
              ! ==== stdlib_slaqr0 for big matrices; stdlib_slahqr for small ones ====
              if( n>nmin ) then
                 call stdlib_slaqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, ilo,ihi, z, ldz, &
                           work, lwork, info )
              else
                 ! ==== small matrix ====
                 call stdlib_slahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, ilo,ihi, z, ldz, &
                           info )
                 if( info>0 ) then
                    ! ==== a rare stdlib_slahqr failure!  stdlib_slaqr0 sometimes succeeds
                    ! .    when stdlib_slahqr fails. ====
                    kbot = info
                    if( n>=nl ) then
                       ! ==== larger matrices have enough subdiagonal scratch
                       ! .    space to call stdlib_slaqr0 directly. ====
                       call stdlib_slaqr0( wantt, wantz, n, ilo, kbot, h, ldh, wr,wi, ilo, ihi, z,&
                                  ldz, work, lwork, info )
                    else
                       ! ==== tiny matrices don't have enough subdiagonal
                       ! .    scratch space to benefit from stdlib_slaqr0.  hence,
                       ! .    tiny matrices must be copied into a larger
                       ! .    array before calling stdlib_slaqr0. ====
                       call stdlib_slacpy( 'A', n, n, h, ldh, hl, nl )
                       hl( n+1, n ) = zero
                       call stdlib_slaset( 'A', nl, nl-n, zero, zero, hl( 1, n+1 ),nl )
                       call stdlib_slaqr0( wantt, wantz, nl, ilo, kbot, hl, nl, wr,wi, ilo, ihi, &
                                 z, ldz, workl, nl, info )
                       if( wantt .or. info/=0 )call stdlib_slacpy( 'A', n, n, hl, nl, h, ldh )
                                 
                    end if
                 end if
              end if
              ! ==== clear out the trash, if necessary. ====
              if( ( wantt .or. info/=0 ) .and. n>2 )call stdlib_slaset( 'L', n-2, n-2, zero, zero,&
                         h( 3, 1 ), ldh )
              ! ==== ensure reported workspace size is backward-compatible with
              ! .    previous lapack versions. ====
              work( 1 ) = max( real( max( 1, n ),KIND=sp), work( 1 ) )
           end if
     end subroutine stdlib_shseqr

     module subroutine stdlib_dhseqr( job, compz, n, ilo, ihi, h, ldh, wr, wi, z,ldz, work, lwork, info )
     !! DHSEQR computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**T, where T is an upper quasi-triangular matrix (the
     !! Schur form), and Z is the orthogonal matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input orthogonal
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           character, intent(in) :: compz, job
           ! Array Arguments 
           real(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(dp), intent(out) :: wi(*), work(*), wr(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: nl = 49
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_dlahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== nl allocates some local workspace to help small matrices
           ! .    through a rare stdlib_dlahqr failure.  nl > ntiny = 15 is
           ! .    required and nl <= nmin = stdlib_ilaenv(ispec=12,...) is recom-
           ! .    mended.  (the default value of nmin is 75.)  using nl = 49
           ! .    allows up to six simultaneous shifts and a 16-by-16
           ! .    deflation window.  ====
           
           
           ! Local Arrays 
           real(dp) :: hl(nl,nl), workl(nl)
           ! Local Scalars 
           integer(ilp) :: i, kbot, nmin
           logical(lk) :: initz, lquery, wantt, wantz
           ! Intrinsic Functions 
           ! Executable Statements 
           ! ==== decode and check the input parameters. ====
           wantt = stdlib_lsame( job, 'S' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           work( 1 ) = real( max( 1, n ),KIND=dp)
           lquery = lwork==-1
           info = 0
           if( .not.stdlib_lsame( job, 'E' ) .and. .not.wantt ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( ldh<max( 1, n ) ) then
              info = -7
           else if( ldz<1 .or. ( wantz .and. ldz<max( 1, n ) ) ) then
              info = -11
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -13
           end if
           if( info/=0 ) then
              ! ==== quick return in case of invalid argument. ====
              call stdlib_xerbla( 'DHSEQR', -info )
              return
           else if( n==0 ) then
              ! ==== quick return in case n = 0; nothing to do. ====
              return
           else if( lquery ) then
              ! ==== quick return in case of a workspace query ====
              call stdlib_dlaqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, ilo,ihi, z, ldz, &
                        work, lwork, info )
              ! ==== ensure reported workspace size is backward-compatible with
              ! .    previous lapack versions. ====
              work( 1 ) = max( real( max( 1, n ),KIND=dp), work( 1 ) )
              return
           else
              ! ==== copy eigenvalues isolated by stdlib_dgebal ====
              do i = 1, ilo - 1
                 wr( i ) = h( i, i )
                 wi( i ) = zero
              end do
              do i = ihi + 1, n
                 wr( i ) = h( i, i )
                 wi( i ) = zero
              end do
              ! ==== initialize z, if requested ====
              if( initz )call stdlib_dlaset( 'A', n, n, zero, one, z, ldz )
              ! ==== quick return if possible ====
              if( ilo==ihi ) then
                 wr( ilo ) = h( ilo, ilo )
                 wi( ilo ) = zero
                 return
              end if
              ! ==== stdlib_dlahqr/stdlib_dlaqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'DHSEQR', job( : 1 ) // compz( : 1 ), n,ilo, ihi, lwork )
                        
              nmin = max( ntiny, nmin )
              ! ==== stdlib_dlaqr0 for big matrices; stdlib_dlahqr for small ones ====
              if( n>nmin ) then
                 call stdlib_dlaqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, ilo,ihi, z, ldz, &
                           work, lwork, info )
              else
                 ! ==== small matrix ====
                 call stdlib_dlahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, ilo,ihi, z, ldz, &
                           info )
                 if( info>0 ) then
                    ! ==== a rare stdlib_dlahqr failure!  stdlib_dlaqr0 sometimes succeeds
                    ! .    when stdlib_dlahqr fails. ====
                    kbot = info
                    if( n>=nl ) then
                       ! ==== larger matrices have enough subdiagonal scratch
                       ! .    space to call stdlib_dlaqr0 directly. ====
                       call stdlib_dlaqr0( wantt, wantz, n, ilo, kbot, h, ldh, wr,wi, ilo, ihi, z,&
                                  ldz, work, lwork, info )
                    else
                       ! ==== tiny matrices don't have enough subdiagonal
                       ! .    scratch space to benefit from stdlib_dlaqr0.  hence,
                       ! .    tiny matrices must be copied into a larger
                       ! .    array before calling stdlib_dlaqr0. ====
                       call stdlib_dlacpy( 'A', n, n, h, ldh, hl, nl )
                       hl( n+1, n ) = zero
                       call stdlib_dlaset( 'A', nl, nl-n, zero, zero, hl( 1, n+1 ),nl )
                       call stdlib_dlaqr0( wantt, wantz, nl, ilo, kbot, hl, nl, wr,wi, ilo, ihi, &
                                 z, ldz, workl, nl, info )
                       if( wantt .or. info/=0 )call stdlib_dlacpy( 'A', n, n, hl, nl, h, ldh )
                                 
                    end if
                 end if
              end if
              ! ==== clear out the trash, if necessary. ====
              if( ( wantt .or. info/=0 ) .and. n>2 )call stdlib_dlaset( 'L', n-2, n-2, zero, zero,&
                         h( 3, 1 ), ldh )
              ! ==== ensure reported workspace size is backward-compatible with
              ! .    previous lapack versions. ====
              work( 1 ) = max( real( max( 1, n ),KIND=dp), work( 1 ) )
           end if
     end subroutine stdlib_dhseqr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$hseqr( job, compz, n, ilo, ihi, h, ldh, wr, wi, z,ldz, work, lwork, info )
     !! DHSEQR: computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**T, where T is an upper quasi-triangular matrix (the
     !! Schur form), and Z is the orthogonal matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input orthogonal
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           character, intent(in) :: compz, job
           ! Array Arguments 
           real(${rk}$), intent(inout) :: h(ldh,*), z(ldz,*)
           real(${rk}$), intent(out) :: wi(*), work(*), wr(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: nl = 49
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_${ri}$lahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== nl allocates some local workspace to help small matrices
           ! .    through a rare stdlib_${ri}$lahqr failure.  nl > ntiny = 15 is
           ! .    required and nl <= nmin = stdlib_ilaenv(ispec=12,...) is recom-
           ! .    mended.  (the default value of nmin is 75.)  using nl = 49
           ! .    allows up to six simultaneous shifts and a 16-by-16
           ! .    deflation window.  ====
           
           
           ! Local Arrays 
           real(${rk}$) :: hl(nl,nl), workl(nl)
           ! Local Scalars 
           integer(ilp) :: i, kbot, nmin
           logical(lk) :: initz, lquery, wantt, wantz
           ! Intrinsic Functions 
           ! Executable Statements 
           ! ==== decode and check the input parameters. ====
           wantt = stdlib_lsame( job, 'S' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           work( 1 ) = real( max( 1, n ),KIND=${rk}$)
           lquery = lwork==-1
           info = 0
           if( .not.stdlib_lsame( job, 'E' ) .and. .not.wantt ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( ldh<max( 1, n ) ) then
              info = -7
           else if( ldz<1 .or. ( wantz .and. ldz<max( 1, n ) ) ) then
              info = -11
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -13
           end if
           if( info/=0 ) then
              ! ==== quick return in case of invalid argument. ====
              call stdlib_xerbla( 'DHSEQR', -info )
              return
           else if( n==0 ) then
              ! ==== quick return in case n = 0; nothing to do. ====
              return
           else if( lquery ) then
              ! ==== quick return in case of a workspace query ====
              call stdlib_${ri}$laqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, ilo,ihi, z, ldz, &
                        work, lwork, info )
              ! ==== ensure reported workspace size is backward-compatible with
              ! .    previous lapack versions. ====
              work( 1 ) = max( real( max( 1, n ),KIND=${rk}$), work( 1 ) )
              return
           else
              ! ==== copy eigenvalues isolated by stdlib_${ri}$gebal ====
              do i = 1, ilo - 1
                 wr( i ) = h( i, i )
                 wi( i ) = zero
              end do
              do i = ihi + 1, n
                 wr( i ) = h( i, i )
                 wi( i ) = zero
              end do
              ! ==== initialize z, if requested ====
              if( initz )call stdlib_${ri}$laset( 'A', n, n, zero, one, z, ldz )
              ! ==== quick return if possible ====
              if( ilo==ihi ) then
                 wr( ilo ) = h( ilo, ilo )
                 wi( ilo ) = zero
                 return
              end if
              ! ==== stdlib_${ri}$lahqr/stdlib_${ri}$laqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'DHSEQR', job( : 1 ) // compz( : 1 ), n,ilo, ihi, lwork )
                        
              nmin = max( ntiny, nmin )
              ! ==== stdlib_${ri}$laqr0 for big matrices; stdlib_${ri}$lahqr for small ones ====
              if( n>nmin ) then
                 call stdlib_${ri}$laqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, ilo,ihi, z, ldz, &
                           work, lwork, info )
              else
                 ! ==== small matrix ====
                 call stdlib_${ri}$lahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi, ilo,ihi, z, ldz, &
                           info )
                 if( info>0 ) then
                    ! ==== a rare stdlib_${ri}$lahqr failure!  stdlib_${ri}$laqr0 sometimes succeeds
                    ! .    when stdlib_${ri}$lahqr fails. ====
                    kbot = info
                    if( n>=nl ) then
                       ! ==== larger matrices have enough subdiagonal scratch
                       ! .    space to call stdlib_${ri}$laqr0 directly. ====
                       call stdlib_${ri}$laqr0( wantt, wantz, n, ilo, kbot, h, ldh, wr,wi, ilo, ihi, z,&
                                  ldz, work, lwork, info )
                    else
                       ! ==== tiny matrices don't have enough subdiagonal
                       ! .    scratch space to benefit from stdlib_${ri}$laqr0.  hence,
                       ! .    tiny matrices must be copied into a larger
                       ! .    array before calling stdlib_${ri}$laqr0. ====
                       call stdlib_${ri}$lacpy( 'A', n, n, h, ldh, hl, nl )
                       hl( n+1, n ) = zero
                       call stdlib_${ri}$laset( 'A', nl, nl-n, zero, zero, hl( 1, n+1 ),nl )
                       call stdlib_${ri}$laqr0( wantt, wantz, nl, ilo, kbot, hl, nl, wr,wi, ilo, ihi, &
                                 z, ldz, workl, nl, info )
                       if( wantt .or. info/=0 )call stdlib_${ri}$lacpy( 'A', n, n, hl, nl, h, ldh )
                                 
                    end if
                 end if
              end if
              ! ==== clear out the trash, if necessary. ====
              if( ( wantt .or. info/=0 ) .and. n>2 )call stdlib_${ri}$laset( 'L', n-2, n-2, zero, zero,&
                         h( 3, 1 ), ldh )
              ! ==== ensure reported workspace size is backward-compatible with
              ! .    previous lapack versions. ====
              work( 1 ) = max( real( max( 1, n ),KIND=${rk}$), work( 1 ) )
           end if
     end subroutine stdlib_${ri}$hseqr

#:endif
#:endfor

     module pure subroutine stdlib_chseqr( job, compz, n, ilo, ihi, h, ldh, w, z, ldz,work, lwork, info )
     !! CHSEQR computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**H, where T is an upper triangular matrix (the
     !! Schur form), and Z is the unitary matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input unitary
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*T*(QZ)**H.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           character, intent(in) :: compz, job
           ! Array Arguments 
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: w(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: nl = 49
           real(sp), parameter :: rzero = 0.0_sp
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_clahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== nl allocates some local workspace to help small matrices
           ! .    through a rare stdlib_clahqr failure.  nl > ntiny = 15 is
           ! .    required and nl <= nmin = stdlib_ilaenv(ispec=12,...) is recom-
           ! .    mended.  (the default value of nmin is 75.)  using nl = 49
           ! .    allows up to six simultaneous shifts and a 16-by-16
           ! .    deflation window.  ====
           
           
           
           ! Local Arrays 
           complex(sp) :: hl(nl,nl), workl(nl)
           ! Local Scalars 
           integer(ilp) :: kbot, nmin
           logical(lk) :: initz, lquery, wantt, wantz
           ! Intrinsic Functions 
           ! Executable Statements 
           ! ==== decode and check the input parameters. ====
           wantt = stdlib_lsame( job, 'S' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           work( 1 ) = cmplx( real( max( 1, n ),KIND=sp), rzero,KIND=sp)
           lquery = lwork==-1
           info = 0
           if( .not.stdlib_lsame( job, 'E' ) .and. .not.wantt ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( ldh<max( 1, n ) ) then
              info = -7
           else if( ldz<1 .or. ( wantz .and. ldz<max( 1, n ) ) ) then
              info = -10
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -12
           end if
           if( info/=0 ) then
              ! ==== quick return in case of invalid argument. ====
              call stdlib_xerbla( 'CHSEQR', -info )
              return
           else if( n==0 ) then
              ! ==== quick return in case n = 0; nothing to do. ====
              return
           else if( lquery ) then
              ! ==== quick return in case of a workspace query ====
              call stdlib_claqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, ilo, ihi, z,ldz, work, &
                        lwork, info )
              ! ==== ensure reported workspace size is backward-compatible with
              ! .    previous lapack versions. ====
              work( 1 ) = cmplx( max( real( work( 1 ),KIND=sp), real( max( 1,n ),KIND=sp) ), &
                        rzero,KIND=sp)
              return
           else
              ! ==== copy eigenvalues isolated by stdlib_cgebal ====
              if( ilo>1 )call stdlib_ccopy( ilo-1, h, ldh+1, w, 1 )
              if( ihi<n )call stdlib_ccopy( n-ihi, h( ihi+1, ihi+1 ), ldh+1, w( ihi+1 ), 1 )
                        
              ! ==== initialize z, if requested ====
              if( initz )call stdlib_claset( 'A', n, n, czero, cone, z, ldz )
              ! ==== quick return if possible ====
              if( ilo==ihi ) then
                 w( ilo ) = h( ilo, ilo )
                 return
              end if
              ! ==== stdlib_clahqr/stdlib_claqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'CHSEQR', job( : 1 ) // compz( : 1 ), n,ilo, ihi, lwork )
                        
              nmin = max( ntiny, nmin )
              ! ==== stdlib_claqr0 for big matrices; stdlib_clahqr for small ones ====
              if( n>nmin ) then
                 call stdlib_claqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, ilo, ihi,z, ldz, work, &
                           lwork, info )
              else
                 ! ==== small matrix ====
                 call stdlib_clahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, ilo, ihi,z, ldz, info )
                           
                 if( info>0 ) then
                    ! ==== a rare stdlib_clahqr failure!  stdlib_claqr0 sometimes succeeds
                    ! .    when stdlib_clahqr fails. ====
                    kbot = info
                    if( n>=nl ) then
                       ! ==== larger matrices have enough subdiagonal scratch
                       ! .    space to call stdlib_claqr0 directly. ====
                       call stdlib_claqr0( wantt, wantz, n, ilo, kbot, h, ldh, w,ilo, ihi, z, ldz,&
                                  work, lwork, info )
                    else
                       ! ==== tiny matrices don't have enough subdiagonal
                       ! .    scratch space to benefit from stdlib_claqr0.  hence,
                       ! .    tiny matrices must be copied into a larger
                       ! .    array before calling stdlib_claqr0. ====
                       call stdlib_clacpy( 'A', n, n, h, ldh, hl, nl )
                       hl( n+1, n ) = czero
                       call stdlib_claset( 'A', nl, nl-n, czero, czero, hl( 1, n+1 ),nl )
                       call stdlib_claqr0( wantt, wantz, nl, ilo, kbot, hl, nl, w,ilo, ihi, z, &
                                 ldz, workl, nl, info )
                       if( wantt .or. info/=0 )call stdlib_clacpy( 'A', n, n, hl, nl, h, ldh )
                                 
                    end if
                 end if
              end if
              ! ==== clear out the trash, if necessary. ====
              if( ( wantt .or. info/=0 ) .and. n>2 )call stdlib_claset( 'L', n-2, n-2, czero, &
                        czero, h( 3, 1 ), ldh )
              ! ==== ensure reported workspace size is backward-compatible with
              ! .    previous lapack versions. ====
              work( 1 ) = cmplx( max( real( max( 1, n ),KIND=sp),real( work( 1 ),KIND=sp) ), &
                        rzero,KIND=sp)
           end if
     end subroutine stdlib_chseqr

     module pure subroutine stdlib_zhseqr( job, compz, n, ilo, ihi, h, ldh, w, z, ldz,work, lwork, info )
     !! ZHSEQR computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**H, where T is an upper triangular matrix (the
     !! Schur form), and Z is the unitary matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input unitary
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*T*(QZ)**H.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           character, intent(in) :: compz, job
           ! Array Arguments 
           complex(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(dp), intent(out) :: w(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: nl = 49
           real(dp), parameter :: rzero = 0.0_dp
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_zlahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== nl allocates some local workspace to help small matrices
           ! .    through a rare stdlib_zlahqr failure.  nl > ntiny = 15 is
           ! .    required and nl <= nmin = stdlib_ilaenv(ispec=12,...) is recom-
           ! .    mended.  (the default value of nmin is 75.)  using nl = 49
           ! .    allows up to six simultaneous shifts and a 16-by-16
           ! .    deflation window.  ====
           
           
           
           ! Local Arrays 
           complex(dp) :: hl(nl,nl), workl(nl)
           ! Local Scalars 
           integer(ilp) :: kbot, nmin
           logical(lk) :: initz, lquery, wantt, wantz
           ! Intrinsic Functions 
           ! Executable Statements 
           ! ==== decode and check the input parameters. ====
           wantt = stdlib_lsame( job, 'S' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           work( 1 ) = cmplx( real( max( 1, n ),KIND=dp), rzero,KIND=dp)
           lquery = lwork==-1
           info = 0
           if( .not.stdlib_lsame( job, 'E' ) .and. .not.wantt ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( ldh<max( 1, n ) ) then
              info = -7
           else if( ldz<1 .or. ( wantz .and. ldz<max( 1, n ) ) ) then
              info = -10
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -12
           end if
           if( info/=0 ) then
              ! ==== quick return in case of invalid argument. ====
              call stdlib_xerbla( 'ZHSEQR', -info )
              return
           else if( n==0 ) then
              ! ==== quick return in case n = 0; nothing to do. ====
              return
           else if( lquery ) then
              ! ==== quick return in case of a workspace query ====
              call stdlib_zlaqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, ilo, ihi, z,ldz, work, &
                        lwork, info )
              ! ==== ensure reported workspace size is backward-compatible with
              ! .    previous lapack versions. ====
              work( 1 ) = cmplx( max( real( work( 1 ),KIND=dp), real( max( 1,n ),KIND=dp) ), &
                        rzero,KIND=dp)
              return
           else
              ! ==== copy eigenvalues isolated by stdlib_zgebal ====
              if( ilo>1 )call stdlib_zcopy( ilo-1, h, ldh+1, w, 1 )
              if( ihi<n )call stdlib_zcopy( n-ihi, h( ihi+1, ihi+1 ), ldh+1, w( ihi+1 ), 1 )
                        
              ! ==== initialize z, if requested ====
              if( initz )call stdlib_zlaset( 'A', n, n, czero, cone, z, ldz )
              ! ==== quick return if possible ====
              if( ilo==ihi ) then
                 w( ilo ) = h( ilo, ilo )
                 return
              end if
              ! ==== stdlib_zlahqr/stdlib_zlaqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'ZHSEQR', job( : 1 ) // compz( : 1 ), n,ilo, ihi, lwork )
                        
              nmin = max( ntiny, nmin )
              ! ==== stdlib_zlaqr0 for big matrices; stdlib_zlahqr for small ones ====
              if( n>nmin ) then
                 call stdlib_zlaqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, ilo, ihi,z, ldz, work, &
                           lwork, info )
              else
                 ! ==== small matrix ====
                 call stdlib_zlahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, ilo, ihi,z, ldz, info )
                           
                 if( info>0 ) then
                    ! ==== a rare stdlib_zlahqr failure!  stdlib_zlaqr0 sometimes succeeds
                    ! .    when stdlib_zlahqr fails. ====
                    kbot = info
                    if( n>=nl ) then
                       ! ==== larger matrices have enough subdiagonal scratch
                       ! .    space to call stdlib_zlaqr0 directly. ====
                       call stdlib_zlaqr0( wantt, wantz, n, ilo, kbot, h, ldh, w,ilo, ihi, z, ldz,&
                                  work, lwork, info )
                    else
                       ! ==== tiny matrices don't have enough subdiagonal
                       ! .    scratch space to benefit from stdlib_zlaqr0.  hence,
                       ! .    tiny matrices must be copied into a larger
                       ! .    array before calling stdlib_zlaqr0. ====
                       call stdlib_zlacpy( 'A', n, n, h, ldh, hl, nl )
                       hl( n+1, n ) = czero
                       call stdlib_zlaset( 'A', nl, nl-n, czero, czero, hl( 1, n+1 ),nl )
                       call stdlib_zlaqr0( wantt, wantz, nl, ilo, kbot, hl, nl, w,ilo, ihi, z, &
                                 ldz, workl, nl, info )
                       if( wantt .or. info/=0 )call stdlib_zlacpy( 'A', n, n, hl, nl, h, ldh )
                                 
                    end if
                 end if
              end if
              ! ==== clear out the trash, if necessary. ====
              if( ( wantt .or. info/=0 ) .and. n>2 )call stdlib_zlaset( 'L', n-2, n-2, czero, &
                        czero, h( 3, 1 ), ldh )
              ! ==== ensure reported workspace size is backward-compatible with
              ! .    previous lapack versions. ====
              work( 1 ) = cmplx( max( real( max( 1, n ),KIND=dp),real( work( 1 ),KIND=dp) ), &
                        rzero,KIND=dp)
           end if
     end subroutine stdlib_zhseqr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hseqr( job, compz, n, ilo, ihi, h, ldh, w, z, ldz,work, lwork, info )
     !! ZHSEQR: computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**H, where T is an upper triangular matrix (the
     !! Schur form), and Z is the unitary matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input unitary
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*T*(QZ)**H.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           character, intent(in) :: compz, job
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(${ck}$), intent(out) :: w(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: nl = 49
           real(${ck}$), parameter :: rzero = 0.0_${ck}$
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_${ci}$lahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== nl allocates some local workspace to help small matrices
           ! .    through a rare stdlib_${ci}$lahqr failure.  nl > ntiny = 15 is
           ! .    required and nl <= nmin = stdlib_ilaenv(ispec=12,...) is recom-
           ! .    mended.  (the default value of nmin is 75.)  using nl = 49
           ! .    allows up to six simultaneous shifts and a 16-by-16
           ! .    deflation window.  ====
           
           
           
           ! Local Arrays 
           complex(${ck}$) :: hl(nl,nl), workl(nl)
           ! Local Scalars 
           integer(ilp) :: kbot, nmin
           logical(lk) :: initz, lquery, wantt, wantz
           ! Intrinsic Functions 
           ! Executable Statements 
           ! ==== decode and check the input parameters. ====
           wantt = stdlib_lsame( job, 'S' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           work( 1 ) = cmplx( real( max( 1, n ),KIND=${ck}$), rzero,KIND=${ck}$)
           lquery = lwork==-1
           info = 0
           if( .not.stdlib_lsame( job, 'E' ) .and. .not.wantt ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( ldh<max( 1, n ) ) then
              info = -7
           else if( ldz<1 .or. ( wantz .and. ldz<max( 1, n ) ) ) then
              info = -10
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -12
           end if
           if( info/=0 ) then
              ! ==== quick return in case of invalid argument. ====
              call stdlib_xerbla( 'ZHSEQR', -info )
              return
           else if( n==0 ) then
              ! ==== quick return in case n = 0; nothing to do. ====
              return
           else if( lquery ) then
              ! ==== quick return in case of a workspace query ====
              call stdlib_${ci}$laqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, ilo, ihi, z,ldz, work, &
                        lwork, info )
              ! ==== ensure reported workspace size is backward-compatible with
              ! .    previous lapack versions. ====
              work( 1 ) = cmplx( max( real( work( 1 ),KIND=${ck}$), real( max( 1,n ),KIND=${ck}$) ), &
                        rzero,KIND=${ck}$)
              return
           else
              ! ==== copy eigenvalues isolated by stdlib_${ci}$gebal ====
              if( ilo>1 )call stdlib_${ci}$copy( ilo-1, h, ldh+1, w, 1 )
              if( ihi<n )call stdlib_${ci}$copy( n-ihi, h( ihi+1, ihi+1 ), ldh+1, w( ihi+1 ), 1 )
                        
              ! ==== initialize z, if requested ====
              if( initz )call stdlib_${ci}$laset( 'A', n, n, czero, cone, z, ldz )
              ! ==== quick return if possible ====
              if( ilo==ihi ) then
                 w( ilo ) = h( ilo, ilo )
                 return
              end if
              ! ==== stdlib_${ci}$lahqr/stdlib_${ci}$laqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'ZHSEQR', job( : 1 ) // compz( : 1 ), n,ilo, ihi, lwork )
                        
              nmin = max( ntiny, nmin )
              ! ==== stdlib_${ci}$laqr0 for big matrices; stdlib_${ci}$lahqr for small ones ====
              if( n>nmin ) then
                 call stdlib_${ci}$laqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, ilo, ihi,z, ldz, work, &
                           lwork, info )
              else
                 ! ==== small matrix ====
                 call stdlib_${ci}$lahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, ilo, ihi,z, ldz, info )
                           
                 if( info>0 ) then
                    ! ==== a rare stdlib_${ci}$lahqr failure!  stdlib_${ci}$laqr0 sometimes succeeds
                    ! .    when stdlib_${ci}$lahqr fails. ====
                    kbot = info
                    if( n>=nl ) then
                       ! ==== larger matrices have enough subdiagonal scratch
                       ! .    space to call stdlib_${ci}$laqr0 directly. ====
                       call stdlib_${ci}$laqr0( wantt, wantz, n, ilo, kbot, h, ldh, w,ilo, ihi, z, ldz,&
                                  work, lwork, info )
                    else
                       ! ==== tiny matrices don't have enough subdiagonal
                       ! .    scratch space to benefit from stdlib_${ci}$laqr0.  hence,
                       ! .    tiny matrices must be copied into a larger
                       ! .    array before calling stdlib_${ci}$laqr0. ====
                       call stdlib_${ci}$lacpy( 'A', n, n, h, ldh, hl, nl )
                       hl( n+1, n ) = czero
                       call stdlib_${ci}$laset( 'A', nl, nl-n, czero, czero, hl( 1, n+1 ),nl )
                       call stdlib_${ci}$laqr0( wantt, wantz, nl, ilo, kbot, hl, nl, w,ilo, ihi, z, &
                                 ldz, workl, nl, info )
                       if( wantt .or. info/=0 )call stdlib_${ci}$lacpy( 'A', n, n, hl, nl, h, ldh )
                                 
                    end if
                 end if
              end if
              ! ==== clear out the trash, if necessary. ====
              if( ( wantt .or. info/=0 ) .and. n>2 )call stdlib_${ci}$laset( 'L', n-2, n-2, czero, &
                        czero, h( 3, 1 ), ldh )
              ! ==== ensure reported workspace size is backward-compatible with
              ! .    previous lapack versions. ====
              work( 1 ) = cmplx( max( real( max( 1, n ),KIND=${ck}$),real( work( 1 ),KIND=${ck}$) ), &
                        rzero,KIND=${ck}$)
           end if
     end subroutine stdlib_${ci}$hseqr

#:endif
#:endfor



     module pure subroutine stdlib_slaln2( ltrans, na, nw, smin, ca, a, lda, d1, d2, b,ldb, wr, wi, x, &
     !! SLALN2 solves a system of the form  (ca A - w D ) X = s B
     !! or (ca A**T - w D) X = s B   with possible scaling ("s") and
     !! perturbation of A.  (A**T means A-transpose.)
     !! A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
     !! real diagonal matrix, w is a real or complex value, and X and B are
     !! NA x 1 matrices -- real if w is real, complex if w is complex.  NA
     !! may be 1 or 2.
     !! If w is complex, X and B are represented as NA x 2 matrices,
     !! the first column of each being the real part and the second
     !! being the imaginary part.
     !! "s" is a scaling factor (<= 1), computed by SLALN2, which is
     !! so chosen that X can be computed without overflow.  X is further
     !! scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
     !! than overflow.
     !! If both singular values of (ca A - w D) are less than SMIN,
     !! SMIN*identity will be used instead of (ca A - w D).  If only one
     !! singular value is less than SMIN, one element of (ca A - w D) will be
     !! perturbed enough to make the smallest singular value roughly SMIN.
     !! If both singular values are at least SMIN, (ca A - w D) will not be
     !! perturbed.  In any case, the perturbation will be at most some small
     !! multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
     !! are computed by infinity-norm approximations, and thus will only be
     !! correct to a factor of 2 or so.
     !! Note: all input quantities are assumed to be smaller than overflow
     !! by a reasonable factor.  (See BIGNUM.)
               ldx, scale, xnorm, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: ltrans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldx, na, nw
           real(sp), intent(in) :: ca, d1, d2, smin, wi, wr
           real(sp), intent(out) :: scale, xnorm
           ! Array Arguments 
           real(sp), intent(in) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: x(ldx,*)
       ! =====================================================================
           
           
           ! Local Scalars 
           integer(ilp) :: icmax, j
           real(sp) :: bbnd, bi1, bi2, bignum, bnorm, br1, br2, ci21, ci22, cmax, cnorm, cr21, &
           cr22, csi, csr, li21, lr21, smini, smlnum, temp, u22abs, ui11, ui11r, ui12, ui12s, &
                     ui22, ur11, ur11r, ur12, ur12s, ur22, xi1, xi2, xr1, xr2
           ! Local Arrays 
           logical(lk) :: cswap(4), rswap(4)
           integer(ilp) :: ipivot(4,4)
           real(sp) :: ci(2,2), civ(4), cr(2,2), crv(4)
           ! Intrinsic Functions 
           ! Equivalences 
           equivalence        ( ci( 1, 1 ), civ( 1 ) ),( cr( 1, 1 ), crv( 1 ) )
           ! Data Statements 
           cswap = [.false.,.false.,.true.,.true.]
           rswap = [.false.,.true.,.false.,.true.]
           ipivot = reshape([1,2,3,4,2,1,4,3,3,4,1,2,4,3,2,1],[4,4])
           ! Executable Statements 
           ! compute bignum
           smlnum = two*stdlib_slamch( 'SAFE MINIMUM' )
           bignum = one / smlnum
           smini = max( smin, smlnum )
           ! don't check for input errors
           info = 0
           ! standard initializations
           scale = one
           if( na==1 ) then
              ! 1 x 1  (i.e., scalar) system   c x = b
              if( nw==1 ) then
                 ! real 1x1 system.
                 ! c = ca a - w d
                 csr = ca*a( 1, 1 ) - wr*d1
                 cnorm = abs( csr )
                 ! if | c | < smini, use c = smini
                 if( cnorm<smini ) then
                    csr = smini
                    cnorm = smini
                    info = 1
                 end if
                 ! check scaling for  x = b / c
                 bnorm = abs( b( 1, 1 ) )
                 if( cnorm<one .and. bnorm>one ) then
                    if( bnorm>bignum*cnorm )scale = one / bnorm
                 end if
                 ! compute x
                 x( 1, 1 ) = ( b( 1, 1 )*scale ) / csr
                 xnorm = abs( x( 1, 1 ) )
              else
                 ! complex 1x1 system (w is complex)
                 ! c = ca a - w d
                 csr = ca*a( 1, 1 ) - wr*d1
                 csi = -wi*d1
                 cnorm = abs( csr ) + abs( csi )
                 ! if | c | < smini, use c = smini
                 if( cnorm<smini ) then
                    csr = smini
                    csi = zero
                    cnorm = smini
                    info = 1
                 end if
                 ! check scaling for  x = b / c
                 bnorm = abs( b( 1, 1 ) ) + abs( b( 1, 2 ) )
                 if( cnorm<one .and. bnorm>one ) then
                    if( bnorm>bignum*cnorm )scale = one / bnorm
                 end if
                 ! compute x
                 call stdlib_sladiv( scale*b( 1, 1 ), scale*b( 1, 2 ), csr, csi,x( 1, 1 ), x( 1, &
                           2 ) )
                 xnorm = abs( x( 1, 1 ) ) + abs( x( 1, 2 ) )
              end if
           else
              ! 2x2 system
              ! compute the realpart of  c = ca a - w d  (or  ca a**t - w d,KIND=sp)
              cr( 1, 1 ) = ca*a( 1, 1 ) - wr*d1
              cr( 2, 2 ) = ca*a( 2, 2 ) - wr*d2
              if( ltrans ) then
                 cr( 1, 2 ) = ca*a( 2, 1 )
                 cr( 2, 1 ) = ca*a( 1, 2 )
              else
                 cr( 2, 1 ) = ca*a( 2, 1 )
                 cr( 1, 2 ) = ca*a( 1, 2 )
              end if
              if( nw==1 ) then
                 ! real2x2 system  (w is real,KIND=sp)
                 ! find the largest element in c
                 cmax = zero
                 icmax = 0
                 do j = 1, 4
                    if( abs( crv( j ) )>cmax ) then
                       cmax = abs( crv( j ) )
                       icmax = j
                    end if
                 end do
                 ! if norm(c) < smini, use smini*identity.
                 if( cmax<smini ) then
                    bnorm = max( abs( b( 1, 1 ) ), abs( b( 2, 1 ) ) )
                    if( smini<one .and. bnorm>one ) then
                       if( bnorm>bignum*smini )scale = one / bnorm
                    end if
                    temp = scale / smini
                    x( 1, 1 ) = temp*b( 1, 1 )
                    x( 2, 1 ) = temp*b( 2, 1 )
                    xnorm = temp*bnorm
                    info = 1
                    return
                 end if
                 ! gaussian elimination with complete pivoting.
                 ur11 = crv( icmax )
                 cr21 = crv( ipivot( 2, icmax ) )
                 ur12 = crv( ipivot( 3, icmax ) )
                 cr22 = crv( ipivot( 4, icmax ) )
                 ur11r = one / ur11
                 lr21 = ur11r*cr21
                 ur22 = cr22 - ur12*lr21
                 ! if smaller pivot < smini, use smini
                 if( abs( ur22 )<smini ) then
                    ur22 = smini
                    info = 1
                 end if
                 if( rswap( icmax ) ) then
                    br1 = b( 2, 1 )
                    br2 = b( 1, 1 )
                 else
                    br1 = b( 1, 1 )
                    br2 = b( 2, 1 )
                 end if
                 br2 = br2 - lr21*br1
                 bbnd = max( abs( br1*( ur22*ur11r ) ), abs( br2 ) )
                 if( bbnd>one .and. abs( ur22 )<one ) then
                    if( bbnd>=bignum*abs( ur22 ) )scale = one / bbnd
                 end if
                 xr2 = ( br2*scale ) / ur22
                 xr1 = ( scale*br1 )*ur11r - xr2*( ur11r*ur12 )
                 if( cswap( icmax ) ) then
                    x( 1, 1 ) = xr2
                    x( 2, 1 ) = xr1
                 else
                    x( 1, 1 ) = xr1
                    x( 2, 1 ) = xr2
                 end if
                 xnorm = max( abs( xr1 ), abs( xr2 ) )
                 ! further scaling if  norm(a) norm(x) > overflow
                 if( xnorm>one .and. cmax>one ) then
                    if( xnorm>bignum / cmax ) then
                       temp = cmax / bignum
                       x( 1, 1 ) = temp*x( 1, 1 )
                       x( 2, 1 ) = temp*x( 2, 1 )
                       xnorm = temp*xnorm
                       scale = temp*scale
                    end if
                 end if
              else
                 ! complex 2x2 system  (w is complex)
                 ! find the largest element in c
                 ci( 1, 1 ) = -wi*d1
                 ci( 2, 1 ) = zero
                 ci( 1, 2 ) = zero
                 ci( 2, 2 ) = -wi*d2
                 cmax = zero
                 icmax = 0
                 do j = 1, 4
                    if( abs( crv( j ) )+abs( civ( j ) )>cmax ) then
                       cmax = abs( crv( j ) ) + abs( civ( j ) )
                       icmax = j
                    end if
                 end do
                 ! if norm(c) < smini, use smini*identity.
                 if( cmax<smini ) then
                    bnorm = max( abs( b( 1, 1 ) )+abs( b( 1, 2 ) ),abs( b( 2, 1 ) )+abs( b( 2, 2 )&
                               ) )
                    if( smini<one .and. bnorm>one ) then
                       if( bnorm>bignum*smini )scale = one / bnorm
                    end if
                    temp = scale / smini
                    x( 1, 1 ) = temp*b( 1, 1 )
                    x( 2, 1 ) = temp*b( 2, 1 )
                    x( 1, 2 ) = temp*b( 1, 2 )
                    x( 2, 2 ) = temp*b( 2, 2 )
                    xnorm = temp*bnorm
                    info = 1
                    return
                 end if
                 ! gaussian elimination with complete pivoting.
                 ur11 = crv( icmax )
                 ui11 = civ( icmax )
                 cr21 = crv( ipivot( 2, icmax ) )
                 ci21 = civ( ipivot( 2, icmax ) )
                 ur12 = crv( ipivot( 3, icmax ) )
                 ui12 = civ( ipivot( 3, icmax ) )
                 cr22 = crv( ipivot( 4, icmax ) )
                 ci22 = civ( ipivot( 4, icmax ) )
                 if( icmax==1 .or. icmax==4 ) then
                    ! code when off-diagonals of pivoted c are real
                    if( abs( ur11 )>abs( ui11 ) ) then
                       temp = ui11 / ur11
                       ur11r = one / ( ur11*( one+temp**2 ) )
                       ui11r = -temp*ur11r
                    else
                       temp = ur11 / ui11
                       ui11r = -one / ( ui11*( one+temp**2 ) )
                       ur11r = -temp*ui11r
                    end if
                    lr21 = cr21*ur11r
                    li21 = cr21*ui11r
                    ur12s = ur12*ur11r
                    ui12s = ur12*ui11r
                    ur22 = cr22 - ur12*lr21
                    ui22 = ci22 - ur12*li21
                 else
                    ! code when diagonals of pivoted c are real
                    ur11r = one / ur11
                    ui11r = zero
                    lr21 = cr21*ur11r
                    li21 = ci21*ur11r
                    ur12s = ur12*ur11r
                    ui12s = ui12*ur11r
                    ur22 = cr22 - ur12*lr21 + ui12*li21
                    ui22 = -ur12*li21 - ui12*lr21
                 end if
                 u22abs = abs( ur22 ) + abs( ui22 )
                 ! if smaller pivot < smini, use smini
                 if( u22abs<smini ) then
                    ur22 = smini
                    ui22 = zero
                    info = 1
                 end if
                 if( rswap( icmax ) ) then
                    br2 = b( 1, 1 )
                    br1 = b( 2, 1 )
                    bi2 = b( 1, 2 )
                    bi1 = b( 2, 2 )
                 else
                    br1 = b( 1, 1 )
                    br2 = b( 2, 1 )
                    bi1 = b( 1, 2 )
                    bi2 = b( 2, 2 )
                 end if
                 br2 = br2 - lr21*br1 + li21*bi1
                 bi2 = bi2 - li21*br1 - lr21*bi1
                 bbnd = max( ( abs( br1 )+abs( bi1 ) )*( u22abs*( abs( ur11r )+abs( ui11r ) ) ),&
                           abs( br2 )+abs( bi2 ) )
                 if( bbnd>one .and. u22abs<one ) then
                    if( bbnd>=bignum*u22abs ) then
                       scale = one / bbnd
                       br1 = scale*br1
                       bi1 = scale*bi1
                       br2 = scale*br2
                       bi2 = scale*bi2
                    end if
                 end if
                 call stdlib_sladiv( br2, bi2, ur22, ui22, xr2, xi2 )
                 xr1 = ur11r*br1 - ui11r*bi1 - ur12s*xr2 + ui12s*xi2
                 xi1 = ui11r*br1 + ur11r*bi1 - ui12s*xr2 - ur12s*xi2
                 if( cswap( icmax ) ) then
                    x( 1, 1 ) = xr2
                    x( 2, 1 ) = xr1
                    x( 1, 2 ) = xi2
                    x( 2, 2 ) = xi1
                 else
                    x( 1, 1 ) = xr1
                    x( 2, 1 ) = xr2
                    x( 1, 2 ) = xi1
                    x( 2, 2 ) = xi2
                 end if
                 xnorm = max( abs( xr1 )+abs( xi1 ), abs( xr2 )+abs( xi2 ) )
                 ! further scaling if  norm(a) norm(x) > overflow
                 if( xnorm>one .and. cmax>one ) then
                    if( xnorm>bignum / cmax ) then
                       temp = cmax / bignum
                       x( 1, 1 ) = temp*x( 1, 1 )
                       x( 2, 1 ) = temp*x( 2, 1 )
                       x( 1, 2 ) = temp*x( 1, 2 )
                       x( 2, 2 ) = temp*x( 2, 2 )
                       xnorm = temp*xnorm
                       scale = temp*scale
                    end if
                 end if
              end if
           end if
           return
     end subroutine stdlib_slaln2

     module pure subroutine stdlib_dlaln2( ltrans, na, nw, smin, ca, a, lda, d1, d2, b,ldb, wr, wi, x, &
     !! DLALN2 solves a system of the form  (ca A - w D ) X = s B
     !! or (ca A**T - w D) X = s B   with possible scaling ("s") and
     !! perturbation of A.  (A**T means A-transpose.)
     !! A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
     !! real diagonal matrix, w is a real or complex value, and X and B are
     !! NA x 1 matrices -- real if w is real, complex if w is complex.  NA
     !! may be 1 or 2.
     !! If w is complex, X and B are represented as NA x 2 matrices,
     !! the first column of each being the real part and the second
     !! being the imaginary part.
     !! "s" is a scaling factor (<= 1), computed by DLALN2, which is
     !! so chosen that X can be computed without overflow.  X is further
     !! scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
     !! than overflow.
     !! If both singular values of (ca A - w D) are less than SMIN,
     !! SMIN*identity will be used instead of (ca A - w D).  If only one
     !! singular value is less than SMIN, one element of (ca A - w D) will be
     !! perturbed enough to make the smallest singular value roughly SMIN.
     !! If both singular values are at least SMIN, (ca A - w D) will not be
     !! perturbed.  In any case, the perturbation will be at most some small
     !! multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
     !! are computed by infinity-norm approximations, and thus will only be
     !! correct to a factor of 2 or so.
     !! Note: all input quantities are assumed to be smaller than overflow
     !! by a reasonable factor.  (See BIGNUM.)
               ldx, scale, xnorm, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: ltrans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldx, na, nw
           real(dp), intent(in) :: ca, d1, d2, smin, wi, wr
           real(dp), intent(out) :: scale, xnorm
           ! Array Arguments 
           real(dp), intent(in) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: x(ldx,*)
       ! =====================================================================
           
           
           ! Local Scalars 
           integer(ilp) :: icmax, j
           real(dp) :: bbnd, bi1, bi2, bignum, bnorm, br1, br2, ci21, ci22, cmax, cnorm, cr21, &
           cr22, csi, csr, li21, lr21, smini, smlnum, temp, u22abs, ui11, ui11r, ui12, ui12s, &
                     ui22, ur11, ur11r, ur12, ur12s, ur22, xi1, xi2, xr1, xr2
           ! Local Arrays 
           logical(lk) :: rswap(4), zswap(4)
           integer(ilp) :: ipivot(4,4)
           real(dp) :: ci(2,2), civ(4), cr(2,2), crv(4)
           ! Intrinsic Functions 
           ! Equivalences 
           equivalence        ( ci( 1, 1 ), civ( 1 ) ),( cr( 1, 1 ), crv( 1 ) )
           ! Data Statements 
           zswap = [.false.,.false.,.true.,.true.]
           rswap = [.false.,.true.,.false.,.true.]
           ipivot = reshape([1,2,3,4,2,1,4,3,3,4,1,2,4,3,2,1],[4,4])
           ! Executable Statements 
           ! compute bignum
           smlnum = two*stdlib_dlamch( 'SAFE MINIMUM' )
           bignum = one / smlnum
           smini = max( smin, smlnum )
           ! don't check for input errors
           info = 0
           ! standard initializations
           scale = one
           if( na==1 ) then
              ! 1 x 1  (i.e., scalar) system   c x = b
              if( nw==1 ) then
                 ! real 1x1 system.
                 ! c = ca a - w d
                 csr = ca*a( 1, 1 ) - wr*d1
                 cnorm = abs( csr )
                 ! if | c | < smini, use c = smini
                 if( cnorm<smini ) then
                    csr = smini
                    cnorm = smini
                    info = 1
                 end if
                 ! check scaling for  x = b / c
                 bnorm = abs( b( 1, 1 ) )
                 if( cnorm<one .and. bnorm>one ) then
                    if( bnorm>bignum*cnorm )scale = one / bnorm
                 end if
                 ! compute x
                 x( 1, 1 ) = ( b( 1, 1 )*scale ) / csr
                 xnorm = abs( x( 1, 1 ) )
              else
                 ! complex 1x1 system (w is complex)
                 ! c = ca a - w d
                 csr = ca*a( 1, 1 ) - wr*d1
                 csi = -wi*d1
                 cnorm = abs( csr ) + abs( csi )
                 ! if | c | < smini, use c = smini
                 if( cnorm<smini ) then
                    csr = smini
                    csi = zero
                    cnorm = smini
                    info = 1
                 end if
                 ! check scaling for  x = b / c
                 bnorm = abs( b( 1, 1 ) ) + abs( b( 1, 2 ) )
                 if( cnorm<one .and. bnorm>one ) then
                    if( bnorm>bignum*cnorm )scale = one / bnorm
                 end if
                 ! compute x
                 call stdlib_dladiv( scale*b( 1, 1 ), scale*b( 1, 2 ), csr, csi,x( 1, 1 ), x( 1, &
                           2 ) )
                 xnorm = abs( x( 1, 1 ) ) + abs( x( 1, 2 ) )
              end if
           else
              ! 2x2 system
              ! compute the realpart of  c = ca a - w d  (or  ca a**t - w d,KIND=dp)
              cr( 1, 1 ) = ca*a( 1, 1 ) - wr*d1
              cr( 2, 2 ) = ca*a( 2, 2 ) - wr*d2
              if( ltrans ) then
                 cr( 1, 2 ) = ca*a( 2, 1 )
                 cr( 2, 1 ) = ca*a( 1, 2 )
              else
                 cr( 2, 1 ) = ca*a( 2, 1 )
                 cr( 1, 2 ) = ca*a( 1, 2 )
              end if
              if( nw==1 ) then
                 ! real2x2 system  (w is real,KIND=dp)
                 ! find the largest element in c
                 cmax = zero
                 icmax = 0
                 do j = 1, 4
                    if( abs( crv( j ) )>cmax ) then
                       cmax = abs( crv( j ) )
                       icmax = j
                    end if
                 end do
                 ! if norm(c) < smini, use smini*identity.
                 if( cmax<smini ) then
                    bnorm = max( abs( b( 1, 1 ) ), abs( b( 2, 1 ) ) )
                    if( smini<one .and. bnorm>one ) then
                       if( bnorm>bignum*smini )scale = one / bnorm
                    end if
                    temp = scale / smini
                    x( 1, 1 ) = temp*b( 1, 1 )
                    x( 2, 1 ) = temp*b( 2, 1 )
                    xnorm = temp*bnorm
                    info = 1
                    return
                 end if
                 ! gaussian elimination with complete pivoting.
                 ur11 = crv( icmax )
                 cr21 = crv( ipivot( 2, icmax ) )
                 ur12 = crv( ipivot( 3, icmax ) )
                 cr22 = crv( ipivot( 4, icmax ) )
                 ur11r = one / ur11
                 lr21 = ur11r*cr21
                 ur22 = cr22 - ur12*lr21
                 ! if smaller pivot < smini, use smini
                 if( abs( ur22 )<smini ) then
                    ur22 = smini
                    info = 1
                 end if
                 if( rswap( icmax ) ) then
                    br1 = b( 2, 1 )
                    br2 = b( 1, 1 )
                 else
                    br1 = b( 1, 1 )
                    br2 = b( 2, 1 )
                 end if
                 br2 = br2 - lr21*br1
                 bbnd = max( abs( br1*( ur22*ur11r ) ), abs( br2 ) )
                 if( bbnd>one .and. abs( ur22 )<one ) then
                    if( bbnd>=bignum*abs( ur22 ) )scale = one / bbnd
                 end if
                 xr2 = ( br2*scale ) / ur22
                 xr1 = ( scale*br1 )*ur11r - xr2*( ur11r*ur12 )
                 if( zswap( icmax ) ) then
                    x( 1, 1 ) = xr2
                    x( 2, 1 ) = xr1
                 else
                    x( 1, 1 ) = xr1
                    x( 2, 1 ) = xr2
                 end if
                 xnorm = max( abs( xr1 ), abs( xr2 ) )
                 ! further scaling if  norm(a) norm(x) > overflow
                 if( xnorm>one .and. cmax>one ) then
                    if( xnorm>bignum / cmax ) then
                       temp = cmax / bignum
                       x( 1, 1 ) = temp*x( 1, 1 )
                       x( 2, 1 ) = temp*x( 2, 1 )
                       xnorm = temp*xnorm
                       scale = temp*scale
                    end if
                 end if
              else
                 ! complex 2x2 system  (w is complex)
                 ! find the largest element in c
                 ci( 1, 1 ) = -wi*d1
                 ci( 2, 1 ) = zero
                 ci( 1, 2 ) = zero
                 ci( 2, 2 ) = -wi*d2
                 cmax = zero
                 icmax = 0
                 do j = 1, 4
                    if( abs( crv( j ) )+abs( civ( j ) )>cmax ) then
                       cmax = abs( crv( j ) ) + abs( civ( j ) )
                       icmax = j
                    end if
                 end do
                 ! if norm(c) < smini, use smini*identity.
                 if( cmax<smini ) then
                    bnorm = max( abs( b( 1, 1 ) )+abs( b( 1, 2 ) ),abs( b( 2, 1 ) )+abs( b( 2, 2 )&
                               ) )
                    if( smini<one .and. bnorm>one ) then
                       if( bnorm>bignum*smini )scale = one / bnorm
                    end if
                    temp = scale / smini
                    x( 1, 1 ) = temp*b( 1, 1 )
                    x( 2, 1 ) = temp*b( 2, 1 )
                    x( 1, 2 ) = temp*b( 1, 2 )
                    x( 2, 2 ) = temp*b( 2, 2 )
                    xnorm = temp*bnorm
                    info = 1
                    return
                 end if
                 ! gaussian elimination with complete pivoting.
                 ur11 = crv( icmax )
                 ui11 = civ( icmax )
                 cr21 = crv( ipivot( 2, icmax ) )
                 ci21 = civ( ipivot( 2, icmax ) )
                 ur12 = crv( ipivot( 3, icmax ) )
                 ui12 = civ( ipivot( 3, icmax ) )
                 cr22 = crv( ipivot( 4, icmax ) )
                 ci22 = civ( ipivot( 4, icmax ) )
                 if( icmax==1 .or. icmax==4 ) then
                    ! code when off-diagonals of pivoted c are real
                    if( abs( ur11 )>abs( ui11 ) ) then
                       temp = ui11 / ur11
                       ur11r = one / ( ur11*( one+temp**2 ) )
                       ui11r = -temp*ur11r
                    else
                       temp = ur11 / ui11
                       ui11r = -one / ( ui11*( one+temp**2 ) )
                       ur11r = -temp*ui11r
                    end if
                    lr21 = cr21*ur11r
                    li21 = cr21*ui11r
                    ur12s = ur12*ur11r
                    ui12s = ur12*ui11r
                    ur22 = cr22 - ur12*lr21
                    ui22 = ci22 - ur12*li21
                 else
                    ! code when diagonals of pivoted c are real
                    ur11r = one / ur11
                    ui11r = zero
                    lr21 = cr21*ur11r
                    li21 = ci21*ur11r
                    ur12s = ur12*ur11r
                    ui12s = ui12*ur11r
                    ur22 = cr22 - ur12*lr21 + ui12*li21
                    ui22 = -ur12*li21 - ui12*lr21
                 end if
                 u22abs = abs( ur22 ) + abs( ui22 )
                 ! if smaller pivot < smini, use smini
                 if( u22abs<smini ) then
                    ur22 = smini
                    ui22 = zero
                    info = 1
                 end if
                 if( rswap( icmax ) ) then
                    br2 = b( 1, 1 )
                    br1 = b( 2, 1 )
                    bi2 = b( 1, 2 )
                    bi1 = b( 2, 2 )
                 else
                    br1 = b( 1, 1 )
                    br2 = b( 2, 1 )
                    bi1 = b( 1, 2 )
                    bi2 = b( 2, 2 )
                 end if
                 br2 = br2 - lr21*br1 + li21*bi1
                 bi2 = bi2 - li21*br1 - lr21*bi1
                 bbnd = max( ( abs( br1 )+abs( bi1 ) )*( u22abs*( abs( ur11r )+abs( ui11r ) ) ),&
                           abs( br2 )+abs( bi2 ) )
                 if( bbnd>one .and. u22abs<one ) then
                    if( bbnd>=bignum*u22abs ) then
                       scale = one / bbnd
                       br1 = scale*br1
                       bi1 = scale*bi1
                       br2 = scale*br2
                       bi2 = scale*bi2
                    end if
                 end if
                 call stdlib_dladiv( br2, bi2, ur22, ui22, xr2, xi2 )
                 xr1 = ur11r*br1 - ui11r*bi1 - ur12s*xr2 + ui12s*xi2
                 xi1 = ui11r*br1 + ur11r*bi1 - ui12s*xr2 - ur12s*xi2
                 if( zswap( icmax ) ) then
                    x( 1, 1 ) = xr2
                    x( 2, 1 ) = xr1
                    x( 1, 2 ) = xi2
                    x( 2, 2 ) = xi1
                 else
                    x( 1, 1 ) = xr1
                    x( 2, 1 ) = xr2
                    x( 1, 2 ) = xi1
                    x( 2, 2 ) = xi2
                 end if
                 xnorm = max( abs( xr1 )+abs( xi1 ), abs( xr2 )+abs( xi2 ) )
                 ! further scaling if  norm(a) norm(x) > overflow
                 if( xnorm>one .and. cmax>one ) then
                    if( xnorm>bignum / cmax ) then
                       temp = cmax / bignum
                       x( 1, 1 ) = temp*x( 1, 1 )
                       x( 2, 1 ) = temp*x( 2, 1 )
                       x( 1, 2 ) = temp*x( 1, 2 )
                       x( 2, 2 ) = temp*x( 2, 2 )
                       xnorm = temp*xnorm
                       scale = temp*scale
                    end if
                 end if
              end if
           end if
           return
     end subroutine stdlib_dlaln2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$laln2( ltrans, na, nw, smin, ca, a, lda, d1, d2, b,ldb, wr, wi, x, &
     !! DLALN2: solves a system of the form  (ca A - w D ) X = s B
     !! or (ca A**T - w D) X = s B   with possible scaling ("s") and
     !! perturbation of A.  (A**T means A-transpose.)
     !! A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
     !! real diagonal matrix, w is a real or complex value, and X and B are
     !! NA x 1 matrices -- real if w is real, complex if w is complex.  NA
     !! may be 1 or 2.
     !! If w is complex, X and B are represented as NA x 2 matrices,
     !! the first column of each being the real part and the second
     !! being the imaginary part.
     !! "s" is a scaling factor (<= 1), computed by DLALN2, which is
     !! so chosen that X can be computed without overflow.  X is further
     !! scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
     !! than overflow.
     !! If both singular values of (ca A - w D) are less than SMIN,
     !! SMIN*identity will be used instead of (ca A - w D).  If only one
     !! singular value is less than SMIN, one element of (ca A - w D) will be
     !! perturbed enough to make the smallest singular value roughly SMIN.
     !! If both singular values are at least SMIN, (ca A - w D) will not be
     !! perturbed.  In any case, the perturbation will be at most some small
     !! multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
     !! are computed by infinity-norm approximations, and thus will only be
     !! correct to a factor of 2 or so.
     !! Note: all input quantities are assumed to be smaller than overflow
     !! by a reasonable factor.  (See BIGNUM.)
               ldx, scale, xnorm, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: ltrans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldx, na, nw
           real(${rk}$), intent(in) :: ca, d1, d2, smin, wi, wr
           real(${rk}$), intent(out) :: scale, xnorm
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: x(ldx,*)
       ! =====================================================================
           
           
           ! Local Scalars 
           integer(ilp) :: icmax, j
           real(${rk}$) :: bbnd, bi1, bi2, bignum, bnorm, br1, br2, ci21, ci22, cmax, cnorm, cr21, &
           cr22, csi, csr, li21, lr21, smini, smlnum, temp, u22abs, ui11, ui11r, ui12, ui12s, &
                     ui22, ur11, ur11r, ur12, ur12s, ur22, xi1, xi2, xr1, xr2
           ! Local Arrays 
           logical(lk) :: rswap(4), zswap(4)
           integer(ilp) :: ipivot(4,4)
           real(${rk}$) :: ci(2,2), civ(4), cr(2,2), crv(4)
           ! Intrinsic Functions 
           ! Equivalences 
           equivalence        ( ci( 1, 1 ), civ( 1 ) ),( cr( 1, 1 ), crv( 1 ) )
           ! Data Statements 
           zswap = [.false.,.false.,.true.,.true.]
           rswap = [.false.,.true.,.false.,.true.]
           ipivot = reshape([1,2,3,4,2,1,4,3,3,4,1,2,4,3,2,1],[4,4])
           ! Executable Statements 
           ! compute bignum
           smlnum = two*stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           bignum = one / smlnum
           smini = max( smin, smlnum )
           ! don't check for input errors
           info = 0
           ! standard initializations
           scale = one
           if( na==1 ) then
              ! 1 x 1  (i.e., scalar) system   c x = b
              if( nw==1 ) then
                 ! real 1x1 system.
                 ! c = ca a - w d
                 csr = ca*a( 1, 1 ) - wr*d1
                 cnorm = abs( csr )
                 ! if | c | < smini, use c = smini
                 if( cnorm<smini ) then
                    csr = smini
                    cnorm = smini
                    info = 1
                 end if
                 ! check scaling for  x = b / c
                 bnorm = abs( b( 1, 1 ) )
                 if( cnorm<one .and. bnorm>one ) then
                    if( bnorm>bignum*cnorm )scale = one / bnorm
                 end if
                 ! compute x
                 x( 1, 1 ) = ( b( 1, 1 )*scale ) / csr
                 xnorm = abs( x( 1, 1 ) )
              else
                 ! complex 1x1 system (w is complex)
                 ! c = ca a - w d
                 csr = ca*a( 1, 1 ) - wr*d1
                 csi = -wi*d1
                 cnorm = abs( csr ) + abs( csi )
                 ! if | c | < smini, use c = smini
                 if( cnorm<smini ) then
                    csr = smini
                    csi = zero
                    cnorm = smini
                    info = 1
                 end if
                 ! check scaling for  x = b / c
                 bnorm = abs( b( 1, 1 ) ) + abs( b( 1, 2 ) )
                 if( cnorm<one .and. bnorm>one ) then
                    if( bnorm>bignum*cnorm )scale = one / bnorm
                 end if
                 ! compute x
                 call stdlib_${ri}$ladiv( scale*b( 1, 1 ), scale*b( 1, 2 ), csr, csi,x( 1, 1 ), x( 1, &
                           2 ) )
                 xnorm = abs( x( 1, 1 ) ) + abs( x( 1, 2 ) )
              end if
           else
              ! 2x2 system
              ! compute the realpart of  c = ca a - w d  (or  ca a**t - w d,KIND=${rk}$)
              cr( 1, 1 ) = ca*a( 1, 1 ) - wr*d1
              cr( 2, 2 ) = ca*a( 2, 2 ) - wr*d2
              if( ltrans ) then
                 cr( 1, 2 ) = ca*a( 2, 1 )
                 cr( 2, 1 ) = ca*a( 1, 2 )
              else
                 cr( 2, 1 ) = ca*a( 2, 1 )
                 cr( 1, 2 ) = ca*a( 1, 2 )
              end if
              if( nw==1 ) then
                 ! real2x2 system  (w is real,KIND=${rk}$)
                 ! find the largest element in c
                 cmax = zero
                 icmax = 0
                 do j = 1, 4
                    if( abs( crv( j ) )>cmax ) then
                       cmax = abs( crv( j ) )
                       icmax = j
                    end if
                 end do
                 ! if norm(c) < smini, use smini*identity.
                 if( cmax<smini ) then
                    bnorm = max( abs( b( 1, 1 ) ), abs( b( 2, 1 ) ) )
                    if( smini<one .and. bnorm>one ) then
                       if( bnorm>bignum*smini )scale = one / bnorm
                    end if
                    temp = scale / smini
                    x( 1, 1 ) = temp*b( 1, 1 )
                    x( 2, 1 ) = temp*b( 2, 1 )
                    xnorm = temp*bnorm
                    info = 1
                    return
                 end if
                 ! gaussian elimination with complete pivoting.
                 ur11 = crv( icmax )
                 cr21 = crv( ipivot( 2, icmax ) )
                 ur12 = crv( ipivot( 3, icmax ) )
                 cr22 = crv( ipivot( 4, icmax ) )
                 ur11r = one / ur11
                 lr21 = ur11r*cr21
                 ur22 = cr22 - ur12*lr21
                 ! if smaller pivot < smini, use smini
                 if( abs( ur22 )<smini ) then
                    ur22 = smini
                    info = 1
                 end if
                 if( rswap( icmax ) ) then
                    br1 = b( 2, 1 )
                    br2 = b( 1, 1 )
                 else
                    br1 = b( 1, 1 )
                    br2 = b( 2, 1 )
                 end if
                 br2 = br2 - lr21*br1
                 bbnd = max( abs( br1*( ur22*ur11r ) ), abs( br2 ) )
                 if( bbnd>one .and. abs( ur22 )<one ) then
                    if( bbnd>=bignum*abs( ur22 ) )scale = one / bbnd
                 end if
                 xr2 = ( br2*scale ) / ur22
                 xr1 = ( scale*br1 )*ur11r - xr2*( ur11r*ur12 )
                 if( zswap( icmax ) ) then
                    x( 1, 1 ) = xr2
                    x( 2, 1 ) = xr1
                 else
                    x( 1, 1 ) = xr1
                    x( 2, 1 ) = xr2
                 end if
                 xnorm = max( abs( xr1 ), abs( xr2 ) )
                 ! further scaling if  norm(a) norm(x) > overflow
                 if( xnorm>one .and. cmax>one ) then
                    if( xnorm>bignum / cmax ) then
                       temp = cmax / bignum
                       x( 1, 1 ) = temp*x( 1, 1 )
                       x( 2, 1 ) = temp*x( 2, 1 )
                       xnorm = temp*xnorm
                       scale = temp*scale
                    end if
                 end if
              else
                 ! complex 2x2 system  (w is complex)
                 ! find the largest element in c
                 ci( 1, 1 ) = -wi*d1
                 ci( 2, 1 ) = zero
                 ci( 1, 2 ) = zero
                 ci( 2, 2 ) = -wi*d2
                 cmax = zero
                 icmax = 0
                 do j = 1, 4
                    if( abs( crv( j ) )+abs( civ( j ) )>cmax ) then
                       cmax = abs( crv( j ) ) + abs( civ( j ) )
                       icmax = j
                    end if
                 end do
                 ! if norm(c) < smini, use smini*identity.
                 if( cmax<smini ) then
                    bnorm = max( abs( b( 1, 1 ) )+abs( b( 1, 2 ) ),abs( b( 2, 1 ) )+abs( b( 2, 2 )&
                               ) )
                    if( smini<one .and. bnorm>one ) then
                       if( bnorm>bignum*smini )scale = one / bnorm
                    end if
                    temp = scale / smini
                    x( 1, 1 ) = temp*b( 1, 1 )
                    x( 2, 1 ) = temp*b( 2, 1 )
                    x( 1, 2 ) = temp*b( 1, 2 )
                    x( 2, 2 ) = temp*b( 2, 2 )
                    xnorm = temp*bnorm
                    info = 1
                    return
                 end if
                 ! gaussian elimination with complete pivoting.
                 ur11 = crv( icmax )
                 ui11 = civ( icmax )
                 cr21 = crv( ipivot( 2, icmax ) )
                 ci21 = civ( ipivot( 2, icmax ) )
                 ur12 = crv( ipivot( 3, icmax ) )
                 ui12 = civ( ipivot( 3, icmax ) )
                 cr22 = crv( ipivot( 4, icmax ) )
                 ci22 = civ( ipivot( 4, icmax ) )
                 if( icmax==1 .or. icmax==4 ) then
                    ! code when off-diagonals of pivoted c are real
                    if( abs( ur11 )>abs( ui11 ) ) then
                       temp = ui11 / ur11
                       ur11r = one / ( ur11*( one+temp**2 ) )
                       ui11r = -temp*ur11r
                    else
                       temp = ur11 / ui11
                       ui11r = -one / ( ui11*( one+temp**2 ) )
                       ur11r = -temp*ui11r
                    end if
                    lr21 = cr21*ur11r
                    li21 = cr21*ui11r
                    ur12s = ur12*ur11r
                    ui12s = ur12*ui11r
                    ur22 = cr22 - ur12*lr21
                    ui22 = ci22 - ur12*li21
                 else
                    ! code when diagonals of pivoted c are real
                    ur11r = one / ur11
                    ui11r = zero
                    lr21 = cr21*ur11r
                    li21 = ci21*ur11r
                    ur12s = ur12*ur11r
                    ui12s = ui12*ur11r
                    ur22 = cr22 - ur12*lr21 + ui12*li21
                    ui22 = -ur12*li21 - ui12*lr21
                 end if
                 u22abs = abs( ur22 ) + abs( ui22 )
                 ! if smaller pivot < smini, use smini
                 if( u22abs<smini ) then
                    ur22 = smini
                    ui22 = zero
                    info = 1
                 end if
                 if( rswap( icmax ) ) then
                    br2 = b( 1, 1 )
                    br1 = b( 2, 1 )
                    bi2 = b( 1, 2 )
                    bi1 = b( 2, 2 )
                 else
                    br1 = b( 1, 1 )
                    br2 = b( 2, 1 )
                    bi1 = b( 1, 2 )
                    bi2 = b( 2, 2 )
                 end if
                 br2 = br2 - lr21*br1 + li21*bi1
                 bi2 = bi2 - li21*br1 - lr21*bi1
                 bbnd = max( ( abs( br1 )+abs( bi1 ) )*( u22abs*( abs( ur11r )+abs( ui11r ) ) ),&
                           abs( br2 )+abs( bi2 ) )
                 if( bbnd>one .and. u22abs<one ) then
                    if( bbnd>=bignum*u22abs ) then
                       scale = one / bbnd
                       br1 = scale*br1
                       bi1 = scale*bi1
                       br2 = scale*br2
                       bi2 = scale*bi2
                    end if
                 end if
                 call stdlib_${ri}$ladiv( br2, bi2, ur22, ui22, xr2, xi2 )
                 xr1 = ur11r*br1 - ui11r*bi1 - ur12s*xr2 + ui12s*xi2
                 xi1 = ui11r*br1 + ur11r*bi1 - ui12s*xr2 - ur12s*xi2
                 if( zswap( icmax ) ) then
                    x( 1, 1 ) = xr2
                    x( 2, 1 ) = xr1
                    x( 1, 2 ) = xi2
                    x( 2, 2 ) = xi1
                 else
                    x( 1, 1 ) = xr1
                    x( 2, 1 ) = xr2
                    x( 1, 2 ) = xi1
                    x( 2, 2 ) = xi2
                 end if
                 xnorm = max( abs( xr1 )+abs( xi1 ), abs( xr2 )+abs( xi2 ) )
                 ! further scaling if  norm(a) norm(x) > overflow
                 if( xnorm>one .and. cmax>one ) then
                    if( xnorm>bignum / cmax ) then
                       temp = cmax / bignum
                       x( 1, 1 ) = temp*x( 1, 1 )
                       x( 2, 1 ) = temp*x( 2, 1 )
                       x( 1, 2 ) = temp*x( 1, 2 )
                       x( 2, 2 ) = temp*x( 2, 2 )
                       xnorm = temp*xnorm
                       scale = temp*scale
                    end if
                 end if
              end if
           end if
           return
     end subroutine stdlib_${ri}$laln2

#:endif
#:endfor







     module subroutine stdlib_sgees( jobvs, sort, select, n, a, lda, sdim, wr, wi,vs, ldvs, work, lwork, &
     !! SGEES computes for an N-by-N real nonsymmetric matrix A, the
     !! eigenvalues, the real Schur form T, and, optionally, the matrix of
     !! Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).
     !! Optionally, it also orders the eigenvalues on the diagonal of the
     !! real Schur form so that selected eigenvalues are at the top left.
     !! The leading columns of Z then form an orthonormal basis for the
     !! invariant subspace corresponding to the selected eigenvalues.
     !! A matrix is in real Schur form if it is upper quasi-triangular with
     !! 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the
     !! form
     !! [  a  b  ]
     !! [  c  a  ]
     !! where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).
               bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvs, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldvs, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: vs(ldvs,*), wi(*), work(*), wr(*)
           ! Function Arguments 
           procedure(stdlib_select_s) :: select
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: cursl, lastsl, lquery, lst2sl, scalea, wantst, wantvs
           integer(ilp) :: hswork, i, i1, i2, ibal, icond, ierr, ieval, ihi, ilo, inxt, ip, itau, &
                     iwrk, maxwrk, minwrk
           real(sp) :: anrm, bignum, cscale, eps, s, sep, smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(sp) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvs = stdlib_lsame( jobvs, 'V' )
           wantst = stdlib_lsame( sort, 'S' )
           if( ( .not.wantvs ) .and. ( .not.stdlib_lsame( jobvs, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldvs<1 .or. ( wantvs .and. ldvs<n ) ) then
              info = -11
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_shseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = 2*n + n*stdlib_ilaenv( 1, 'SGEHRD', ' ', n, 1, n, 0 )
                 minwrk = 3*n
                 call stdlib_shseqr( 'S', jobvs, n, 1, n, a, lda, wr, wi, vs, ldvs,work, -1, &
                           ieval )
                 hswork = work( 1 )
                 if( .not.wantvs ) then
                    maxwrk = max( maxwrk, n + hswork )
                 else
                    maxwrk = max( maxwrk, 2*n + ( n - 1 )*stdlib_ilaenv( 1,'SORGHR', ' ', n, 1, n,&
                               -1 ) )
                    maxwrk = max( maxwrk, n + hswork )
                 end if
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -13
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGEES ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_slange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_slascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (workspace: need n)
           ibal = 1
           call stdlib_sgebal( 'P', n, a, lda, ilo, ihi, work( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (workspace: need 3*n, prefer 2*n+n*nb)
           itau = n + ibal
           iwrk = n + itau
           call stdlib_sgehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvs ) then
              ! copy householder vectors to vs
              call stdlib_slacpy( 'L', n, n, a, lda, vs, ldvs )
              ! generate orthogonal matrix in vs
              ! (workspace: need 3*n-1, prefer 2*n+(n-1)*nb)
              call stdlib_sorghr( n, ilo, ihi, vs, ldvs, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
           end if
           sdim = 0
           ! perform qr iteration, accumulating schur vectors in vs if desired
           ! (workspace: need n+1, prefer n+hswork (see comments) )
           iwrk = itau
           call stdlib_shseqr( 'S', jobvs, n, ilo, ihi, a, lda, wr, wi, vs, ldvs,work( iwrk ), &
                     lwork-iwrk+1, ieval )
           if( ieval>0 )info = ieval
           ! sort eigenvalues if desired
           if( wantst .and. info==0 ) then
              if( scalea ) then
                 call stdlib_slascl( 'G', 0, 0, cscale, anrm, n, 1, wr, n, ierr )
                 call stdlib_slascl( 'G', 0, 0, cscale, anrm, n, 1, wi, n, ierr )
              end if
              do i = 1, n
                 bwork( i ) = select( wr( i ), wi( i ) )
              end do
              ! reorder eigenvalues and transform schur vectors
              ! (workspace: none needed)
              call stdlib_strsen( 'N', jobvs, bwork, n, a, lda, vs, ldvs, wr, wi,sdim, s, sep, &
                        work( iwrk ), lwork-iwrk+1, idum, 1,icond )
              if( icond>0 )info = n + icond
           end if
           if( wantvs ) then
              ! undo balancing
              ! (workspace: need n)
              call stdlib_sgebak( 'P', 'R', n, ilo, ihi, work( ibal ), n, vs, ldvs,ierr )
           end if
           if( scalea ) then
              ! undo scaling for the schur form of a
              call stdlib_slascl( 'H', 0, 0, cscale, anrm, n, n, a, lda, ierr )
              call stdlib_scopy( n, a, lda+1, wr, 1 )
              if( cscale==smlnum ) then
                 ! if scaling back towards underflow, adjust wi if an
                 ! offdiagonal element of a 2-by-2 block in the schur form
                 ! underflows.
                 if( ieval>0 ) then
                    i1 = ieval + 1
                    i2 = ihi - 1
                    call stdlib_slascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wi,max( ilo-1, 1 ), &
                              ierr )
                 else if( wantst ) then
                    i1 = 1
                    i2 = n - 1
                 else
                    i1 = ilo
                    i2 = ihi - 1
                 end if
                 inxt = i1 - 1
                 loop_20: do i = i1, i2
                    if( i<inxt )cycle loop_20
                    if( wi( i )==zero ) then
                       inxt = i + 1
                    else
                       if( a( i+1, i )==zero ) then
                          wi( i ) = zero
                          wi( i+1 ) = zero
                       else if( a( i+1, i )/=zero .and. a( i, i+1 )==zero ) then
                          wi( i ) = zero
                          wi( i+1 ) = zero
                          if( i>1 )call stdlib_sswap( i-1, a( 1, i ), 1, a( 1, i+1 ), 1 )
                          if( n>i+1 )call stdlib_sswap( n-i-1, a( i, i+2 ), lda,a( i+1, i+2 ), &
                                    lda )
                          if( wantvs ) then
                             call stdlib_sswap( n, vs( 1, i ), 1, vs( 1, i+1 ), 1 )
                          end if
                          a( i, i+1 ) = a( i+1, i )
                          a( i+1, i ) = zero
                       end if
                       inxt = i + 2
                    end if
                 end do loop_20
              end if
              ! undo scaling for the imaginary part of the eigenvalues
              call stdlib_slascl( 'G', 0, 0, cscale, anrm, n-ieval, 1,wi( ieval+1 ), max( n-ieval,&
                         1 ), ierr )
           end if
           if( wantst .and. info==0 ) then
              ! check if reordering successful
              lastsl = .true.
              lst2sl = .true.
              sdim = 0
              ip = 0
              do i = 1, n
                 cursl = select( wr( i ), wi( i ) )
                 if( wi( i )==zero ) then
                    if( cursl )sdim = sdim + 1
                    ip = 0
                    if( cursl .and. .not.lastsl )info = n + 2
                 else
                    if( ip==1 ) then
                       ! last eigenvalue of conjugate pair
                       cursl = cursl .or. lastsl
                       lastsl = cursl
                       if( cursl )sdim = sdim + 2
                       ip = -1
                       if( cursl .and. .not.lst2sl )info = n + 2
                    else
                       ! first eigenvalue of conjugate pair
                       ip = 1
                    end if
                 end if
                 lst2sl = lastsl
                 lastsl = cursl
              end do
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_sgees

     module subroutine stdlib_dgees( jobvs, sort, select, n, a, lda, sdim, wr, wi,vs, ldvs, work, lwork, &
     !! DGEES computes for an N-by-N real nonsymmetric matrix A, the
     !! eigenvalues, the real Schur form T, and, optionally, the matrix of
     !! Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).
     !! Optionally, it also orders the eigenvalues on the diagonal of the
     !! real Schur form so that selected eigenvalues are at the top left.
     !! The leading columns of Z then form an orthonormal basis for the
     !! invariant subspace corresponding to the selected eigenvalues.
     !! A matrix is in real Schur form if it is upper quasi-triangular with
     !! 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the
     !! form
     !! [  a  b  ]
     !! [  c  a  ]
     !! where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).
               bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvs, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldvs, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: vs(ldvs,*), wi(*), work(*), wr(*)
           ! Function Arguments 
           procedure(stdlib_select_d) :: select
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: cursl, lastsl, lquery, lst2sl, scalea, wantst, wantvs
           integer(ilp) :: hswork, i, i1, i2, ibal, icond, ierr, ieval, ihi, ilo, inxt, ip, itau, &
                     iwrk, maxwrk, minwrk
           real(dp) :: anrm, bignum, cscale, eps, s, sep, smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(dp) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvs = stdlib_lsame( jobvs, 'V' )
           wantst = stdlib_lsame( sort, 'S' )
           if( ( .not.wantvs ) .and. ( .not.stdlib_lsame( jobvs, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldvs<1 .or. ( wantvs .and. ldvs<n ) ) then
              info = -11
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_dhseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = 2*n + n*stdlib_ilaenv( 1, 'DGEHRD', ' ', n, 1, n, 0 )
                 minwrk = 3*n
                 call stdlib_dhseqr( 'S', jobvs, n, 1, n, a, lda, wr, wi, vs, ldvs,work, -1, &
                           ieval )
                 hswork = work( 1 )
                 if( .not.wantvs ) then
                    maxwrk = max( maxwrk, n + hswork )
                 else
                    maxwrk = max( maxwrk, 2*n + ( n - 1 )*stdlib_ilaenv( 1,'DORGHR', ' ', n, 1, n,&
                               -1 ) )
                    maxwrk = max( maxwrk, n + hswork )
                 end if
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -13
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEES ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' )
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_dlange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_dlascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (workspace: need n)
           ibal = 1
           call stdlib_dgebal( 'P', n, a, lda, ilo, ihi, work( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (workspace: need 3*n, prefer 2*n+n*nb)
           itau = n + ibal
           iwrk = n + itau
           call stdlib_dgehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvs ) then
              ! copy householder vectors to vs
              call stdlib_dlacpy( 'L', n, n, a, lda, vs, ldvs )
              ! generate orthogonal matrix in vs
              ! (workspace: need 3*n-1, prefer 2*n+(n-1)*nb)
              call stdlib_dorghr( n, ilo, ihi, vs, ldvs, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
           end if
           sdim = 0
           ! perform qr iteration, accumulating schur vectors in vs if desired
           ! (workspace: need n+1, prefer n+hswork (see comments) )
           iwrk = itau
           call stdlib_dhseqr( 'S', jobvs, n, ilo, ihi, a, lda, wr, wi, vs, ldvs,work( iwrk ), &
                     lwork-iwrk+1, ieval )
           if( ieval>0 )info = ieval
           ! sort eigenvalues if desired
           if( wantst .and. info==0 ) then
              if( scalea ) then
                 call stdlib_dlascl( 'G', 0, 0, cscale, anrm, n, 1, wr, n, ierr )
                 call stdlib_dlascl( 'G', 0, 0, cscale, anrm, n, 1, wi, n, ierr )
              end if
              do i = 1, n
                 bwork( i ) = select( wr( i ), wi( i ) )
              end do
              ! reorder eigenvalues and transform schur vectors
              ! (workspace: none needed)
              call stdlib_dtrsen( 'N', jobvs, bwork, n, a, lda, vs, ldvs, wr, wi,sdim, s, sep, &
                        work( iwrk ), lwork-iwrk+1, idum, 1,icond )
              if( icond>0 )info = n + icond
           end if
           if( wantvs ) then
              ! undo balancing
              ! (workspace: need n)
              call stdlib_dgebak( 'P', 'R', n, ilo, ihi, work( ibal ), n, vs, ldvs,ierr )
           end if
           if( scalea ) then
              ! undo scaling for the schur form of a
              call stdlib_dlascl( 'H', 0, 0, cscale, anrm, n, n, a, lda, ierr )
              call stdlib_dcopy( n, a, lda+1, wr, 1 )
              if( cscale==smlnum ) then
                 ! if scaling back towards underflow, adjust wi if an
                 ! offdiagonal element of a 2-by-2 block in the schur form
                 ! underflows.
                 if( ieval>0 ) then
                    i1 = ieval + 1
                    i2 = ihi - 1
                    call stdlib_dlascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wi,max( ilo-1, 1 ), &
                              ierr )
                 else if( wantst ) then
                    i1 = 1
                    i2 = n - 1
                 else
                    i1 = ilo
                    i2 = ihi - 1
                 end if
                 inxt = i1 - 1
                 loop_20: do i = i1, i2
                    if( i<inxt )cycle loop_20
                    if( wi( i )==zero ) then
                       inxt = i + 1
                    else
                       if( a( i+1, i )==zero ) then
                          wi( i ) = zero
                          wi( i+1 ) = zero
                       else if( a( i+1, i )/=zero .and. a( i, i+1 )==zero ) then
                          wi( i ) = zero
                          wi( i+1 ) = zero
                          if( i>1 )call stdlib_dswap( i-1, a( 1, i ), 1, a( 1, i+1 ), 1 )
                          if( n>i+1 )call stdlib_dswap( n-i-1, a( i, i+2 ), lda,a( i+1, i+2 ), &
                                    lda )
                          if( wantvs ) then
                             call stdlib_dswap( n, vs( 1, i ), 1, vs( 1, i+1 ), 1 )
                          end if
                          a( i, i+1 ) = a( i+1, i )
                          a( i+1, i ) = zero
                       end if
                       inxt = i + 2
                    end if
                 end do loop_20
              end if
              ! undo scaling for the imaginary part of the eigenvalues
              call stdlib_dlascl( 'G', 0, 0, cscale, anrm, n-ieval, 1,wi( ieval+1 ), max( n-ieval,&
                         1 ), ierr )
           end if
           if( wantst .and. info==0 ) then
              ! check if reordering successful
              lastsl = .true.
              lst2sl = .true.
              sdim = 0
              ip = 0
              do i = 1, n
                 cursl = select( wr( i ), wi( i ) )
                 if( wi( i )==zero ) then
                    if( cursl )sdim = sdim + 1
                    ip = 0
                    if( cursl .and. .not.lastsl )info = n + 2
                 else
                    if( ip==1 ) then
                       ! last eigenvalue of conjugate pair
                       cursl = cursl .or. lastsl
                       lastsl = cursl
                       if( cursl )sdim = sdim + 2
                       ip = -1
                       if( cursl .and. .not.lst2sl )info = n + 2
                    else
                       ! first eigenvalue of conjugate pair
                       ip = 1
                    end if
                 end if
                 lst2sl = lastsl
                 lastsl = cursl
              end do
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_dgees

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$gees( jobvs, sort, select, n, a, lda, sdim, wr, wi,vs, ldvs, work, lwork, &
     !! DGEES: computes for an N-by-N real nonsymmetric matrix A, the
     !! eigenvalues, the real Schur form T, and, optionally, the matrix of
     !! Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).
     !! Optionally, it also orders the eigenvalues on the diagonal of the
     !! real Schur form so that selected eigenvalues are at the top left.
     !! The leading columns of Z then form an orthonormal basis for the
     !! invariant subspace corresponding to the selected eigenvalues.
     !! A matrix is in real Schur form if it is upper quasi-triangular with
     !! 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the
     !! form
     !! [  a  b  ]
     !! [  c  a  ]
     !! where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).
               bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvs, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldvs, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: vs(ldvs,*), wi(*), work(*), wr(*)
           ! Function Arguments 
           procedure(stdlib_select_${ri}$) :: select
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: cursl, lastsl, lquery, lst2sl, scalea, wantst, wantvs
           integer(ilp) :: hswork, i, i1, i2, ibal, icond, ierr, ieval, ihi, ilo, inxt, ip, itau, &
                     iwrk, maxwrk, minwrk
           real(${rk}$) :: anrm, bignum, cscale, eps, s, sep, smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(${rk}$) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvs = stdlib_lsame( jobvs, 'V' )
           wantst = stdlib_lsame( sort, 'S' )
           if( ( .not.wantvs ) .and. ( .not.stdlib_lsame( jobvs, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldvs<1 .or. ( wantvs .and. ldvs<n ) ) then
              info = -11
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_${ri}$hseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = 2*n + n*stdlib_ilaenv( 1, 'DGEHRD', ' ', n, 1, n, 0 )
                 minwrk = 3*n
                 call stdlib_${ri}$hseqr( 'S', jobvs, n, 1, n, a, lda, wr, wi, vs, ldvs,work, -1, &
                           ieval )
                 hswork = work( 1 )
                 if( .not.wantvs ) then
                    maxwrk = max( maxwrk, n + hswork )
                 else
                    maxwrk = max( maxwrk, 2*n + ( n - 1 )*stdlib_ilaenv( 1,'DORGHR', ' ', n, 1, n,&
                               -1 ) )
                    maxwrk = max( maxwrk, n + hswork )
                 end if
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -13
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEES ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_${ri}$lascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (workspace: need n)
           ibal = 1
           call stdlib_${ri}$gebal( 'P', n, a, lda, ilo, ihi, work( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (workspace: need 3*n, prefer 2*n+n*nb)
           itau = n + ibal
           iwrk = n + itau
           call stdlib_${ri}$gehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvs ) then
              ! copy householder vectors to vs
              call stdlib_${ri}$lacpy( 'L', n, n, a, lda, vs, ldvs )
              ! generate orthogonal matrix in vs
              ! (workspace: need 3*n-1, prefer 2*n+(n-1)*nb)
              call stdlib_${ri}$orghr( n, ilo, ihi, vs, ldvs, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
           end if
           sdim = 0
           ! perform qr iteration, accumulating schur vectors in vs if desired
           ! (workspace: need n+1, prefer n+hswork (see comments) )
           iwrk = itau
           call stdlib_${ri}$hseqr( 'S', jobvs, n, ilo, ihi, a, lda, wr, wi, vs, ldvs,work( iwrk ), &
                     lwork-iwrk+1, ieval )
           if( ieval>0 )info = ieval
           ! sort eigenvalues if desired
           if( wantst .and. info==0 ) then
              if( scalea ) then
                 call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, n, 1, wr, n, ierr )
                 call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, n, 1, wi, n, ierr )
              end if
              do i = 1, n
                 bwork( i ) = select( wr( i ), wi( i ) )
              end do
              ! reorder eigenvalues and transform schur vectors
              ! (workspace: none needed)
              call stdlib_${ri}$trsen( 'N', jobvs, bwork, n, a, lda, vs, ldvs, wr, wi,sdim, s, sep, &
                        work( iwrk ), lwork-iwrk+1, idum, 1,icond )
              if( icond>0 )info = n + icond
           end if
           if( wantvs ) then
              ! undo balancing
              ! (workspace: need n)
              call stdlib_${ri}$gebak( 'P', 'R', n, ilo, ihi, work( ibal ), n, vs, ldvs,ierr )
           end if
           if( scalea ) then
              ! undo scaling for the schur form of a
              call stdlib_${ri}$lascl( 'H', 0, 0, cscale, anrm, n, n, a, lda, ierr )
              call stdlib_${ri}$copy( n, a, lda+1, wr, 1 )
              if( cscale==smlnum ) then
                 ! if scaling back towards underflow, adjust wi if an
                 ! offdiagonal element of a 2-by-2 block in the schur form
                 ! underflows.
                 if( ieval>0 ) then
                    i1 = ieval + 1
                    i2 = ihi - 1
                    call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wi,max( ilo-1, 1 ), &
                              ierr )
                 else if( wantst ) then
                    i1 = 1
                    i2 = n - 1
                 else
                    i1 = ilo
                    i2 = ihi - 1
                 end if
                 inxt = i1 - 1
                 loop_20: do i = i1, i2
                    if( i<inxt )cycle loop_20
                    if( wi( i )==zero ) then
                       inxt = i + 1
                    else
                       if( a( i+1, i )==zero ) then
                          wi( i ) = zero
                          wi( i+1 ) = zero
                       else if( a( i+1, i )/=zero .and. a( i, i+1 )==zero ) then
                          wi( i ) = zero
                          wi( i+1 ) = zero
                          if( i>1 )call stdlib_${ri}$swap( i-1, a( 1, i ), 1, a( 1, i+1 ), 1 )
                          if( n>i+1 )call stdlib_${ri}$swap( n-i-1, a( i, i+2 ), lda,a( i+1, i+2 ), &
                                    lda )
                          if( wantvs ) then
                             call stdlib_${ri}$swap( n, vs( 1, i ), 1, vs( 1, i+1 ), 1 )
                          end if
                          a( i, i+1 ) = a( i+1, i )
                          a( i+1, i ) = zero
                       end if
                       inxt = i + 2
                    end if
                 end do loop_20
              end if
              ! undo scaling for the imaginary part of the eigenvalues
              call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, n-ieval, 1,wi( ieval+1 ), max( n-ieval,&
                         1 ), ierr )
           end if
           if( wantst .and. info==0 ) then
              ! check if reordering successful
              lastsl = .true.
              lst2sl = .true.
              sdim = 0
              ip = 0
              do i = 1, n
                 cursl = select( wr( i ), wi( i ) )
                 if( wi( i )==zero ) then
                    if( cursl )sdim = sdim + 1
                    ip = 0
                    if( cursl .and. .not.lastsl )info = n + 2
                 else
                    if( ip==1 ) then
                       ! last eigenvalue of conjugate pair
                       cursl = cursl .or. lastsl
                       lastsl = cursl
                       if( cursl )sdim = sdim + 2
                       ip = -1
                       if( cursl .and. .not.lst2sl )info = n + 2
                    else
                       ! first eigenvalue of conjugate pair
                       ip = 1
                    end if
                 end if
                 lst2sl = lastsl
                 lastsl = cursl
              end do
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_${ri}$gees

#:endif
#:endfor

     module subroutine stdlib_cgees( jobvs, sort, select, n, a, lda, sdim, w, vs,ldvs, work, lwork, &
     !! CGEES computes for an N-by-N complex nonsymmetric matrix A, the
     !! eigenvalues, the Schur form T, and, optionally, the matrix of Schur
     !! vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).
     !! Optionally, it also orders the eigenvalues on the diagonal of the
     !! Schur form so that selected eigenvalues are at the top left.
     !! The leading columns of Z then form an orthonormal basis for the
     !! invariant subspace corresponding to the selected eigenvalues.
     !! A complex matrix is in Schur form if it is upper triangular.
               rwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvs, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldvs, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: vs(ldvs,*), w(*), work(*)
           ! Function Arguments 
           procedure(stdlib_select_c) :: select
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantst, wantvs
           integer(ilp) :: hswork, i, ibal, icond, ierr, ieval, ihi, ilo, itau, iwrk, maxwrk, &
                     minwrk
           real(sp) :: anrm, bignum, cscale, eps, s, sep, smlnum
           ! Local Arrays 
           real(sp) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvs = stdlib_lsame( jobvs, 'V' )
           wantst = stdlib_lsame( sort, 'S' )
           if( ( .not.wantvs ) .and. ( .not.stdlib_lsame( jobvs, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldvs<1 .or. ( wantvs .and. ldvs<n ) ) then
              info = -10
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to real
             ! workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_chseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = n + n*stdlib_ilaenv( 1, 'CGEHRD', ' ', n, 1, n, 0 )
                 minwrk = 2*n
                 call stdlib_chseqr( 'S', jobvs, n, 1, n, a, lda, w, vs, ldvs,work, -1, ieval )
                           
                 hswork = real( work( 1 ),KIND=sp)
                 if( .not.wantvs ) then
                    maxwrk = max( maxwrk, hswork )
                 else
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'CUNGHR',' ', n, 1, n, -&
                              1 ) )
                    maxwrk = max( maxwrk, hswork )
                 end if
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEES ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_clascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (cworkspace: none)
           ! (rworkspace: need n)
           ibal = 1
           call stdlib_cgebal( 'P', n, a, lda, ilo, ihi, rwork( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (cworkspace: need 2*n, prefer n+n*nb)
           ! (rworkspace: none)
           itau = 1
           iwrk = n + itau
           call stdlib_cgehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvs ) then
              ! copy householder vectors to vs
              call stdlib_clacpy( 'L', n, n, a, lda, vs, ldvs )
              ! generate unitary matrix in vs
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_cunghr( n, ilo, ihi, vs, ldvs, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
           end if
           sdim = 0
           ! perform qr iteration, accumulating schur vectors in vs if desired
           ! (cworkspace: need 1, prefer hswork (see comments) )
           ! (rworkspace: none)
           iwrk = itau
           call stdlib_chseqr( 'S', jobvs, n, ilo, ihi, a, lda, w, vs, ldvs,work( iwrk ), lwork-&
                     iwrk+1, ieval )
           if( ieval>0 )info = ieval
           ! sort eigenvalues if desired
           if( wantst .and. info==0 ) then
              if( scalea )call stdlib_clascl( 'G', 0, 0, cscale, anrm, n, 1, w, n, ierr )
              do i = 1, n
                 bwork( i ) = select( w( i ) )
              end do
              ! reorder eigenvalues and transform schur vectors
              ! (cworkspace: none)
              ! (rworkspace: none)
              call stdlib_ctrsen( 'N', jobvs, bwork, n, a, lda, vs, ldvs, w, sdim,s, sep, work( &
                        iwrk ), lwork-iwrk+1, icond )
           end if
           if( wantvs ) then
              ! undo balancing
              ! (cworkspace: none)
              ! (rworkspace: need n)
              call stdlib_cgebak( 'P', 'R', n, ilo, ihi, rwork( ibal ), n, vs, ldvs,ierr )
           end if
           if( scalea ) then
              ! undo scaling for the schur form of a
              call stdlib_clascl( 'U', 0, 0, cscale, anrm, n, n, a, lda, ierr )
              call stdlib_ccopy( n, a, lda+1, w, 1 )
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_cgees

     module subroutine stdlib_zgees( jobvs, sort, select, n, a, lda, sdim, w, vs,ldvs, work, lwork, &
     !! ZGEES computes for an N-by-N complex nonsymmetric matrix A, the
     !! eigenvalues, the Schur form T, and, optionally, the matrix of Schur
     !! vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).
     !! Optionally, it also orders the eigenvalues on the diagonal of the
     !! Schur form so that selected eigenvalues are at the top left.
     !! The leading columns of Z then form an orthonormal basis for the
     !! invariant subspace corresponding to the selected eigenvalues.
     !! A complex matrix is in Schur form if it is upper triangular.
               rwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvs, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldvs, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: vs(ldvs,*), w(*), work(*)
           ! Function Arguments 
           procedure(stdlib_select_z) :: select
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantst, wantvs
           integer(ilp) :: hswork, i, ibal, icond, ierr, ieval, ihi, ilo, itau, iwrk, maxwrk, &
                     minwrk
           real(dp) :: anrm, bignum, cscale, eps, s, sep, smlnum
           ! Local Arrays 
           real(dp) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvs = stdlib_lsame( jobvs, 'V' )
           wantst = stdlib_lsame( sort, 'S' )
           if( ( .not.wantvs ) .and. ( .not.stdlib_lsame( jobvs, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldvs<1 .or. ( wantvs .and. ldvs<n ) ) then
              info = -10
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to real
             ! workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_zhseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = n + n*stdlib_ilaenv( 1, 'ZGEHRD', ' ', n, 1, n, 0 )
                 minwrk = 2*n
                 call stdlib_zhseqr( 'S', jobvs, n, 1, n, a, lda, w, vs, ldvs,work, -1, ieval )
                           
                 hswork = real( work( 1 ),KIND=dp)
                 if( .not.wantvs ) then
                    maxwrk = max( maxwrk, hswork )
                 else
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'ZUNGHR',' ', n, 1, n, -&
                              1 ) )
                    maxwrk = max( maxwrk, hswork )
                 end if
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEES ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' )
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_zlange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_zlascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (cworkspace: none)
           ! (rworkspace: need n)
           ibal = 1
           call stdlib_zgebal( 'P', n, a, lda, ilo, ihi, rwork( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (cworkspace: need 2*n, prefer n+n*nb)
           ! (rworkspace: none)
           itau = 1
           iwrk = n + itau
           call stdlib_zgehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvs ) then
              ! copy householder vectors to vs
              call stdlib_zlacpy( 'L', n, n, a, lda, vs, ldvs )
              ! generate unitary matrix in vs
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_zunghr( n, ilo, ihi, vs, ldvs, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
           end if
           sdim = 0
           ! perform qr iteration, accumulating schur vectors in vs if desired
           ! (cworkspace: need 1, prefer hswork (see comments) )
           ! (rworkspace: none)
           iwrk = itau
           call stdlib_zhseqr( 'S', jobvs, n, ilo, ihi, a, lda, w, vs, ldvs,work( iwrk ), lwork-&
                     iwrk+1, ieval )
           if( ieval>0 )info = ieval
           ! sort eigenvalues if desired
           if( wantst .and. info==0 ) then
              if( scalea )call stdlib_zlascl( 'G', 0, 0, cscale, anrm, n, 1, w, n, ierr )
              do i = 1, n
                 bwork( i ) = select( w( i ) )
              end do
              ! reorder eigenvalues and transform schur vectors
              ! (cworkspace: none)
              ! (rworkspace: none)
              call stdlib_ztrsen( 'N', jobvs, bwork, n, a, lda, vs, ldvs, w, sdim,s, sep, work( &
                        iwrk ), lwork-iwrk+1, icond )
           end if
           if( wantvs ) then
              ! undo balancing
              ! (cworkspace: none)
              ! (rworkspace: need n)
              call stdlib_zgebak( 'P', 'R', n, ilo, ihi, rwork( ibal ), n, vs, ldvs,ierr )
           end if
           if( scalea ) then
              ! undo scaling for the schur form of a
              call stdlib_zlascl( 'U', 0, 0, cscale, anrm, n, n, a, lda, ierr )
              call stdlib_zcopy( n, a, lda+1, w, 1 )
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_zgees

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$gees( jobvs, sort, select, n, a, lda, sdim, w, vs,ldvs, work, lwork, &
     !! ZGEES: computes for an N-by-N complex nonsymmetric matrix A, the
     !! eigenvalues, the Schur form T, and, optionally, the matrix of Schur
     !! vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).
     !! Optionally, it also orders the eigenvalues on the diagonal of the
     !! Schur form so that selected eigenvalues are at the top left.
     !! The leading columns of Z then form an orthonormal basis for the
     !! invariant subspace corresponding to the selected eigenvalues.
     !! A complex matrix is in Schur form if it is upper triangular.
               rwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvs, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldvs, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: vs(ldvs,*), w(*), work(*)
           ! Function Arguments 
           procedure(stdlib_select_${ci}$) :: select
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantst, wantvs
           integer(ilp) :: hswork, i, ibal, icond, ierr, ieval, ihi, ilo, itau, iwrk, maxwrk, &
                     minwrk
           real(${ck}$) :: anrm, bignum, cscale, eps, s, sep, smlnum
           ! Local Arrays 
           real(${ck}$) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvs = stdlib_lsame( jobvs, 'V' )
           wantst = stdlib_lsame( sort, 'S' )
           if( ( .not.wantvs ) .and. ( .not.stdlib_lsame( jobvs, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldvs<1 .or. ( wantvs .and. ldvs<n ) ) then
              info = -10
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to real
             ! workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_${ci}$hseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = n + n*stdlib_ilaenv( 1, 'ZGEHRD', ' ', n, 1, n, 0 )
                 minwrk = 2*n
                 call stdlib_${ci}$hseqr( 'S', jobvs, n, 1, n, a, lda, w, vs, ldvs,work, -1, ieval )
                           
                 hswork = real( work( 1 ),KIND=${ck}$)
                 if( .not.wantvs ) then
                    maxwrk = max( maxwrk, hswork )
                 else
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'ZUNGHR',' ', n, 1, n, -&
                              1 ) )
                    maxwrk = max( maxwrk, hswork )
                 end if
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEES ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_${c2ri(ci)}$lamch( 'P' )
           smlnum = stdlib_${c2ri(ci)}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${c2ri(ci)}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ci}$lange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_${ci}$lascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (cworkspace: none)
           ! (rworkspace: need n)
           ibal = 1
           call stdlib_${ci}$gebal( 'P', n, a, lda, ilo, ihi, rwork( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (cworkspace: need 2*n, prefer n+n*nb)
           ! (rworkspace: none)
           itau = 1
           iwrk = n + itau
           call stdlib_${ci}$gehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvs ) then
              ! copy householder vectors to vs
              call stdlib_${ci}$lacpy( 'L', n, n, a, lda, vs, ldvs )
              ! generate unitary matrix in vs
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_${ci}$unghr( n, ilo, ihi, vs, ldvs, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
           end if
           sdim = 0
           ! perform qr iteration, accumulating schur vectors in vs if desired
           ! (cworkspace: need 1, prefer hswork (see comments) )
           ! (rworkspace: none)
           iwrk = itau
           call stdlib_${ci}$hseqr( 'S', jobvs, n, ilo, ihi, a, lda, w, vs, ldvs,work( iwrk ), lwork-&
                     iwrk+1, ieval )
           if( ieval>0 )info = ieval
           ! sort eigenvalues if desired
           if( wantst .and. info==0 ) then
              if( scalea )call stdlib_${ci}$lascl( 'G', 0, 0, cscale, anrm, n, 1, w, n, ierr )
              do i = 1, n
                 bwork( i ) = select( w( i ) )
              end do
              ! reorder eigenvalues and transform schur vectors
              ! (cworkspace: none)
              ! (rworkspace: none)
              call stdlib_${ci}$trsen( 'N', jobvs, bwork, n, a, lda, vs, ldvs, w, sdim,s, sep, work( &
                        iwrk ), lwork-iwrk+1, icond )
           end if
           if( wantvs ) then
              ! undo balancing
              ! (cworkspace: none)
              ! (rworkspace: need n)
              call stdlib_${ci}$gebak( 'P', 'R', n, ilo, ihi, rwork( ibal ), n, vs, ldvs,ierr )
           end if
           if( scalea ) then
              ! undo scaling for the schur form of a
              call stdlib_${ci}$lascl( 'U', 0, 0, cscale, anrm, n, n, a, lda, ierr )
              call stdlib_${ci}$copy( n, a, lda+1, w, 1 )
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_${ci}$gees

#:endif
#:endfor



     module pure subroutine stdlib_sgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! SGGHRD reduces a pair of real matrices (A,B) to generalized upper
     !! Hessenberg form using orthogonal transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the orthogonal matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**T*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**T*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**T*x.
     !! The orthogonal matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T
     !! Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T
     !! If Q1 is the orthogonal matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then SGGHRD reduces the original
     !! problem to generalized Hessenberg form.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilq, ilz
           integer(ilp) :: icompq, icompz, jcol, jrow
           real(sp) :: c, s, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode compq
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              icompq = 0
           end if
           ! decode compz
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              icompz = 0
           end if
           ! test the input parameters.
           info = 0
           if( icompq<=0 ) then
              info = -1
           else if( icompz<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( ilq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( ilz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGGHRD', -info )
              return
           end if
           ! initialize q and z if desired.
           if( icompq==3 )call stdlib_slaset( 'FULL', n, n, zero, one, q, ldq )
           if( icompz==3 )call stdlib_slaset( 'FULL', n, n, zero, one, z, ldz )
           ! quick return if possible
           if( n<=1 )return
           ! zero out lower triangle of b
           do jcol = 1, n - 1
              do jrow = jcol + 1, n
                 b( jrow, jcol ) = zero
              end do
           end do
           ! reduce a and b
           do jcol = ilo, ihi - 2
              do jrow = ihi, jcol + 2, -1
                 ! step 1: rotate rows jrow-1, jrow to kill a(jrow,jcol)
                 temp = a( jrow-1, jcol )
                 call stdlib_slartg( temp, a( jrow, jcol ), c, s,a( jrow-1, jcol ) )
                 a( jrow, jcol ) = zero
                 call stdlib_srot( n-jcol, a( jrow-1, jcol+1 ), lda,a( jrow, jcol+1 ), lda, c, s )
                           
                 call stdlib_srot( n+2-jrow, b( jrow-1, jrow-1 ), ldb,b( jrow, jrow-1 ), ldb, c, &
                           s )
                 if( ilq )call stdlib_srot( n, q( 1, jrow-1 ), 1, q( 1, jrow ), 1, c, s )
                 ! step 2: rotate columns jrow, jrow-1 to kill b(jrow,jrow-1)
                 temp = b( jrow, jrow )
                 call stdlib_slartg( temp, b( jrow, jrow-1 ), c, s,b( jrow, jrow ) )
                 b( jrow, jrow-1 ) = zero
                 call stdlib_srot( ihi, a( 1, jrow ), 1, a( 1, jrow-1 ), 1, c, s )
                 call stdlib_srot( jrow-1, b( 1, jrow ), 1, b( 1, jrow-1 ), 1, c,s )
                 if( ilz )call stdlib_srot( n, z( 1, jrow ), 1, z( 1, jrow-1 ), 1, c, s )
              end do
           end do
           return
     end subroutine stdlib_sgghrd

     module pure subroutine stdlib_dgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! DGGHRD reduces a pair of real matrices (A,B) to generalized upper
     !! Hessenberg form using orthogonal transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the orthogonal matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**T*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**T*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**T*x.
     !! The orthogonal matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T
     !! Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T
     !! If Q1 is the orthogonal matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then DGGHRD reduces the original
     !! problem to generalized Hessenberg form.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilq, ilz
           integer(ilp) :: icompq, icompz, jcol, jrow
           real(dp) :: c, s, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode compq
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              icompq = 0
           end if
           ! decode compz
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              icompz = 0
           end if
           ! test the input parameters.
           info = 0
           if( icompq<=0 ) then
              info = -1
           else if( icompz<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( ilq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( ilz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGHRD', -info )
              return
           end if
           ! initialize q and z if desired.
           if( icompq==3 )call stdlib_dlaset( 'FULL', n, n, zero, one, q, ldq )
           if( icompz==3 )call stdlib_dlaset( 'FULL', n, n, zero, one, z, ldz )
           ! quick return if possible
           if( n<=1 )return
           ! zero out lower triangle of b
           do jcol = 1, n - 1
              do jrow = jcol + 1, n
                 b( jrow, jcol ) = zero
              end do
           end do
           ! reduce a and b
           do jcol = ilo, ihi - 2
              do jrow = ihi, jcol + 2, -1
                 ! step 1: rotate rows jrow-1, jrow to kill a(jrow,jcol)
                 temp = a( jrow-1, jcol )
                 call stdlib_dlartg( temp, a( jrow, jcol ), c, s,a( jrow-1, jcol ) )
                 a( jrow, jcol ) = zero
                 call stdlib_drot( n-jcol, a( jrow-1, jcol+1 ), lda,a( jrow, jcol+1 ), lda, c, s )
                           
                 call stdlib_drot( n+2-jrow, b( jrow-1, jrow-1 ), ldb,b( jrow, jrow-1 ), ldb, c, &
                           s )
                 if( ilq )call stdlib_drot( n, q( 1, jrow-1 ), 1, q( 1, jrow ), 1, c, s )
                 ! step 2: rotate columns jrow, jrow-1 to kill b(jrow,jrow-1)
                 temp = b( jrow, jrow )
                 call stdlib_dlartg( temp, b( jrow, jrow-1 ), c, s,b( jrow, jrow ) )
                 b( jrow, jrow-1 ) = zero
                 call stdlib_drot( ihi, a( 1, jrow ), 1, a( 1, jrow-1 ), 1, c, s )
                 call stdlib_drot( jrow-1, b( 1, jrow ), 1, b( 1, jrow-1 ), 1, c,s )
                 if( ilz )call stdlib_drot( n, z( 1, jrow ), 1, z( 1, jrow-1 ), 1, c, s )
              end do
           end do
           return
     end subroutine stdlib_dgghrd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$gghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! DGGHRD: reduces a pair of real matrices (A,B) to generalized upper
     !! Hessenberg form using orthogonal transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the orthogonal matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**T*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**T*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**T*x.
     !! The orthogonal matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T
     !! Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T
     !! If Q1 is the orthogonal matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then DGGHRD reduces the original
     !! problem to generalized Hessenberg form.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilq, ilz
           integer(ilp) :: icompq, icompz, jcol, jrow
           real(${rk}$) :: c, s, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode compq
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              icompq = 0
           end if
           ! decode compz
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              icompz = 0
           end if
           ! test the input parameters.
           info = 0
           if( icompq<=0 ) then
              info = -1
           else if( icompz<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( ilq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( ilz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGHRD', -info )
              return
           end if
           ! initialize q and z if desired.
           if( icompq==3 )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, q, ldq )
           if( icompz==3 )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, z, ldz )
           ! quick return if possible
           if( n<=1 )return
           ! zero out lower triangle of b
           do jcol = 1, n - 1
              do jrow = jcol + 1, n
                 b( jrow, jcol ) = zero
              end do
           end do
           ! reduce a and b
           do jcol = ilo, ihi - 2
              do jrow = ihi, jcol + 2, -1
                 ! step 1: rotate rows jrow-1, jrow to kill a(jrow,jcol)
                 temp = a( jrow-1, jcol )
                 call stdlib_${ri}$lartg( temp, a( jrow, jcol ), c, s,a( jrow-1, jcol ) )
                 a( jrow, jcol ) = zero
                 call stdlib_${ri}$rot( n-jcol, a( jrow-1, jcol+1 ), lda,a( jrow, jcol+1 ), lda, c, s )
                           
                 call stdlib_${ri}$rot( n+2-jrow, b( jrow-1, jrow-1 ), ldb,b( jrow, jrow-1 ), ldb, c, &
                           s )
                 if( ilq )call stdlib_${ri}$rot( n, q( 1, jrow-1 ), 1, q( 1, jrow ), 1, c, s )
                 ! step 2: rotate columns jrow, jrow-1 to kill b(jrow,jrow-1)
                 temp = b( jrow, jrow )
                 call stdlib_${ri}$lartg( temp, b( jrow, jrow-1 ), c, s,b( jrow, jrow ) )
                 b( jrow, jrow-1 ) = zero
                 call stdlib_${ri}$rot( ihi, a( 1, jrow ), 1, a( 1, jrow-1 ), 1, c, s )
                 call stdlib_${ri}$rot( jrow-1, b( 1, jrow ), 1, b( 1, jrow-1 ), 1, c,s )
                 if( ilz )call stdlib_${ri}$rot( n, z( 1, jrow ), 1, z( 1, jrow-1 ), 1, c, s )
              end do
           end do
           return
     end subroutine stdlib_${ri}$gghrd

#:endif
#:endfor

     module pure subroutine stdlib_cgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! CGGHRD reduces a pair of complex matrices (A,B) to generalized upper
     !! Hessenberg form using unitary transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the generalized
     !! eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the unitary matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**H*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**H*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**H*x.
     !! The unitary matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H
     !! Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H
     !! If Q1 is the unitary matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then CGGHRD reduces the original
     !! problem to generalized Hessenberg form.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilq, ilz
           integer(ilp) :: icompq, icompz, jcol, jrow
           real(sp) :: c
           complex(sp) :: ctemp, s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode compq
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              icompq = 0
           end if
           ! decode compz
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              icompz = 0
           end if
           ! test the input parameters.
           info = 0
           if( icompq<=0 ) then
              info = -1
           else if( icompz<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( ilq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( ilz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGHRD', -info )
              return
           end if
           ! initialize q and z if desired.
           if( icompq==3 )call stdlib_claset( 'FULL', n, n, czero, cone, q, ldq )
           if( icompz==3 )call stdlib_claset( 'FULL', n, n, czero, cone, z, ldz )
           ! quick return if possible
           if( n<=1 )return
           ! zero out lower triangle of b
           do jcol = 1, n - 1
              do jrow = jcol + 1, n
                 b( jrow, jcol ) = czero
              end do
           end do
           ! reduce a and b
           do jcol = ilo, ihi - 2
              do jrow = ihi, jcol + 2, -1
                 ! step 1: rotate rows jrow-1, jrow to kill a(jrow,jcol)
                 ctemp = a( jrow-1, jcol )
                 call stdlib_clartg( ctemp, a( jrow, jcol ), c, s,a( jrow-1, jcol ) )
                 a( jrow, jcol ) = czero
                 call stdlib_crot( n-jcol, a( jrow-1, jcol+1 ), lda,a( jrow, jcol+1 ), lda, c, s )
                           
                 call stdlib_crot( n+2-jrow, b( jrow-1, jrow-1 ), ldb,b( jrow, jrow-1 ), ldb, c, &
                           s )
                 if( ilq )call stdlib_crot( n, q( 1, jrow-1 ), 1, q( 1, jrow ), 1, c,conjg( s ) )
                           
                 ! step 2: rotate columns jrow, jrow-1 to kill b(jrow,jrow-1)
                 ctemp = b( jrow, jrow )
                 call stdlib_clartg( ctemp, b( jrow, jrow-1 ), c, s,b( jrow, jrow ) )
                 b( jrow, jrow-1 ) = czero
                 call stdlib_crot( ihi, a( 1, jrow ), 1, a( 1, jrow-1 ), 1, c, s )
                 call stdlib_crot( jrow-1, b( 1, jrow ), 1, b( 1, jrow-1 ), 1, c,s )
                 if( ilz )call stdlib_crot( n, z( 1, jrow ), 1, z( 1, jrow-1 ), 1, c, s )
              end do
           end do
           return
     end subroutine stdlib_cgghrd

     module pure subroutine stdlib_zgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! ZGGHRD reduces a pair of complex matrices (A,B) to generalized upper
     !! Hessenberg form using unitary transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the unitary matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**H*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**H*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**H*x.
     !! The unitary matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H
     !! Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H
     !! If Q1 is the unitary matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then ZGGHRD reduces the original
     !! problem to generalized Hessenberg form.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilq, ilz
           integer(ilp) :: icompq, icompz, jcol, jrow
           real(dp) :: c
           complex(dp) :: ctemp, s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode compq
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              icompq = 0
           end if
           ! decode compz
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              icompz = 0
           end if
           ! test the input parameters.
           info = 0
           if( icompq<=0 ) then
              info = -1
           else if( icompz<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( ilq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( ilz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGHRD', -info )
              return
           end if
           ! initialize q and z if desired.
           if( icompq==3 )call stdlib_zlaset( 'FULL', n, n, czero, cone, q, ldq )
           if( icompz==3 )call stdlib_zlaset( 'FULL', n, n, czero, cone, z, ldz )
           ! quick return if possible
           if( n<=1 )return
           ! zero out lower triangle of b
           do jcol = 1, n - 1
              do jrow = jcol + 1, n
                 b( jrow, jcol ) = czero
              end do
           end do
           ! reduce a and b
           do jcol = ilo, ihi - 2
              do jrow = ihi, jcol + 2, -1
                 ! step 1: rotate rows jrow-1, jrow to kill a(jrow,jcol)
                 ctemp = a( jrow-1, jcol )
                 call stdlib_zlartg( ctemp, a( jrow, jcol ), c, s,a( jrow-1, jcol ) )
                 a( jrow, jcol ) = czero
                 call stdlib_zrot( n-jcol, a( jrow-1, jcol+1 ), lda,a( jrow, jcol+1 ), lda, c, s )
                           
                 call stdlib_zrot( n+2-jrow, b( jrow-1, jrow-1 ), ldb,b( jrow, jrow-1 ), ldb, c, &
                           s )
                 if( ilq )call stdlib_zrot( n, q( 1, jrow-1 ), 1, q( 1, jrow ), 1, c,conjg( s ) )
                           
                 ! step 2: rotate columns jrow, jrow-1 to kill b(jrow,jrow-1)
                 ctemp = b( jrow, jrow )
                 call stdlib_zlartg( ctemp, b( jrow, jrow-1 ), c, s,b( jrow, jrow ) )
                 b( jrow, jrow-1 ) = czero
                 call stdlib_zrot( ihi, a( 1, jrow ), 1, a( 1, jrow-1 ), 1, c, s )
                 call stdlib_zrot( jrow-1, b( 1, jrow ), 1, b( 1, jrow-1 ), 1, c,s )
                 if( ilz )call stdlib_zrot( n, z( 1, jrow ), 1, z( 1, jrow-1 ), 1, c, s )
              end do
           end do
           return
     end subroutine stdlib_zgghrd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$gghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! ZGGHRD: reduces a pair of complex matrices (A,B) to generalized upper
     !! Hessenberg form using unitary transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the unitary matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**H*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**H*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**H*x.
     !! The unitary matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H
     !! Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H
     !! If Q1 is the unitary matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then ZGGHRD reduces the original
     !! problem to generalized Hessenberg form.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilq, ilz
           integer(ilp) :: icompq, icompz, jcol, jrow
           real(${ck}$) :: c
           complex(${ck}$) :: ctemp, s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode compq
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              icompq = 0
           end if
           ! decode compz
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              icompz = 0
           end if
           ! test the input parameters.
           info = 0
           if( icompq<=0 ) then
              info = -1
           else if( icompz<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( ilq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( ilz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGHRD', -info )
              return
           end if
           ! initialize q and z if desired.
           if( icompq==3 )call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, q, ldq )
           if( icompz==3 )call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, z, ldz )
           ! quick return if possible
           if( n<=1 )return
           ! zero out lower triangle of b
           do jcol = 1, n - 1
              do jrow = jcol + 1, n
                 b( jrow, jcol ) = czero
              end do
           end do
           ! reduce a and b
           do jcol = ilo, ihi - 2
              do jrow = ihi, jcol + 2, -1
                 ! step 1: rotate rows jrow-1, jrow to kill a(jrow,jcol)
                 ctemp = a( jrow-1, jcol )
                 call stdlib_${ci}$lartg( ctemp, a( jrow, jcol ), c, s,a( jrow-1, jcol ) )
                 a( jrow, jcol ) = czero
                 call stdlib_${ci}$rot( n-jcol, a( jrow-1, jcol+1 ), lda,a( jrow, jcol+1 ), lda, c, s )
                           
                 call stdlib_${ci}$rot( n+2-jrow, b( jrow-1, jrow-1 ), ldb,b( jrow, jrow-1 ), ldb, c, &
                           s )
                 if( ilq )call stdlib_${ci}$rot( n, q( 1, jrow-1 ), 1, q( 1, jrow ), 1, c,conjg( s ) )
                           
                 ! step 2: rotate columns jrow, jrow-1 to kill b(jrow,jrow-1)
                 ctemp = b( jrow, jrow )
                 call stdlib_${ci}$lartg( ctemp, b( jrow, jrow-1 ), c, s,b( jrow, jrow ) )
                 b( jrow, jrow-1 ) = czero
                 call stdlib_${ci}$rot( ihi, a( 1, jrow ), 1, a( 1, jrow-1 ), 1, c, s )
                 call stdlib_${ci}$rot( jrow-1, b( 1, jrow ), 1, b( 1, jrow-1 ), 1, c,s )
                 if( ilz )call stdlib_${ci}$rot( n, z( 1, jrow ), 1, z( 1, jrow-1 ), 1, c, s )
              end do
           end do
           return
     end subroutine stdlib_${ci}$gghrd

#:endif
#:endfor



     module pure subroutine stdlib_slaqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts,sr, si, h, ldh, &
     !! SLAQR5 , called by SLAQR0, performs a
     !! single small-bulge multi-shift QR sweep.
               iloz, ihiz, z, ldz, v, ldv, u,ldu, nv, wv, ldwv, nh, wh, ldwh )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv, ldwh, ldwv, &
                     ldz, n, nh, nshfts, nv
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(sp), intent(inout) :: h(ldh,*), si(*), sr(*), z(ldz,*)
           real(sp), intent(out) :: u(ldu,*), v(ldv,*), wh(ldwh,*), wv(ldwv,*)
        ! ================================================================
           
           ! Local Scalars 
           real(sp) :: alpha, beta, h11, h12, h21, h22, refsum, safmax, safmin, scl, smlnum, swap,&
                      tst1, tst2, ulp
           integer(ilp) :: i, i2, i4, incol, j, jbot, jcol, jlen, jrow, jtop, k, k1, kdu, kms, &
                     krcol, m, m22, mbot, mtop, nbmps, ndcol, ns, nu
           logical(lk) :: accum, bmp22
           ! Intrinsic Functions 
           ! Local Arrays 
           real(sp) :: vt(3)
           ! Executable Statements 
           ! ==== if there are no shifts, then there is nothing to do. ====
           if( nshfts<2 )return
           ! ==== if the active block is empty or 1-by-1, then there
           ! .    is nothing to do. ====
           if( ktop>=kbot )return
           ! ==== shuffle shifts into pairs of real shifts and pairs
           ! .    of complex conjugate shifts assuming complex
           ! .    conjugate shifts are already adjacent to one
           ! .    another. ====
           do i = 1, nshfts - 2, 2
              if( si( i )/=-si( i+1 ) ) then
                 swap = sr( i )
                 sr( i ) = sr( i+1 )
                 sr( i+1 ) = sr( i+2 )
                 sr( i+2 ) = swap
                 swap = si( i )
                 si( i ) = si( i+1 )
                 si( i+1 ) = si( i+2 )
                 si( i+2 ) = swap
              end if
           end do
           ! ==== nshfts is supposed to be even, but if it is odd,
           ! .    then simply reduce it by one.  the shuffle above
           ! .    ensures that the dropped shift is real and that
           ! .    the remaining shifts are paired. ====
           ns = nshfts - mod( nshfts, 2 )
           ! ==== machine constants for deflation ====
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = one / safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=sp) / ulp )
           ! ==== use accumulated reflections to update far-from-diagonal
           ! .    entries ? ====
           accum = ( kacc22==1 ) .or. ( kacc22==2 )
           ! ==== clear trash ====
           if( ktop+2<=kbot )h( ktop+2, ktop ) = zero
           ! ==== nbmps = number of 2-shift bulges in the chain ====
           nbmps = ns / 2
           ! ==== kdu = width of slab ====
           kdu = 4*nbmps
           ! ==== create and chase chains of nbmps bulges ====
           loop_180: do incol = ktop - 2*nbmps + 1, kbot - 2, 2*nbmps
              ! jtop = index from which updates from the right start.
              if( accum ) then
                 jtop = max( ktop, incol )
              else if( wantt ) then
                 jtop = 1
              else
                 jtop = ktop
              end if
              ndcol = incol + kdu
              if( accum )call stdlib_slaset( 'ALL', kdu, kdu, zero, one, u, ldu )
              ! ==== near-the-diagonal bulge chase.  the following loop
              ! .    performs the near-the-diagonal part of a small bulge
              ! .    multi-shift qr sweep.  each 4*nbmps column diagonal
              ! .    chunk extends from column incol to column ndcol
              ! .    (including both column incol and column ndcol). the
              ! .    following loop chases a 2*nbmps+1 column long chain of
              ! .    nbmps bulges 2*nbmps-1 columns to the right.  (incol
              ! .    may be less than ktop and and ndcol may be greater than
              ! .    kbot indicating phantom columns from which to chase
              ! .    bulges before they are actually introduced or to which
              ! .    to chase bulges beyond column kbot.)  ====
              loop_145: do krcol = incol, min( incol+2*nbmps-1, kbot-2 )
                 ! ==== bulges number mtop to mbot are active double implicit
                 ! .    shift bulges.  there may or may not also be small
                 ! .    2-by-2 bulge, if there is room.  the inactive bulges
                 ! .    (if any) must wait until the active bulges have moved
                 ! .    down the diagonal to make room.  the phantom matrix
                 ! .    paradigm described above helps keep track.  ====
                 mtop = max( 1, ( ktop-krcol ) / 2+1 )
                 mbot = min( nbmps, ( kbot-krcol-1 ) / 2 )
                 m22 = mbot + 1
                 bmp22 = ( mbot<nbmps ) .and. ( krcol+2*( m22-1 ) )==( kbot-2 )
                 ! ==== generate reflections to chase the chain right
                 ! .    one column.  (the minimum value of k is ktop-1.) ====
                 if ( bmp22 ) then
                    ! ==== special case: 2-by-2 reflection at bottom treated
                    ! .    separately ====
                    k = krcol + 2*( m22-1 )
                    if( k==ktop-1 ) then
                       call stdlib_slaqr1( 2, h( k+1, k+1 ), ldh, sr( 2*m22-1 ),si( 2*m22-1 ), sr(&
                                  2*m22 ), si( 2*m22 ),v( 1, m22 ) )
                       beta = v( 1, m22 )
                       call stdlib_slarfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                    else
                       beta = h( k+1, k )
                       v( 2, m22 ) = h( k+2, k )
                       call stdlib_slarfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                       h( k+1, k ) = beta
                       h( k+2, k ) = zero
                    end if
                    ! ==== perform update from right within
                    ! .    computational window. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m22 )*( h( j, k+1 )+v( 2, m22 )*h( j, k+2 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) - refsum*v( 2, m22 )
                    end do
                    ! ==== perform update from left within
                    ! .    computational window. ====
                    if( accum ) then
                       jbot = min( ndcol, kbot )
                    else if( wantt ) then
                       jbot = n
                    else
                       jbot = kbot
                    end if
                    do j = k+1, jbot
                       refsum = v( 1, m22 )*( h( k+1, j )+v( 2, m22 )*h( k+2, j ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m22 )
                    end do
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is zero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k>=ktop ) then
                       if( h( k+1, k )/=zero ) then
                          tst1 = abs( h( k, k ) ) + abs( h( k+1, k+1 ) )
                          if( tst1==zero ) then
                             if( k>=ktop+1 )tst1 = tst1 + abs( h( k, k-1 ) )
                             if( k>=ktop+2 )tst1 = tst1 + abs( h( k, k-2 ) )
                             if( k>=ktop+3 )tst1 = tst1 + abs( h( k, k-3 ) )
                             if( k<=kbot-2 )tst1 = tst1 + abs( h( k+2, k+1 ) )
                             if( k<=kbot-3 )tst1 = tst1 + abs( h( k+3, k+1 ) )
                             if( k<=kbot-4 )tst1 = tst1 + abs( h( k+4, k+1 ) )
                          end if
                          if( abs( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) )then
                             h12 = max( abs( h( k+1, k ) ),abs( h( k, k+1 ) ) )
                             h21 = min( abs( h( k+1, k ) ),abs( h( k, k+1 ) ) )
                             h11 = max( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             h22 = min( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             scl = h11 + h12
                             tst2 = h22*( h11 / scl )
                             if( tst2==zero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) ) &
                                       then
                                h( k+1, k ) = zero
                             end if
                          end if
                       end if
                    end if
                    ! ==== accumulate orthogonal transformations. ====
                    if( accum ) then
                       kms = k - incol
                       do j = max( 1, ktop-incol ), kdu
                          refsum = v( 1, m22 )*( u( j, kms+1 )+v( 2, m22 )*u( j, kms+2 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) - refsum*v( 2, m22 )
                       end do
                    else if( wantz ) then
                       do j = iloz, ihiz
                          refsum = v( 1, m22 )*( z( j, k+1 )+v( 2, m22 )*z( j, k+2 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) - refsum*v( 2, m22 )
                       end do
                    end if
                 end if
                 ! ==== normal case: chain of 3-by-3 reflections ====
                 loop_80: do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    if( k==ktop-1 ) then
                       call stdlib_slaqr1( 3, h( ktop, ktop ), ldh, sr( 2*m-1 ),si( 2*m-1 ), sr( &
                                 2*m ), si( 2*m ),v( 1, m ) )
                       alpha = v( 1, m )
                       call stdlib_slarfg( 3, alpha, v( 2, m ), 1, v( 1, m ) )
                    else
                       ! ==== perform delayed transformation of row below
                       ! .    mth bulge. exploit fact that first two elements
                       ! .    of row are actually zero. ====
                       refsum = v( 1, m )*v( 3, m )*h( k+3, k+2 )
                       h( k+3, k   ) = -refsum
                       h( k+3, k+1 ) = -refsum*v( 2, m )
                       h( k+3, k+2 ) = h( k+3, k+2 ) - refsum*v( 3, m )
                       ! ==== calculate reflection to move
                       ! .    mth bulge one step. ====
                       beta      = h( k+1, k )
                       v( 2, m ) = h( k+2, k )
                       v( 3, m ) = h( k+3, k )
                       call stdlib_slarfg( 3, beta, v( 2, m ), 1, v( 1, m ) )
                       ! ==== a bulge may collapse because of vigilant
                       ! .    deflation or destructive underflow.  in the
                       ! .    underflow case, try the two-small-subdiagonals
                       ! .    trick to try to reinflate the bulge.  ====
                       if( h( k+3, k )/=zero .or. h( k+3, k+1 )/=zero .or. h( k+3, k+2 )==zero ) &
                                 then
                          ! ==== typical case: not collapsed (yet). ====
                          h( k+1, k ) = beta
                          h( k+2, k ) = zero
                          h( k+3, k ) = zero
                       else
                          ! ==== atypical case: collapsed.  attempt to
                          ! .    reintroduce ignoring h(k+1,k) and h(k+2,k).
                          ! .    if the fill resulting from the new
                          ! .    reflector is too large, then abandon it.
                          ! .    otherwise, use the new one. ====
                          call stdlib_slaqr1( 3, h( k+1, k+1 ), ldh, sr( 2*m-1 ),si( 2*m-1 ), sr( &
                                    2*m ), si( 2*m ),vt )
                          alpha = vt( 1 )
                          call stdlib_slarfg( 3, alpha, vt( 2 ), 1, vt( 1 ) )
                          refsum = vt( 1 )*( h( k+1, k )+vt( 2 )*h( k+2, k ) )
                          if( abs( h( k+2, k )-refsum*vt( 2 ) )+abs( refsum*vt( 3 ) )>ulp*( abs( &
                                    h( k, k ) )+abs( h( k+1,k+1 ) )+abs( h( k+2, k+2 ) ) ) ) then
                             ! ==== starting a new bulge here would
                             ! .    create non-negligible fill.  use
                             ! .    the old one with trepidation. ====
                             h( k+1, k ) = beta
                             h( k+2, k ) = zero
                             h( k+3, k ) = zero
                          else
                             ! ==== starting a new bulge here would
                             ! .    create only negligible fill.
                             ! .    replace the old reflector with
                             ! .    the new one. ====
                             h( k+1, k ) = h( k+1, k ) - refsum
                             h( k+2, k ) = zero
                             h( k+3, k ) = zero
                             v( 1, m ) = vt( 1 )
                             v( 2, m ) = vt( 2 )
                             v( 3, m ) = vt( 3 )
                          end if
                       end if
                    end if
                    ! ====  apply reflection from the right and
                    ! .     the first column of update from the left.
                    ! .     these updates are required for the vigilant
                    ! .     deflation check. we still delay most of the
                    ! .     updates from the left for efficiency. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m )*( h( j, k+1 )+v( 2, m )*h( j, k+2 )+v( 3, m )*h( j, k+3 &
                                 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) - refsum*v( 2, m )
                       h( j, k+3 ) = h( j, k+3 ) - refsum*v( 3, m )
                    end do
                    ! ==== perform update from left for subsequent
                    ! .    column. ====
                    refsum = v( 1, m )*( h( k+1, k+1 )+v( 2, m )*h( k+2, k+1 )+v( 3, m )*h( k+3, &
                              k+1 ) )
                    h( k+1, k+1 ) = h( k+1, k+1 ) - refsum
                    h( k+2, k+1 ) = h( k+2, k+1 ) - refsum*v( 2, m )
                    h( k+3, k+1 ) = h( k+3, k+1 ) - refsum*v( 3, m )
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is zero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k<ktop)cycle
                    if( h( k+1, k )/=zero ) then
                       tst1 = abs( h( k, k ) ) + abs( h( k+1, k+1 ) )
                       if( tst1==zero ) then
                          if( k>=ktop+1 )tst1 = tst1 + abs( h( k, k-1 ) )
                          if( k>=ktop+2 )tst1 = tst1 + abs( h( k, k-2 ) )
                          if( k>=ktop+3 )tst1 = tst1 + abs( h( k, k-3 ) )
                          if( k<=kbot-2 )tst1 = tst1 + abs( h( k+2, k+1 ) )
                          if( k<=kbot-3 )tst1 = tst1 + abs( h( k+3, k+1 ) )
                          if( k<=kbot-4 )tst1 = tst1 + abs( h( k+4, k+1 ) )
                       end if
                       if( abs( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) )then
                          h12 = max( abs( h( k+1, k ) ), abs( h( k, k+1 ) ) )
                          h21 = min( abs( h( k+1, k ) ), abs( h( k, k+1 ) ) )
                          h11 = max( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                          h22 = min( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                          scl = h11 + h12
                          tst2 = h22*( h11 / scl )
                          if( tst2==zero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) ) &
                                    then
                             h( k+1, k ) = zero
                          end if
                       end if
                    end if
                 end do loop_80
                 ! ==== multiply h by reflections from the left ====
                 if( accum ) then
                    jbot = min( ndcol, kbot )
                 else if( wantt ) then
                    jbot = n
                 else
                    jbot = kbot
                 end if
                 do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    do j = max( ktop, krcol + 2*m ), jbot
                       refsum = v( 1, m )*( h( k+1, j )+v( 2, m )*h( k+2, j )+v( 3, m )*h( k+3, j &
                                 ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m )
                       h( k+3, j ) = h( k+3, j ) - refsum*v( 3, m )
                    end do
                 end do
                 ! ==== accumulate orthogonal transformations. ====
                 if( accum ) then
                    ! ==== accumulate u. (if needed, update z later
                    ! .    with an efficient matrix-matrix
                    ! .    multiply.) ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       kms = k - incol
                       i2 = max( 1, ktop-incol )
                       i2 = max( i2, kms-(krcol-incol)+1 )
                       i4 = min( kdu, krcol + 2*( mbot-1 ) - incol + 5 )
                       do j = i2, i4
                          refsum = v( 1, m )*( u( j, kms+1 )+v( 2, m )*u( j, kms+2 )+v( 3, m )*u( &
                                    j, kms+3 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) - refsum*v( 2, m )
                          u( j, kms+3 ) = u( j, kms+3 ) - refsum*v( 3, m )
                       end do
                    end do
                 else if( wantz ) then
                    ! ==== u is not accumulated, so update z
                    ! .    now by multiplying by reflections
                    ! .    from the right. ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       do j = iloz, ihiz
                          refsum = v( 1, m )*( z( j, k+1 )+v( 2, m )*z( j, k+2 )+v( 3, m )*z( j, &
                                    k+3 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) - refsum*v( 2, m )
                          z( j, k+3 ) = z( j, k+3 ) - refsum*v( 3, m )
                       end do
                    end do
                 end if
                 ! ==== end of near-the-diagonal bulge chase. ====
              end do loop_145
              ! ==== use u (if accumulated) to update far-from-diagonal
              ! .    entries in h.  if required, use u to update z as
              ! .    well. ====
              if( accum ) then
                 if( wantt ) then
                    jtop = 1
                    jbot = n
                 else
                    jtop = ktop
                    jbot = kbot
                 end if
                 k1 = max( 1, ktop-incol )
                 nu = ( kdu-max( 0, ndcol-kbot ) ) - k1 + 1
                 ! ==== horizontal multiply ====
                 do jcol = min( ndcol, kbot ) + 1, jbot, nh
                    jlen = min( nh, jbot-jcol+1 )
                    call stdlib_sgemm( 'C', 'N', nu, jlen, nu, one, u( k1, k1 ),ldu, h( incol+k1, &
                              jcol ), ldh, zero, wh,ldwh )
                    call stdlib_slacpy( 'ALL', nu, jlen, wh, ldwh,h( incol+k1, jcol ), ldh )
                              
                 end do
                 ! ==== vertical multiply ====
                 do jrow = jtop, max( ktop, incol ) - 1, nv
                    jlen = min( nv, max( ktop, incol )-jrow )
                    call stdlib_sgemm( 'N', 'N', jlen, nu, nu, one,h( jrow, incol+k1 ), ldh, u( &
                              k1, k1 ),ldu, zero, wv, ldwv )
                    call stdlib_slacpy( 'ALL', jlen, nu, wv, ldwv,h( jrow, incol+k1 ), ldh )
                              
                 end do
                 ! ==== z multiply (also vertical) ====
                 if( wantz ) then
                    do jrow = iloz, ihiz, nv
                       jlen = min( nv, ihiz-jrow+1 )
                       call stdlib_sgemm( 'N', 'N', jlen, nu, nu, one,z( jrow, incol+k1 ), ldz, u(&
                                  k1, k1 ),ldu, zero, wv, ldwv )
                       call stdlib_slacpy( 'ALL', jlen, nu, wv, ldwv,z( jrow, incol+k1 ), ldz )
                                 
                    end do
                 end if
              end if
           end do loop_180
     end subroutine stdlib_slaqr5

     module pure subroutine stdlib_dlaqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts,sr, si, h, ldh, &
     !! DLAQR5 , called by DLAQR0, performs a
     !! single small-bulge multi-shift QR sweep.
               iloz, ihiz, z, ldz, v, ldv, u,ldu, nv, wv, ldwv, nh, wh, ldwh )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv, ldwh, ldwv, &
                     ldz, n, nh, nshfts, nv
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(dp), intent(inout) :: h(ldh,*), si(*), sr(*), z(ldz,*)
           real(dp), intent(out) :: u(ldu,*), v(ldv,*), wh(ldwh,*), wv(ldwv,*)
        ! ================================================================
           
           ! Local Scalars 
           real(dp) :: alpha, beta, h11, h12, h21, h22, refsum, safmax, safmin, scl, smlnum, swap,&
                      tst1, tst2, ulp
           integer(ilp) :: i, i2, i4, incol, j, jbot, jcol, jlen, jrow, jtop, k, k1, kdu, kms, &
                     krcol, m, m22, mbot, mtop, nbmps, ndcol, ns, nu
           logical(lk) :: accum, bmp22
           ! Intrinsic Functions 
           ! Local Arrays 
           real(dp) :: vt(3)
           ! Executable Statements 
           ! ==== if there are no shifts, then there is nothing to do. ====
           if( nshfts<2 )return
           ! ==== if the active block is empty or 1-by-1, then there
           ! .    is nothing to do. ====
           if( ktop>=kbot )return
           ! ==== shuffle shifts into pairs of real shifts and pairs
           ! .    of complex conjugate shifts assuming complex
           ! .    conjugate shifts are already adjacent to one
           ! .    another. ====
           do i = 1, nshfts - 2, 2
              if( si( i )/=-si( i+1 ) ) then
                 swap = sr( i )
                 sr( i ) = sr( i+1 )
                 sr( i+1 ) = sr( i+2 )
                 sr( i+2 ) = swap
                 swap = si( i )
                 si( i ) = si( i+1 )
                 si( i+1 ) = si( i+2 )
                 si( i+2 ) = swap
              end if
           end do
           ! ==== nshfts is supposed to be even, but if it is odd,
           ! .    then simply reduce it by one.  the shuffle above
           ! .    ensures that the dropped shift is real and that
           ! .    the remaining shifts are paired. ====
           ns = nshfts - mod( nshfts, 2 )
           ! ==== machine constants for deflation ====
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safmax = one / safmin
           call stdlib_dlabad( safmin, safmax )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=dp) / ulp )
           ! ==== use accumulated reflections to update far-from-diagonal
           ! .    entries ? ====
           accum = ( kacc22==1 ) .or. ( kacc22==2 )
           ! ==== clear trash ====
           if( ktop+2<=kbot )h( ktop+2, ktop ) = zero
           ! ==== nbmps = number of 2-shift bulges in the chain ====
           nbmps = ns / 2
           ! ==== kdu = width of slab ====
           kdu = 4*nbmps
           ! ==== create and chase chains of nbmps bulges ====
           loop_180: do incol = ktop - 2*nbmps + 1, kbot - 2, 2*nbmps
              ! jtop = index from which updates from the right start.
              if( accum ) then
                 jtop = max( ktop, incol )
              else if( wantt ) then
                 jtop = 1
              else
                 jtop = ktop
              end if
              ndcol = incol + kdu
              if( accum )call stdlib_dlaset( 'ALL', kdu, kdu, zero, one, u, ldu )
              ! ==== near-the-diagonal bulge chase.  the following loop
              ! .    performs the near-the-diagonal part of a small bulge
              ! .    multi-shift qr sweep.  each 4*nbmps column diagonal
              ! .    chunk extends from column incol to column ndcol
              ! .    (including both column incol and column ndcol). the
              ! .    following loop chases a 2*nbmps+1 column long chain of
              ! .    nbmps bulges 2*nbmps columns to the right.  (incol
              ! .    may be less than ktop and and ndcol may be greater than
              ! .    kbot indicating phantom columns from which to chase
              ! .    bulges before they are actually introduced or to which
              ! .    to chase bulges beyond column kbot.)  ====
              loop_145: do krcol = incol, min( incol+2*nbmps-1, kbot-2 )
                 ! ==== bulges number mtop to mbot are active double implicit
                 ! .    shift bulges.  there may or may not also be small
                 ! .    2-by-2 bulge, if there is room.  the inactive bulges
                 ! .    (if any) must wait until the active bulges have moved
                 ! .    down the diagonal to make room.  the phantom matrix
                 ! .    paradigm described above helps keep track.  ====
                 mtop = max( 1, ( ktop-krcol ) / 2+1 )
                 mbot = min( nbmps, ( kbot-krcol-1 ) / 2 )
                 m22 = mbot + 1
                 bmp22 = ( mbot<nbmps ) .and. ( krcol+2*( m22-1 ) )==( kbot-2 )
                 ! ==== generate reflections to chase the chain right
                 ! .    one column.  (the minimum value of k is ktop-1.) ====
                 if ( bmp22 ) then
                    ! ==== special case: 2-by-2 reflection at bottom treated
                    ! .    separately ====
                    k = krcol + 2*( m22-1 )
                    if( k==ktop-1 ) then
                       call stdlib_dlaqr1( 2, h( k+1, k+1 ), ldh, sr( 2*m22-1 ),si( 2*m22-1 ), sr(&
                                  2*m22 ), si( 2*m22 ),v( 1, m22 ) )
                       beta = v( 1, m22 )
                       call stdlib_dlarfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                    else
                       beta = h( k+1, k )
                       v( 2, m22 ) = h( k+2, k )
                       call stdlib_dlarfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                       h( k+1, k ) = beta
                       h( k+2, k ) = zero
                    end if
                    ! ==== perform update from right within
                    ! .    computational window. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m22 )*( h( j, k+1 )+v( 2, m22 )*h( j, k+2 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) - refsum*v( 2, m22 )
                    end do
                    ! ==== perform update from left within
                    ! .    computational window. ====
                    if( accum ) then
                       jbot = min( ndcol, kbot )
                    else if( wantt ) then
                       jbot = n
                    else
                       jbot = kbot
                    end if
                    do j = k+1, jbot
                       refsum = v( 1, m22 )*( h( k+1, j )+v( 2, m22 )*h( k+2, j ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m22 )
                    end do
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is zero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k>=ktop ) then
                       if( h( k+1, k )/=zero ) then
                          tst1 = abs( h( k, k ) ) + abs( h( k+1, k+1 ) )
                          if( tst1==zero ) then
                             if( k>=ktop+1 )tst1 = tst1 + abs( h( k, k-1 ) )
                             if( k>=ktop+2 )tst1 = tst1 + abs( h( k, k-2 ) )
                             if( k>=ktop+3 )tst1 = tst1 + abs( h( k, k-3 ) )
                             if( k<=kbot-2 )tst1 = tst1 + abs( h( k+2, k+1 ) )
                             if( k<=kbot-3 )tst1 = tst1 + abs( h( k+3, k+1 ) )
                             if( k<=kbot-4 )tst1 = tst1 + abs( h( k+4, k+1 ) )
                          end if
                          if( abs( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) ) then
                             h12 = max( abs( h( k+1, k ) ),abs( h( k, k+1 ) ) )
                             h21 = min( abs( h( k+1, k ) ),abs( h( k, k+1 ) ) )
                             h11 = max( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             h22 = min( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             scl = h11 + h12
                             tst2 = h22*( h11 / scl )
                             if( tst2==zero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) ) &
                                       then
                                h( k+1, k ) = zero
                             end if
                          end if
                       end if
                    end if
                    ! ==== accumulate orthogonal transformations. ====
                    if( accum ) then
                       kms = k - incol
                       do j = max( 1, ktop-incol ), kdu
                          refsum = v( 1, m22 )*( u( j, kms+1 )+v( 2, m22 )*u( j, kms+2 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) - refsum*v( 2, m22 )
                       end do
                    else if( wantz ) then
                       do j = iloz, ihiz
                          refsum = v( 1, m22 )*( z( j, k+1 )+v( 2, m22 )*z( j, k+2 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) - refsum*v( 2, m22 )
                       end do
                    end if
                 end if
                 ! ==== normal case: chain of 3-by-3 reflections ====
                 loop_80: do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    if( k==ktop-1 ) then
                       call stdlib_dlaqr1( 3, h( ktop, ktop ), ldh, sr( 2*m-1 ),si( 2*m-1 ), sr( &
                                 2*m ), si( 2*m ),v( 1, m ) )
                       alpha = v( 1, m )
                       call stdlib_dlarfg( 3, alpha, v( 2, m ), 1, v( 1, m ) )
                    else
                       ! ==== perform delayed transformation of row below
                       ! .    mth bulge. exploit fact that first two elements
                       ! .    of row are actually zero. ====
                       refsum = v( 1, m )*v( 3, m )*h( k+3, k+2 )
                       h( k+3, k   ) = -refsum
                       h( k+3, k+1 ) = -refsum*v( 2, m )
                       h( k+3, k+2 ) = h( k+3, k+2 ) - refsum*v( 3, m )
                       ! ==== calculate reflection to move
                       ! .    mth bulge one step. ====
                       beta      = h( k+1, k )
                       v( 2, m ) = h( k+2, k )
                       v( 3, m ) = h( k+3, k )
                       call stdlib_dlarfg( 3, beta, v( 2, m ), 1, v( 1, m ) )
                       ! ==== a bulge may collapse because of vigilant
                       ! .    deflation or destructive underflow.  in the
                       ! .    underflow case, try the two-small-subdiagonals
                       ! .    trick to try to reinflate the bulge.  ====
                       if( h( k+3, k )/=zero .or. h( k+3, k+1 )/=zero .or. h( k+3, k+2 )==zero ) &
                                 then
                          ! ==== typical case: not collapsed (yet). ====
                          h( k+1, k ) = beta
                          h( k+2, k ) = zero
                          h( k+3, k ) = zero
                       else
                          ! ==== atypical case: collapsed.  attempt to
                          ! .    reintroduce ignoring h(k+1,k) and h(k+2,k).
                          ! .    if the fill resulting from the new
                          ! .    reflector is too large, then abandon it.
                          ! .    otherwise, use the new one. ====
                          call stdlib_dlaqr1( 3, h( k+1, k+1 ), ldh, sr( 2*m-1 ),si( 2*m-1 ), sr( &
                                    2*m ), si( 2*m ),vt )
                          alpha = vt( 1 )
                          call stdlib_dlarfg( 3, alpha, vt( 2 ), 1, vt( 1 ) )
                          refsum = vt( 1 )*( h( k+1, k )+vt( 2 )*h( k+2, k ) )
                          if( abs( h( k+2, k )-refsum*vt( 2 ) )+abs( refsum*vt( 3 ) )>ulp*( abs( &
                                    h( k, k ) )+abs( h( k+1,k+1 ) )+abs( h( k+2, k+2 ) ) ) ) then
                             ! ==== starting a new bulge here would
                             ! .    create non-negligible fill.  use
                             ! .    the old one with trepidation. ====
                             h( k+1, k ) = beta
                             h( k+2, k ) = zero
                             h( k+3, k ) = zero
                          else
                             ! ==== starting a new bulge here would
                             ! .    create only negligible fill.
                             ! .    replace the old reflector with
                             ! .    the new one. ====
                             h( k+1, k ) = h( k+1, k ) - refsum
                             h( k+2, k ) = zero
                             h( k+3, k ) = zero
                             v( 1, m ) = vt( 1 )
                             v( 2, m ) = vt( 2 )
                             v( 3, m ) = vt( 3 )
                          end if
                       end if
                    end if
                    ! ====  apply reflection from the right and
                    ! .     the first column of update from the left.
                    ! .     these updates are required for the vigilant
                    ! .     deflation check. we still delay most of the
                    ! .     updates from the left for efficiency. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m )*( h( j, k+1 )+v( 2, m )*h( j, k+2 )+v( 3, m )*h( j, k+3 &
                                 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) - refsum*v( 2, m )
                       h( j, k+3 ) = h( j, k+3 ) - refsum*v( 3, m )
                    end do
                    ! ==== perform update from left for subsequent
                    ! .    column. ====
                    refsum = v( 1, m )*( h( k+1, k+1 )+v( 2, m )*h( k+2, k+1 )+v( 3, m )*h( k+3, &
                              k+1 ) )
                    h( k+1, k+1 ) = h( k+1, k+1 ) - refsum
                    h( k+2, k+1 ) = h( k+2, k+1 ) - refsum*v( 2, m )
                    h( k+3, k+1 ) = h( k+3, k+1 ) - refsum*v( 3, m )
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is zero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k<ktop)cycle
                    if( h( k+1, k )/=zero ) then
                       tst1 = abs( h( k, k ) ) + abs( h( k+1, k+1 ) )
                       if( tst1==zero ) then
                          if( k>=ktop+1 )tst1 = tst1 + abs( h( k, k-1 ) )
                          if( k>=ktop+2 )tst1 = tst1 + abs( h( k, k-2 ) )
                          if( k>=ktop+3 )tst1 = tst1 + abs( h( k, k-3 ) )
                          if( k<=kbot-2 )tst1 = tst1 + abs( h( k+2, k+1 ) )
                          if( k<=kbot-3 )tst1 = tst1 + abs( h( k+3, k+1 ) )
                          if( k<=kbot-4 )tst1 = tst1 + abs( h( k+4, k+1 ) )
                       end if
                       if( abs( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) )then
                          h12 = max( abs( h( k+1, k ) ), abs( h( k, k+1 ) ) )
                          h21 = min( abs( h( k+1, k ) ), abs( h( k, k+1 ) ) )
                          h11 = max( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                          h22 = min( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                          scl = h11 + h12
                          tst2 = h22*( h11 / scl )
                          if( tst2==zero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) ) &
                                    then
                             h( k+1, k ) = zero
                          end if
                       end if
                    end if
                 end do loop_80
                 ! ==== multiply h by reflections from the left ====
                 if( accum ) then
                    jbot = min( ndcol, kbot )
                 else if( wantt ) then
                    jbot = n
                 else
                    jbot = kbot
                 end if
                 do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    do j = max( ktop, krcol + 2*m ), jbot
                       refsum = v( 1, m )*( h( k+1, j )+v( 2, m )*h( k+2, j )+v( 3, m )*h( k+3, j &
                                 ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m )
                       h( k+3, j ) = h( k+3, j ) - refsum*v( 3, m )
                    end do
                 end do
                 ! ==== accumulate orthogonal transformations. ====
                 if( accum ) then
                    ! ==== accumulate u. (if needed, update z later
                    ! .    with an efficient matrix-matrix
                    ! .    multiply.) ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       kms = k - incol
                       i2 = max( 1, ktop-incol )
                       i2 = max( i2, kms-(krcol-incol)+1 )
                       i4 = min( kdu, krcol + 2*( mbot-1 ) - incol + 5 )
                       do j = i2, i4
                          refsum = v( 1, m )*( u( j, kms+1 )+v( 2, m )*u( j, kms+2 )+v( 3, m )*u( &
                                    j, kms+3 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) - refsum*v( 2, m )
                          u( j, kms+3 ) = u( j, kms+3 ) - refsum*v( 3, m )
                       end do
                    end do
                 else if( wantz ) then
                    ! ==== u is not accumulated, so update z
                    ! .    now by multiplying by reflections
                    ! .    from the right. ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       do j = iloz, ihiz
                          refsum = v( 1, m )*( z( j, k+1 )+v( 2, m )*z( j, k+2 )+v( 3, m )*z( j, &
                                    k+3 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) - refsum*v( 2, m )
                          z( j, k+3 ) = z( j, k+3 ) - refsum*v( 3, m )
                       end do
                    end do
                 end if
                 ! ==== end of near-the-diagonal bulge chase. ====
              end do loop_145
              ! ==== use u (if accumulated) to update far-from-diagonal
              ! .    entries in h.  if required, use u to update z as
              ! .    well. ====
              if( accum ) then
                 if( wantt ) then
                    jtop = 1
                    jbot = n
                 else
                    jtop = ktop
                    jbot = kbot
                 end if
                 k1 = max( 1, ktop-incol )
                 nu = ( kdu-max( 0, ndcol-kbot ) ) - k1 + 1
                 ! ==== horizontal multiply ====
                 do jcol = min( ndcol, kbot ) + 1, jbot, nh
                    jlen = min( nh, jbot-jcol+1 )
                    call stdlib_dgemm( 'C', 'N', nu, jlen, nu, one, u( k1, k1 ),ldu, h( incol+k1, &
                              jcol ), ldh, zero, wh,ldwh )
                    call stdlib_dlacpy( 'ALL', nu, jlen, wh, ldwh,h( incol+k1, jcol ), ldh )
                              
                 end do
                 ! ==== vertical multiply ====
                 do jrow = jtop, max( ktop, incol ) - 1, nv
                    jlen = min( nv, max( ktop, incol )-jrow )
                    call stdlib_dgemm( 'N', 'N', jlen, nu, nu, one,h( jrow, incol+k1 ), ldh, u( &
                              k1, k1 ),ldu, zero, wv, ldwv )
                    call stdlib_dlacpy( 'ALL', jlen, nu, wv, ldwv,h( jrow, incol+k1 ), ldh )
                              
                 end do
                 ! ==== z multiply (also vertical) ====
                 if( wantz ) then
                    do jrow = iloz, ihiz, nv
                       jlen = min( nv, ihiz-jrow+1 )
                       call stdlib_dgemm( 'N', 'N', jlen, nu, nu, one,z( jrow, incol+k1 ), ldz, u(&
                                  k1, k1 ),ldu, zero, wv, ldwv )
                       call stdlib_dlacpy( 'ALL', jlen, nu, wv, ldwv,z( jrow, incol+k1 ), ldz )
                                 
                    end do
                 end if
              end if
           end do loop_180
     end subroutine stdlib_dlaqr5

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$laqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts,sr, si, h, ldh, &
     !! DLAQR5:, called by DLAQR0, performs a
     !! single small-bulge multi-shift QR sweep.
               iloz, ihiz, z, ldz, v, ldv, u,ldu, nv, wv, ldwv, nh, wh, ldwh )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv, ldwh, ldwv, &
                     ldz, n, nh, nshfts, nv
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(${rk}$), intent(inout) :: h(ldh,*), si(*), sr(*), z(ldz,*)
           real(${rk}$), intent(out) :: u(ldu,*), v(ldv,*), wh(ldwh,*), wv(ldwv,*)
        ! ================================================================
           
           ! Local Scalars 
           real(${rk}$) :: alpha, beta, h11, h12, h21, h22, refsum, safmax, safmin, scl, smlnum, swap,&
                      tst1, tst2, ulp
           integer(ilp) :: i, i2, i4, incol, j, jbot, jcol, jlen, jrow, jtop, k, k1, kdu, kms, &
                     krcol, m, m22, mbot, mtop, nbmps, ndcol, ns, nu
           logical(lk) :: accum, bmp22
           ! Intrinsic Functions 
           ! Local Arrays 
           real(${rk}$) :: vt(3)
           ! Executable Statements 
           ! ==== if there are no shifts, then there is nothing to do. ====
           if( nshfts<2 )return
           ! ==== if the active block is empty or 1-by-1, then there
           ! .    is nothing to do. ====
           if( ktop>=kbot )return
           ! ==== shuffle shifts into pairs of real shifts and pairs
           ! .    of complex conjugate shifts assuming complex
           ! .    conjugate shifts are already adjacent to one
           ! .    another. ====
           do i = 1, nshfts - 2, 2
              if( si( i )/=-si( i+1 ) ) then
                 swap = sr( i )
                 sr( i ) = sr( i+1 )
                 sr( i+1 ) = sr( i+2 )
                 sr( i+2 ) = swap
                 swap = si( i )
                 si( i ) = si( i+1 )
                 si( i+1 ) = si( i+2 )
                 si( i+2 ) = swap
              end if
           end do
           ! ==== nshfts is supposed to be even, but if it is odd,
           ! .    then simply reduce it by one.  the shuffle above
           ! .    ensures that the dropped shift is real and that
           ! .    the remaining shifts are paired. ====
           ns = nshfts - mod( nshfts, 2 )
           ! ==== machine constants for deflation ====
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safmax = one / safmin
           call stdlib_${ri}$labad( safmin, safmax )
           ulp = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=${rk}$) / ulp )
           ! ==== use accumulated reflections to update far-from-diagonal
           ! .    entries ? ====
           accum = ( kacc22==1 ) .or. ( kacc22==2 )
           ! ==== clear trash ====
           if( ktop+2<=kbot )h( ktop+2, ktop ) = zero
           ! ==== nbmps = number of 2-shift bulges in the chain ====
           nbmps = ns / 2
           ! ==== kdu = width of slab ====
           kdu = 4*nbmps
           ! ==== create and chase chains of nbmps bulges ====
           loop_180: do incol = ktop - 2*nbmps + 1, kbot - 2, 2*nbmps
              ! jtop = index from which updates from the right start.
              if( accum ) then
                 jtop = max( ktop, incol )
              else if( wantt ) then
                 jtop = 1
              else
                 jtop = ktop
              end if
              ndcol = incol + kdu
              if( accum )call stdlib_${ri}$laset( 'ALL', kdu, kdu, zero, one, u, ldu )
              ! ==== near-the-diagonal bulge chase.  the following loop
              ! .    performs the near-the-diagonal part of a small bulge
              ! .    multi-shift qr sweep.  each 4*nbmps column diagonal
              ! .    chunk extends from column incol to column ndcol
              ! .    (including both column incol and column ndcol). the
              ! .    following loop chases a 2*nbmps+1 column long chain of
              ! .    nbmps bulges 2*nbmps columns to the right.  (incol
              ! .    may be less than ktop and and ndcol may be greater than
              ! .    kbot indicating phantom columns from which to chase
              ! .    bulges before they are actually introduced or to which
              ! .    to chase bulges beyond column kbot.)  ====
              loop_145: do krcol = incol, min( incol+2*nbmps-1, kbot-2 )
                 ! ==== bulges number mtop to mbot are active double implicit
                 ! .    shift bulges.  there may or may not also be small
                 ! .    2-by-2 bulge, if there is room.  the inactive bulges
                 ! .    (if any) must wait until the active bulges have moved
                 ! .    down the diagonal to make room.  the phantom matrix
                 ! .    paradigm described above helps keep track.  ====
                 mtop = max( 1, ( ktop-krcol ) / 2+1 )
                 mbot = min( nbmps, ( kbot-krcol-1 ) / 2 )
                 m22 = mbot + 1
                 bmp22 = ( mbot<nbmps ) .and. ( krcol+2*( m22-1 ) )==( kbot-2 )
                 ! ==== generate reflections to chase the chain right
                 ! .    one column.  (the minimum value of k is ktop-1.) ====
                 if ( bmp22 ) then
                    ! ==== special case: 2-by-2 reflection at bottom treated
                    ! .    separately ====
                    k = krcol + 2*( m22-1 )
                    if( k==ktop-1 ) then
                       call stdlib_${ri}$laqr1( 2, h( k+1, k+1 ), ldh, sr( 2*m22-1 ),si( 2*m22-1 ), sr(&
                                  2*m22 ), si( 2*m22 ),v( 1, m22 ) )
                       beta = v( 1, m22 )
                       call stdlib_${ri}$larfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                    else
                       beta = h( k+1, k )
                       v( 2, m22 ) = h( k+2, k )
                       call stdlib_${ri}$larfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                       h( k+1, k ) = beta
                       h( k+2, k ) = zero
                    end if
                    ! ==== perform update from right within
                    ! .    computational window. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m22 )*( h( j, k+1 )+v( 2, m22 )*h( j, k+2 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) - refsum*v( 2, m22 )
                    end do
                    ! ==== perform update from left within
                    ! .    computational window. ====
                    if( accum ) then
                       jbot = min( ndcol, kbot )
                    else if( wantt ) then
                       jbot = n
                    else
                       jbot = kbot
                    end if
                    do j = k+1, jbot
                       refsum = v( 1, m22 )*( h( k+1, j )+v( 2, m22 )*h( k+2, j ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m22 )
                    end do
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is zero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k>=ktop ) then
                       if( h( k+1, k )/=zero ) then
                          tst1 = abs( h( k, k ) ) + abs( h( k+1, k+1 ) )
                          if( tst1==zero ) then
                             if( k>=ktop+1 )tst1 = tst1 + abs( h( k, k-1 ) )
                             if( k>=ktop+2 )tst1 = tst1 + abs( h( k, k-2 ) )
                             if( k>=ktop+3 )tst1 = tst1 + abs( h( k, k-3 ) )
                             if( k<=kbot-2 )tst1 = tst1 + abs( h( k+2, k+1 ) )
                             if( k<=kbot-3 )tst1 = tst1 + abs( h( k+3, k+1 ) )
                             if( k<=kbot-4 )tst1 = tst1 + abs( h( k+4, k+1 ) )
                          end if
                          if( abs( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) ) then
                             h12 = max( abs( h( k+1, k ) ),abs( h( k, k+1 ) ) )
                             h21 = min( abs( h( k+1, k ) ),abs( h( k, k+1 ) ) )
                             h11 = max( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             h22 = min( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             scl = h11 + h12
                             tst2 = h22*( h11 / scl )
                             if( tst2==zero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) ) &
                                       then
                                h( k+1, k ) = zero
                             end if
                          end if
                       end if
                    end if
                    ! ==== accumulate orthogonal transformations. ====
                    if( accum ) then
                       kms = k - incol
                       do j = max( 1, ktop-incol ), kdu
                          refsum = v( 1, m22 )*( u( j, kms+1 )+v( 2, m22 )*u( j, kms+2 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) - refsum*v( 2, m22 )
                       end do
                    else if( wantz ) then
                       do j = iloz, ihiz
                          refsum = v( 1, m22 )*( z( j, k+1 )+v( 2, m22 )*z( j, k+2 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) - refsum*v( 2, m22 )
                       end do
                    end if
                 end if
                 ! ==== normal case: chain of 3-by-3 reflections ====
                 loop_80: do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    if( k==ktop-1 ) then
                       call stdlib_${ri}$laqr1( 3, h( ktop, ktop ), ldh, sr( 2*m-1 ),si( 2*m-1 ), sr( &
                                 2*m ), si( 2*m ),v( 1, m ) )
                       alpha = v( 1, m )
                       call stdlib_${ri}$larfg( 3, alpha, v( 2, m ), 1, v( 1, m ) )
                    else
                       ! ==== perform delayed transformation of row below
                       ! .    mth bulge. exploit fact that first two elements
                       ! .    of row are actually zero. ====
                       refsum = v( 1, m )*v( 3, m )*h( k+3, k+2 )
                       h( k+3, k   ) = -refsum
                       h( k+3, k+1 ) = -refsum*v( 2, m )
                       h( k+3, k+2 ) = h( k+3, k+2 ) - refsum*v( 3, m )
                       ! ==== calculate reflection to move
                       ! .    mth bulge one step. ====
                       beta      = h( k+1, k )
                       v( 2, m ) = h( k+2, k )
                       v( 3, m ) = h( k+3, k )
                       call stdlib_${ri}$larfg( 3, beta, v( 2, m ), 1, v( 1, m ) )
                       ! ==== a bulge may collapse because of vigilant
                       ! .    deflation or destructive underflow.  in the
                       ! .    underflow case, try the two-small-subdiagonals
                       ! .    trick to try to reinflate the bulge.  ====
                       if( h( k+3, k )/=zero .or. h( k+3, k+1 )/=zero .or. h( k+3, k+2 )==zero ) &
                                 then
                          ! ==== typical case: not collapsed (yet). ====
                          h( k+1, k ) = beta
                          h( k+2, k ) = zero
                          h( k+3, k ) = zero
                       else
                          ! ==== atypical case: collapsed.  attempt to
                          ! .    reintroduce ignoring h(k+1,k) and h(k+2,k).
                          ! .    if the fill resulting from the new
                          ! .    reflector is too large, then abandon it.
                          ! .    otherwise, use the new one. ====
                          call stdlib_${ri}$laqr1( 3, h( k+1, k+1 ), ldh, sr( 2*m-1 ),si( 2*m-1 ), sr( &
                                    2*m ), si( 2*m ),vt )
                          alpha = vt( 1 )
                          call stdlib_${ri}$larfg( 3, alpha, vt( 2 ), 1, vt( 1 ) )
                          refsum = vt( 1 )*( h( k+1, k )+vt( 2 )*h( k+2, k ) )
                          if( abs( h( k+2, k )-refsum*vt( 2 ) )+abs( refsum*vt( 3 ) )>ulp*( abs( &
                                    h( k, k ) )+abs( h( k+1,k+1 ) )+abs( h( k+2, k+2 ) ) ) ) then
                             ! ==== starting a new bulge here would
                             ! .    create non-negligible fill.  use
                             ! .    the old one with trepidation. ====
                             h( k+1, k ) = beta
                             h( k+2, k ) = zero
                             h( k+3, k ) = zero
                          else
                             ! ==== starting a new bulge here would
                             ! .    create only negligible fill.
                             ! .    replace the old reflector with
                             ! .    the new one. ====
                             h( k+1, k ) = h( k+1, k ) - refsum
                             h( k+2, k ) = zero
                             h( k+3, k ) = zero
                             v( 1, m ) = vt( 1 )
                             v( 2, m ) = vt( 2 )
                             v( 3, m ) = vt( 3 )
                          end if
                       end if
                    end if
                    ! ====  apply reflection from the right and
                    ! .     the first column of update from the left.
                    ! .     these updates are required for the vigilant
                    ! .     deflation check. we still delay most of the
                    ! .     updates from the left for efficiency. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m )*( h( j, k+1 )+v( 2, m )*h( j, k+2 )+v( 3, m )*h( j, k+3 &
                                 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) - refsum*v( 2, m )
                       h( j, k+3 ) = h( j, k+3 ) - refsum*v( 3, m )
                    end do
                    ! ==== perform update from left for subsequent
                    ! .    column. ====
                    refsum = v( 1, m )*( h( k+1, k+1 )+v( 2, m )*h( k+2, k+1 )+v( 3, m )*h( k+3, &
                              k+1 ) )
                    h( k+1, k+1 ) = h( k+1, k+1 ) - refsum
                    h( k+2, k+1 ) = h( k+2, k+1 ) - refsum*v( 2, m )
                    h( k+3, k+1 ) = h( k+3, k+1 ) - refsum*v( 3, m )
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is zero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k<ktop)cycle
                    if( h( k+1, k )/=zero ) then
                       tst1 = abs( h( k, k ) ) + abs( h( k+1, k+1 ) )
                       if( tst1==zero ) then
                          if( k>=ktop+1 )tst1 = tst1 + abs( h( k, k-1 ) )
                          if( k>=ktop+2 )tst1 = tst1 + abs( h( k, k-2 ) )
                          if( k>=ktop+3 )tst1 = tst1 + abs( h( k, k-3 ) )
                          if( k<=kbot-2 )tst1 = tst1 + abs( h( k+2, k+1 ) )
                          if( k<=kbot-3 )tst1 = tst1 + abs( h( k+3, k+1 ) )
                          if( k<=kbot-4 )tst1 = tst1 + abs( h( k+4, k+1 ) )
                       end if
                       if( abs( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) )then
                          h12 = max( abs( h( k+1, k ) ), abs( h( k, k+1 ) ) )
                          h21 = min( abs( h( k+1, k ) ), abs( h( k, k+1 ) ) )
                          h11 = max( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                          h22 = min( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                          scl = h11 + h12
                          tst2 = h22*( h11 / scl )
                          if( tst2==zero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) ) &
                                    then
                             h( k+1, k ) = zero
                          end if
                       end if
                    end if
                 end do loop_80
                 ! ==== multiply h by reflections from the left ====
                 if( accum ) then
                    jbot = min( ndcol, kbot )
                 else if( wantt ) then
                    jbot = n
                 else
                    jbot = kbot
                 end if
                 do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    do j = max( ktop, krcol + 2*m ), jbot
                       refsum = v( 1, m )*( h( k+1, j )+v( 2, m )*h( k+2, j )+v( 3, m )*h( k+3, j &
                                 ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m )
                       h( k+3, j ) = h( k+3, j ) - refsum*v( 3, m )
                    end do
                 end do
                 ! ==== accumulate orthogonal transformations. ====
                 if( accum ) then
                    ! ==== accumulate u. (if needed, update z later
                    ! .    with an efficient matrix-matrix
                    ! .    multiply.) ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       kms = k - incol
                       i2 = max( 1, ktop-incol )
                       i2 = max( i2, kms-(krcol-incol)+1 )
                       i4 = min( kdu, krcol + 2*( mbot-1 ) - incol + 5 )
                       do j = i2, i4
                          refsum = v( 1, m )*( u( j, kms+1 )+v( 2, m )*u( j, kms+2 )+v( 3, m )*u( &
                                    j, kms+3 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) - refsum*v( 2, m )
                          u( j, kms+3 ) = u( j, kms+3 ) - refsum*v( 3, m )
                       end do
                    end do
                 else if( wantz ) then
                    ! ==== u is not accumulated, so update z
                    ! .    now by multiplying by reflections
                    ! .    from the right. ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       do j = iloz, ihiz
                          refsum = v( 1, m )*( z( j, k+1 )+v( 2, m )*z( j, k+2 )+v( 3, m )*z( j, &
                                    k+3 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) - refsum*v( 2, m )
                          z( j, k+3 ) = z( j, k+3 ) - refsum*v( 3, m )
                       end do
                    end do
                 end if
                 ! ==== end of near-the-diagonal bulge chase. ====
              end do loop_145
              ! ==== use u (if accumulated) to update far-from-diagonal
              ! .    entries in h.  if required, use u to update z as
              ! .    well. ====
              if( accum ) then
                 if( wantt ) then
                    jtop = 1
                    jbot = n
                 else
                    jtop = ktop
                    jbot = kbot
                 end if
                 k1 = max( 1, ktop-incol )
                 nu = ( kdu-max( 0, ndcol-kbot ) ) - k1 + 1
                 ! ==== horizontal multiply ====
                 do jcol = min( ndcol, kbot ) + 1, jbot, nh
                    jlen = min( nh, jbot-jcol+1 )
                    call stdlib_${ri}$gemm( 'C', 'N', nu, jlen, nu, one, u( k1, k1 ),ldu, h( incol+k1, &
                              jcol ), ldh, zero, wh,ldwh )
                    call stdlib_${ri}$lacpy( 'ALL', nu, jlen, wh, ldwh,h( incol+k1, jcol ), ldh )
                              
                 end do
                 ! ==== vertical multiply ====
                 do jrow = jtop, max( ktop, incol ) - 1, nv
                    jlen = min( nv, max( ktop, incol )-jrow )
                    call stdlib_${ri}$gemm( 'N', 'N', jlen, nu, nu, one,h( jrow, incol+k1 ), ldh, u( &
                              k1, k1 ),ldu, zero, wv, ldwv )
                    call stdlib_${ri}$lacpy( 'ALL', jlen, nu, wv, ldwv,h( jrow, incol+k1 ), ldh )
                              
                 end do
                 ! ==== z multiply (also vertical) ====
                 if( wantz ) then
                    do jrow = iloz, ihiz, nv
                       jlen = min( nv, ihiz-jrow+1 )
                       call stdlib_${ri}$gemm( 'N', 'N', jlen, nu, nu, one,z( jrow, incol+k1 ), ldz, u(&
                                  k1, k1 ),ldu, zero, wv, ldwv )
                       call stdlib_${ri}$lacpy( 'ALL', jlen, nu, wv, ldwv,z( jrow, incol+k1 ), ldz )
                                 
                    end do
                 end if
              end if
           end do loop_180
     end subroutine stdlib_${ri}$laqr5

#:endif
#:endfor

     module pure subroutine stdlib_claqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts, s,h, ldh, iloz, &
     !! CLAQR5 called by CLAQR0 performs a
     !! single small-bulge multi-shift QR sweep.
               ihiz, z, ldz, v, ldv, u, ldu, nv,wv, ldwv, nh, wh, ldwh )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv, ldwh, ldwv, &
                     ldz, n, nh, nshfts, nv
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(sp), intent(inout) :: h(ldh,*), s(*), z(ldz,*)
           complex(sp), intent(out) :: u(ldu,*), v(ldv,*), wh(ldwh,*), wv(ldwv,*)
        ! ================================================================
           ! Parameters 
           real(sp), parameter :: rzero = 0.0_sp
           real(sp), parameter :: rone = 1.0_sp
           
           
           ! Local Scalars 
           complex(sp) :: alpha, beta, cdum, refsum
           real(sp) :: h11, h12, h21, h22, safmax, safmin, scl, smlnum, tst1, tst2, ulp
           integer(ilp) :: i2, i4, incol, j, jbot, jcol, jlen, jrow, jtop, k, k1, kdu, kms, krcol,&
                      m, m22, mbot, mtop, nbmps, ndcol, ns, nu
           logical(lk) :: accum, bmp22
           ! Intrinsic Functions 
           ! Local Arrays 
           complex(sp) :: vt(3)
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! ==== if there are no shifts, then there is nothing to do. ====
           if( nshfts<2 )return
           ! ==== if the active block is empty or 1-by-1, then there
           ! .    is nothing to do. ====
           if( ktop>=kbot )return
           ! ==== nshfts is supposed to be even, but if it is odd,
           ! .    then simply reduce it by cone.  ====
           ns = nshfts - mod( nshfts, 2 )
           ! ==== machine constants for deflation ====
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=sp) / ulp )
           ! ==== use accumulated reflections to update far-from-diagonal
           ! .    entries ? ====
           accum = ( kacc22==1 ) .or. ( kacc22==2 )
           ! ==== clear trash ====
           if( ktop+2<=kbot )h( ktop+2, ktop ) = czero
           ! ==== nbmps = number of 2-shift bulges in the chain ====
           nbmps = ns / 2
           ! ==== kdu = width of slab ====
           kdu = 4*nbmps
           ! ==== create and chase chains of nbmps bulges ====
           loop_180: do incol = ktop - 2*nbmps + 1, kbot - 2, 2*nbmps
              ! jtop = index from which updates from the right start.
              if( accum ) then
                 jtop = max( ktop, incol )
              else if( wantt ) then
                 jtop = 1
              else
                 jtop = ktop
              end if
              ndcol = incol + kdu
              if( accum )call stdlib_claset( 'ALL', kdu, kdu, czero, cone, u, ldu )
              ! ==== near-the-diagonal bulge chase.  the following loop
              ! .    performs the near-the-diagonal part of a small bulge
              ! .    multi-shift qr sweep.  each 4*nbmps column diagonal
              ! .    chunk extends from column incol to column ndcol
              ! .    (including both column incol and column ndcol). the
              ! .    following loop chases a 2*nbmps+1 column long chain of
              ! .    nbmps bulges 2*nbmps columns to the right.  (incol
              ! .    may be less than ktop and and ndcol may be greater than
              ! .    kbot indicating phantom columns from which to chase
              ! .    bulges before they are actually introduced or to which
              ! .    to chase bulges beyond column kbot.)  ====
              loop_145: do krcol = incol, min( incol+2*nbmps-1, kbot-2 )
                 ! ==== bulges number mtop to mbot are active double implicit
                 ! .    shift bulges.  there may or may not also be small
                 ! .    2-by-2 bulge, if there is room.  the inactive bulges
                 ! .    (if any) must wait until the active bulges have moved
                 ! .    down the diagonal to make room.  the phantom matrix
                 ! .    paradigm described above helps keep track.  ====
                 mtop = max( 1, ( ktop-krcol ) / 2+1 )
                 mbot = min( nbmps, ( kbot-krcol-1 ) / 2 )
                 m22 = mbot + 1
                 bmp22 = ( mbot<nbmps ) .and. ( krcol+2*( m22-1 ) )==( kbot-2 )
                 ! ==== generate reflections to chase the chain right
                 ! .    cone column.  (the minimum value of k is ktop-1.) ====
                 if ( bmp22 ) then
                    ! ==== special case: 2-by-2 reflection at bottom treated
                    ! .    separately ====
                    k = krcol + 2*( m22-1 )
                    if( k==ktop-1 ) then
                       call stdlib_claqr1( 2, h( k+1, k+1 ), ldh, s( 2*m22-1 ),s( 2*m22 ), v( 1, &
                                 m22 ) )
                       beta = v( 1, m22 )
                       call stdlib_clarfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                    else
                       beta = h( k+1, k )
                       v( 2, m22 ) = h( k+2, k )
                       call stdlib_clarfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                       h( k+1, k ) = beta
                       h( k+2, k ) = czero
                    end if
                    ! ==== perform update from right within
                    ! .    computational window. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m22 )*( h( j, k+1 )+v( 2, m22 )*h( j, k+2 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) -refsum*conjg( v( 2, m22 ) )
                    end do
                    ! ==== perform update from left within
                    ! .    computational window. ====
                    if( accum ) then
                       jbot = min( ndcol, kbot )
                    else if( wantt ) then
                       jbot = n
                    else
                       jbot = kbot
                    end if
                    do j = k+1, jbot
                       refsum = conjg( v( 1, m22 ) )*( h( k+1, j )+conjg( v( 2, m22 ) )*h( k+2, j &
                                 ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m22 )
                    end do
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is czero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k>=ktop) then
                       if( h( k+1, k )/=czero ) then
                          tst1 = cabs1( h( k, k ) ) + cabs1( h( k+1, k+1 ) )
                          if( tst1==rzero ) then
                             if( k>=ktop+1 )tst1 = tst1 + cabs1( h( k, k-1 ) )
                             if( k>=ktop+2 )tst1 = tst1 + cabs1( h( k, k-2 ) )
                             if( k>=ktop+3 )tst1 = tst1 + cabs1( h( k, k-3 ) )
                             if( k<=kbot-2 )tst1 = tst1 + cabs1( h( k+2, k+1 ) )
                             if( k<=kbot-3 )tst1 = tst1 + cabs1( h( k+3, k+1 ) )
                             if( k<=kbot-4 )tst1 = tst1 + cabs1( h( k+4, k+1 ) )
                          end if
                          if( cabs1( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) ) then
                             h12 = max( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                             h21 = min( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                             h11 = max( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             h22 = min( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             scl = h11 + h12
                             tst2 = h22*( h11 / scl )
                             if( tst2==rzero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) )h( &
                                       k+1, k ) = czero
                          end if
                       end if
                    end if
                    ! ==== accumulate orthogonal transformations. ====
                    if( accum ) then
                       kms = k - incol
                       do j = max( 1, ktop-incol ), kdu
                          refsum = v( 1, m22 )*( u( j, kms+1 )+v( 2, m22 )*u( j, kms+2 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) -refsum*conjg( v( 2, m22 ) )
                       end do
                    else if( wantz ) then
                       do j = iloz, ihiz
                          refsum = v( 1, m22 )*( z( j, k+1 )+v( 2, m22 )*z( j, k+2 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) -refsum*conjg( v( 2, m22 ) )
                       end do
                    end if
                 end if
                 ! ==== normal case: chain of 3-by-3 reflections ====
                 loop_80: do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    if( k==ktop-1 ) then
                       call stdlib_claqr1( 3, h( ktop, ktop ), ldh, s( 2*m-1 ),s( 2*m ), v( 1, m )&
                                  )
                       alpha = v( 1, m )
                       call stdlib_clarfg( 3, alpha, v( 2, m ), 1, v( 1, m ) )
                    else
                       ! ==== perform delayed transformation of row below
                       ! .    mth bulge. exploit fact that first two elements
                       ! .    of row are actually czero. ====
                       refsum = v( 1, m )*v( 3, m )*h( k+3, k+2 )
                       h( k+3, k   ) = -refsum
                       h( k+3, k+1 ) = -refsum*conjg( v( 2, m ) )
                       h( k+3, k+2 ) = h( k+3, k+2 ) -refsum*conjg( v( 3, m ) )
                       ! ==== calculate reflection to move
                       ! .    mth bulge cone step. ====
                       beta      = h( k+1, k )
                       v( 2, m ) = h( k+2, k )
                       v( 3, m ) = h( k+3, k )
                       call stdlib_clarfg( 3, beta, v( 2, m ), 1, v( 1, m ) )
                       ! ==== a bulge may collapse because of vigilant
                       ! .    deflation or destructive underflow.  in the
                       ! .    underflow case, try the two-small-subdiagonals
                       ! .    trick to try to reinflate the bulge.  ====
                       if( h( k+3, k )/=czero .or. h( k+3, k+1 )/=czero .or. h( k+3, k+2 )==czero &
                                 ) then
                          ! ==== typical case: not collapsed (yet). ====
                          h( k+1, k ) = beta
                          h( k+2, k ) = czero
                          h( k+3, k ) = czero
                       else
                          ! ==== atypical case: collapsed.  attempt to
                          ! .    reintroduce ignoring h(k+1,k) and h(k+2,k).
                          ! .    if the fill resulting from the new
                          ! .    reflector is too large, then abandon it.
                          ! .    otherwise, use the new cone. ====
                          call stdlib_claqr1( 3, h( k+1, k+1 ), ldh, s( 2*m-1 ),s( 2*m ), vt )
                                    
                          alpha = vt( 1 )
                          call stdlib_clarfg( 3, alpha, vt( 2 ), 1, vt( 1 ) )
                          refsum = conjg( vt( 1 ) )*( h( k+1, k )+conjg( vt( 2 ) )*h( k+2, k ) )
                                    
                          if( cabs1( h( k+2, k )-refsum*vt( 2 ) )+cabs1( refsum*vt( 3 ) )>ulp*( &
                          cabs1( h( k, k ) )+cabs1( h( k+1,k+1 ) )+cabs1( h( k+2, k+2 ) ) ) ) &
                                    then
                             ! ==== starting a new bulge here would
                             ! .    create non-negligible fill.  use
                             ! .    the old cone with trepidation. ====
                             h( k+1, k ) = beta
                             h( k+2, k ) = czero
                             h( k+3, k ) = czero
                          else
                             ! ==== starting a new bulge here would
                             ! .    create only negligible fill.
                             ! .    replace the old reflector with
                             ! .    the new cone. ====
                             h( k+1, k ) = h( k+1, k ) - refsum
                             h( k+2, k ) = czero
                             h( k+3, k ) = czero
                             v( 1, m ) = vt( 1 )
                             v( 2, m ) = vt( 2 )
                             v( 3, m ) = vt( 3 )
                          end if
                       end if
                    end if
                    ! ====  apply reflection from the right and
                    ! .     the first column of update from the left.
                    ! .     these updates are required for the vigilant
                    ! .     deflation check. we still delay most of the
                    ! .     updates from the left for efficiency. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m )*( h( j, k+1 )+v( 2, m )*h( j, k+2 )+v( 3, m )*h( j, k+3 &
                                 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) -refsum*conjg( v( 2, m ) )
                       h( j, k+3 ) = h( j, k+3 ) -refsum*conjg( v( 3, m ) )
                    end do
                    ! ==== perform update from left for subsequent
                    ! .    column. ====
                    refsum =  conjg( v( 1, m ) )*( h( k+1, k+1 )+conjg( v( 2, m ) )*h( k+2, k+1 )+&
                              conjg( v( 3, m ) )*h( k+3, k+1 ) )
                    h( k+1, k+1 ) = h( k+1, k+1 ) - refsum
                    h( k+2, k+1 ) = h( k+2, k+1 ) - refsum*v( 2, m )
                    h( k+3, k+1 ) = h( k+3, k+1 ) - refsum*v( 3, m )
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is czero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k<ktop)cycle
                    if( h( k+1, k )/=czero ) then
                       tst1 = cabs1( h( k, k ) ) + cabs1( h( k+1, k+1 ) )
                       if( tst1==rzero ) then
                          if( k>=ktop+1 )tst1 = tst1 + cabs1( h( k, k-1 ) )
                          if( k>=ktop+2 )tst1 = tst1 + cabs1( h( k, k-2 ) )
                          if( k>=ktop+3 )tst1 = tst1 + cabs1( h( k, k-3 ) )
                          if( k<=kbot-2 )tst1 = tst1 + cabs1( h( k+2, k+1 ) )
                          if( k<=kbot-3 )tst1 = tst1 + cabs1( h( k+3, k+1 ) )
                          if( k<=kbot-4 )tst1 = tst1 + cabs1( h( k+4, k+1 ) )
                       end if
                       if( cabs1( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) )then
                          h12 = max( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                          h21 = min( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                          h11 = max( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                    
                          h22 = min( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                    
                          scl = h11 + h12
                          tst2 = h22*( h11 / scl )
                          if( tst2==rzero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) )h( k+1,&
                                     k ) = czero
                       end if
                    end if
                 end do loop_80
                 ! ==== multiply h by reflections from the left ====
                 if( accum ) then
                    jbot = min( ndcol, kbot )
                 else if( wantt ) then
                    jbot = n
                 else
                    jbot = kbot
                 end if
                 do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    do j = max( ktop, krcol + 2*m ), jbot
                       refsum = conjg( v( 1, m ) )*( h( k+1, j )+conjg( v( 2, m ) )*h( k+2, j )+&
                                 conjg( v( 3, m ) )*h( k+3, j ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m )
                       h( k+3, j ) = h( k+3, j ) - refsum*v( 3, m )
                    end do
                 end do
                 ! ==== accumulate orthogonal transformations. ====
                 if( accum ) then
                    ! ==== accumulate u. (if needed, update z later
                    ! .    with an efficient matrix-matrix
                    ! .    multiply.) ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       kms = k - incol
                       i2 = max( 1, ktop-incol )
                       i2 = max( i2, kms-(krcol-incol)+1 )
                       i4 = min( kdu, krcol + 2*( mbot-1 ) - incol + 5 )
                       do j = i2, i4
                          refsum = v( 1, m )*( u( j, kms+1 )+v( 2, m )*u( j, kms+2 )+v( 3, m )*u( &
                                    j, kms+3 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) -refsum*conjg( v( 2, m ) )
                          u( j, kms+3 ) = u( j, kms+3 ) -refsum*conjg( v( 3, m ) )
                       end do
                    end do
                 else if( wantz ) then
                    ! ==== u is not accumulated, so update z
                    ! .    now by multiplying by reflections
                    ! .    from the right. ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       do j = iloz, ihiz
                          refsum = v( 1, m )*( z( j, k+1 )+v( 2, m )*z( j, k+2 )+v( 3, m )*z( j, &
                                    k+3 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) -refsum*conjg( v( 2, m ) )
                          z( j, k+3 ) = z( j, k+3 ) -refsum*conjg( v( 3, m ) )
                       end do
                    end do
                 end if
                 ! ==== end of near-the-diagonal bulge chase. ====
              end do loop_145
              ! ==== use u (if accumulated) to update far-from-diagonal
              ! .    entries in h.  if required, use u to update z as
              ! .    well. ====
              if( accum ) then
                 if( wantt ) then
                    jtop = 1
                    jbot = n
                 else
                    jtop = ktop
                    jbot = kbot
                 end if
                 k1 = max( 1, ktop-incol )
                 nu = ( kdu-max( 0, ndcol-kbot ) ) - k1 + 1
                 ! ==== horizontal multiply ====
                 do jcol = min( ndcol, kbot ) + 1, jbot, nh
                    jlen = min( nh, jbot-jcol+1 )
                    call stdlib_cgemm( 'C', 'N', nu, jlen, nu, cone, u( k1, k1 ),ldu, h( incol+k1,&
                               jcol ), ldh, czero, wh,ldwh )
                    call stdlib_clacpy( 'ALL', nu, jlen, wh, ldwh,h( incol+k1, jcol ), ldh )
                              
                 end do
                 ! ==== vertical multiply ====
                 do jrow = jtop, max( ktop, incol ) - 1, nv
                    jlen = min( nv, max( ktop, incol )-jrow )
                    call stdlib_cgemm( 'N', 'N', jlen, nu, nu, cone,h( jrow, incol+k1 ), ldh, u( &
                              k1, k1 ),ldu, czero, wv, ldwv )
                    call stdlib_clacpy( 'ALL', jlen, nu, wv, ldwv,h( jrow, incol+k1 ), ldh )
                              
                 end do
                 ! ==== z multiply (also vertical) ====
                 if( wantz ) then
                    do jrow = iloz, ihiz, nv
                       jlen = min( nv, ihiz-jrow+1 )
                       call stdlib_cgemm( 'N', 'N', jlen, nu, nu, cone,z( jrow, incol+k1 ), ldz, &
                                 u( k1, k1 ),ldu, czero, wv, ldwv )
                       call stdlib_clacpy( 'ALL', jlen, nu, wv, ldwv,z( jrow, incol+k1 ), ldz )
                                 
                    end do
                 end if
              end if
           end do loop_180
     end subroutine stdlib_claqr5

     module pure subroutine stdlib_zlaqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts, s,h, ldh, iloz, &
     !! ZLAQR5 , called by ZLAQR0, performs a
     !! single small-bulge multi-shift QR sweep.
               ihiz, z, ldz, v, ldv, u, ldu, nv,wv, ldwv, nh, wh, ldwh )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv, ldwh, ldwv, &
                     ldz, n, nh, nshfts, nv
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(dp), intent(inout) :: h(ldh,*), s(*), z(ldz,*)
           complex(dp), intent(out) :: u(ldu,*), v(ldv,*), wh(ldwh,*), wv(ldwv,*)
        ! ================================================================
           ! Parameters 
           real(dp), parameter :: rzero = 0.0_dp
           real(dp), parameter :: rone = 1.0_dp
           
           
           ! Local Scalars 
           complex(dp) :: alpha, beta, cdum, refsum
           real(dp) :: h11, h12, h21, h22, safmax, safmin, scl, smlnum, tst1, tst2, ulp
           integer(ilp) :: i2, i4, incol, j, jbot, jcol, jlen, jrow, jtop, k, k1, kdu, kms, krcol,&
                      m, m22, mbot, mtop, nbmps, ndcol, ns, nu
           logical(lk) :: accum, bmp22
           ! Intrinsic Functions 
           ! Local Arrays 
           complex(dp) :: vt(3)
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! ==== if there are no shifts, then there is nothing to do. ====
           if( nshfts<2 )return
           ! ==== if the active block is empty or 1-by-1, then there
           ! .    is nothing to do. ====
           if( ktop>=kbot )return
           ! ==== nshfts is supposed to be even, but if it is odd,
           ! .    then simply reduce it by cone.  ====
           ns = nshfts - mod( nshfts, 2 )
           ! ==== machine constants for deflation ====
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_dlabad( safmin, safmax )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=dp) / ulp )
           ! ==== use accumulated reflections to update far-from-diagonal
           ! .    entries ? ====
           accum = ( kacc22==1 ) .or. ( kacc22==2 )
           ! ==== clear trash ====
           if( ktop+2<=kbot )h( ktop+2, ktop ) = czero
           ! ==== nbmps = number of 2-shift bulges in the chain ====
           nbmps = ns / 2
           ! ==== kdu = width of slab ====
           kdu = 4*nbmps
           ! ==== create and chase chains of nbmps bulges ====
           loop_180: do incol = ktop - 2*nbmps + 1, kbot - 2, 2*nbmps
              ! jtop = index from which updates from the right start.
              if( accum ) then
                 jtop = max( ktop, incol )
              else if( wantt ) then
                 jtop = 1
              else
                 jtop = ktop
              end if
              ndcol = incol + kdu
              if( accum )call stdlib_zlaset( 'ALL', kdu, kdu, czero, cone, u, ldu )
              ! ==== near-the-diagonal bulge chase.  the following loop
              ! .    performs the near-the-diagonal part of a small bulge
              ! .    multi-shift qr sweep.  each 4*nbmps column diagonal
              ! .    chunk extends from column incol to column ndcol
              ! .    (including both column incol and column ndcol). the
              ! .    following loop chases a 2*nbmps+1 column long chain of
              ! .    nbmps bulges 2*nbmps columns to the right.  (incol
              ! .    may be less than ktop and and ndcol may be greater than
              ! .    kbot indicating phantom columns from which to chase
              ! .    bulges before they are actually introduced or to which
              ! .    to chase bulges beyond column kbot.)  ====
              loop_145: do krcol = incol, min( incol+2*nbmps-1, kbot-2 )
                 ! ==== bulges number mtop to mbot are active double implicit
                 ! .    shift bulges.  there may or may not also be small
                 ! .    2-by-2 bulge, if there is room.  the inactive bulges
                 ! .    (if any) must wait until the active bulges have moved
                 ! .    down the diagonal to make room.  the phantom matrix
                 ! .    paradigm described above helps keep track.  ====
                 mtop = max( 1, ( ktop-krcol ) / 2+1 )
                 mbot = min( nbmps, ( kbot-krcol-1 ) / 2 )
                 m22 = mbot + 1
                 bmp22 = ( mbot<nbmps ) .and. ( krcol+2*( m22-1 ) )==( kbot-2 )
                 ! ==== generate reflections to chase the chain right
                 ! .    cone column.  (the minimum value of k is ktop-1.) ====
                 if ( bmp22 ) then
                    ! ==== special case: 2-by-2 reflection at bottom treated
                    ! .    separately ====
                    k = krcol + 2*( m22-1 )
                    if( k==ktop-1 ) then
                       call stdlib_zlaqr1( 2, h( k+1, k+1 ), ldh, s( 2*m22-1 ),s( 2*m22 ), v( 1, &
                                 m22 ) )
                       beta = v( 1, m22 )
                       call stdlib_zlarfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                    else
                       beta = h( k+1, k )
                       v( 2, m22 ) = h( k+2, k )
                       call stdlib_zlarfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                       h( k+1, k ) = beta
                       h( k+2, k ) = czero
                    end if
                    ! ==== perform update from right within
                    ! .    computational window. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m22 )*( h( j, k+1 )+v( 2, m22 )*h( j, k+2 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) -refsum*conjg( v( 2, m22 ) )
                    end do
                    ! ==== perform update from left within
                    ! .    computational window. ====
                    if( accum ) then
                       jbot = min( ndcol, kbot )
                    else if( wantt ) then
                       jbot = n
                    else
                       jbot = kbot
                    end if
                    do j = k+1, jbot
                       refsum = conjg( v( 1, m22 ) )*( h( k+1, j )+conjg( v( 2, m22 ) )*h( k+2, j &
                                 ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m22 )
                    end do
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is czero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k>=ktop ) then
                       if( h( k+1, k )/=czero ) then
                          tst1 = cabs1( h( k, k ) ) + cabs1( h( k+1, k+1 ) )
                          if( tst1==rzero ) then
                             if( k>=ktop+1 )tst1 = tst1 + cabs1( h( k, k-1 ) )
                             if( k>=ktop+2 )tst1 = tst1 + cabs1( h( k, k-2 ) )
                             if( k>=ktop+3 )tst1 = tst1 + cabs1( h( k, k-3 ) )
                             if( k<=kbot-2 )tst1 = tst1 + cabs1( h( k+2, k+1 ) )
                             if( k<=kbot-3 )tst1 = tst1 + cabs1( h( k+3, k+1 ) )
                             if( k<=kbot-4 )tst1 = tst1 + cabs1( h( k+4, k+1 ) )
                          end if
                          if( cabs1( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) ) then
                             h12 = max( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                             h21 = min( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                             h11 = max( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             h22 = min( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             scl = h11 + h12
                             tst2 = h22*( h11 / scl )
                             if( tst2==rzero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) )h( &
                                       k+1, k ) = czero
                          end if
                       end if
                    end if
                    ! ==== accumulate orthogonal transformations. ====
                    if( accum ) then
                       kms = k - incol
                       do j = max( 1, ktop-incol ), kdu
                          refsum = v( 1, m22 )*( u( j, kms+1 )+v( 2, m22 )*u( j, kms+2 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) -refsum*conjg( v( 2, m22 ) )
                       end do
                    else if( wantz ) then
                       do j = iloz, ihiz
                          refsum = v( 1, m22 )*( z( j, k+1 )+v( 2, m22 )*z( j, k+2 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) -refsum*conjg( v( 2, m22 ) )
                       end do
                    end if
                 end if
                 ! ==== normal case: chain of 3-by-3 reflections ====
                 loop_80: do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    if( k==ktop-1 ) then
                       call stdlib_zlaqr1( 3, h( ktop, ktop ), ldh, s( 2*m-1 ),s( 2*m ), v( 1, m )&
                                  )
                       alpha = v( 1, m )
                       call stdlib_zlarfg( 3, alpha, v( 2, m ), 1, v( 1, m ) )
                    else
                       ! ==== perform delayed transformation of row below
                       ! .    mth bulge. exploit fact that first two elements
                       ! .    of row are actually czero. ====
                       refsum = v( 1, m )*v( 3, m )*h( k+3, k+2 )
                       h( k+3, k   ) = -refsum
                       h( k+3, k+1 ) = -refsum*conjg( v( 2, m ) )
                       h( k+3, k+2 ) = h( k+3, k+2 ) -refsum*conjg( v( 3, m ) )
                       ! ==== calculate reflection to move
                       ! .    mth bulge cone step. ====
                       beta      = h( k+1, k )
                       v( 2, m ) = h( k+2, k )
                       v( 3, m ) = h( k+3, k )
                       call stdlib_zlarfg( 3, beta, v( 2, m ), 1, v( 1, m ) )
                       ! ==== a bulge may collapse because of vigilant
                       ! .    deflation or destructive underflow.  in the
                       ! .    underflow case, try the two-small-subdiagonals
                       ! .    trick to try to reinflate the bulge.  ====
                       if( h( k+3, k )/=czero .or. h( k+3, k+1 )/=czero .or. h( k+3, k+2 )==czero &
                                 ) then
                          ! ==== typical case: not collapsed (yet). ====
                          h( k+1, k ) = beta
                          h( k+2, k ) = czero
                          h( k+3, k ) = czero
                       else
                          ! ==== atypical case: collapsed.  attempt to
                          ! .    reintroduce ignoring h(k+1,k) and h(k+2,k).
                          ! .    if the fill resulting from the new
                          ! .    reflector is too large, then abandon it.
                          ! .    otherwise, use the new cone. ====
                          call stdlib_zlaqr1( 3, h( k+1, k+1 ), ldh, s( 2*m-1 ),s( 2*m ), vt )
                                    
                          alpha = vt( 1 )
                          call stdlib_zlarfg( 3, alpha, vt( 2 ), 1, vt( 1 ) )
                          refsum = conjg( vt( 1 ) )*( h( k+1, k )+conjg( vt( 2 ) )*h( k+2, k ) )
                                    
                          if( cabs1( h( k+2, k )-refsum*vt( 2 ) )+cabs1( refsum*vt( 3 ) )>ulp*( &
                          cabs1( h( k, k ) )+cabs1( h( k+1,k+1 ) )+cabs1( h( k+2, k+2 ) ) ) ) &
                                    then
                             ! ==== starting a new bulge here would
                             ! .    create non-negligible fill.  use
                             ! .    the old cone with trepidation. ====
                             h( k+1, k ) = beta
                             h( k+2, k ) = czero
                             h( k+3, k ) = czero
                          else
                             ! ==== starting a new bulge here would
                             ! .    create only negligible fill.
                             ! .    replace the old reflector with
                             ! .    the new cone. ====
                             h( k+1, k ) = h( k+1, k ) - refsum
                             h( k+2, k ) = czero
                             h( k+3, k ) = czero
                             v( 1, m ) = vt( 1 )
                             v( 2, m ) = vt( 2 )
                             v( 3, m ) = vt( 3 )
                          end if
                       end if
                    end if
                    ! ====  apply reflection from the right and
                    ! .     the first column of update from the left.
                    ! .     these updates are required for the vigilant
                    ! .     deflation check. we still delay most of the
                    ! .     updates from the left for efficiency. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m )*( h( j, k+1 )+v( 2, m )*h( j, k+2 )+v( 3, m )*h( j, k+3 &
                                 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) -refsum*conjg( v( 2, m ) )
                       h( j, k+3 ) = h( j, k+3 ) -refsum*conjg( v( 3, m ) )
                    end do
                    ! ==== perform update from left for subsequent
                    ! .    column. ====
                    refsum =  conjg( v( 1, m ) )*( h( k+1, k+1 )+conjg( v( 2, m ) )*h( k+2, k+1 )+&
                              conjg( v( 3, m ) )*h( k+3, k+1 ) )
                    h( k+1, k+1 ) = h( k+1, k+1 ) - refsum
                    h( k+2, k+1 ) = h( k+2, k+1 ) - refsum*v( 2, m )
                    h( k+3, k+1 ) = h( k+3, k+1 ) - refsum*v( 3, m )
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is czero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k<ktop)cycle
                    if( h( k+1, k )/=czero ) then
                       tst1 = cabs1( h( k, k ) ) + cabs1( h( k+1, k+1 ) )
                       if( tst1==rzero ) then
                          if( k>=ktop+1 )tst1 = tst1 + cabs1( h( k, k-1 ) )
                          if( k>=ktop+2 )tst1 = tst1 + cabs1( h( k, k-2 ) )
                          if( k>=ktop+3 )tst1 = tst1 + cabs1( h( k, k-3 ) )
                          if( k<=kbot-2 )tst1 = tst1 + cabs1( h( k+2, k+1 ) )
                          if( k<=kbot-3 )tst1 = tst1 + cabs1( h( k+3, k+1 ) )
                          if( k<=kbot-4 )tst1 = tst1 + cabs1( h( k+4, k+1 ) )
                       end if
                       if( cabs1( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) )then
                          h12 = max( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                          h21 = min( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                          h11 = max( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                    
                          h22 = min( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                    
                          scl = h11 + h12
                          tst2 = h22*( h11 / scl )
                          if( tst2==rzero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) )h( k+1,&
                                     k ) = czero
                       end if
                    end if
                 end do loop_80
                 ! ==== multiply h by reflections from the left ====
                 if( accum ) then
                    jbot = min( ndcol, kbot )
                 else if( wantt ) then
                    jbot = n
                 else
                    jbot = kbot
                 end if
                 do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    do j = max( ktop, krcol + 2*m ), jbot
                       refsum = conjg( v( 1, m ) )*( h( k+1, j )+conjg( v( 2, m ) )*h( k+2, j )+&
                                 conjg( v( 3, m ) )*h( k+3, j ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m )
                       h( k+3, j ) = h( k+3, j ) - refsum*v( 3, m )
                    end do
                 end do
                 ! ==== accumulate orthogonal transformations. ====
                 if( accum ) then
                    ! ==== accumulate u. (if needed, update z later
                    ! .    with an efficient matrix-matrix
                    ! .    multiply.) ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       kms = k - incol
                       i2 = max( 1, ktop-incol )
                       i2 = max( i2, kms-(krcol-incol)+1 )
                       i4 = min( kdu, krcol + 2*( mbot-1 ) - incol + 5 )
                       do j = i2, i4
                          refsum = v( 1, m )*( u( j, kms+1 )+v( 2, m )*u( j, kms+2 )+v( 3, m )*u( &
                                    j, kms+3 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) -refsum*conjg( v( 2, m ) )
                          u( j, kms+3 ) = u( j, kms+3 ) -refsum*conjg( v( 3, m ) )
                       end do
                    end do
                 else if( wantz ) then
                    ! ==== u is not accumulated, so update z
                    ! .    now by multiplying by reflections
                    ! .    from the right. ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       do j = iloz, ihiz
                          refsum = v( 1, m )*( z( j, k+1 )+v( 2, m )*z( j, k+2 )+v( 3, m )*z( j, &
                                    k+3 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) -refsum*conjg( v( 2, m ) )
                          z( j, k+3 ) = z( j, k+3 ) -refsum*conjg( v( 3, m ) )
                       end do
                    end do
                 end if
                 ! ==== end of near-the-diagonal bulge chase. ====
              end do loop_145
              ! ==== use u (if accumulated) to update far-from-diagonal
              ! .    entries in h.  if required, use u to update z as
              ! .    well. ====
              if( accum ) then
                 if( wantt ) then
                    jtop = 1
                    jbot = n
                 else
                    jtop = ktop
                    jbot = kbot
                 end if
                 k1 = max( 1, ktop-incol )
                 nu = ( kdu-max( 0, ndcol-kbot ) ) - k1 + 1
                 ! ==== horizontal multiply ====
                 do jcol = min( ndcol, kbot ) + 1, jbot, nh
                    jlen = min( nh, jbot-jcol+1 )
                    call stdlib_zgemm( 'C', 'N', nu, jlen, nu, cone, u( k1, k1 ),ldu, h( incol+k1,&
                               jcol ), ldh, czero, wh,ldwh )
                    call stdlib_zlacpy( 'ALL', nu, jlen, wh, ldwh,h( incol+k1, jcol ), ldh )
                              
                 end do
                 ! ==== vertical multiply ====
                 do jrow = jtop, max( ktop, incol ) - 1, nv
                    jlen = min( nv, max( ktop, incol )-jrow )
                    call stdlib_zgemm( 'N', 'N', jlen, nu, nu, cone,h( jrow, incol+k1 ), ldh, u( &
                              k1, k1 ),ldu, czero, wv, ldwv )
                    call stdlib_zlacpy( 'ALL', jlen, nu, wv, ldwv,h( jrow, incol+k1 ), ldh )
                              
                 end do
                 ! ==== z multiply (also vertical) ====
                 if( wantz ) then
                    do jrow = iloz, ihiz, nv
                       jlen = min( nv, ihiz-jrow+1 )
                       call stdlib_zgemm( 'N', 'N', jlen, nu, nu, cone,z( jrow, incol+k1 ), ldz, &
                                 u( k1, k1 ),ldu, czero, wv, ldwv )
                       call stdlib_zlacpy( 'ALL', jlen, nu, wv, ldwv,z( jrow, incol+k1 ), ldz )
                                 
                    end do
                 end if
              end if
           end do loop_180
     end subroutine stdlib_zlaqr5

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$laqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts, s,h, ldh, iloz, &
     !! ZLAQR5:, called by ZLAQR0, performs a
     !! single small-bulge multi-shift QR sweep.
               ihiz, z, ldz, v, ldv, u, ldu, nv,wv, ldwv, nh, wh, ldwh )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv, ldwh, ldwv, &
                     ldz, n, nh, nshfts, nv
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: h(ldh,*), s(*), z(ldz,*)
           complex(${ck}$), intent(out) :: u(ldu,*), v(ldv,*), wh(ldwh,*), wv(ldwv,*)
        ! ================================================================
           ! Parameters 
           real(${ck}$), parameter :: rzero = 0.0_${ck}$
           real(${ck}$), parameter :: rone = 1.0_${ck}$
           
           
           ! Local Scalars 
           complex(${ck}$) :: alpha, beta, cdum, refsum
           real(${ck}$) :: h11, h12, h21, h22, safmax, safmin, scl, smlnum, tst1, tst2, ulp
           integer(ilp) :: i2, i4, incol, j, jbot, jcol, jlen, jrow, jtop, k, k1, kdu, kms, krcol,&
                      m, m22, mbot, mtop, nbmps, ndcol, ns, nu
           logical(lk) :: accum, bmp22
           ! Intrinsic Functions 
           ! Local Arrays 
           complex(${ck}$) :: vt(3)
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! ==== if there are no shifts, then there is nothing to do. ====
           if( nshfts<2 )return
           ! ==== if the active block is empty or 1-by-1, then there
           ! .    is nothing to do. ====
           if( ktop>=kbot )return
           ! ==== nshfts is supposed to be even, but if it is odd,
           ! .    then simply reduce it by cone.  ====
           ns = nshfts - mod( nshfts, 2 )
           ! ==== machine constants for deflation ====
           safmin = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_${c2ri(ci)}$labad( safmin, safmax )
           ulp = stdlib_${c2ri(ci)}$lamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=${ck}$) / ulp )
           ! ==== use accumulated reflections to update far-from-diagonal
           ! .    entries ? ====
           accum = ( kacc22==1 ) .or. ( kacc22==2 )
           ! ==== clear trash ====
           if( ktop+2<=kbot )h( ktop+2, ktop ) = czero
           ! ==== nbmps = number of 2-shift bulges in the chain ====
           nbmps = ns / 2
           ! ==== kdu = width of slab ====
           kdu = 4*nbmps
           ! ==== create and chase chains of nbmps bulges ====
           loop_180: do incol = ktop - 2*nbmps + 1, kbot - 2, 2*nbmps
              ! jtop = index from which updates from the right start.
              if( accum ) then
                 jtop = max( ktop, incol )
              else if( wantt ) then
                 jtop = 1
              else
                 jtop = ktop
              end if
              ndcol = incol + kdu
              if( accum )call stdlib_${ci}$laset( 'ALL', kdu, kdu, czero, cone, u, ldu )
              ! ==== near-the-diagonal bulge chase.  the following loop
              ! .    performs the near-the-diagonal part of a small bulge
              ! .    multi-shift qr sweep.  each 4*nbmps column diagonal
              ! .    chunk extends from column incol to column ndcol
              ! .    (including both column incol and column ndcol). the
              ! .    following loop chases a 2*nbmps+1 column long chain of
              ! .    nbmps bulges 2*nbmps columns to the right.  (incol
              ! .    may be less than ktop and and ndcol may be greater than
              ! .    kbot indicating phantom columns from which to chase
              ! .    bulges before they are actually introduced or to which
              ! .    to chase bulges beyond column kbot.)  ====
              loop_145: do krcol = incol, min( incol+2*nbmps-1, kbot-2 )
                 ! ==== bulges number mtop to mbot are active double implicit
                 ! .    shift bulges.  there may or may not also be small
                 ! .    2-by-2 bulge, if there is room.  the inactive bulges
                 ! .    (if any) must wait until the active bulges have moved
                 ! .    down the diagonal to make room.  the phantom matrix
                 ! .    paradigm described above helps keep track.  ====
                 mtop = max( 1, ( ktop-krcol ) / 2+1 )
                 mbot = min( nbmps, ( kbot-krcol-1 ) / 2 )
                 m22 = mbot + 1
                 bmp22 = ( mbot<nbmps ) .and. ( krcol+2*( m22-1 ) )==( kbot-2 )
                 ! ==== generate reflections to chase the chain right
                 ! .    cone column.  (the minimum value of k is ktop-1.) ====
                 if ( bmp22 ) then
                    ! ==== special case: 2-by-2 reflection at bottom treated
                    ! .    separately ====
                    k = krcol + 2*( m22-1 )
                    if( k==ktop-1 ) then
                       call stdlib_${ci}$laqr1( 2, h( k+1, k+1 ), ldh, s( 2*m22-1 ),s( 2*m22 ), v( 1, &
                                 m22 ) )
                       beta = v( 1, m22 )
                       call stdlib_${ci}$larfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                    else
                       beta = h( k+1, k )
                       v( 2, m22 ) = h( k+2, k )
                       call stdlib_${ci}$larfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                       h( k+1, k ) = beta
                       h( k+2, k ) = czero
                    end if
                    ! ==== perform update from right within
                    ! .    computational window. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m22 )*( h( j, k+1 )+v( 2, m22 )*h( j, k+2 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) -refsum*conjg( v( 2, m22 ) )
                    end do
                    ! ==== perform update from left within
                    ! .    computational window. ====
                    if( accum ) then
                       jbot = min( ndcol, kbot )
                    else if( wantt ) then
                       jbot = n
                    else
                       jbot = kbot
                    end if
                    do j = k+1, jbot
                       refsum = conjg( v( 1, m22 ) )*( h( k+1, j )+conjg( v( 2, m22 ) )*h( k+2, j &
                                 ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m22 )
                    end do
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is czero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k>=ktop ) then
                       if( h( k+1, k )/=czero ) then
                          tst1 = cabs1( h( k, k ) ) + cabs1( h( k+1, k+1 ) )
                          if( tst1==rzero ) then
                             if( k>=ktop+1 )tst1 = tst1 + cabs1( h( k, k-1 ) )
                             if( k>=ktop+2 )tst1 = tst1 + cabs1( h( k, k-2 ) )
                             if( k>=ktop+3 )tst1 = tst1 + cabs1( h( k, k-3 ) )
                             if( k<=kbot-2 )tst1 = tst1 + cabs1( h( k+2, k+1 ) )
                             if( k<=kbot-3 )tst1 = tst1 + cabs1( h( k+3, k+1 ) )
                             if( k<=kbot-4 )tst1 = tst1 + cabs1( h( k+4, k+1 ) )
                          end if
                          if( cabs1( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) ) then
                             h12 = max( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                             h21 = min( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                             h11 = max( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             h22 = min( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             scl = h11 + h12
                             tst2 = h22*( h11 / scl )
                             if( tst2==rzero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) )h( &
                                       k+1, k ) = czero
                          end if
                       end if
                    end if
                    ! ==== accumulate orthogonal transformations. ====
                    if( accum ) then
                       kms = k - incol
                       do j = max( 1, ktop-incol ), kdu
                          refsum = v( 1, m22 )*( u( j, kms+1 )+v( 2, m22 )*u( j, kms+2 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) -refsum*conjg( v( 2, m22 ) )
                       end do
                    else if( wantz ) then
                       do j = iloz, ihiz
                          refsum = v( 1, m22 )*( z( j, k+1 )+v( 2, m22 )*z( j, k+2 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) -refsum*conjg( v( 2, m22 ) )
                       end do
                    end if
                 end if
                 ! ==== normal case: chain of 3-by-3 reflections ====
                 loop_80: do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    if( k==ktop-1 ) then
                       call stdlib_${ci}$laqr1( 3, h( ktop, ktop ), ldh, s( 2*m-1 ),s( 2*m ), v( 1, m )&
                                  )
                       alpha = v( 1, m )
                       call stdlib_${ci}$larfg( 3, alpha, v( 2, m ), 1, v( 1, m ) )
                    else
                       ! ==== perform delayed transformation of row below
                       ! .    mth bulge. exploit fact that first two elements
                       ! .    of row are actually czero. ====
                       refsum = v( 1, m )*v( 3, m )*h( k+3, k+2 )
                       h( k+3, k   ) = -refsum
                       h( k+3, k+1 ) = -refsum*conjg( v( 2, m ) )
                       h( k+3, k+2 ) = h( k+3, k+2 ) -refsum*conjg( v( 3, m ) )
                       ! ==== calculate reflection to move
                       ! .    mth bulge cone step. ====
                       beta      = h( k+1, k )
                       v( 2, m ) = h( k+2, k )
                       v( 3, m ) = h( k+3, k )
                       call stdlib_${ci}$larfg( 3, beta, v( 2, m ), 1, v( 1, m ) )
                       ! ==== a bulge may collapse because of vigilant
                       ! .    deflation or destructive underflow.  in the
                       ! .    underflow case, try the two-small-subdiagonals
                       ! .    trick to try to reinflate the bulge.  ====
                       if( h( k+3, k )/=czero .or. h( k+3, k+1 )/=czero .or. h( k+3, k+2 )==czero &
                                 ) then
                          ! ==== typical case: not collapsed (yet). ====
                          h( k+1, k ) = beta
                          h( k+2, k ) = czero
                          h( k+3, k ) = czero
                       else
                          ! ==== atypical case: collapsed.  attempt to
                          ! .    reintroduce ignoring h(k+1,k) and h(k+2,k).
                          ! .    if the fill resulting from the new
                          ! .    reflector is too large, then abandon it.
                          ! .    otherwise, use the new cone. ====
                          call stdlib_${ci}$laqr1( 3, h( k+1, k+1 ), ldh, s( 2*m-1 ),s( 2*m ), vt )
                                    
                          alpha = vt( 1 )
                          call stdlib_${ci}$larfg( 3, alpha, vt( 2 ), 1, vt( 1 ) )
                          refsum = conjg( vt( 1 ) )*( h( k+1, k )+conjg( vt( 2 ) )*h( k+2, k ) )
                                    
                          if( cabs1( h( k+2, k )-refsum*vt( 2 ) )+cabs1( refsum*vt( 3 ) )>ulp*( &
                          cabs1( h( k, k ) )+cabs1( h( k+1,k+1 ) )+cabs1( h( k+2, k+2 ) ) ) ) &
                                    then
                             ! ==== starting a new bulge here would
                             ! .    create non-negligible fill.  use
                             ! .    the old cone with trepidation. ====
                             h( k+1, k ) = beta
                             h( k+2, k ) = czero
                             h( k+3, k ) = czero
                          else
                             ! ==== starting a new bulge here would
                             ! .    create only negligible fill.
                             ! .    replace the old reflector with
                             ! .    the new cone. ====
                             h( k+1, k ) = h( k+1, k ) - refsum
                             h( k+2, k ) = czero
                             h( k+3, k ) = czero
                             v( 1, m ) = vt( 1 )
                             v( 2, m ) = vt( 2 )
                             v( 3, m ) = vt( 3 )
                          end if
                       end if
                    end if
                    ! ====  apply reflection from the right and
                    ! .     the first column of update from the left.
                    ! .     these updates are required for the vigilant
                    ! .     deflation check. we still delay most of the
                    ! .     updates from the left for efficiency. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m )*( h( j, k+1 )+v( 2, m )*h( j, k+2 )+v( 3, m )*h( j, k+3 &
                                 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) -refsum*conjg( v( 2, m ) )
                       h( j, k+3 ) = h( j, k+3 ) -refsum*conjg( v( 3, m ) )
                    end do
                    ! ==== perform update from left for subsequent
                    ! .    column. ====
                    refsum =  conjg( v( 1, m ) )*( h( k+1, k+1 )+conjg( v( 2, m ) )*h( k+2, k+1 )+&
                              conjg( v( 3, m ) )*h( k+3, k+1 ) )
                    h( k+1, k+1 ) = h( k+1, k+1 ) - refsum
                    h( k+2, k+1 ) = h( k+2, k+1 ) - refsum*v( 2, m )
                    h( k+3, k+1 ) = h( k+3, k+1 ) - refsum*v( 3, m )
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is czero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k<ktop)cycle
                    if( h( k+1, k )/=czero ) then
                       tst1 = cabs1( h( k, k ) ) + cabs1( h( k+1, k+1 ) )
                       if( tst1==rzero ) then
                          if( k>=ktop+1 )tst1 = tst1 + cabs1( h( k, k-1 ) )
                          if( k>=ktop+2 )tst1 = tst1 + cabs1( h( k, k-2 ) )
                          if( k>=ktop+3 )tst1 = tst1 + cabs1( h( k, k-3 ) )
                          if( k<=kbot-2 )tst1 = tst1 + cabs1( h( k+2, k+1 ) )
                          if( k<=kbot-3 )tst1 = tst1 + cabs1( h( k+3, k+1 ) )
                          if( k<=kbot-4 )tst1 = tst1 + cabs1( h( k+4, k+1 ) )
                       end if
                       if( cabs1( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) )then
                          h12 = max( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                          h21 = min( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                          h11 = max( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                    
                          h22 = min( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                    
                          scl = h11 + h12
                          tst2 = h22*( h11 / scl )
                          if( tst2==rzero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) )h( k+1,&
                                     k ) = czero
                       end if
                    end if
                 end do loop_80
                 ! ==== multiply h by reflections from the left ====
                 if( accum ) then
                    jbot = min( ndcol, kbot )
                 else if( wantt ) then
                    jbot = n
                 else
                    jbot = kbot
                 end if
                 do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    do j = max( ktop, krcol + 2*m ), jbot
                       refsum = conjg( v( 1, m ) )*( h( k+1, j )+conjg( v( 2, m ) )*h( k+2, j )+&
                                 conjg( v( 3, m ) )*h( k+3, j ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m )
                       h( k+3, j ) = h( k+3, j ) - refsum*v( 3, m )
                    end do
                 end do
                 ! ==== accumulate orthogonal transformations. ====
                 if( accum ) then
                    ! ==== accumulate u. (if needed, update z later
                    ! .    with an efficient matrix-matrix
                    ! .    multiply.) ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       kms = k - incol
                       i2 = max( 1, ktop-incol )
                       i2 = max( i2, kms-(krcol-incol)+1 )
                       i4 = min( kdu, krcol + 2*( mbot-1 ) - incol + 5 )
                       do j = i2, i4
                          refsum = v( 1, m )*( u( j, kms+1 )+v( 2, m )*u( j, kms+2 )+v( 3, m )*u( &
                                    j, kms+3 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) -refsum*conjg( v( 2, m ) )
                          u( j, kms+3 ) = u( j, kms+3 ) -refsum*conjg( v( 3, m ) )
                       end do
                    end do
                 else if( wantz ) then
                    ! ==== u is not accumulated, so update z
                    ! .    now by multiplying by reflections
                    ! .    from the right. ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       do j = iloz, ihiz
                          refsum = v( 1, m )*( z( j, k+1 )+v( 2, m )*z( j, k+2 )+v( 3, m )*z( j, &
                                    k+3 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) -refsum*conjg( v( 2, m ) )
                          z( j, k+3 ) = z( j, k+3 ) -refsum*conjg( v( 3, m ) )
                       end do
                    end do
                 end if
                 ! ==== end of near-the-diagonal bulge chase. ====
              end do loop_145
              ! ==== use u (if accumulated) to update far-from-diagonal
              ! .    entries in h.  if required, use u to update z as
              ! .    well. ====
              if( accum ) then
                 if( wantt ) then
                    jtop = 1
                    jbot = n
                 else
                    jtop = ktop
                    jbot = kbot
                 end if
                 k1 = max( 1, ktop-incol )
                 nu = ( kdu-max( 0, ndcol-kbot ) ) - k1 + 1
                 ! ==== horizontal multiply ====
                 do jcol = min( ndcol, kbot ) + 1, jbot, nh
                    jlen = min( nh, jbot-jcol+1 )
                    call stdlib_${ci}$gemm( 'C', 'N', nu, jlen, nu, cone, u( k1, k1 ),ldu, h( incol+k1,&
                               jcol ), ldh, czero, wh,ldwh )
                    call stdlib_${ci}$lacpy( 'ALL', nu, jlen, wh, ldwh,h( incol+k1, jcol ), ldh )
                              
                 end do
                 ! ==== vertical multiply ====
                 do jrow = jtop, max( ktop, incol ) - 1, nv
                    jlen = min( nv, max( ktop, incol )-jrow )
                    call stdlib_${ci}$gemm( 'N', 'N', jlen, nu, nu, cone,h( jrow, incol+k1 ), ldh, u( &
                              k1, k1 ),ldu, czero, wv, ldwv )
                    call stdlib_${ci}$lacpy( 'ALL', jlen, nu, wv, ldwv,h( jrow, incol+k1 ), ldh )
                              
                 end do
                 ! ==== z multiply (also vertical) ====
                 if( wantz ) then
                    do jrow = iloz, ihiz, nv
                       jlen = min( nv, ihiz-jrow+1 )
                       call stdlib_${ci}$gemm( 'N', 'N', jlen, nu, nu, cone,z( jrow, incol+k1 ), ldz, &
                                 u( k1, k1 ),ldu, czero, wv, ldwv )
                       call stdlib_${ci}$lacpy( 'ALL', jlen, nu, wv, ldwv,z( jrow, incol+k1 ), ldz )
                                 
                    end do
                 end if
              end if
           end do loop_180
     end subroutine stdlib_${ci}$laqr5

#:endif
#:endfor



     module pure subroutine stdlib_stgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! STGSYL solves the generalized Sylvester equation:
     !! A * R - L * B = scale * C                 (1)
     !! D * R - L * E = scale * F
     !! where R and L are unknown m-by-n matrices, (A, D), (B, E) and
     !! (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
     !! respectively, with real entries. (A, D) and (B, E) must be in
     !! generalized (real) Schur canonical form, i.e. A, B are upper quasi
     !! triangular and D, E are upper triangular.
     !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
     !! scaling factor chosen to avoid overflow.
     !! In matrix notation (1) is equivalent to solve  Zx = scale b, where
     !! Z is defined as
     !! Z = [ kron(In, A)  -kron(B**T, Im) ]         (2)
     !! [ kron(In, D)  -kron(E**T, Im) ].
     !! Here Ik is the identity matrix of size k and X**T is the transpose of
     !! X. kron(X, Y) is the Kronecker product between the matrices X and Y.
     !! If TRANS = 'T', STGSYL solves the transposed system Z**T*y = scale*b,
     !! which is equivalent to solve for R and L in
     !! A**T * R + D**T * L = scale * C           (3)
     !! R * B**T + L * E**T = scale * -F
     !! This case (TRANS = 'T') is used to compute an one-norm-based estimate
     !! of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
     !! and (B,E), using SLACON.
     !! If IJOB >= 1, STGSYL computes a Frobenius norm-based estimate
     !! of Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
     !! reciprocal of the smallest singular value of Z. See [1-2] for more
     !! information.
     !! This is a level 3 BLAS algorithm.
               ldf, scale, dif, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, lwork, m, n
           integer(ilp), intent(out) :: info
           real(sp), intent(out) :: dif, scale
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           real(sp), intent(inout) :: c(ldc,*), f(ldf,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_scopy by calls to stdlib_slaset.
        ! sven hammarling, 1/5/02.
           
           ! Local Scalars 
           logical(lk) :: lquery, notran
           integer(ilp) :: i, ie, ifunc, iround, is, isolve, j, je, js, k, linfo, lwmin, mb, nb, &
                     p, ppqq, pq, q
           real(sp) :: dscale, dsum, scale2, scaloc
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>4 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info==0 ) then
              if( notran ) then
                 if( ijob==1 .or. ijob==2 ) then
                    lwmin = max( 1, 2*m*n )
                 else
                    lwmin = 1
                 end if
              else
                 lwmin = 1
              end if
              work( 1 ) = lwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -20
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STGSYL', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              scale = 1
              if( notran ) then
                 if( ijob/=0 ) then
                    dif = 0
                 end if
              end if
              return
           end if
           ! determine optimal block sizes mb and nb
           mb = stdlib_ilaenv( 2, 'STGSYL', trans, m, n, -1, -1 )
           nb = stdlib_ilaenv( 5, 'STGSYL', trans, m, n, -1, -1 )
           isolve = 1
           ifunc = 0
           if( notran ) then
              if( ijob>=3 ) then
                 ifunc = ijob - 2
                 call stdlib_slaset( 'F', m, n, zero, zero, c, ldc )
                 call stdlib_slaset( 'F', m, n, zero, zero, f, ldf )
              else if( ijob>=1 .and. notran ) then
                 isolve = 2
              end if
           end if
           if( ( mb<=1 .and. nb<=1 ) .or. ( mb>=m .and. nb>=n ) )then
              loop_30: do iround = 1, isolve
                 ! use unblocked level 2 solver
                 dscale = zero
                 dsum = one
                 pq = 0
                 call stdlib_stgsy2( trans, ifunc, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f,&
                            ldf, scale, dsum, dscale,iwork, pq, info )
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=sp) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=sp) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_slacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_slacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_slaset( 'F', m, n, zero, zero, c, ldc )
                    call stdlib_slaset( 'F', m, n, zero, zero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_slacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_slacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_30
              return
           end if
           ! determine block structure of a
           p = 0
           i = 1
           40 continue
           if( i>m )go to 50
           p = p + 1
           iwork( p ) = i
           i = i + mb
           if( i>=m )go to 50
           if( a( i, i-1 )/=zero )i = i + 1
           go to 40
           50 continue
           iwork( p+1 ) = m + 1
           if( iwork( p )==iwork( p+1 ) )p = p - 1
           ! determine block structure of b
           q = p + 1
           j = 1
           60 continue
           if( j>n )go to 70
           q = q + 1
           iwork( q ) = j
           j = j + nb
           if( j>=n )go to 70
           if( b( j, j-1 )/=zero )j = j + 1
           go to 60
           70 continue
           iwork( q+1 ) = n + 1
           if( iwork( q )==iwork( q+1 ) )q = q - 1
           if( notran ) then
              loop_150: do iround = 1, isolve
                 ! solve (i, j)-subsystem
                     ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                     ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
                 ! for i = p, p - 1,..., 1; j = 1, 2,..., q
                 dscale = zero
                 dsum = one
                 pq = 0
                 scale = one
                 loop_130: do j = p + 2, q
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    loop_120: do i = p, 1, -1
                       is = iwork( i )
                       ie = iwork( i+1 ) - 1
                       mb = ie - is + 1
                       ppqq = 0
                       call stdlib_stgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), &
                       ldb, c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, &
                                 scaloc, dsum, dscale,iwork( q+2 ), ppqq, linfo )
                       if( linfo>0 )info = linfo
                       pq = pq + ppqq
                       if( scaloc/=one ) then
                          do k = 1, js - 1
                             call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          do k = js, je
                             call stdlib_sscal( is-1, scaloc, c( 1, k ), 1 )
                             call stdlib_sscal( is-1, scaloc, f( 1, k ), 1 )
                          end do
                          do k = js, je
                             call stdlib_sscal( m-ie, scaloc, c( ie+1, k ), 1 )
                             call stdlib_sscal( m-ie, scaloc, f( ie+1, k ), 1 )
                          end do
                          do k = je + 1, n
                             call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_sgemm( 'N', 'N', is-1, nb, mb, -one,a( 1, is ), lda, c( is, &
                                    js ), ldc, one,c( 1, js ), ldc )
                          call stdlib_sgemm( 'N', 'N', is-1, nb, mb, -one,d( 1, is ), ldd, c( is, &
                                    js ), ldc, one,f( 1, js ), ldf )
                       end if
                       if( j<q ) then
                          call stdlib_sgemm( 'N', 'N', mb, n-je, nb, one,f( is, js ), ldf, b( js, &
                                    je+1 ), ldb,one, c( is, je+1 ), ldc )
                          call stdlib_sgemm( 'N', 'N', mb, n-je, nb, one,f( is, js ), ldf, e( js, &
                                    je+1 ), lde,one, f( is, je+1 ), ldf )
                       end if
                    end do loop_120
                 end do loop_130
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=sp) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=sp) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_slacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_slacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_slaset( 'F', m, n, zero, zero, c, ldc )
                    call stdlib_slaset( 'F', m, n, zero, zero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_slacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_slacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_150
           else
              ! solve transposed (i, j)-subsystem
                   ! a(i, i)**t * r(i, j)  + d(i, i)**t * l(i, j)  =  c(i, j)
                   ! r(i, j)  * b(j, j)**t + l(i, j)  * e(j, j)**t = -f(i, j)
              ! for i = 1,2,..., p; j = q, q-1,..., 1
              scale = one
              loop_210: do i = 1, p
                 is = iwork( i )
                 ie = iwork( i+1 ) - 1
                 mb = ie - is + 1
                 loop_200: do j = q, p + 2, -1
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    call stdlib_stgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), ldb, &
                    c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, scaloc, &
                              dsum, dscale,iwork( q+2 ), ppqq, linfo )
                    if( linfo>0 )info = linfo
                    if( scaloc/=one ) then
                       do k = 1, js - 1
                          call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                          call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                       end do
                       do k = js, je
                          call stdlib_sscal( is-1, scaloc, c( 1, k ), 1 )
                          call stdlib_sscal( is-1, scaloc, f( 1, k ), 1 )
                       end do
                       do k = js, je
                          call stdlib_sscal( m-ie, scaloc, c( ie+1, k ), 1 )
                          call stdlib_sscal( m-ie, scaloc, f( ie+1, k ), 1 )
                       end do
                       do k = je + 1, n
                          call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                          call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    ! substitute r(i, j) and l(i, j) into remaining equation.
                    if( j>p+2 ) then
                       call stdlib_sgemm( 'N', 'T', mb, js-1, nb, one, c( is, js ),ldc, b( 1, js )&
                                 , ldb, one, f( is, 1 ),ldf )
                       call stdlib_sgemm( 'N', 'T', mb, js-1, nb, one, f( is, js ),ldf, e( 1, js )&
                                 , lde, one, f( is, 1 ),ldf )
                    end if
                    if( i<p ) then
                       call stdlib_sgemm( 'T', 'N', m-ie, nb, mb, -one,a( is, ie+1 ), lda, c( is, &
                                 js ), ldc, one,c( ie+1, js ), ldc )
                       call stdlib_sgemm( 'T', 'N', m-ie, nb, mb, -one,d( is, ie+1 ), ldd, f( is, &
                                 js ), ldf, one,c( ie+1, js ), ldc )
                    end if
                 end do loop_200
              end do loop_210
           end if
           work( 1 ) = lwmin
           return
     end subroutine stdlib_stgsyl

     module pure subroutine stdlib_dtgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! DTGSYL solves the generalized Sylvester equation:
     !! A * R - L * B = scale * C                 (1)
     !! D * R - L * E = scale * F
     !! where R and L are unknown m-by-n matrices, (A, D), (B, E) and
     !! (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
     !! respectively, with real entries. (A, D) and (B, E) must be in
     !! generalized (real) Schur canonical form, i.e. A, B are upper quasi
     !! triangular and D, E are upper triangular.
     !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
     !! scaling factor chosen to avoid overflow.
     !! In matrix notation (1) is equivalent to solve  Zx = scale b, where
     !! Z is defined as
     !! Z = [ kron(In, A)  -kron(B**T, Im) ]         (2)
     !! [ kron(In, D)  -kron(E**T, Im) ].
     !! Here Ik is the identity matrix of size k and X**T is the transpose of
     !! X. kron(X, Y) is the Kronecker product between the matrices X and Y.
     !! If TRANS = 'T', DTGSYL solves the transposed system Z**T*y = scale*b,
     !! which is equivalent to solve for R and L in
     !! A**T * R + D**T * L = scale * C           (3)
     !! R * B**T + L * E**T = scale * -F
     !! This case (TRANS = 'T') is used to compute an one-norm-based estimate
     !! of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
     !! and (B,E), using DLACON.
     !! If IJOB >= 1, DTGSYL computes a Frobenius norm-based estimate
     !! of Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
     !! reciprocal of the smallest singular value of Z. See [1-2] for more
     !! information.
     !! This is a level 3 BLAS algorithm.
               ldf, scale, dif, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, lwork, m, n
           integer(ilp), intent(out) :: info
           real(dp), intent(out) :: dif, scale
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           real(dp), intent(inout) :: c(ldc,*), f(ldf,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_dcopy by calls to stdlib_dlaset.
        ! sven hammarling, 1/5/02.
           
           ! Local Scalars 
           logical(lk) :: lquery, notran
           integer(ilp) :: i, ie, ifunc, iround, is, isolve, j, je, js, k, linfo, lwmin, mb, nb, &
                     p, ppqq, pq, q
           real(dp) :: dscale, dsum, scale2, scaloc
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>4 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info==0 ) then
              if( notran ) then
                 if( ijob==1 .or. ijob==2 ) then
                    lwmin = max( 1, 2*m*n )
                 else
                    lwmin = 1
                 end if
              else
                 lwmin = 1
              end if
              work( 1 ) = lwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -20
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSYL', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              scale = 1
              if( notran ) then
                 if( ijob/=0 ) then
                    dif = 0
                 end if
              end if
              return
           end if
           ! determine optimal block sizes mb and nb
           mb = stdlib_ilaenv( 2, 'DTGSYL', trans, m, n, -1, -1 )
           nb = stdlib_ilaenv( 5, 'DTGSYL', trans, m, n, -1, -1 )
           isolve = 1
           ifunc = 0
           if( notran ) then
              if( ijob>=3 ) then
                 ifunc = ijob - 2
                 call stdlib_dlaset( 'F', m, n, zero, zero, c, ldc )
                 call stdlib_dlaset( 'F', m, n, zero, zero, f, ldf )
              else if( ijob>=1 ) then
                 isolve = 2
              end if
           end if
           if( ( mb<=1 .and. nb<=1 ) .or. ( mb>=m .and. nb>=n ) )then
              loop_30: do iround = 1, isolve
                 ! use unblocked level 2 solver
                 dscale = zero
                 dsum = one
                 pq = 0
                 call stdlib_dtgsy2( trans, ifunc, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f,&
                            ldf, scale, dsum, dscale,iwork, pq, info )
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=dp) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=dp) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_dlacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_dlacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_dlaset( 'F', m, n, zero, zero, c, ldc )
                    call stdlib_dlaset( 'F', m, n, zero, zero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_dlacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_dlacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_30
              return
           end if
           ! determine block structure of a
           p = 0
           i = 1
           40 continue
           if( i>m )go to 50
           p = p + 1
           iwork( p ) = i
           i = i + mb
           if( i>=m )go to 50
           if( a( i, i-1 )/=zero )i = i + 1
           go to 40
           50 continue
           iwork( p+1 ) = m + 1
           if( iwork( p )==iwork( p+1 ) )p = p - 1
           ! determine block structure of b
           q = p + 1
           j = 1
           60 continue
           if( j>n )go to 70
           q = q + 1
           iwork( q ) = j
           j = j + nb
           if( j>=n )go to 70
           if( b( j, j-1 )/=zero )j = j + 1
           go to 60
           70 continue
           iwork( q+1 ) = n + 1
           if( iwork( q )==iwork( q+1 ) )q = q - 1
           if( notran ) then
              loop_150: do iround = 1, isolve
                 ! solve (i, j)-subsystem
                     ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                     ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
                 ! for i = p, p - 1,..., 1; j = 1, 2,..., q
                 dscale = zero
                 dsum = one
                 pq = 0
                 scale = one
                 loop_130: do j = p + 2, q
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    loop_120: do i = p, 1, -1
                       is = iwork( i )
                       ie = iwork( i+1 ) - 1
                       mb = ie - is + 1
                       ppqq = 0
                       call stdlib_dtgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), &
                       ldb, c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, &
                                 scaloc, dsum, dscale,iwork( q+2 ), ppqq, linfo )
                       if( linfo>0 )info = linfo
                       pq = pq + ppqq
                       if( scaloc/=one ) then
                          do k = 1, js - 1
                             call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          do k = js, je
                             call stdlib_dscal( is-1, scaloc, c( 1, k ), 1 )
                             call stdlib_dscal( is-1, scaloc, f( 1, k ), 1 )
                          end do
                          do k = js, je
                             call stdlib_dscal( m-ie, scaloc, c( ie+1, k ), 1 )
                             call stdlib_dscal( m-ie, scaloc, f( ie+1, k ), 1 )
                          end do
                          do k = je + 1, n
                             call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_dgemm( 'N', 'N', is-1, nb, mb, -one,a( 1, is ), lda, c( is, &
                                    js ), ldc, one,c( 1, js ), ldc )
                          call stdlib_dgemm( 'N', 'N', is-1, nb, mb, -one,d( 1, is ), ldd, c( is, &
                                    js ), ldc, one,f( 1, js ), ldf )
                       end if
                       if( j<q ) then
                          call stdlib_dgemm( 'N', 'N', mb, n-je, nb, one,f( is, js ), ldf, b( js, &
                                    je+1 ), ldb,one, c( is, je+1 ), ldc )
                          call stdlib_dgemm( 'N', 'N', mb, n-je, nb, one,f( is, js ), ldf, e( js, &
                                    je+1 ), lde,one, f( is, je+1 ), ldf )
                       end if
                    end do loop_120
                 end do loop_130
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=dp) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=dp) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_dlacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_dlacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_dlaset( 'F', m, n, zero, zero, c, ldc )
                    call stdlib_dlaset( 'F', m, n, zero, zero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_dlacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_dlacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_150
           else
              ! solve transposed (i, j)-subsystem
                   ! a(i, i)**t * r(i, j)  + d(i, i)**t * l(i, j)  =  c(i, j)
                   ! r(i, j)  * b(j, j)**t + l(i, j)  * e(j, j)**t = -f(i, j)
              ! for i = 1,2,..., p; j = q, q-1,..., 1
              scale = one
              loop_210: do i = 1, p
                 is = iwork( i )
                 ie = iwork( i+1 ) - 1
                 mb = ie - is + 1
                 loop_200: do j = q, p + 2, -1
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    call stdlib_dtgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), ldb, &
                    c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, scaloc, &
                              dsum, dscale,iwork( q+2 ), ppqq, linfo )
                    if( linfo>0 )info = linfo
                    if( scaloc/=one ) then
                       do k = 1, js - 1
                          call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                          call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                       end do
                       do k = js, je
                          call stdlib_dscal( is-1, scaloc, c( 1, k ), 1 )
                          call stdlib_dscal( is-1, scaloc, f( 1, k ), 1 )
                       end do
                       do k = js, je
                          call stdlib_dscal( m-ie, scaloc, c( ie+1, k ), 1 )
                          call stdlib_dscal( m-ie, scaloc, f( ie+1, k ), 1 )
                       end do
                       do k = je + 1, n
                          call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                          call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    ! substitute r(i, j) and l(i, j) into remaining equation.
                    if( j>p+2 ) then
                       call stdlib_dgemm( 'N', 'T', mb, js-1, nb, one, c( is, js ),ldc, b( 1, js )&
                                 , ldb, one, f( is, 1 ),ldf )
                       call stdlib_dgemm( 'N', 'T', mb, js-1, nb, one, f( is, js ),ldf, e( 1, js )&
                                 , lde, one, f( is, 1 ),ldf )
                    end if
                    if( i<p ) then
                       call stdlib_dgemm( 'T', 'N', m-ie, nb, mb, -one,a( is, ie+1 ), lda, c( is, &
                                 js ), ldc, one,c( ie+1, js ), ldc )
                       call stdlib_dgemm( 'T', 'N', m-ie, nb, mb, -one,d( is, ie+1 ), ldd, f( is, &
                                 js ), ldf, one,c( ie+1, js ), ldc )
                    end if
                 end do loop_200
              end do loop_210
           end if
           work( 1 ) = lwmin
           return
     end subroutine stdlib_dtgsyl

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$tgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! DTGSYL: solves the generalized Sylvester equation:
     !! A * R - L * B = scale * C                 (1)
     !! D * R - L * E = scale * F
     !! where R and L are unknown m-by-n matrices, (A, D), (B, E) and
     !! (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
     !! respectively, with real entries. (A, D) and (B, E) must be in
     !! generalized (real) Schur canonical form, i.e. A, B are upper quasi
     !! triangular and D, E are upper triangular.
     !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
     !! scaling factor chosen to avoid overflow.
     !! In matrix notation (1) is equivalent to solve  Zx = scale b, where
     !! Z is defined as
     !! Z = [ kron(In, A)  -kron(B**T, Im) ]         (2)
     !! [ kron(In, D)  -kron(E**T, Im) ].
     !! Here Ik is the identity matrix of size k and X**T is the transpose of
     !! X. kron(X, Y) is the Kronecker product between the matrices X and Y.
     !! If TRANS = 'T', DTGSYL solves the transposed system Z**T*y = scale*b,
     !! which is equivalent to solve for R and L in
     !! A**T * R + D**T * L = scale * C           (3)
     !! R * B**T + L * E**T = scale * -F
     !! This case (TRANS = 'T') is used to compute an one-norm-based estimate
     !! of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
     !! and (B,E), using DLACON.
     !! If IJOB >= 1, DTGSYL computes a Frobenius norm-based estimate
     !! of Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
     !! reciprocal of the smallest singular value of Z. See [1-2] for more
     !! information.
     !! This is a level 3 BLAS algorithm.
               ldf, scale, dif, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, lwork, m, n
           integer(ilp), intent(out) :: info
           real(${rk}$), intent(out) :: dif, scale
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           real(${rk}$), intent(inout) :: c(ldc,*), f(ldf,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_${ri}$copy by calls to stdlib_${ri}$laset.
        ! sven hammarling, 1/5/02.
           
           ! Local Scalars 
           logical(lk) :: lquery, notran
           integer(ilp) :: i, ie, ifunc, iround, is, isolve, j, je, js, k, linfo, lwmin, mb, nb, &
                     p, ppqq, pq, q
           real(${rk}$) :: dscale, dsum, scale2, scaloc
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>4 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info==0 ) then
              if( notran ) then
                 if( ijob==1 .or. ijob==2 ) then
                    lwmin = max( 1, 2*m*n )
                 else
                    lwmin = 1
                 end if
              else
                 lwmin = 1
              end if
              work( 1 ) = lwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -20
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSYL', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              scale = 1
              if( notran ) then
                 if( ijob/=0 ) then
                    dif = 0
                 end if
              end if
              return
           end if
           ! determine optimal block sizes mb and nb
           mb = stdlib_ilaenv( 2, 'DTGSYL', trans, m, n, -1, -1 )
           nb = stdlib_ilaenv( 5, 'DTGSYL', trans, m, n, -1, -1 )
           isolve = 1
           ifunc = 0
           if( notran ) then
              if( ijob>=3 ) then
                 ifunc = ijob - 2
                 call stdlib_${ri}$laset( 'F', m, n, zero, zero, c, ldc )
                 call stdlib_${ri}$laset( 'F', m, n, zero, zero, f, ldf )
              else if( ijob>=1 ) then
                 isolve = 2
              end if
           end if
           if( ( mb<=1 .and. nb<=1 ) .or. ( mb>=m .and. nb>=n ) )then
              loop_30: do iround = 1, isolve
                 ! use unblocked level 2 solver
                 dscale = zero
                 dsum = one
                 pq = 0
                 call stdlib_${ri}$tgsy2( trans, ifunc, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f,&
                            ldf, scale, dsum, dscale,iwork, pq, info )
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=${rk}$) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=${rk}$) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_${ri}$lacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_${ri}$lacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_${ri}$laset( 'F', m, n, zero, zero, c, ldc )
                    call stdlib_${ri}$laset( 'F', m, n, zero, zero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_${ri}$lacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_${ri}$lacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_30
              return
           end if
           ! determine block structure of a
           p = 0
           i = 1
           40 continue
           if( i>m )go to 50
           p = p + 1
           iwork( p ) = i
           i = i + mb
           if( i>=m )go to 50
           if( a( i, i-1 )/=zero )i = i + 1
           go to 40
           50 continue
           iwork( p+1 ) = m + 1
           if( iwork( p )==iwork( p+1 ) )p = p - 1
           ! determine block structure of b
           q = p + 1
           j = 1
           60 continue
           if( j>n )go to 70
           q = q + 1
           iwork( q ) = j
           j = j + nb
           if( j>=n )go to 70
           if( b( j, j-1 )/=zero )j = j + 1
           go to 60
           70 continue
           iwork( q+1 ) = n + 1
           if( iwork( q )==iwork( q+1 ) )q = q - 1
           if( notran ) then
              loop_150: do iround = 1, isolve
                 ! solve (i, j)-subsystem
                     ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                     ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
                 ! for i = p, p - 1,..., 1; j = 1, 2,..., q
                 dscale = zero
                 dsum = one
                 pq = 0
                 scale = one
                 loop_130: do j = p + 2, q
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    loop_120: do i = p, 1, -1
                       is = iwork( i )
                       ie = iwork( i+1 ) - 1
                       mb = ie - is + 1
                       ppqq = 0
                       call stdlib_${ri}$tgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), &
                       ldb, c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, &
                                 scaloc, dsum, dscale,iwork( q+2 ), ppqq, linfo )
                       if( linfo>0 )info = linfo
                       pq = pq + ppqq
                       if( scaloc/=one ) then
                          do k = 1, js - 1
                             call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                          end do
                          do k = js, je
                             call stdlib_${ri}$scal( is-1, scaloc, c( 1, k ), 1 )
                             call stdlib_${ri}$scal( is-1, scaloc, f( 1, k ), 1 )
                          end do
                          do k = js, je
                             call stdlib_${ri}$scal( m-ie, scaloc, c( ie+1, k ), 1 )
                             call stdlib_${ri}$scal( m-ie, scaloc, f( ie+1, k ), 1 )
                          end do
                          do k = je + 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_${ri}$gemm( 'N', 'N', is-1, nb, mb, -one,a( 1, is ), lda, c( is, &
                                    js ), ldc, one,c( 1, js ), ldc )
                          call stdlib_${ri}$gemm( 'N', 'N', is-1, nb, mb, -one,d( 1, is ), ldd, c( is, &
                                    js ), ldc, one,f( 1, js ), ldf )
                       end if
                       if( j<q ) then
                          call stdlib_${ri}$gemm( 'N', 'N', mb, n-je, nb, one,f( is, js ), ldf, b( js, &
                                    je+1 ), ldb,one, c( is, je+1 ), ldc )
                          call stdlib_${ri}$gemm( 'N', 'N', mb, n-je, nb, one,f( is, js ), ldf, e( js, &
                                    je+1 ), lde,one, f( is, je+1 ), ldf )
                       end if
                    end do loop_120
                 end do loop_130
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=${rk}$) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=${rk}$) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_${ri}$lacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_${ri}$lacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_${ri}$laset( 'F', m, n, zero, zero, c, ldc )
                    call stdlib_${ri}$laset( 'F', m, n, zero, zero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_${ri}$lacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_${ri}$lacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_150
           else
              ! solve transposed (i, j)-subsystem
                   ! a(i, i)**t * r(i, j)  + d(i, i)**t * l(i, j)  =  c(i, j)
                   ! r(i, j)  * b(j, j)**t + l(i, j)  * e(j, j)**t = -f(i, j)
              ! for i = 1,2,..., p; j = q, q-1,..., 1
              scale = one
              loop_210: do i = 1, p
                 is = iwork( i )
                 ie = iwork( i+1 ) - 1
                 mb = ie - is + 1
                 loop_200: do j = q, p + 2, -1
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    call stdlib_${ri}$tgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), ldb, &
                    c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, scaloc, &
                              dsum, dscale,iwork( q+2 ), ppqq, linfo )
                    if( linfo>0 )info = linfo
                    if( scaloc/=one ) then
                       do k = 1, js - 1
                          call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                          call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                       end do
                       do k = js, je
                          call stdlib_${ri}$scal( is-1, scaloc, c( 1, k ), 1 )
                          call stdlib_${ri}$scal( is-1, scaloc, f( 1, k ), 1 )
                       end do
                       do k = js, je
                          call stdlib_${ri}$scal( m-ie, scaloc, c( ie+1, k ), 1 )
                          call stdlib_${ri}$scal( m-ie, scaloc, f( ie+1, k ), 1 )
                       end do
                       do k = je + 1, n
                          call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                          call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    ! substitute r(i, j) and l(i, j) into remaining equation.
                    if( j>p+2 ) then
                       call stdlib_${ri}$gemm( 'N', 'T', mb, js-1, nb, one, c( is, js ),ldc, b( 1, js )&
                                 , ldb, one, f( is, 1 ),ldf )
                       call stdlib_${ri}$gemm( 'N', 'T', mb, js-1, nb, one, f( is, js ),ldf, e( 1, js )&
                                 , lde, one, f( is, 1 ),ldf )
                    end if
                    if( i<p ) then
                       call stdlib_${ri}$gemm( 'T', 'N', m-ie, nb, mb, -one,a( is, ie+1 ), lda, c( is, &
                                 js ), ldc, one,c( ie+1, js ), ldc )
                       call stdlib_${ri}$gemm( 'T', 'N', m-ie, nb, mb, -one,d( is, ie+1 ), ldd, f( is, &
                                 js ), ldf, one,c( ie+1, js ), ldc )
                    end if
                 end do loop_200
              end do loop_210
           end if
           work( 1 ) = lwmin
           return
     end subroutine stdlib_${ri}$tgsyl

#:endif
#:endfor

     module pure subroutine stdlib_ctgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! CTGSYL solves the generalized Sylvester equation:
     !! A * R - L * B = scale * C            (1)
     !! D * R - L * E = scale * F
     !! where R and L are unknown m-by-n matrices, (A, D), (B, E) and
     !! (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
     !! respectively, with complex entries. A, B, D and E are upper
     !! triangular (i.e., (A,D) and (B,E) in generalized Schur form).
     !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1
     !! is an output scaling factor chosen to avoid overflow.
     !! In matrix notation (1) is equivalent to solve Zx = scale*b, where Z
     !! is defined as
     !! Z = [ kron(In, A)  -kron(B**H, Im) ]        (2)
     !! [ kron(In, D)  -kron(E**H, Im) ],
     !! Here Ix is the identity matrix of size x and X**H is the conjugate
     !! transpose of X. Kron(X, Y) is the Kronecker product between the
     !! matrices X and Y.
     !! If TRANS = 'C', y in the conjugate transposed system Z**H *y = scale*b
     !! is solved for, which is equivalent to solve for R and L in
     !! A**H * R + D**H * L = scale * C           (3)
     !! R * B**H + L * E**H = scale * -F
     !! This case (TRANS = 'C') is used to compute an one-norm-based estimate
     !! of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
     !! and (B,E), using CLACON.
     !! If IJOB >= 1, CTGSYL computes a Frobenius norm-based estimate of
     !! Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
     !! reciprocal of the smallest singular value of Z.
     !! This is a level-3 BLAS algorithm.
               ldf, scale, dif, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, lwork, m, n
           integer(ilp), intent(out) :: info
           real(sp), intent(out) :: dif, scale
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           complex(sp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           complex(sp), intent(inout) :: c(ldc,*), f(ldf,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_ccopy by calls to stdlib_claset.
        ! sven hammarling, 1/5/02.
           
           
           ! Local Scalars 
           logical(lk) :: lquery, notran
           integer(ilp) :: i, ie, ifunc, iround, is, isolve, j, je, js, k, linfo, lwmin, mb, nb, &
                     p, pq, q
           real(sp) :: dscale, dsum, scale2, scaloc
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>4 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info==0 ) then
              if( notran ) then
                 if( ijob==1 .or. ijob==2 ) then
                    lwmin = max( 1, 2*m*n )
                 else
                    lwmin = 1
                 end if
              else
                 lwmin = 1
              end if
              work( 1 ) = lwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -20
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGSYL', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              scale = 1
              if( notran ) then
                 if( ijob/=0 ) then
                    dif = 0
                 end if
              end if
              return
           end if
           ! determine  optimal block sizes mb and nb
           mb = stdlib_ilaenv( 2, 'CTGSYL', trans, m, n, -1, -1 )
           nb = stdlib_ilaenv( 5, 'CTGSYL', trans, m, n, -1, -1 )
           isolve = 1
           ifunc = 0
           if( notran ) then
              if( ijob>=3 ) then
                 ifunc = ijob - 2
                 call stdlib_claset( 'F', m, n, czero, czero, c, ldc )
                 call stdlib_claset( 'F', m, n, czero, czero, f, ldf )
              else if( ijob>=1 .and. notran ) then
                 isolve = 2
              end if
           end if
           if( ( mb<=1 .and. nb<=1 ) .or. ( mb>=m .and. nb>=n ) )then
              ! use unblocked level 2 solver
              loop_30: do iround = 1, isolve
                 scale = one
                 dscale = zero
                 dsum = one
                 pq = m*n
                 call stdlib_ctgsy2( trans, ifunc, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f,&
                            ldf, scale, dsum, dscale,info )
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=sp) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=sp) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_clacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_clacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_claset( 'F', m, n, czero, czero, c, ldc )
                    call stdlib_claset( 'F', m, n, czero, czero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_clacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_clacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_30
              return
           end if
           ! determine block structure of a
           p = 0
           i = 1
           40 continue
           if( i>m )go to 50
           p = p + 1
           iwork( p ) = i
           i = i + mb
           if( i>=m )go to 50
           go to 40
           50 continue
           iwork( p+1 ) = m + 1
           if( iwork( p )==iwork( p+1 ) )p = p - 1
           ! determine block structure of b
           q = p + 1
           j = 1
           60 continue
           if( j>n )go to 70
           q = q + 1
           iwork( q ) = j
           j = j + nb
           if( j>=n )go to 70
           go to 60
           70 continue
           iwork( q+1 ) = n + 1
           if( iwork( q )==iwork( q+1 ) )q = q - 1
           if( notran ) then
              loop_150: do iround = 1, isolve
                 ! solve (i, j) - subsystem
                     ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                     ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
                 ! for i = p, p - 1, ..., 1; j = 1, 2, ..., q
                 pq = 0
                 scale = one
                 dscale = zero
                 dsum = one
                 loop_130: do j = p + 2, q
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    loop_120: do i = p, 1, -1
                       is = iwork( i )
                       ie = iwork( i+1 ) - 1
                       mb = ie - is + 1
                       call stdlib_ctgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), &
                       ldb, c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, &
                                 scaloc, dsum, dscale,linfo )
                       if( linfo>0 )info = linfo
                       pq = pq + mb*nb
                       if( scaloc/=one ) then
                          do k = 1, js - 1
                             call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), c( 1, k ),1 )
                                       
                             call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), f( 1, k ),1 )
                                       
                          end do
                          do k = js, je
                             call stdlib_cscal( is-1, cmplx( scaloc, zero,KIND=sp),c( 1, k ), 1 )
                                       
                             call stdlib_cscal( is-1, cmplx( scaloc, zero,KIND=sp),f( 1, k ), 1 )
                                       
                          end do
                          do k = js, je
                             call stdlib_cscal( m-ie, cmplx( scaloc, zero,KIND=sp),c( ie+1, k ), &
                                       1 )
                             call stdlib_cscal( m-ie, cmplx( scaloc, zero,KIND=sp),f( ie+1, k ), &
                                       1 )
                          end do
                          do k = je + 1, n
                             call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), c( 1, k ),1 )
                                       
                             call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), f( 1, k ),1 )
                                       
                          end do
                          scale = scale*scaloc
                       end if
                       ! substitute r(i,j) and l(i,j) into remaining equation.
                       if( i>1 ) then
                          call stdlib_cgemm( 'N', 'N', is-1, nb, mb,cmplx( -one, zero,KIND=sp), a(&
                           1, is ), lda,c( is, js ), ldc, cmplx( one, zero,KIND=sp),c( 1, js ), &
                                     ldc )
                          call stdlib_cgemm( 'N', 'N', is-1, nb, mb,cmplx( -one, zero,KIND=sp), d(&
                           1, is ), ldd,c( is, js ), ldc, cmplx( one, zero,KIND=sp),f( 1, js ), &
                                     ldf )
                       end if
                       if( j<q ) then
                          call stdlib_cgemm( 'N', 'N', mb, n-je, nb,cmplx( one, zero,KIND=sp), f( &
                          is, js ), ldf,b( js, je+1 ), ldb, cmplx( one, zero,KIND=sp),c( is, je+1 &
                                    ), ldc )
                          call stdlib_cgemm( 'N', 'N', mb, n-je, nb,cmplx( one, zero,KIND=sp), f( &
                          is, js ), ldf,e( js, je+1 ), lde, cmplx( one, zero,KIND=sp),f( is, je+1 &
                                    ), ldf )
                       end if
                    end do loop_120
                 end do loop_130
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=sp) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=sp) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_clacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_clacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_claset( 'F', m, n, czero, czero, c, ldc )
                    call stdlib_claset( 'F', m, n, czero, czero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_clacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_clacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_150
           else
              ! solve transposed (i, j)-subsystem
                  ! a(i, i)**h * r(i, j) + d(i, i)**h * l(i, j) = c(i, j)
                  ! r(i, j) * b(j, j)  + l(i, j) * e(j, j) = -f(i, j)
              ! for i = 1,2,..., p; j = q, q-1,..., 1
              scale = one
              loop_210: do i = 1, p
                 is = iwork( i )
                 ie = iwork( i+1 ) - 1
                 mb = ie - is + 1
                 loop_200: do j = q, p + 2, -1
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    call stdlib_ctgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), ldb, &
                    c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, scaloc, &
                              dsum, dscale,linfo )
                    if( linfo>0 )info = linfo
                    if( scaloc/=one ) then
                       do k = 1, js - 1
                          call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), c( 1, k ),1 )
                                    
                          call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), f( 1, k ),1 )
                                    
                       end do
                       do k = js, je
                          call stdlib_cscal( is-1, cmplx( scaloc, zero,KIND=sp), c( 1, k ),1 )
                                    
                          call stdlib_cscal( is-1, cmplx( scaloc, zero,KIND=sp), f( 1, k ),1 )
                                    
                       end do
                       do k = js, je
                          call stdlib_cscal( m-ie, cmplx( scaloc, zero,KIND=sp),c( ie+1, k ), 1 )
                                    
                          call stdlib_cscal( m-ie, cmplx( scaloc, zero,KIND=sp),f( ie+1, k ), 1 )
                                    
                       end do
                       do k = je + 1, n
                          call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), c( 1, k ),1 )
                                    
                          call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), f( 1, k ),1 )
                                    
                       end do
                       scale = scale*scaloc
                    end if
                    ! substitute r(i,j) and l(i,j) into remaining equation.
                    if( j>p+2 ) then
                       call stdlib_cgemm( 'N', 'C', mb, js-1, nb,cmplx( one, zero,KIND=sp), c( is,&
                        js ), ldc,b( 1, js ), ldb, cmplx( one, zero,KIND=sp),f( is, 1 ), ldf )
                                  
                       call stdlib_cgemm( 'N', 'C', mb, js-1, nb,cmplx( one, zero,KIND=sp), f( is,&
                        js ), ldf,e( 1, js ), lde, cmplx( one, zero,KIND=sp),f( is, 1 ), ldf )
                                  
                    end if
                    if( i<p ) then
                       call stdlib_cgemm( 'C', 'N', m-ie, nb, mb,cmplx( -one, zero,KIND=sp), a( &
                       is, ie+1 ), lda,c( is, js ), ldc, cmplx( one, zero,KIND=sp),c( ie+1, js ), &
                                 ldc )
                       call stdlib_cgemm( 'C', 'N', m-ie, nb, mb,cmplx( -one, zero,KIND=sp), d( &
                       is, ie+1 ), ldd,f( is, js ), ldf, cmplx( one, zero,KIND=sp),c( ie+1, js ), &
                                 ldc )
                    end if
                 end do loop_200
              end do loop_210
           end if
           work( 1 ) = lwmin
           return
     end subroutine stdlib_ctgsyl

     module pure subroutine stdlib_ztgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! ZTGSYL solves the generalized Sylvester equation:
     !! A * R - L * B = scale * C            (1)
     !! D * R - L * E = scale * F
     !! where R and L are unknown m-by-n matrices, (A, D), (B, E) and
     !! (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
     !! respectively, with complex entries. A, B, D and E are upper
     !! triangular (i.e., (A,D) and (B,E) in generalized Schur form).
     !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1
     !! is an output scaling factor chosen to avoid overflow.
     !! In matrix notation (1) is equivalent to solve Zx = scale*b, where Z
     !! is defined as
     !! Z = [ kron(In, A)  -kron(B**H, Im) ]        (2)
     !! [ kron(In, D)  -kron(E**H, Im) ],
     !! Here Ix is the identity matrix of size x and X**H is the conjugate
     !! transpose of X. Kron(X, Y) is the Kronecker product between the
     !! matrices X and Y.
     !! If TRANS = 'C', y in the conjugate transposed system Z**H *y = scale*b
     !! is solved for, which is equivalent to solve for R and L in
     !! A**H * R + D**H * L = scale * C           (3)
     !! R * B**H + L * E**H = scale * -F
     !! This case (TRANS = 'C') is used to compute an one-norm-based estimate
     !! of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
     !! and (B,E), using ZLACON.
     !! If IJOB >= 1, ZTGSYL computes a Frobenius norm-based estimate of
     !! Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
     !! reciprocal of the smallest singular value of Z.
     !! This is a level-3 BLAS algorithm.
               ldf, scale, dif, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, lwork, m, n
           integer(ilp), intent(out) :: info
           real(dp), intent(out) :: dif, scale
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           complex(dp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           complex(dp), intent(inout) :: c(ldc,*), f(ldf,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_ccopy by calls to stdlib_claset.
        ! sven hammarling, 1/5/02.
           
           
           ! Local Scalars 
           logical(lk) :: lquery, notran
           integer(ilp) :: i, ie, ifunc, iround, is, isolve, j, je, js, k, linfo, lwmin, mb, nb, &
                     p, pq, q
           real(dp) :: dscale, dsum, scale2, scaloc
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>4 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info==0 ) then
              if( notran ) then
                 if( ijob==1 .or. ijob==2 ) then
                    lwmin = max( 1, 2*m*n )
                 else
                    lwmin = 1
                 end if
              else
                 lwmin = 1
              end if
              work( 1 ) = lwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -20
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGSYL', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              scale = 1
              if( notran ) then
                 if( ijob/=0 ) then
                    dif = 0
                 end if
              end if
              return
           end if
           ! determine  optimal block sizes mb and nb
           mb = stdlib_ilaenv( 2, 'ZTGSYL', trans, m, n, -1, -1 )
           nb = stdlib_ilaenv( 5, 'ZTGSYL', trans, m, n, -1, -1 )
           isolve = 1
           ifunc = 0
           if( notran ) then
              if( ijob>=3 ) then
                 ifunc = ijob - 2
                 call stdlib_zlaset( 'F', m, n, czero, czero, c, ldc )
                 call stdlib_zlaset( 'F', m, n, czero, czero, f, ldf )
              else if( ijob>=1 .and. notran ) then
                 isolve = 2
              end if
           end if
           if( ( mb<=1 .and. nb<=1 ) .or. ( mb>=m .and. nb>=n ) )then
              ! use unblocked level 2 solver
              loop_30: do iround = 1, isolve
                 scale = one
                 dscale = zero
                 dsum = one
                 pq = m*n
                 call stdlib_ztgsy2( trans, ifunc, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f,&
                            ldf, scale, dsum, dscale,info )
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=dp) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=dp) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_zlacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_zlacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_zlaset( 'F', m, n, czero, czero, c, ldc )
                    call stdlib_zlaset( 'F', m, n, czero, czero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_zlacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_zlacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_30
              return
           end if
           ! determine block structure of a
           p = 0
           i = 1
           40 continue
           if( i>m )go to 50
           p = p + 1
           iwork( p ) = i
           i = i + mb
           if( i>=m )go to 50
           go to 40
           50 continue
           iwork( p+1 ) = m + 1
           if( iwork( p )==iwork( p+1 ) )p = p - 1
           ! determine block structure of b
           q = p + 1
           j = 1
           60 continue
           if( j>n )go to 70
           q = q + 1
           iwork( q ) = j
           j = j + nb
           if( j>=n )go to 70
           go to 60
           70 continue
           iwork( q+1 ) = n + 1
           if( iwork( q )==iwork( q+1 ) )q = q - 1
           if( notran ) then
              loop_150: do iround = 1, isolve
                 ! solve (i, j) - subsystem
                     ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                     ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
                 ! for i = p, p - 1, ..., 1; j = 1, 2, ..., q
                 pq = 0
                 scale = one
                 dscale = zero
                 dsum = one
                 loop_130: do j = p + 2, q
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    loop_120: do i = p, 1, -1
                       is = iwork( i )
                       ie = iwork( i+1 ) - 1
                       mb = ie - is + 1
                       call stdlib_ztgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), &
                       ldb, c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, &
                                 scaloc, dsum, dscale,linfo )
                       if( linfo>0 )info = linfo
                       pq = pq + mb*nb
                       if( scaloc/=one ) then
                          do k = 1, js - 1
                             call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp),c( 1, k ), 1 )
                                       
                             call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp),f( 1, k ), 1 )
                                       
                          end do
                          do k = js, je
                             call stdlib_zscal( is-1, cmplx( scaloc, zero,KIND=dp),c( 1, k ), 1 )
                                       
                             call stdlib_zscal( is-1, cmplx( scaloc, zero,KIND=dp),f( 1, k ), 1 )
                                       
                          end do
                          do k = js, je
                             call stdlib_zscal( m-ie, cmplx( scaloc, zero,KIND=dp),c( ie+1, k ), &
                                       1 )
                             call stdlib_zscal( m-ie, cmplx( scaloc, zero,KIND=dp),f( ie+1, k ), &
                                       1 )
                          end do
                          do k = je + 1, n
                             call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp),c( 1, k ), 1 )
                                       
                             call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp),f( 1, k ), 1 )
                                       
                          end do
                          scale = scale*scaloc
                       end if
                       ! substitute r(i,j) and l(i,j) into remaining equation.
                       if( i>1 ) then
                          call stdlib_zgemm( 'N', 'N', is-1, nb, mb,cmplx( -one, zero,KIND=dp), a(&
                           1, is ), lda,c( is, js ), ldc, cmplx( one, zero,KIND=dp),c( 1, js ), &
                                     ldc )
                          call stdlib_zgemm( 'N', 'N', is-1, nb, mb,cmplx( -one, zero,KIND=dp), d(&
                           1, is ), ldd,c( is, js ), ldc, cmplx( one, zero,KIND=dp),f( 1, js ), &
                                     ldf )
                       end if
                       if( j<q ) then
                          call stdlib_zgemm( 'N', 'N', mb, n-je, nb,cmplx( one, zero,KIND=dp), f( &
                          is, js ), ldf,b( js, je+1 ), ldb,cmplx( one, zero,KIND=dp), c( is, je+1 &
                                    ),ldc )
                          call stdlib_zgemm( 'N', 'N', mb, n-je, nb,cmplx( one, zero,KIND=dp), f( &
                          is, js ), ldf,e( js, je+1 ), lde,cmplx( one, zero,KIND=dp), f( is, je+1 &
                                    ),ldf )
                       end if
                    end do loop_120
                 end do loop_130
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=dp) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=dp) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_zlacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_zlacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_zlaset( 'F', m, n, czero, czero, c, ldc )
                    call stdlib_zlaset( 'F', m, n, czero, czero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_zlacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_zlacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_150
           else
              ! solve transposed (i, j)-subsystem
                  ! a(i, i)**h * r(i, j) + d(i, i)**h * l(i, j) = c(i, j)
                  ! r(i, j) * b(j, j)  + l(i, j) * e(j, j) = -f(i, j)
              ! for i = 1,2,..., p; j = q, q-1,..., 1
              scale = one
              loop_210: do i = 1, p
                 is = iwork( i )
                 ie = iwork( i+1 ) - 1
                 mb = ie - is + 1
                 loop_200: do j = q, p + 2, -1
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    call stdlib_ztgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), ldb, &
                    c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, scaloc, &
                              dsum, dscale,linfo )
                    if( linfo>0 )info = linfo
                    if( scaloc/=one ) then
                       do k = 1, js - 1
                          call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp), c( 1, k ),1 )
                                    
                          call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp), f( 1, k ),1 )
                                    
                       end do
                       do k = js, je
                          call stdlib_zscal( is-1, cmplx( scaloc, zero,KIND=dp),c( 1, k ), 1 )
                                    
                          call stdlib_zscal( is-1, cmplx( scaloc, zero,KIND=dp),f( 1, k ), 1 )
                                    
                       end do
                       do k = js, je
                          call stdlib_zscal( m-ie, cmplx( scaloc, zero,KIND=dp),c( ie+1, k ), 1 )
                                    
                          call stdlib_zscal( m-ie, cmplx( scaloc, zero,KIND=dp),f( ie+1, k ), 1 )
                                    
                       end do
                       do k = je + 1, n
                          call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp), c( 1, k ),1 )
                                    
                          call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp), f( 1, k ),1 )
                                    
                       end do
                       scale = scale*scaloc
                    end if
                    ! substitute r(i,j) and l(i,j) into remaining equation.
                    if( j>p+2 ) then
                       call stdlib_zgemm( 'N', 'C', mb, js-1, nb,cmplx( one, zero,KIND=dp), c( is,&
                        js ), ldc,b( 1, js ), ldb, cmplx( one, zero,KIND=dp),f( is, 1 ), ldf )
                                  
                       call stdlib_zgemm( 'N', 'C', mb, js-1, nb,cmplx( one, zero,KIND=dp), f( is,&
                        js ), ldf,e( 1, js ), lde, cmplx( one, zero,KIND=dp),f( is, 1 ), ldf )
                                  
                    end if
                    if( i<p ) then
                       call stdlib_zgemm( 'C', 'N', m-ie, nb, mb,cmplx( -one, zero,KIND=dp), a( &
                       is, ie+1 ), lda,c( is, js ), ldc, cmplx( one, zero,KIND=dp),c( ie+1, js ), &
                                 ldc )
                       call stdlib_zgemm( 'C', 'N', m-ie, nb, mb,cmplx( -one, zero,KIND=dp), d( &
                       is, ie+1 ), ldd,f( is, js ), ldf, cmplx( one, zero,KIND=dp),c( ie+1, js ), &
                                 ldc )
                    end if
                 end do loop_200
              end do loop_210
           end if
           work( 1 ) = lwmin
           return
     end subroutine stdlib_ztgsyl

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$tgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! ZTGSYL: solves the generalized Sylvester equation:
     !! A * R - L * B = scale * C            (1)
     !! D * R - L * E = scale * F
     !! where R and L are unknown m-by-n matrices, (A, D), (B, E) and
     !! (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
     !! respectively, with complex entries. A, B, D and E are upper
     !! triangular (i.e., (A,D) and (B,E) in generalized Schur form).
     !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1
     !! is an output scaling factor chosen to avoid overflow.
     !! In matrix notation (1) is equivalent to solve Zx = scale*b, where Z
     !! is defined as
     !! Z = [ kron(In, A)  -kron(B**H, Im) ]        (2)
     !! [ kron(In, D)  -kron(E**H, Im) ],
     !! Here Ix is the identity matrix of size x and X**H is the conjugate
     !! transpose of X. Kron(X, Y) is the Kronecker product between the
     !! matrices X and Y.
     !! If TRANS = 'C', y in the conjugate transposed system Z**H *y = scale*b
     !! is solved for, which is equivalent to solve for R and L in
     !! A**H * R + D**H * L = scale * C           (3)
     !! R * B**H + L * E**H = scale * -F
     !! This case (TRANS = 'C') is used to compute an one-norm-based estimate
     !! of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
     !! and (B,E), using ZLACON.
     !! If IJOB >= 1, ZTGSYL computes a Frobenius norm-based estimate of
     !! Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
     !! reciprocal of the smallest singular value of Z.
     !! This is a level-3 BLAS algorithm.
               ldf, scale, dif, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, lwork, m, n
           integer(ilp), intent(out) :: info
           real(${ck}$), intent(out) :: dif, scale
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           complex(${ck}$), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           complex(${ck}$), intent(inout) :: c(ldc,*), f(ldf,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_zcopy by calls to stdlib_zlaset.
        ! sven hammarling, 1/5/02.
           
           
           ! Local Scalars 
           logical(lk) :: lquery, notran
           integer(ilp) :: i, ie, ifunc, iround, is, isolve, j, je, js, k, linfo, lwmin, mb, nb, &
                     p, pq, q
           real(${ck}$) :: dscale, dsum, scale2, scaloc
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>4 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info==0 ) then
              if( notran ) then
                 if( ijob==1 .or. ijob==2 ) then
                    lwmin = max( 1, 2*m*n )
                 else
                    lwmin = 1
                 end if
              else
                 lwmin = 1
              end if
              work( 1 ) = lwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -20
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGSYL', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              scale = 1
              if( notran ) then
                 if( ijob/=0 ) then
                    dif = 0
                 end if
              end if
              return
           end if
           ! determine  optimal block sizes mb and nb
           mb = stdlib_ilaenv( 2, 'ZTGSYL', trans, m, n, -1, -1 )
           nb = stdlib_ilaenv( 5, 'ZTGSYL', trans, m, n, -1, -1 )
           isolve = 1
           ifunc = 0
           if( notran ) then
              if( ijob>=3 ) then
                 ifunc = ijob - 2
                 call stdlib_${ci}$laset( 'F', m, n, czero, czero, c, ldc )
                 call stdlib_${ci}$laset( 'F', m, n, czero, czero, f, ldf )
              else if( ijob>=1 .and. notran ) then
                 isolve = 2
              end if
           end if
           if( ( mb<=1 .and. nb<=1 ) .or. ( mb>=m .and. nb>=n ) )then
              ! use unblocked level 2 solver
              loop_30: do iround = 1, isolve
                 scale = one
                 dscale = zero
                 dsum = one
                 pq = m*n
                 call stdlib_${ci}$tgsy2( trans, ifunc, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f,&
                            ldf, scale, dsum, dscale,info )
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=${ck}$) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=${ck}$) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_${ci}$lacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_${ci}$lacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_${ci}$laset( 'F', m, n, czero, czero, c, ldc )
                    call stdlib_${ci}$laset( 'F', m, n, czero, czero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_${ci}$lacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_${ci}$lacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_30
              return
           end if
           ! determine block structure of a
           p = 0
           i = 1
           40 continue
           if( i>m )go to 50
           p = p + 1
           iwork( p ) = i
           i = i + mb
           if( i>=m )go to 50
           go to 40
           50 continue
           iwork( p+1 ) = m + 1
           if( iwork( p )==iwork( p+1 ) )p = p - 1
           ! determine block structure of b
           q = p + 1
           j = 1
           60 continue
           if( j>n )go to 70
           q = q + 1
           iwork( q ) = j
           j = j + nb
           if( j>=n )go to 70
           go to 60
           70 continue
           iwork( q+1 ) = n + 1
           if( iwork( q )==iwork( q+1 ) )q = q - 1
           if( notran ) then
              loop_150: do iround = 1, isolve
                 ! solve (i, j) - subsystem
                     ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                     ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
                 ! for i = p, p - 1, ..., 1; j = 1, 2, ..., q
                 pq = 0
                 scale = one
                 dscale = zero
                 dsum = one
                 loop_130: do j = p + 2, q
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    loop_120: do i = p, 1, -1
                       is = iwork( i )
                       ie = iwork( i+1 ) - 1
                       mb = ie - is + 1
                       call stdlib_${ci}$tgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), &
                       ldb, c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, &
                                 scaloc, dsum, dscale,linfo )
                       if( linfo>0 )info = linfo
                       pq = pq + mb*nb
                       if( scaloc/=one ) then
                          do k = 1, js - 1
                             call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$),c( 1, k ), 1 )
                                       
                             call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$),f( 1, k ), 1 )
                                       
                          end do
                          do k = js, je
                             call stdlib_${ci}$scal( is-1, cmplx( scaloc, zero,KIND=${ck}$),c( 1, k ), 1 )
                                       
                             call stdlib_${ci}$scal( is-1, cmplx( scaloc, zero,KIND=${ck}$),f( 1, k ), 1 )
                                       
                          end do
                          do k = js, je
                             call stdlib_${ci}$scal( m-ie, cmplx( scaloc, zero,KIND=${ck}$),c( ie+1, k ), &
                                       1 )
                             call stdlib_${ci}$scal( m-ie, cmplx( scaloc, zero,KIND=${ck}$),f( ie+1, k ), &
                                       1 )
                          end do
                          do k = je + 1, n
                             call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$),c( 1, k ), 1 )
                                       
                             call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$),f( 1, k ), 1 )
                                       
                          end do
                          scale = scale*scaloc
                       end if
                       ! substitute r(i,j) and l(i,j) into remaining equation.
                       if( i>1 ) then
                          call stdlib_${ci}$gemm( 'N', 'N', is-1, nb, mb,cmplx( -one, zero,KIND=${ck}$), a(&
                           1, is ), lda,c( is, js ), ldc, cmplx( one, zero,KIND=${ck}$),c( 1, js ), &
                                     ldc )
                          call stdlib_${ci}$gemm( 'N', 'N', is-1, nb, mb,cmplx( -one, zero,KIND=${ck}$), d(&
                           1, is ), ldd,c( is, js ), ldc, cmplx( one, zero,KIND=${ck}$),f( 1, js ), &
                                     ldf )
                       end if
                       if( j<q ) then
                          call stdlib_${ci}$gemm( 'N', 'N', mb, n-je, nb,cmplx( one, zero,KIND=${ck}$), f( &
                          is, js ), ldf,b( js, je+1 ), ldb,cmplx( one, zero,KIND=${ck}$), c( is, je+1 &
                                    ),ldc )
                          call stdlib_${ci}$gemm( 'N', 'N', mb, n-je, nb,cmplx( one, zero,KIND=${ck}$), f( &
                          is, js ), ldf,e( js, je+1 ), lde,cmplx( one, zero,KIND=${ck}$), f( is, je+1 &
                                    ),ldf )
                       end if
                    end do loop_120
                 end do loop_130
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=${ck}$) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=${ck}$) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_${ci}$lacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_${ci}$lacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_${ci}$laset( 'F', m, n, czero, czero, c, ldc )
                    call stdlib_${ci}$laset( 'F', m, n, czero, czero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_${ci}$lacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_${ci}$lacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_150
           else
              ! solve transposed (i, j)-subsystem
                  ! a(i, i)**h * r(i, j) + d(i, i)**h * l(i, j) = c(i, j)
                  ! r(i, j) * b(j, j)  + l(i, j) * e(j, j) = -f(i, j)
              ! for i = 1,2,..., p; j = q, q-1,..., 1
              scale = one
              loop_210: do i = 1, p
                 is = iwork( i )
                 ie = iwork( i+1 ) - 1
                 mb = ie - is + 1
                 loop_200: do j = q, p + 2, -1
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    call stdlib_${ci}$tgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), ldb, &
                    c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, scaloc, &
                              dsum, dscale,linfo )
                    if( linfo>0 )info = linfo
                    if( scaloc/=one ) then
                       do k = 1, js - 1
                          call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$), c( 1, k ),1 )
                                    
                          call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$), f( 1, k ),1 )
                                    
                       end do
                       do k = js, je
                          call stdlib_${ci}$scal( is-1, cmplx( scaloc, zero,KIND=${ck}$),c( 1, k ), 1 )
                                    
                          call stdlib_${ci}$scal( is-1, cmplx( scaloc, zero,KIND=${ck}$),f( 1, k ), 1 )
                                    
                       end do
                       do k = js, je
                          call stdlib_${ci}$scal( m-ie, cmplx( scaloc, zero,KIND=${ck}$),c( ie+1, k ), 1 )
                                    
                          call stdlib_${ci}$scal( m-ie, cmplx( scaloc, zero,KIND=${ck}$),f( ie+1, k ), 1 )
                                    
                       end do
                       do k = je + 1, n
                          call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$), c( 1, k ),1 )
                                    
                          call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$), f( 1, k ),1 )
                                    
                       end do
                       scale = scale*scaloc
                    end if
                    ! substitute r(i,j) and l(i,j) into remaining equation.
                    if( j>p+2 ) then
                       call stdlib_${ci}$gemm( 'N', 'C', mb, js-1, nb,cmplx( one, zero,KIND=${ck}$), c( is,&
                        js ), ldc,b( 1, js ), ldb, cmplx( one, zero,KIND=${ck}$),f( is, 1 ), ldf )
                                  
                       call stdlib_${ci}$gemm( 'N', 'C', mb, js-1, nb,cmplx( one, zero,KIND=${ck}$), f( is,&
                        js ), ldf,e( 1, js ), lde, cmplx( one, zero,KIND=${ck}$),f( is, 1 ), ldf )
                                  
                    end if
                    if( i<p ) then
                       call stdlib_${ci}$gemm( 'C', 'N', m-ie, nb, mb,cmplx( -one, zero,KIND=${ck}$), a( &
                       is, ie+1 ), lda,c( is, js ), ldc, cmplx( one, zero,KIND=${ck}$),c( ie+1, js ), &
                                 ldc )
                       call stdlib_${ci}$gemm( 'C', 'N', m-ie, nb, mb,cmplx( -one, zero,KIND=${ck}$), d( &
                       is, ie+1 ), ldd,f( is, js ), ldf, cmplx( one, zero,KIND=${ck}$),c( ie+1, js ), &
                                 ldc )
                    end if
                 end do loop_200
              end do loop_210
           end if
           work( 1 ) = lwmin
           return
     end subroutine stdlib_${ci}$tgsyl

#:endif
#:endfor



     module subroutine stdlib_sggesx( jobvsl, jobvsr, sort, selctg, sense, n, a, lda,b, ldb, sdim, &
     !! SGGESX computes for a pair of N-by-N real nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, the real Schur form (S,T), and,
     !! optionally, the left and/or right matrices of Schur vectors (VSL and
     !! VSR).  This gives the generalized Schur factorization
     !! (A,B) = ( (VSL) S (VSR)**T, (VSL) T (VSR)**T )
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! quasi-triangular matrix S and the upper triangular matrix T; computes
     !! a reciprocal condition number for the average of the selected
     !! eigenvalues (RCONDE); and computes a reciprocal condition number for
     !! the right and left deflating subspaces corresponding to the selected
     !! eigenvalues (RCONDV). The leading columns of VSL and VSR then form
     !! an orthonormal basis for the corresponding left and right eigenspaces
     !! (deflating subspaces).
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0 or for both being zero.
     !! A pair of matrices (S,T) is in generalized real Schur form if T is
     !! upper triangular with non-negative diagonal and S is block upper
     !! triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
     !! to real generalized eigenvalues, while 2-by-2 blocks of S will be
     !! "standardized" by making the corresponding elements of T have the
     !! form:
     !! [  a  0  ]
     !! [  0  b  ]
     !! and the pair of corresponding 2-by-2 blocks in S and T will have a
     !! complex conjugate pair of generalized eigenvalues.
     alphar, alphai, beta, vsl, ldvsl,vsr, ldvsr, rconde, rcondv, work, lwork, iwork,liwork, &
               bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sense, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, liwork, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: alphai(*), alphar(*), beta(*), rconde(2), rcondv(2), vsl(&
                     ldvsl,*), vsr(ldvsr,*), work(*)
           ! Function Arguments 
           procedure(stdlib_selctg_s) :: selctg
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, lst2sl, wantsb, &
                     wantse, wantsn, wantst, wantsv
           integer(ilp) :: i, icols, ierr, ihi, ijob, ijobvl, ijobvr, ileft, ilo, ip, iright, &
                     irows, itau, iwrk, liwmin, lwrk, maxwrk, minwrk
           real(sp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pl, pr, safmax, safmin, &
                     smlnum
           ! Local Arrays 
           real(sp) :: dif(2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( wantsn ) then
              ijob = 0
           else if( wantse ) then
              ijob = 1
           else if( wantsv ) then
              ijob = 2
           else if( wantsb ) then
              ijob = 4
           end if
           ! test the input arguments
           info = 0
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( .not.( wantsn .or. wantse .or. wantsv .or. wantsb ) .or.( .not.wantst .and. &
                     .not.wantsn ) ) then
              info = -5
           else if( n<0 ) then
              info = -6
           else if( lda<max( 1, n ) ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -16
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -18
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              if( n>0) then
                 minwrk = max( 8*n, 6*n + 16 )
                 maxwrk = minwrk - n +n*stdlib_ilaenv( 1, 'SGEQRF', ' ', n, 1, n, 0 )
                 maxwrk = max( maxwrk, minwrk - n +n*stdlib_ilaenv( 1, 'SORMQR', ' ', n, 1, n, -1 &
                           ) )
                 if( ilvsl ) then
                    maxwrk = max( maxwrk, minwrk - n +n*stdlib_ilaenv( 1, 'SORGQR', ' ', n, 1, n, &
                              -1 ) )
                 end if
                 lwrk = maxwrk
                 if( ijob>=1 )lwrk = max( lwrk, n*n/2 )
              else
                 minwrk = 1
                 maxwrk = 1
                 lwrk   = 1
              end if
              work( 1 ) = lwrk
              if( wantsn .or. n==0 ) then
                 liwmin = 1
              else
                 liwmin = n + 6
              end if
              iwork( 1 ) = liwmin
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -22
              else if( liwork<liwmin  .and. .not.lquery ) then
                 info = -24
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGGESX', -info )
              return
           else if (lquery) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           safmin = stdlib_slamch( 'S' )
           safmax = one / safmin
           call stdlib_slabad( safmin, safmax )
           smlnum = sqrt( safmin ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_slange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_slascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_slange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_slascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (workspace: need 6*n + 2*n for permutation parameters)
           ileft = 1
           iright = n + 1
           iwrk = iright + n
           call stdlib_sggbal( 'P', n, a, lda, b, ldb, ilo, ihi, work( ileft ),work( iright ), &
                     work( iwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = iwrk
           iwrk = itau + irows
           call stdlib_sgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           ! (workspace: need n, prefer n*nb)
           call stdlib_sormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           ! (workspace: need n, prefer n*nb)
           if( ilvsl ) then
              call stdlib_slaset( 'FULL', n, n, zero, one, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_slacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_sorgqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_slaset( 'FULL', n, n, zero, one, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           call stdlib_sgghrd( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      ierr )
           sdim = 0
           ! perform qz algorithm, computing schur vectors if desired
           ! (workspace: need n)
           iwrk = itau
           call stdlib_shgeqz( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vsl, ldvsl, vsr, ldvsr,work( iwrk ), lwork+1-iwrk, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 50
           end if
           ! sort eigenvalues alpha/beta and compute the reciprocal of
           ! condition number(s)
           ! (workspace: if ijob >= 1, need max( 8*(n+1), 2*sdim*(n-sdim) )
                       ! otherwise, need 8*(n+1) )
           if( wantst ) then
              ! undo scaling on eigenvalues before selctging
              if( ilascl ) then
                 call stdlib_slascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n,ierr )
                 call stdlib_slascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n,ierr )
              end if
              if( ilbscl )call stdlib_slascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alphar( i ), alphai( i ), beta( i ) )
              end do
              ! reorder eigenvalues, transform generalized schur vectors, and
              ! compute reciprocal condition numbers
              call stdlib_stgsen( ijob, ilvsl, ilvsr, bwork, n, a, lda, b, ldb,alphar, alphai, &
              beta, vsl, ldvsl, vsr, ldvsr,sdim, pl, pr, dif, work( iwrk ), lwork-iwrk+1,iwork, &
                        liwork, ierr )
              if( ijob>=1 )maxwrk = max( maxwrk, 2*sdim*( n-sdim ) )
              if( ierr==-22 ) then
                  ! not enough real workspace
                 info = -22
              else
                 if( ijob==1 .or. ijob==4 ) then
                    rconde( 1 ) = pl
                    rconde( 2 ) = pr
                 end if
                 if( ijob==2 .or. ijob==4 ) then
                    rcondv( 1 ) = dif( 1 )
                    rcondv( 2 ) = dif( 2 )
                 end if
                 if( ierr==1 )info = n + 3
              end if
           end if
           ! apply permutation to vsl and vsr
           ! (workspace: none needed)
           if( ilvsl )call stdlib_sggbak( 'P', 'L', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_sggbak( 'P', 'R', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsr, ldvsr, ierr )
           ! check if unscaling would cause over/underflow, if so, rescale
           ! (alphar(i),alphai(i),beta(i)) so beta(i) is on the order of
           ! b(i,i) and alphar(i) and alphai(i) are on the order of a(i,i)
           if( ilascl ) then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                    if( ( alphar( i ) / safmax )>( anrmto / anrm ) .or.( safmin / alphar( i ) )>( &
                              anrm / anrmto ) )then
                       work( 1 ) = abs( a( i, i ) / alphar( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    else if( ( alphai( i ) / safmax )>( anrmto / anrm ).or. ( safmin / alphai( i )&
                               )>( anrm / anrmto ) )then
                       work( 1 ) = abs( a( i, i+1 ) / alphai( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    end if
                 end if
              end do
           end if
           if( ilbscl ) then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                    if( ( beta( i ) / safmax )>( bnrmto / bnrm ) .or.( safmin / beta( i ) )>( &
                              bnrm / bnrmto ) ) then
                       work( 1 ) = abs( b( i, i ) / beta( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    end if
                 end if
              end do
           end if
           ! undo scaling
           if( ilascl ) then
              call stdlib_slascl( 'H', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_slascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_slascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_slascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_slascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              lst2sl = .true.
              sdim = 0
              ip = 0
              do i = 1, n
                 cursl = selctg( alphar( i ), alphai( i ), beta( i ) )
                 if( alphai( i )==zero ) then
                    if( cursl )sdim = sdim + 1
                    ip = 0
                    if( cursl .and. .not.lastsl )info = n + 2
                 else
                    if( ip==1 ) then
                       ! last eigenvalue of conjugate pair
                       cursl = cursl .or. lastsl
                       lastsl = cursl
                       if( cursl )sdim = sdim + 2
                       ip = -1
                       if( cursl .and. .not.lst2sl )info = n + 2
                    else
                       ! first eigenvalue of conjugate pair
                       ip = 1
                    end if
                 end if
                 lst2sl = lastsl
                 lastsl = cursl
              end do
           end if
           50 continue
           work( 1 ) = maxwrk
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_sggesx

     module subroutine stdlib_dggesx( jobvsl, jobvsr, sort, selctg, sense, n, a, lda,b, ldb, sdim, &
     !! DGGESX computes for a pair of N-by-N real nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, the real Schur form (S,T), and,
     !! optionally, the left and/or right matrices of Schur vectors (VSL and
     !! VSR).  This gives the generalized Schur factorization
     !! (A,B) = ( (VSL) S (VSR)**T, (VSL) T (VSR)**T )
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! quasi-triangular matrix S and the upper triangular matrix T; computes
     !! a reciprocal condition number for the average of the selected
     !! eigenvalues (RCONDE); and computes a reciprocal condition number for
     !! the right and left deflating subspaces corresponding to the selected
     !! eigenvalues (RCONDV). The leading columns of VSL and VSR then form
     !! an orthonormal basis for the corresponding left and right eigenspaces
     !! (deflating subspaces).
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0 or for both being zero.
     !! A pair of matrices (S,T) is in generalized real Schur form if T is
     !! upper triangular with non-negative diagonal and S is block upper
     !! triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
     !! to real generalized eigenvalues, while 2-by-2 blocks of S will be
     !! "standardized" by making the corresponding elements of T have the
     !! form:
     !! [  a  0  ]
     !! [  0  b  ]
     !! and the pair of corresponding 2-by-2 blocks in S and T will have a
     !! complex conjugate pair of generalized eigenvalues.
     alphar, alphai, beta, vsl, ldvsl,vsr, ldvsr, rconde, rcondv, work, lwork, iwork,liwork, &
               bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sense, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, liwork, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: alphai(*), alphar(*), beta(*), rconde(2), rcondv(2), vsl(&
                     ldvsl,*), vsr(ldvsr,*), work(*)
           ! Function Arguments 
           procedure(stdlib_selctg_d) :: selctg
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, lst2sl, wantsb, &
                     wantse, wantsn, wantst, wantsv
           integer(ilp) :: i, icols, ierr, ihi, ijob, ijobvl, ijobvr, ileft, ilo, ip, iright, &
                     irows, itau, iwrk, liwmin, lwrk, maxwrk, minwrk
           real(dp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pl, pr, safmax, safmin, &
                     smlnum
           ! Local Arrays 
           real(dp) :: dif(2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( wantsn ) then
              ijob = 0
           else if( wantse ) then
              ijob = 1
           else if( wantsv ) then
              ijob = 2
           else if( wantsb ) then
              ijob = 4
           end if
           ! test the input arguments
           info = 0
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( .not.( wantsn .or. wantse .or. wantsv .or. wantsb ) .or.( .not.wantst .and. &
                     .not.wantsn ) ) then
              info = -5
           else if( n<0 ) then
              info = -6
           else if( lda<max( 1, n ) ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -16
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -18
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              if( n>0) then
                 minwrk = max( 8*n, 6*n + 16 )
                 maxwrk = minwrk - n +n*stdlib_ilaenv( 1, 'DGEQRF', ' ', n, 1, n, 0 )
                 maxwrk = max( maxwrk, minwrk - n +n*stdlib_ilaenv( 1, 'DORMQR', ' ', n, 1, n, -1 &
                           ) )
                 if( ilvsl ) then
                    maxwrk = max( maxwrk, minwrk - n +n*stdlib_ilaenv( 1, 'DORGQR', ' ', n, 1, n, &
                              -1 ) )
                 end if
                 lwrk = maxwrk
                 if( ijob>=1 )lwrk = max( lwrk, n*n/2 )
              else
                 minwrk = 1
                 maxwrk = 1
                 lwrk   = 1
              end if
              work( 1 ) = lwrk
              if( wantsn .or. n==0 ) then
                 liwmin = 1
              else
                 liwmin = n + 6
              end if
              iwork( 1 ) = liwmin
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -22
              else if( liwork<liwmin  .and. .not.lquery ) then
                 info = -24
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGESX', -info )
              return
           else if (lquery) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           safmin = stdlib_dlamch( 'S' )
           safmax = one / safmin
           call stdlib_dlabad( safmin, safmax )
           smlnum = sqrt( safmin ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_dlange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_dlascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_dlange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_dlascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (workspace: need 6*n + 2*n for permutation parameters)
           ileft = 1
           iright = n + 1
           iwrk = iright + n
           call stdlib_dggbal( 'P', n, a, lda, b, ldb, ilo, ihi, work( ileft ),work( iright ), &
                     work( iwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = iwrk
           iwrk = itau + irows
           call stdlib_dgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           ! (workspace: need n, prefer n*nb)
           call stdlib_dormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           ! (workspace: need n, prefer n*nb)
           if( ilvsl ) then
              call stdlib_dlaset( 'FULL', n, n, zero, one, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_dlacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_dorgqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_dlaset( 'FULL', n, n, zero, one, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           call stdlib_dgghrd( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      ierr )
           sdim = 0
           ! perform qz algorithm, computing schur vectors if desired
           ! (workspace: need n)
           iwrk = itau
           call stdlib_dhgeqz( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vsl, ldvsl, vsr, ldvsr,work( iwrk ), lwork+1-iwrk, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 60
           end if
           ! sort eigenvalues alpha/beta and compute the reciprocal of
           ! condition number(s)
           ! (workspace: if ijob >= 1, need max( 8*(n+1), 2*sdim*(n-sdim) )
                       ! otherwise, need 8*(n+1) )
           if( wantst ) then
              ! undo scaling on eigenvalues before selctging
              if( ilascl ) then
                 call stdlib_dlascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n,ierr )
                 call stdlib_dlascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n,ierr )
              end if
              if( ilbscl )call stdlib_dlascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alphar( i ), alphai( i ), beta( i ) )
              end do
              ! reorder eigenvalues, transform generalized schur vectors, and
              ! compute reciprocal condition numbers
              call stdlib_dtgsen( ijob, ilvsl, ilvsr, bwork, n, a, lda, b, ldb,alphar, alphai, &
              beta, vsl, ldvsl, vsr, ldvsr,sdim, pl, pr, dif, work( iwrk ), lwork-iwrk+1,iwork, &
                        liwork, ierr )
              if( ijob>=1 )maxwrk = max( maxwrk, 2*sdim*( n-sdim ) )
              if( ierr==-22 ) then
                  ! not enough real workspace
                 info = -22
              else
                 if( ijob==1 .or. ijob==4 ) then
                    rconde( 1 ) = pl
                    rconde( 2 ) = pr
                 end if
                 if( ijob==2 .or. ijob==4 ) then
                    rcondv( 1 ) = dif( 1 )
                    rcondv( 2 ) = dif( 2 )
                 end if
                 if( ierr==1 )info = n + 3
              end if
           end if
           ! apply permutation to vsl and vsr
           ! (workspace: none needed)
           if( ilvsl )call stdlib_dggbak( 'P', 'L', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_dggbak( 'P', 'R', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsr, ldvsr, ierr )
           ! check if unscaling would cause over/underflow, if so, rescale
           ! (alphar(i),alphai(i),beta(i)) so beta(i) is on the order of
           ! b(i,i) and alphar(i) and alphai(i) are on the order of a(i,i)
           if( ilascl ) then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                    if( ( alphar( i ) / safmax )>( anrmto / anrm ) .or.( safmin / alphar( i ) )>( &
                              anrm / anrmto ) ) then
                       work( 1 ) = abs( a( i, i ) / alphar( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    else if( ( alphai( i ) / safmax )>( anrmto / anrm ) .or.( safmin / alphai( i )&
                               )>( anrm / anrmto ) )then
                       work( 1 ) = abs( a( i, i+1 ) / alphai( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    end if
                 end if
              end do
           end if
           if( ilbscl ) then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                    if( ( beta( i ) / safmax )>( bnrmto / bnrm ) .or.( safmin / beta( i ) )>( &
                              bnrm / bnrmto ) ) then
                       work( 1 ) = abs( b( i, i ) / beta( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    end if
                 end if
              end do
           end if
           ! undo scaling
           if( ilascl ) then
              call stdlib_dlascl( 'H', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_dlascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_dlascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_dlascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_dlascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              lst2sl = .true.
              sdim = 0
              ip = 0
              do i = 1, n
                 cursl = selctg( alphar( i ), alphai( i ), beta( i ) )
                 if( alphai( i )==zero ) then
                    if( cursl )sdim = sdim + 1
                    ip = 0
                    if( cursl .and. .not.lastsl )info = n + 2
                 else
                    if( ip==1 ) then
                       ! last eigenvalue of conjugate pair
                       cursl = cursl .or. lastsl
                       lastsl = cursl
                       if( cursl )sdim = sdim + 2
                       ip = -1
                       if( cursl .and. .not.lst2sl )info = n + 2
                    else
                       ! first eigenvalue of conjugate pair
                       ip = 1
                    end if
                 end if
                 lst2sl = lastsl
                 lastsl = cursl
              end do
           end if
           60 continue
           work( 1 ) = maxwrk
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_dggesx

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$ggesx( jobvsl, jobvsr, sort, selctg, sense, n, a, lda,b, ldb, sdim, &
     !! DGGESX: computes for a pair of N-by-N real nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, the real Schur form (S,T), and,
     !! optionally, the left and/or right matrices of Schur vectors (VSL and
     !! VSR).  This gives the generalized Schur factorization
     !! (A,B) = ( (VSL) S (VSR)**T, (VSL) T (VSR)**T )
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! quasi-triangular matrix S and the upper triangular matrix T; computes
     !! a reciprocal condition number for the average of the selected
     !! eigenvalues (RCONDE); and computes a reciprocal condition number for
     !! the right and left deflating subspaces corresponding to the selected
     !! eigenvalues (RCONDV). The leading columns of VSL and VSR then form
     !! an orthonormal basis for the corresponding left and right eigenspaces
     !! (deflating subspaces).
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0 or for both being zero.
     !! A pair of matrices (S,T) is in generalized real Schur form if T is
     !! upper triangular with non-negative diagonal and S is block upper
     !! triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
     !! to real generalized eigenvalues, while 2-by-2 blocks of S will be
     !! "standardized" by making the corresponding elements of T have the
     !! form:
     !! [  a  0  ]
     !! [  0  b  ]
     !! and the pair of corresponding 2-by-2 blocks in S and T will have a
     !! complex conjugate pair of generalized eigenvalues.
     alphar, alphai, beta, vsl, ldvsl,vsr, ldvsr, rconde, rcondv, work, lwork, iwork,liwork, &
               bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sense, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, liwork, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), rconde(2), rcondv(2), vsl(&
                     ldvsl,*), vsr(ldvsr,*), work(*)
           ! Function Arguments 
           procedure(stdlib_selctg_${ri}$) :: selctg
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, lst2sl, wantsb, &
                     wantse, wantsn, wantst, wantsv
           integer(ilp) :: i, icols, ierr, ihi, ijob, ijobvl, ijobvr, ileft, ilo, ip, iright, &
                     irows, itau, iwrk, liwmin, lwrk, maxwrk, minwrk
           real(${rk}$) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pl, pr, safmax, safmin, &
                     smlnum
           ! Local Arrays 
           real(${rk}$) :: dif(2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( wantsn ) then
              ijob = 0
           else if( wantse ) then
              ijob = 1
           else if( wantsv ) then
              ijob = 2
           else if( wantsb ) then
              ijob = 4
           end if
           ! test the input arguments
           info = 0
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( .not.( wantsn .or. wantse .or. wantsv .or. wantsb ) .or.( .not.wantst .and. &
                     .not.wantsn ) ) then
              info = -5
           else if( n<0 ) then
              info = -6
           else if( lda<max( 1, n ) ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -16
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -18
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              if( n>0) then
                 minwrk = max( 8*n, 6*n + 16 )
                 maxwrk = minwrk - n +n*stdlib_ilaenv( 1, 'DGEQRF', ' ', n, 1, n, 0 )
                 maxwrk = max( maxwrk, minwrk - n +n*stdlib_ilaenv( 1, 'DORMQR', ' ', n, 1, n, -1 &
                           ) )
                 if( ilvsl ) then
                    maxwrk = max( maxwrk, minwrk - n +n*stdlib_ilaenv( 1, 'DORGQR', ' ', n, 1, n, &
                              -1 ) )
                 end if
                 lwrk = maxwrk
                 if( ijob>=1 )lwrk = max( lwrk, n*n/2 )
              else
                 minwrk = 1
                 maxwrk = 1
                 lwrk   = 1
              end if
              work( 1 ) = lwrk
              if( wantsn .or. n==0 ) then
                 liwmin = 1
              else
                 liwmin = n + 6
              end if
              iwork( 1 ) = liwmin
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -22
              else if( liwork<liwmin  .and. .not.lquery ) then
                 info = -24
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGESX', -info )
              return
           else if (lquery) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           safmin = stdlib_${ri}$lamch( 'S' )
           safmax = one / safmin
           call stdlib_${ri}$labad( safmin, safmax )
           smlnum = sqrt( safmin ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_${ri}$lascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_${ri}$lange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_${ri}$lascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (workspace: need 6*n + 2*n for permutation parameters)
           ileft = 1
           iright = n + 1
           iwrk = iright + n
           call stdlib_${ri}$ggbal( 'P', n, a, lda, b, ldb, ilo, ihi, work( ileft ),work( iright ), &
                     work( iwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = iwrk
           iwrk = itau + irows
           call stdlib_${ri}$geqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           ! (workspace: need n, prefer n*nb)
           call stdlib_${ri}$ormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           ! (workspace: need n, prefer n*nb)
           if( ilvsl ) then
              call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_${ri}$lacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_${ri}$orgqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           call stdlib_${ri}$gghrd( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      ierr )
           sdim = 0
           ! perform qz algorithm, computing schur vectors if desired
           ! (workspace: need n)
           iwrk = itau
           call stdlib_${ri}$hgeqz( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vsl, ldvsl, vsr, ldvsr,work( iwrk ), lwork+1-iwrk, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 60
           end if
           ! sort eigenvalues alpha/beta and compute the reciprocal of
           ! condition number(s)
           ! (workspace: if ijob >= 1, need max( 8*(n+1), 2*sdim*(n-sdim) )
                       ! otherwise, need 8*(n+1) )
           if( wantst ) then
              ! undo scaling on eigenvalues before selctging
              if( ilascl ) then
                 call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n,ierr )
                 call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n,ierr )
              end if
              if( ilbscl )call stdlib_${ri}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alphar( i ), alphai( i ), beta( i ) )
              end do
              ! reorder eigenvalues, transform generalized schur vectors, and
              ! compute reciprocal condition numbers
              call stdlib_${ri}$tgsen( ijob, ilvsl, ilvsr, bwork, n, a, lda, b, ldb,alphar, alphai, &
              beta, vsl, ldvsl, vsr, ldvsr,sdim, pl, pr, dif, work( iwrk ), lwork-iwrk+1,iwork, &
                        liwork, ierr )
              if( ijob>=1 )maxwrk = max( maxwrk, 2*sdim*( n-sdim ) )
              if( ierr==-22 ) then
                  ! not enough real workspace
                 info = -22
              else
                 if( ijob==1 .or. ijob==4 ) then
                    rconde( 1 ) = pl
                    rconde( 2 ) = pr
                 end if
                 if( ijob==2 .or. ijob==4 ) then
                    rcondv( 1 ) = dif( 1 )
                    rcondv( 2 ) = dif( 2 )
                 end if
                 if( ierr==1 )info = n + 3
              end if
           end if
           ! apply permutation to vsl and vsr
           ! (workspace: none needed)
           if( ilvsl )call stdlib_${ri}$ggbak( 'P', 'L', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_${ri}$ggbak( 'P', 'R', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsr, ldvsr, ierr )
           ! check if unscaling would cause over/underflow, if so, rescale
           ! (alphar(i),alphai(i),beta(i)) so beta(i) is on the order of
           ! b(i,i) and alphar(i) and alphai(i) are on the order of a(i,i)
           if( ilascl ) then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                    if( ( alphar( i ) / safmax )>( anrmto / anrm ) .or.( safmin / alphar( i ) )>( &
                              anrm / anrmto ) ) then
                       work( 1 ) = abs( a( i, i ) / alphar( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    else if( ( alphai( i ) / safmax )>( anrmto / anrm ) .or.( safmin / alphai( i )&
                               )>( anrm / anrmto ) )then
                       work( 1 ) = abs( a( i, i+1 ) / alphai( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    end if
                 end if
              end do
           end if
           if( ilbscl ) then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                    if( ( beta( i ) / safmax )>( bnrmto / bnrm ) .or.( safmin / beta( i ) )>( &
                              bnrm / bnrmto ) ) then
                       work( 1 ) = abs( b( i, i ) / beta( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    end if
                 end if
              end do
           end if
           ! undo scaling
           if( ilascl ) then
              call stdlib_${ri}$lascl( 'H', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_${ri}$lascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              lst2sl = .true.
              sdim = 0
              ip = 0
              do i = 1, n
                 cursl = selctg( alphar( i ), alphai( i ), beta( i ) )
                 if( alphai( i )==zero ) then
                    if( cursl )sdim = sdim + 1
                    ip = 0
                    if( cursl .and. .not.lastsl )info = n + 2
                 else
                    if( ip==1 ) then
                       ! last eigenvalue of conjugate pair
                       cursl = cursl .or. lastsl
                       lastsl = cursl
                       if( cursl )sdim = sdim + 2
                       ip = -1
                       if( cursl .and. .not.lst2sl )info = n + 2
                    else
                       ! first eigenvalue of conjugate pair
                       ip = 1
                    end if
                 end if
                 lst2sl = lastsl
                 lastsl = cursl
              end do
           end if
           60 continue
           work( 1 ) = maxwrk
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ri}$ggesx

#:endif
#:endfor

     module subroutine stdlib_cggesx( jobvsl, jobvsr, sort, selctg, sense, n, a, lda,b, ldb, sdim, alpha,&
     !! CGGESX computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, the complex Schur form (S,T),
     !! and, optionally, the left and/or right matrices of Schur vectors (VSL
     !! and VSR).  This gives the generalized Schur factorization
     !! (A,B) = ( (VSL) S (VSR)**H, (VSL) T (VSR)**H )
     !! where (VSR)**H is the conjugate-transpose of VSR.
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! triangular matrix S and the upper triangular matrix T; computes
     !! a reciprocal condition number for the average of the selected
     !! eigenvalues (RCONDE); and computes a reciprocal condition number for
     !! the right and left deflating subspaces corresponding to the selected
     !! eigenvalues (RCONDV). The leading columns of VSL and VSR then form
     !! an orthonormal basis for the corresponding left and right eigenspaces
     !! (deflating subspaces).
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0 or for both being zero.
     !! A pair of matrices (S,T) is in generalized complex Schur form if T is
     !! upper triangular with non-negative diagonal and S is upper
     !! triangular.
      beta, vsl, ldvsl, vsr,ldvsr, rconde, rcondv, work, lwork, rwork,iwork, liwork, bwork, info )
                
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sense, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, liwork, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(out) :: rconde(2), rcondv(2), rwork(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: alpha(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), work(*)
                     
           ! Function Arguments 
           procedure(stdlib_selctg_c) :: selctg
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, wantsb, wantse, &
                     wantsn, wantst, wantsv
           integer(ilp) :: i, icols, ierr, ihi, ijob, ijobvl, ijobvr, ileft, ilo, iright, irows, &
                     irwrk, itau, iwrk, liwmin, lwrk, maxwrk, minwrk
           real(sp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pl, pr, smlnum
           ! Local Arrays 
           real(sp) :: dif(2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( wantsn ) then
              ijob = 0
           else if( wantse ) then
              ijob = 1
           else if( wantsv ) then
              ijob = 2
           else if( wantsb ) then
              ijob = 4
           end if
           ! test the input arguments
           info = 0
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( .not.( wantsn .or. wantse .or. wantsv .or. wantsb ) .or.( .not.wantst .and. &
                     .not.wantsn ) ) then
              info = -5
           else if( n<0 ) then
              info = -6
           else if( lda<max( 1, n ) ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -15
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -17
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              if( n>0) then
                 minwrk = 2*n
                 maxwrk = n*(1 + stdlib_ilaenv( 1, 'CGEQRF', ' ', n, 1, n, 0 ) )
                 maxwrk = max( maxwrk, n*( 1 +stdlib_ilaenv( 1, 'CUNMQR', ' ', n, 1, n, -1 ) ) )
                           
                 if( ilvsl ) then
                    maxwrk = max( maxwrk, n*( 1 +stdlib_ilaenv( 1, 'CUNGQR', ' ', n, 1, n, -1 ) ) &
                              )
                 end if
                 lwrk = maxwrk
                 if( ijob>=1 )lwrk = max( lwrk, n*n/2 )
              else
                 minwrk = 1
                 maxwrk = 1
                 lwrk   = 1
              end if
              work( 1 ) = lwrk
              if( wantsn .or. n==0 ) then
                 liwmin = 1
              else
                 liwmin = n + 2
              end if
              iwork( 1 ) = liwmin
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -21
              else if( liwork<liwmin  .and. .not.lquery) then
                 info = -24
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGESX', -info )
              return
           else if (lquery) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_clascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_clange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (real workspace: need 6*n)
           ileft = 1
           iright = n + 1
           irwrk = iright + n
           call stdlib_cggbal( 'P', n, a, lda, b, ldb, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     rwork( irwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (complex workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = 1
           iwrk = itau + irows
           call stdlib_cgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the unitary transformation to matrix a
           ! (complex workspace: need n, prefer n*nb)
           call stdlib_cunmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           ! (complex workspace: need n, prefer n*nb)
           if( ilvsl ) then
              call stdlib_claset( 'FULL', n, n, czero, cone, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_clacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_cungqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_claset( 'FULL', n, n, czero, cone, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           call stdlib_cgghrd( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      ierr )
           sdim = 0
           ! perform qz algorithm, computing schur vectors if desired
           ! (complex workspace: need n)
           ! (real workspace:    need n)
           iwrk = itau
           call stdlib_chgeqz( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vsl, &
                     ldvsl, vsr, ldvsr, work( iwrk ),lwork+1-iwrk, rwork( irwrk ), ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 40
           end if
           ! sort eigenvalues alpha/beta and compute the reciprocal of
           ! condition number(s)
           if( wantst ) then
              ! undo scaling on eigenvalues before selctging
              if( ilascl )call stdlib_clascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
                        
              if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alpha( i ), beta( i ) )
              end do
              ! reorder eigenvalues, transform generalized schur vectors, and
              ! compute reciprocal condition numbers
              ! (complex workspace: if ijob >= 1, need max(1, 2*sdim*(n-sdim))
                                  ! otherwise, need 1 )
              call stdlib_ctgsen( ijob, ilvsl, ilvsr, bwork, n, a, lda, b, ldb,alpha, beta, vsl, &
              ldvsl, vsr, ldvsr, sdim, pl, pr,dif, work( iwrk ), lwork-iwrk+1, iwork, liwork,ierr &
                        )
              if( ijob>=1 )maxwrk = max( maxwrk, 2*sdim*( n-sdim ) )
              if( ierr==-21 ) then
                  ! not enough complex workspace
                 info = -21
              else
                 if( ijob==1 .or. ijob==4 ) then
                    rconde( 1 ) = pl
                    rconde( 2 ) = pr
                 end if
                 if( ijob==2 .or. ijob==4 ) then
                    rcondv( 1 ) = dif( 1 )
                    rcondv( 2 ) = dif( 2 )
                 end if
                 if( ierr==1 )info = n + 3
              end if
           end if
           ! apply permutation to vsl and vsr
           ! (workspace: none needed)
           if( ilvsl )call stdlib_cggbak( 'P', 'L', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_cggbak( 'P', 'R', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsr, ldvsr, ierr )
           ! undo scaling
           if( ilascl ) then
              call stdlib_clascl( 'U', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_clascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_clascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_clascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              sdim = 0
              do i = 1, n
                 cursl = selctg( alpha( i ), beta( i ) )
                 if( cursl )sdim = sdim + 1
                 if( cursl .and. .not.lastsl )info = n + 2
                 lastsl = cursl
              end do
           end if
           40 continue
           work( 1 ) = maxwrk
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_cggesx

     module subroutine stdlib_zggesx( jobvsl, jobvsr, sort, selctg, sense, n, a, lda,b, ldb, sdim, alpha,&
     !! ZGGESX computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, the complex Schur form (S,T),
     !! and, optionally, the left and/or right matrices of Schur vectors (VSL
     !! and VSR).  This gives the generalized Schur factorization
     !! (A,B) = ( (VSL) S (VSR)**H, (VSL) T (VSR)**H )
     !! where (VSR)**H is the conjugate-transpose of VSR.
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! triangular matrix S and the upper triangular matrix T; computes
     !! a reciprocal condition number for the average of the selected
     !! eigenvalues (RCONDE); and computes a reciprocal condition number for
     !! the right and left deflating subspaces corresponding to the selected
     !! eigenvalues (RCONDV). The leading columns of VSL and VSR then form
     !! an orthonormal basis for the corresponding left and right eigenspaces
     !! (deflating subspaces).
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0 or for both being zero.
     !! A pair of matrices (S,T) is in generalized complex Schur form if T is
     !! upper triangular with non-negative diagonal and S is upper
     !! triangular.
      beta, vsl, ldvsl, vsr,ldvsr, rconde, rcondv, work, lwork, rwork,iwork, liwork, bwork, info )
                
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sense, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, liwork, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(out) :: rconde(2), rcondv(2), rwork(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: alpha(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), work(*)
                     
           ! Function Arguments 
           procedure(stdlib_selctg_z) :: selctg
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, wantsb, wantse, &
                     wantsn, wantst, wantsv
           integer(ilp) :: i, icols, ierr, ihi, ijob, ijobvl, ijobvr, ileft, ilo, iright, irows, &
                     irwrk, itau, iwrk, liwmin, lwrk, maxwrk, minwrk
           real(dp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pl, pr, smlnum
           ! Local Arrays 
           real(dp) :: dif(2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( wantsn ) then
              ijob = 0
           else if( wantse ) then
              ijob = 1
           else if( wantsv ) then
              ijob = 2
           else if( wantsb ) then
              ijob = 4
           end if
           ! test the input arguments
           info = 0
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( .not.( wantsn .or. wantse .or. wantsv .or. wantsb ) .or.( .not.wantst .and. &
                     .not.wantsn ) ) then
              info = -5
           else if( n<0 ) then
              info = -6
           else if( lda<max( 1, n ) ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -15
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -17
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              if( n>0) then
                 minwrk = 2*n
                 maxwrk = n*(1 + stdlib_ilaenv( 1, 'ZGEQRF', ' ', n, 1, n, 0 ) )
                 maxwrk = max( maxwrk, n*( 1 +stdlib_ilaenv( 1, 'ZUNMQR', ' ', n, 1, n, -1 ) ) )
                           
                 if( ilvsl ) then
                    maxwrk = max( maxwrk, n*( 1 +stdlib_ilaenv( 1, 'ZUNGQR', ' ', n, 1, n, -1 ) ) &
                              )
                 end if
                 lwrk = maxwrk
                 if( ijob>=1 )lwrk = max( lwrk, n*n/2 )
              else
                 minwrk = 1
                 maxwrk = 1
                 lwrk   = 1
              end if
              work( 1 ) = lwrk
              if( wantsn .or. n==0 ) then
                 liwmin = 1
              else
                 liwmin = n + 2
              end if
              iwork( 1 ) = liwmin
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -21
              else if( liwork<liwmin  .and. .not.lquery) then
                 info = -24
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGESX', -info )
              return
           else if (lquery) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' )
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_zlange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_zlascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_zlange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_zlascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (real workspace: need 6*n)
           ileft = 1
           iright = n + 1
           irwrk = iright + n
           call stdlib_zggbal( 'P', n, a, lda, b, ldb, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     rwork( irwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (complex workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = 1
           iwrk = itau + irows
           call stdlib_zgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the unitary transformation to matrix a
           ! (complex workspace: need n, prefer n*nb)
           call stdlib_zunmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           ! (complex workspace: need n, prefer n*nb)
           if( ilvsl ) then
              call stdlib_zlaset( 'FULL', n, n, czero, cone, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_zlacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_zungqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_zlaset( 'FULL', n, n, czero, cone, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           call stdlib_zgghrd( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      ierr )
           sdim = 0
           ! perform qz algorithm, computing schur vectors if desired
           ! (complex workspace: need n)
           ! (real workspace:    need n)
           iwrk = itau
           call stdlib_zhgeqz( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vsl, &
                     ldvsl, vsr, ldvsr, work( iwrk ),lwork+1-iwrk, rwork( irwrk ), ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 40
           end if
           ! sort eigenvalues alpha/beta and compute the reciprocal of
           ! condition number(s)
           if( wantst ) then
              ! undo scaling on eigenvalues before selctging
              if( ilascl )call stdlib_zlascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
                        
              if( ilbscl )call stdlib_zlascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alpha( i ), beta( i ) )
              end do
              ! reorder eigenvalues, transform generalized schur vectors, and
              ! compute reciprocal condition numbers
              ! (complex workspace: if ijob >= 1, need max(1, 2*sdim*(n-sdim))
                                  ! otherwise, need 1 )
              call stdlib_ztgsen( ijob, ilvsl, ilvsr, bwork, n, a, lda, b, ldb,alpha, beta, vsl, &
              ldvsl, vsr, ldvsr, sdim, pl, pr,dif, work( iwrk ), lwork-iwrk+1, iwork, liwork,ierr &
                        )
              if( ijob>=1 )maxwrk = max( maxwrk, 2*sdim*( n-sdim ) )
              if( ierr==-21 ) then
                  ! not enough complex workspace
                 info = -21
              else
                 if( ijob==1 .or. ijob==4 ) then
                    rconde( 1 ) = pl
                    rconde( 2 ) = pr
                 end if
                 if( ijob==2 .or. ijob==4 ) then
                    rcondv( 1 ) = dif( 1 )
                    rcondv( 2 ) = dif( 2 )
                 end if
                 if( ierr==1 )info = n + 3
              end if
           end if
           ! apply permutation to vsl and vsr
           ! (workspace: none needed)
           if( ilvsl )call stdlib_zggbak( 'P', 'L', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_zggbak( 'P', 'R', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsr, ldvsr, ierr )
           ! undo scaling
           if( ilascl ) then
              call stdlib_zlascl( 'U', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_zlascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_zlascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_zlascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              sdim = 0
              do i = 1, n
                 cursl = selctg( alpha( i ), beta( i ) )
                 if( cursl )sdim = sdim + 1
                 if( cursl .and. .not.lastsl )info = n + 2
                 lastsl = cursl
              end do
           end if
           40 continue
           work( 1 ) = maxwrk
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_zggesx

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$ggesx( jobvsl, jobvsr, sort, selctg, sense, n, a, lda,b, ldb, sdim, alpha,&
     !! ZGGESX: computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, the complex Schur form (S,T),
     !! and, optionally, the left and/or right matrices of Schur vectors (VSL
     !! and VSR).  This gives the generalized Schur factorization
     !! (A,B) = ( (VSL) S (VSR)**H, (VSL) T (VSR)**H )
     !! where (VSR)**H is the conjugate-transpose of VSR.
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! triangular matrix S and the upper triangular matrix T; computes
     !! a reciprocal condition number for the average of the selected
     !! eigenvalues (RCONDE); and computes a reciprocal condition number for
     !! the right and left deflating subspaces corresponding to the selected
     !! eigenvalues (RCONDV). The leading columns of VSL and VSR then form
     !! an orthonormal basis for the corresponding left and right eigenspaces
     !! (deflating subspaces).
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0 or for both being zero.
     !! A pair of matrices (S,T) is in generalized complex Schur form if T is
     !! upper triangular with non-negative diagonal and S is upper
     !! triangular.
      beta, vsl, ldvsl, vsr,ldvsr, rconde, rcondv, work, lwork, rwork,iwork, liwork, bwork, info )
                
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sense, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, liwork, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${ck}$), intent(out) :: rconde(2), rcondv(2), rwork(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: alpha(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), work(*)
                     
           ! Function Arguments 
           procedure(stdlib_selctg_${ci}$) :: selctg
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, wantsb, wantse, &
                     wantsn, wantst, wantsv
           integer(ilp) :: i, icols, ierr, ihi, ijob, ijobvl, ijobvr, ileft, ilo, iright, irows, &
                     irwrk, itau, iwrk, liwmin, lwrk, maxwrk, minwrk
           real(${ck}$) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pl, pr, smlnum
           ! Local Arrays 
           real(${ck}$) :: dif(2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           wantsn = stdlib_lsame( sense, 'N' )
           wantse = stdlib_lsame( sense, 'E' )
           wantsv = stdlib_lsame( sense, 'V' )
           wantsb = stdlib_lsame( sense, 'B' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( wantsn ) then
              ijob = 0
           else if( wantse ) then
              ijob = 1
           else if( wantsv ) then
              ijob = 2
           else if( wantsb ) then
              ijob = 4
           end if
           ! test the input arguments
           info = 0
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( .not.( wantsn .or. wantse .or. wantsv .or. wantsb ) .or.( .not.wantst .and. &
                     .not.wantsn ) ) then
              info = -5
           else if( n<0 ) then
              info = -6
           else if( lda<max( 1, n ) ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -15
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -17
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              if( n>0) then
                 minwrk = 2*n
                 maxwrk = n*(1 + stdlib_ilaenv( 1, 'ZGEQRF', ' ', n, 1, n, 0 ) )
                 maxwrk = max( maxwrk, n*( 1 +stdlib_ilaenv( 1, 'ZUNMQR', ' ', n, 1, n, -1 ) ) )
                           
                 if( ilvsl ) then
                    maxwrk = max( maxwrk, n*( 1 +stdlib_ilaenv( 1, 'ZUNGQR', ' ', n, 1, n, -1 ) ) &
                              )
                 end if
                 lwrk = maxwrk
                 if( ijob>=1 )lwrk = max( lwrk, n*n/2 )
              else
                 minwrk = 1
                 maxwrk = 1
                 lwrk   = 1
              end if
              work( 1 ) = lwrk
              if( wantsn .or. n==0 ) then
                 liwmin = 1
              else
                 liwmin = n + 2
              end if
              iwork( 1 ) = liwmin
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -21
              else if( liwork<liwmin  .and. .not.lquery) then
                 info = -24
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGESX', -info )
              return
           else if (lquery) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_${c2ri(ci)}$lamch( 'P' )
           smlnum = stdlib_${c2ri(ci)}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${c2ri(ci)}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ci}$lange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_${ci}$lascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_${ci}$lange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_${ci}$lascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (real workspace: need 6*n)
           ileft = 1
           iright = n + 1
           irwrk = iright + n
           call stdlib_${ci}$ggbal( 'P', n, a, lda, b, ldb, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     rwork( irwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (complex workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = 1
           iwrk = itau + irows
           call stdlib_${ci}$geqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the unitary transformation to matrix a
           ! (complex workspace: need n, prefer n*nb)
           call stdlib_${ci}$unmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           ! (complex workspace: need n, prefer n*nb)
           if( ilvsl ) then
              call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_${ci}$lacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_${ci}$ungqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           call stdlib_${ci}$gghrd( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      ierr )
           sdim = 0
           ! perform qz algorithm, computing schur vectors if desired
           ! (complex workspace: need n)
           ! (real workspace:    need n)
           iwrk = itau
           call stdlib_${ci}$hgeqz( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vsl, &
                     ldvsl, vsr, ldvsr, work( iwrk ),lwork+1-iwrk, rwork( irwrk ), ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 40
           end if
           ! sort eigenvalues alpha/beta and compute the reciprocal of
           ! condition number(s)
           if( wantst ) then
              ! undo scaling on eigenvalues before selctging
              if( ilascl )call stdlib_${ci}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
                        
              if( ilbscl )call stdlib_${ci}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alpha( i ), beta( i ) )
              end do
              ! reorder eigenvalues, transform generalized schur vectors, and
              ! compute reciprocal condition numbers
              ! (complex workspace: if ijob >= 1, need max(1, 2*sdim*(n-sdim))
                                  ! otherwise, need 1 )
              call stdlib_${ci}$tgsen( ijob, ilvsl, ilvsr, bwork, n, a, lda, b, ldb,alpha, beta, vsl, &
              ldvsl, vsr, ldvsr, sdim, pl, pr,dif, work( iwrk ), lwork-iwrk+1, iwork, liwork,ierr &
                        )
              if( ijob>=1 )maxwrk = max( maxwrk, 2*sdim*( n-sdim ) )
              if( ierr==-21 ) then
                  ! not enough complex workspace
                 info = -21
              else
                 if( ijob==1 .or. ijob==4 ) then
                    rconde( 1 ) = pl
                    rconde( 2 ) = pr
                 end if
                 if( ijob==2 .or. ijob==4 ) then
                    rcondv( 1 ) = dif( 1 )
                    rcondv( 2 ) = dif( 2 )
                 end if
                 if( ierr==1 )info = n + 3
              end if
           end if
           ! apply permutation to vsl and vsr
           ! (workspace: none needed)
           if( ilvsl )call stdlib_${ci}$ggbak( 'P', 'L', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_${ci}$ggbak( 'P', 'R', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsr, ldvsr, ierr )
           ! undo scaling
           if( ilascl ) then
              call stdlib_${ci}$lascl( 'U', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_${ci}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_${ci}$lascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_${ci}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              sdim = 0
              do i = 1, n
                 cursl = selctg( alpha( i ), beta( i ) )
                 if( cursl )sdim = sdim + 1
                 if( cursl .and. .not.lastsl )info = n + 2
                 lastsl = cursl
              end do
           end if
           40 continue
           work( 1 ) = maxwrk
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ci}$ggesx

#:endif
#:endfor



     module pure subroutine stdlib_stgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! STGSY2 solves the generalized Sylvester equation:
     !! A * R - L * B = scale * C                (1)
     !! D * R - L * E = scale * F,
     !! using Level 1 and 2 BLAS. where R and L are unknown M-by-N matrices,
     !! (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
     !! N-by-N and M-by-N, respectively, with real entries. (A, D) and (B, E)
     !! must be in generalized Schur canonical form, i.e. A, B are upper
     !! quasi triangular and D, E are upper triangular. The solution (R, L)
     !! overwrites (C, F). 0 <= SCALE <= 1 is an output scaling factor
     !! chosen to avoid overflow.
     !! In matrix notation solving equation (1) corresponds to solve
     !! Z*x = scale*b, where Z is defined as
     !! Z = [ kron(In, A)  -kron(B**T, Im) ]             (2)
     !! [ kron(In, D)  -kron(E**T, Im) ],
     !! Ik is the identity matrix of size k and X**T is the transpose of X.
     !! kron(X, Y) is the Kronecker product between the matrices X and Y.
     !! In the process of solving (1), we solve a number of such systems
     !! where Dim(In), Dim(In) = 1 or 2.
     !! If TRANS = 'T', solve the transposed system Z**T*y = scale*b for y,
     !! which is equivalent to solve for R and L in
     !! A**T * R  + D**T * L   = scale * C           (3)
     !! R  * B**T + L  * E**T  = scale * -F
     !! This case is used to compute an estimate of Dif[(A, D), (B, E)] =
     !! sigma_min(Z) using reverse communication with SLACON.
     !! STGSY2 also (IJOB >= 1) contributes to the computation in STGSYL
     !! of an upper bound on the separation between to matrix pairs. Then
     !! the input (A, D), (B, E) are sub-pencils of the matrix pair in
     !! STGSYL. See STGSYL for details.
               ldf, scale, rdsum, rdscal,iwork, pq, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, m, n
           integer(ilp), intent(out) :: info, pq
           real(sp), intent(inout) :: rdscal, rdsum
           real(sp), intent(out) :: scale
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           real(sp), intent(inout) :: c(ldc,*), f(ldf,*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_scopy by calls to stdlib_slaset.
        ! sven hammarling, 27/5/02.
           ! Parameters 
           integer(ilp), parameter :: ldz = 8
           
           
           ! Local Scalars 
           logical(lk) :: notran
           integer(ilp) :: i, ie, ierr, ii, is, isp1, j, je, jj, js, jsp1, k, mb, nb, p, q, &
                     zdim
           real(sp) :: alpha, scaloc
           ! Local Arrays 
           integer(ilp) :: ipiv(ldz), jpiv(ldz)
           real(sp) :: rhs(ldz), z(ldz,ldz)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           ierr = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>2 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STGSY2', -info )
              return
           end if
           ! determine block structure of a
           pq = 0
           p = 0
           i = 1
           10 continue
           if( i>m )go to 20
           p = p + 1
           iwork( p ) = i
           if( i==m )go to 20
           if( a( i+1, i )/=zero ) then
              i = i + 2
           else
              i = i + 1
           end if
           go to 10
           20 continue
           iwork( p+1 ) = m + 1
           ! determine block structure of b
           q = p + 1
           j = 1
           30 continue
           if( j>n )go to 40
           q = q + 1
           iwork( q ) = j
           if( j==n )go to 40
           if( b( j+1, j )/=zero ) then
              j = j + 2
           else
              j = j + 1
           end if
           go to 30
           40 continue
           iwork( q+1 ) = n + 1
           pq = p*( q-p-1 )
           if( notran ) then
              ! solve (i, j) - subsystem
                 ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                 ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
              ! for i = p, p - 1, ..., 1; j = 1, 2, ..., q
              scale = one
              scaloc = one
              loop_120: do j = p + 2, q
                 js = iwork( j )
                 jsp1 = js + 1
                 je = iwork( j+1 ) - 1
                 nb = je - js + 1
                 loop_110: do i = p, 1, -1
                    is = iwork( i )
                    isp1 = is + 1
                    ie = iwork( i+1 ) - 1
                    mb = ie - is + 1
                    zdim = mb*nb*2
                    if( ( mb==1 ) .and. ( nb==1 ) ) then
                       ! build a 2-by-2 system z * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = d( is, is )
                       z( 1, 2 ) = -b( js, js )
                       z( 2, 2 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = f( is, js )
                       ! solve z * x = rhs
                       call stdlib_sgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_sgesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_slatdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       f( is, js ) = rhs( 2 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          alpha = -rhs( 1 )
                          call stdlib_saxpy( is-1, alpha, a( 1, is ), 1, c( 1, js ),1 )
                          call stdlib_saxpy( is-1, alpha, d( 1, is ), 1, f( 1, js ),1 )
                       end if
                       if( j<q ) then
                          call stdlib_saxpy( n-je, rhs( 2 ), b( js, je+1 ), ldb,c( is, je+1 ), &
                                    ldc )
                          call stdlib_saxpy( n-je, rhs( 2 ), e( js, je+1 ), lde,f( is, je+1 ), &
                                    ldf )
                       end if
                    else if( ( mb==1 ) .and. ( nb==2 ) ) then
                       ! build a 4-by-4 system z * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = zero
                       z( 3, 1 ) = d( is, is )
                       z( 4, 1 ) = zero
                       z( 1, 2 ) = zero
                       z( 2, 2 ) = a( is, is )
                       z( 3, 2 ) = zero
                       z( 4, 2 ) = d( is, is )
                       z( 1, 3 ) = -b( js, js )
                       z( 2, 3 ) = -b( js, jsp1 )
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = -e( js, jsp1 )
                       z( 1, 4 ) = -b( jsp1, js )
                       z( 2, 4 ) = -b( jsp1, jsp1 )
                       z( 3, 4 ) = zero
                       z( 4, 4 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( is, jsp1 )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( is, jsp1 )
                       ! solve z * x = rhs
                       call stdlib_sgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_sgesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_slatdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( is, jsp1 ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( is, jsp1 ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_sger( is-1, nb, -one, a( 1, is ), 1, rhs( 1 ),1, c( 1, js ),&
                                     ldc )
                          call stdlib_sger( is-1, nb, -one, d( 1, is ), 1, rhs( 1 ),1, f( 1, js ),&
                                     ldf )
                       end if
                       if( j<q ) then
                          call stdlib_saxpy( n-je, rhs( 3 ), b( js, je+1 ), ldb,c( is, je+1 ), &
                                    ldc )
                          call stdlib_saxpy( n-je, rhs( 3 ), e( js, je+1 ), lde,f( is, je+1 ), &
                                    ldf )
                          call stdlib_saxpy( n-je, rhs( 4 ), b( jsp1, je+1 ), ldb,c( is, je+1 ), &
                                    ldc )
                          call stdlib_saxpy( n-je, rhs( 4 ), e( jsp1, je+1 ), lde,f( is, je+1 ), &
                                    ldf )
                       end if
                    else if( ( mb==2 ) .and. ( nb==1 ) ) then
                       ! build a 4-by-4 system z * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( isp1, is )
                       z( 3, 1 ) = d( is, is )
                       z( 4, 1 ) = zero
                       z( 1, 2 ) = a( is, isp1 )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 3, 2 ) = d( is, isp1 )
                       z( 4, 2 ) = d( isp1, isp1 )
                       z( 1, 3 ) = -b( js, js )
                       z( 2, 3 ) = zero
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = zero
                       z( 1, 4 ) = zero
                       z( 2, 4 ) = -b( js, js )
                       z( 3, 4 ) = zero
                       z( 4, 4 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( isp1, js )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( isp1, js )
                       ! solve z * x = rhs
                       call stdlib_sgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_sgesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_slatdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( isp1, js ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( isp1, js ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_sgemv( 'N', is-1, mb, -one, a( 1, is ), lda,rhs( 1 ), 1, &
                                    one, c( 1, js ), 1 )
                          call stdlib_sgemv( 'N', is-1, mb, -one, d( 1, is ), ldd,rhs( 1 ), 1, &
                                    one, f( 1, js ), 1 )
                       end if
                       if( j<q ) then
                          call stdlib_sger( mb, n-je, one, rhs( 3 ), 1,b( js, je+1 ), ldb, c( is, &
                                    je+1 ), ldc )
                          call stdlib_sger( mb, n-je, one, rhs( 3 ), 1,e( js, je+1 ), lde, f( is, &
                                    je+1 ), ldf )
                       end if
                    else if( ( mb==2 ) .and. ( nb==2 ) ) then
                       ! build an 8-by-8 system z * x = rhs
                       call stdlib_slaset( 'F', ldz, ldz, zero, zero, z, ldz )
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( isp1, is )
                       z( 5, 1 ) = d( is, is )
                       z( 1, 2 ) = a( is, isp1 )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 5, 2 ) = d( is, isp1 )
                       z( 6, 2 ) = d( isp1, isp1 )
                       z( 3, 3 ) = a( is, is )
                       z( 4, 3 ) = a( isp1, is )
                       z( 7, 3 ) = d( is, is )
                       z( 3, 4 ) = a( is, isp1 )
                       z( 4, 4 ) = a( isp1, isp1 )
                       z( 7, 4 ) = d( is, isp1 )
                       z( 8, 4 ) = d( isp1, isp1 )
                       z( 1, 5 ) = -b( js, js )
                       z( 3, 5 ) = -b( js, jsp1 )
                       z( 5, 5 ) = -e( js, js )
                       z( 7, 5 ) = -e( js, jsp1 )
                       z( 2, 6 ) = -b( js, js )
                       z( 4, 6 ) = -b( js, jsp1 )
                       z( 6, 6 ) = -e( js, js )
                       z( 8, 6 ) = -e( js, jsp1 )
                       z( 1, 7 ) = -b( jsp1, js )
                       z( 3, 7 ) = -b( jsp1, jsp1 )
                       z( 7, 7 ) = -e( jsp1, jsp1 )
                       z( 2, 8 ) = -b( jsp1, js )
                       z( 4, 8 ) = -b( jsp1, jsp1 )
                       z( 8, 8 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_scopy( mb, c( is, js+jj ), 1, rhs( k ), 1 )
                          call stdlib_scopy( mb, f( is, js+jj ), 1, rhs( ii ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! solve z * x = rhs
                       call stdlib_sgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_sgesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_slatdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_scopy( mb, rhs( k ), 1, c( is, js+jj ), 1 )
                          call stdlib_scopy( mb, rhs( ii ), 1, f( is, js+jj ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_sgemm( 'N', 'N', is-1, nb, mb, -one,a( 1, is ), lda, rhs( 1 &
                                    ), mb, one,c( 1, js ), ldc )
                          call stdlib_sgemm( 'N', 'N', is-1, nb, mb, -one,d( 1, is ), ldd, rhs( 1 &
                                    ), mb, one,f( 1, js ), ldf )
                       end if
                       if( j<q ) then
                          k = mb*nb + 1
                          call stdlib_sgemm( 'N', 'N', mb, n-je, nb, one, rhs( k ),mb, b( js, je+&
                                    1 ), ldb, one,c( is, je+1 ), ldc )
                          call stdlib_sgemm( 'N', 'N', mb, n-je, nb, one, rhs( k ),mb, e( js, je+&
                                    1 ), lde, one,f( is, je+1 ), ldf )
                       end if
                    end if
                 end do loop_110
              end do loop_120
           else
              ! solve (i, j) - subsystem
                   ! a(i, i)**t * r(i, j) + d(i, i)**t * l(j, j)  =  c(i, j)
                   ! r(i, i)  * b(j, j) + l(i, j)  * e(j, j)  = -f(i, j)
              ! for i = 1, 2, ..., p, j = q, q - 1, ..., 1
              scale = one
              scaloc = one
              loop_200: do i = 1, p
                 is = iwork( i )
                 isp1 = is + 1
                 ie = iwork( i+1 ) - 1
                 mb = ie - is + 1
                 loop_190: do j = q, p + 2, -1
                    js = iwork( j )
                    jsp1 = js + 1
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    zdim = mb*nb*2
                    if( ( mb==1 ) .and. ( nb==1 ) ) then
                       ! build a 2-by-2 system z**t * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = -b( js, js )
                       z( 1, 2 ) = d( is, is )
                       z( 2, 2 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = f( is, js )
                       ! solve z**t * x = rhs
                       call stdlib_sgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_sgesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       f( is, js ) = rhs( 2 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          alpha = rhs( 1 )
                          call stdlib_saxpy( js-1, alpha, b( 1, js ), 1, f( is, 1 ),ldf )
                          alpha = rhs( 2 )
                          call stdlib_saxpy( js-1, alpha, e( 1, js ), 1, f( is, 1 ),ldf )
                       end if
                       if( i<p ) then
                          alpha = -rhs( 1 )
                          call stdlib_saxpy( m-ie, alpha, a( is, ie+1 ), lda,c( ie+1, js ), 1 )
                                    
                          alpha = -rhs( 2 )
                          call stdlib_saxpy( m-ie, alpha, d( is, ie+1 ), ldd,c( ie+1, js ), 1 )
                                    
                       end if
                    else if( ( mb==1 ) .and. ( nb==2 ) ) then
                       ! build a 4-by-4 system z**t * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = zero
                       z( 3, 1 ) = -b( js, js )
                       z( 4, 1 ) = -b( jsp1, js )
                       z( 1, 2 ) = zero
                       z( 2, 2 ) = a( is, is )
                       z( 3, 2 ) = -b( js, jsp1 )
                       z( 4, 2 ) = -b( jsp1, jsp1 )
                       z( 1, 3 ) = d( is, is )
                       z( 2, 3 ) = zero
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = zero
                       z( 1, 4 ) = zero
                       z( 2, 4 ) = d( is, is )
                       z( 3, 4 ) = -e( js, jsp1 )
                       z( 4, 4 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( is, jsp1 )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( is, jsp1 )
                       ! solve z**t * x = rhs
                       call stdlib_sgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_sgesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( is, jsp1 ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( is, jsp1 ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          call stdlib_saxpy( js-1, rhs( 1 ), b( 1, js ), 1,f( is, 1 ), ldf )
                                    
                          call stdlib_saxpy( js-1, rhs( 2 ), b( 1, jsp1 ), 1,f( is, 1 ), ldf )
                                    
                          call stdlib_saxpy( js-1, rhs( 3 ), e( 1, js ), 1,f( is, 1 ), ldf )
                                    
                          call stdlib_saxpy( js-1, rhs( 4 ), e( 1, jsp1 ), 1,f( is, 1 ), ldf )
                                    
                       end if
                       if( i<p ) then
                          call stdlib_sger( m-ie, nb, -one, a( is, ie+1 ), lda,rhs( 1 ), 1, c( ie+&
                                    1, js ), ldc )
                          call stdlib_sger( m-ie, nb, -one, d( is, ie+1 ), ldd,rhs( 3 ), 1, c( ie+&
                                    1, js ), ldc )
                       end if
                    else if( ( mb==2 ) .and. ( nb==1 ) ) then
                       ! build a 4-by-4 system z**t * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( is, isp1 )
                       z( 3, 1 ) = -b( js, js )
                       z( 4, 1 ) = zero
                       z( 1, 2 ) = a( isp1, is )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 3, 2 ) = zero
                       z( 4, 2 ) = -b( js, js )
                       z( 1, 3 ) = d( is, is )
                       z( 2, 3 ) = d( is, isp1 )
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = zero
                       z( 1, 4 ) = zero
                       z( 2, 4 ) = d( isp1, isp1 )
                       z( 3, 4 ) = zero
                       z( 4, 4 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( isp1, js )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( isp1, js )
                       ! solve z**t * x = rhs
                       call stdlib_sgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_sgesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( isp1, js ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( isp1, js ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          call stdlib_sger( mb, js-1, one, rhs( 1 ), 1, b( 1, js ),1, f( is, 1 ), &
                                    ldf )
                          call stdlib_sger( mb, js-1, one, rhs( 3 ), 1, e( 1, js ),1, f( is, 1 ), &
                                    ldf )
                       end if
                       if( i<p ) then
                          call stdlib_sgemv( 'T', mb, m-ie, -one, a( is, ie+1 ),lda, rhs( 1 ), 1, &
                                    one, c( ie+1, js ),1 )
                          call stdlib_sgemv( 'T', mb, m-ie, -one, d( is, ie+1 ),ldd, rhs( 3 ), 1, &
                                    one, c( ie+1, js ),1 )
                       end if
                    else if( ( mb==2 ) .and. ( nb==2 ) ) then
                       ! build an 8-by-8 system z**t * x = rhs
                       call stdlib_slaset( 'F', ldz, ldz, zero, zero, z, ldz )
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( is, isp1 )
                       z( 5, 1 ) = -b( js, js )
                       z( 7, 1 ) = -b( jsp1, js )
                       z( 1, 2 ) = a( isp1, is )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 6, 2 ) = -b( js, js )
                       z( 8, 2 ) = -b( jsp1, js )
                       z( 3, 3 ) = a( is, is )
                       z( 4, 3 ) = a( is, isp1 )
                       z( 5, 3 ) = -b( js, jsp1 )
                       z( 7, 3 ) = -b( jsp1, jsp1 )
                       z( 3, 4 ) = a( isp1, is )
                       z( 4, 4 ) = a( isp1, isp1 )
                       z( 6, 4 ) = -b( js, jsp1 )
                       z( 8, 4 ) = -b( jsp1, jsp1 )
                       z( 1, 5 ) = d( is, is )
                       z( 2, 5 ) = d( is, isp1 )
                       z( 5, 5 ) = -e( js, js )
                       z( 2, 6 ) = d( isp1, isp1 )
                       z( 6, 6 ) = -e( js, js )
                       z( 3, 7 ) = d( is, is )
                       z( 4, 7 ) = d( is, isp1 )
                       z( 5, 7 ) = -e( js, jsp1 )
                       z( 7, 7 ) = -e( jsp1, jsp1 )
                       z( 4, 8 ) = d( isp1, isp1 )
                       z( 6, 8 ) = -e( js, jsp1 )
                       z( 8, 8 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_scopy( mb, c( is, js+jj ), 1, rhs( k ), 1 )
                          call stdlib_scopy( mb, f( is, js+jj ), 1, rhs( ii ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! solve z**t * x = rhs
                       call stdlib_sgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_sgesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_scopy( mb, rhs( k ), 1, c( is, js+jj ), 1 )
                          call stdlib_scopy( mb, rhs( ii ), 1, f( is, js+jj ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          call stdlib_sgemm( 'N', 'T', mb, js-1, nb, one,c( is, js ), ldc, b( 1, &
                                    js ), ldb, one,f( is, 1 ), ldf )
                          call stdlib_sgemm( 'N', 'T', mb, js-1, nb, one,f( is, js ), ldf, e( 1, &
                                    js ), lde, one,f( is, 1 ), ldf )
                       end if
                       if( i<p ) then
                          call stdlib_sgemm( 'T', 'N', m-ie, nb, mb, -one,a( is, ie+1 ), lda, c( &
                                    is, js ), ldc,one, c( ie+1, js ), ldc )
                          call stdlib_sgemm( 'T', 'N', m-ie, nb, mb, -one,d( is, ie+1 ), ldd, f( &
                                    is, js ), ldf,one, c( ie+1, js ), ldc )
                       end if
                    end if
                 end do loop_190
              end do loop_200
           end if
           return
     end subroutine stdlib_stgsy2

     module pure subroutine stdlib_dtgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! DTGSY2 solves the generalized Sylvester equation:
     !! A * R - L * B = scale * C                (1)
     !! D * R - L * E = scale * F,
     !! using Level 1 and 2 BLAS. where R and L are unknown M-by-N matrices,
     !! (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
     !! N-by-N and M-by-N, respectively, with real entries. (A, D) and (B, E)
     !! must be in generalized Schur canonical form, i.e. A, B are upper
     !! quasi triangular and D, E are upper triangular. The solution (R, L)
     !! overwrites (C, F). 0 <= SCALE <= 1 is an output scaling factor
     !! chosen to avoid overflow.
     !! In matrix notation solving equation (1) corresponds to solve
     !! Z*x = scale*b, where Z is defined as
     !! Z = [ kron(In, A)  -kron(B**T, Im) ]             (2)
     !! [ kron(In, D)  -kron(E**T, Im) ],
     !! Ik is the identity matrix of size k and X**T is the transpose of X.
     !! kron(X, Y) is the Kronecker product between the matrices X and Y.
     !! In the process of solving (1), we solve a number of such systems
     !! where Dim(In), Dim(In) = 1 or 2.
     !! If TRANS = 'T', solve the transposed system Z**T*y = scale*b for y,
     !! which is equivalent to solve for R and L in
     !! A**T * R  + D**T * L   = scale * C           (3)
     !! R  * B**T + L  * E**T  = scale * -F
     !! This case is used to compute an estimate of Dif[(A, D), (B, E)] =
     !! sigma_min(Z) using reverse communication with DLACON.
     !! DTGSY2 also (IJOB >= 1) contributes to the computation in DTGSYL
     !! of an upper bound on the separation between to matrix pairs. Then
     !! the input (A, D), (B, E) are sub-pencils of the matrix pair in
     !! DTGSYL. See DTGSYL for details.
               ldf, scale, rdsum, rdscal,iwork, pq, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, m, n
           integer(ilp), intent(out) :: info, pq
           real(dp), intent(inout) :: rdscal, rdsum
           real(dp), intent(out) :: scale
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           real(dp), intent(inout) :: c(ldc,*), f(ldf,*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_dcopy by calls to stdlib_dlaset.
        ! sven hammarling, 27/5/02.
           ! Parameters 
           integer(ilp), parameter :: ldz = 8
           
           
           ! Local Scalars 
           logical(lk) :: notran
           integer(ilp) :: i, ie, ierr, ii, is, isp1, j, je, jj, js, jsp1, k, mb, nb, p, q, &
                     zdim
           real(dp) :: alpha, scaloc
           ! Local Arrays 
           integer(ilp) :: ipiv(ldz), jpiv(ldz)
           real(dp) :: rhs(ldz), z(ldz,ldz)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           ierr = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>2 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSY2', -info )
              return
           end if
           ! determine block structure of a
           pq = 0
           p = 0
           i = 1
           10 continue
           if( i>m )go to 20
           p = p + 1
           iwork( p ) = i
           if( i==m )go to 20
           if( a( i+1, i )/=zero ) then
              i = i + 2
           else
              i = i + 1
           end if
           go to 10
           20 continue
           iwork( p+1 ) = m + 1
           ! determine block structure of b
           q = p + 1
           j = 1
           30 continue
           if( j>n )go to 40
           q = q + 1
           iwork( q ) = j
           if( j==n )go to 40
           if( b( j+1, j )/=zero ) then
              j = j + 2
           else
              j = j + 1
           end if
           go to 30
           40 continue
           iwork( q+1 ) = n + 1
           pq = p*( q-p-1 )
           if( notran ) then
              ! solve (i, j) - subsystem
                 ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                 ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
              ! for i = p, p - 1, ..., 1; j = 1, 2, ..., q
              scale = one
              scaloc = one
              loop_120: do j = p + 2, q
                 js = iwork( j )
                 jsp1 = js + 1
                 je = iwork( j+1 ) - 1
                 nb = je - js + 1
                 loop_110: do i = p, 1, -1
                    is = iwork( i )
                    isp1 = is + 1
                    ie = iwork( i+1 ) - 1
                    mb = ie - is + 1
                    zdim = mb*nb*2
                    if( ( mb==1 ) .and. ( nb==1 ) ) then
                       ! build a 2-by-2 system z * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = d( is, is )
                       z( 1, 2 ) = -b( js, js )
                       z( 2, 2 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = f( is, js )
                       ! solve z * x = rhs
                       call stdlib_dgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_dgesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_dlatdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       f( is, js ) = rhs( 2 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          alpha = -rhs( 1 )
                          call stdlib_daxpy( is-1, alpha, a( 1, is ), 1, c( 1, js ),1 )
                          call stdlib_daxpy( is-1, alpha, d( 1, is ), 1, f( 1, js ),1 )
                       end if
                       if( j<q ) then
                          call stdlib_daxpy( n-je, rhs( 2 ), b( js, je+1 ), ldb,c( is, je+1 ), &
                                    ldc )
                          call stdlib_daxpy( n-je, rhs( 2 ), e( js, je+1 ), lde,f( is, je+1 ), &
                                    ldf )
                       end if
                    else if( ( mb==1 ) .and. ( nb==2 ) ) then
                       ! build a 4-by-4 system z * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = zero
                       z( 3, 1 ) = d( is, is )
                       z( 4, 1 ) = zero
                       z( 1, 2 ) = zero
                       z( 2, 2 ) = a( is, is )
                       z( 3, 2 ) = zero
                       z( 4, 2 ) = d( is, is )
                       z( 1, 3 ) = -b( js, js )
                       z( 2, 3 ) = -b( js, jsp1 )
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = -e( js, jsp1 )
                       z( 1, 4 ) = -b( jsp1, js )
                       z( 2, 4 ) = -b( jsp1, jsp1 )
                       z( 3, 4 ) = zero
                       z( 4, 4 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( is, jsp1 )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( is, jsp1 )
                       ! solve z * x = rhs
                       call stdlib_dgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_dgesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_dlatdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( is, jsp1 ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( is, jsp1 ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_dger( is-1, nb, -one, a( 1, is ), 1, rhs( 1 ),1, c( 1, js ),&
                                     ldc )
                          call stdlib_dger( is-1, nb, -one, d( 1, is ), 1, rhs( 1 ),1, f( 1, js ),&
                                     ldf )
                       end if
                       if( j<q ) then
                          call stdlib_daxpy( n-je, rhs( 3 ), b( js, je+1 ), ldb,c( is, je+1 ), &
                                    ldc )
                          call stdlib_daxpy( n-je, rhs( 3 ), e( js, je+1 ), lde,f( is, je+1 ), &
                                    ldf )
                          call stdlib_daxpy( n-je, rhs( 4 ), b( jsp1, je+1 ), ldb,c( is, je+1 ), &
                                    ldc )
                          call stdlib_daxpy( n-je, rhs( 4 ), e( jsp1, je+1 ), lde,f( is, je+1 ), &
                                    ldf )
                       end if
                    else if( ( mb==2 ) .and. ( nb==1 ) ) then
                       ! build a 4-by-4 system z * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( isp1, is )
                       z( 3, 1 ) = d( is, is )
                       z( 4, 1 ) = zero
                       z( 1, 2 ) = a( is, isp1 )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 3, 2 ) = d( is, isp1 )
                       z( 4, 2 ) = d( isp1, isp1 )
                       z( 1, 3 ) = -b( js, js )
                       z( 2, 3 ) = zero
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = zero
                       z( 1, 4 ) = zero
                       z( 2, 4 ) = -b( js, js )
                       z( 3, 4 ) = zero
                       z( 4, 4 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( isp1, js )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( isp1, js )
                       ! solve z * x = rhs
                       call stdlib_dgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_dgesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_dlatdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( isp1, js ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( isp1, js ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_dgemv( 'N', is-1, mb, -one, a( 1, is ), lda,rhs( 1 ), 1, &
                                    one, c( 1, js ), 1 )
                          call stdlib_dgemv( 'N', is-1, mb, -one, d( 1, is ), ldd,rhs( 1 ), 1, &
                                    one, f( 1, js ), 1 )
                       end if
                       if( j<q ) then
                          call stdlib_dger( mb, n-je, one, rhs( 3 ), 1,b( js, je+1 ), ldb, c( is, &
                                    je+1 ), ldc )
                          call stdlib_dger( mb, n-je, one, rhs( 3 ), 1,e( js, je+1 ), lde, f( is, &
                                    je+1 ), ldf )
                       end if
                    else if( ( mb==2 ) .and. ( nb==2 ) ) then
                       ! build an 8-by-8 system z * x = rhs
                       call stdlib_dlaset( 'F', ldz, ldz, zero, zero, z, ldz )
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( isp1, is )
                       z( 5, 1 ) = d( is, is )
                       z( 1, 2 ) = a( is, isp1 )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 5, 2 ) = d( is, isp1 )
                       z( 6, 2 ) = d( isp1, isp1 )
                       z( 3, 3 ) = a( is, is )
                       z( 4, 3 ) = a( isp1, is )
                       z( 7, 3 ) = d( is, is )
                       z( 3, 4 ) = a( is, isp1 )
                       z( 4, 4 ) = a( isp1, isp1 )
                       z( 7, 4 ) = d( is, isp1 )
                       z( 8, 4 ) = d( isp1, isp1 )
                       z( 1, 5 ) = -b( js, js )
                       z( 3, 5 ) = -b( js, jsp1 )
                       z( 5, 5 ) = -e( js, js )
                       z( 7, 5 ) = -e( js, jsp1 )
                       z( 2, 6 ) = -b( js, js )
                       z( 4, 6 ) = -b( js, jsp1 )
                       z( 6, 6 ) = -e( js, js )
                       z( 8, 6 ) = -e( js, jsp1 )
                       z( 1, 7 ) = -b( jsp1, js )
                       z( 3, 7 ) = -b( jsp1, jsp1 )
                       z( 7, 7 ) = -e( jsp1, jsp1 )
                       z( 2, 8 ) = -b( jsp1, js )
                       z( 4, 8 ) = -b( jsp1, jsp1 )
                       z( 8, 8 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_dcopy( mb, c( is, js+jj ), 1, rhs( k ), 1 )
                          call stdlib_dcopy( mb, f( is, js+jj ), 1, rhs( ii ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! solve z * x = rhs
                       call stdlib_dgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_dgesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_dlatdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_dcopy( mb, rhs( k ), 1, c( is, js+jj ), 1 )
                          call stdlib_dcopy( mb, rhs( ii ), 1, f( is, js+jj ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_dgemm( 'N', 'N', is-1, nb, mb, -one,a( 1, is ), lda, rhs( 1 &
                                    ), mb, one,c( 1, js ), ldc )
                          call stdlib_dgemm( 'N', 'N', is-1, nb, mb, -one,d( 1, is ), ldd, rhs( 1 &
                                    ), mb, one,f( 1, js ), ldf )
                       end if
                       if( j<q ) then
                          k = mb*nb + 1
                          call stdlib_dgemm( 'N', 'N', mb, n-je, nb, one, rhs( k ),mb, b( js, je+&
                                    1 ), ldb, one,c( is, je+1 ), ldc )
                          call stdlib_dgemm( 'N', 'N', mb, n-je, nb, one, rhs( k ),mb, e( js, je+&
                                    1 ), lde, one,f( is, je+1 ), ldf )
                       end if
                    end if
                 end do loop_110
              end do loop_120
           else
              ! solve (i, j) - subsystem
                   ! a(i, i)**t * r(i, j) + d(i, i)**t * l(j, j)  =  c(i, j)
                   ! r(i, i)  * b(j, j) + l(i, j)  * e(j, j)  = -f(i, j)
              ! for i = 1, 2, ..., p, j = q, q - 1, ..., 1
              scale = one
              scaloc = one
              loop_200: do i = 1, p
                 is = iwork( i )
                 isp1 = is + 1
                 ie = iwork ( i+1 ) - 1
                 mb = ie - is + 1
                 loop_190: do j = q, p + 2, -1
                    js = iwork( j )
                    jsp1 = js + 1
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    zdim = mb*nb*2
                    if( ( mb==1 ) .and. ( nb==1 ) ) then
                       ! build a 2-by-2 system z**t * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = -b( js, js )
                       z( 1, 2 ) = d( is, is )
                       z( 2, 2 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = f( is, js )
                       ! solve z**t * x = rhs
                       call stdlib_dgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_dgesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       f( is, js ) = rhs( 2 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          alpha = rhs( 1 )
                          call stdlib_daxpy( js-1, alpha, b( 1, js ), 1, f( is, 1 ),ldf )
                          alpha = rhs( 2 )
                          call stdlib_daxpy( js-1, alpha, e( 1, js ), 1, f( is, 1 ),ldf )
                       end if
                       if( i<p ) then
                          alpha = -rhs( 1 )
                          call stdlib_daxpy( m-ie, alpha, a( is, ie+1 ), lda,c( ie+1, js ), 1 )
                                    
                          alpha = -rhs( 2 )
                          call stdlib_daxpy( m-ie, alpha, d( is, ie+1 ), ldd,c( ie+1, js ), 1 )
                                    
                       end if
                    else if( ( mb==1 ) .and. ( nb==2 ) ) then
                       ! build a 4-by-4 system z**t * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = zero
                       z( 3, 1 ) = -b( js, js )
                       z( 4, 1 ) = -b( jsp1, js )
                       z( 1, 2 ) = zero
                       z( 2, 2 ) = a( is, is )
                       z( 3, 2 ) = -b( js, jsp1 )
                       z( 4, 2 ) = -b( jsp1, jsp1 )
                       z( 1, 3 ) = d( is, is )
                       z( 2, 3 ) = zero
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = zero
                       z( 1, 4 ) = zero
                       z( 2, 4 ) = d( is, is )
                       z( 3, 4 ) = -e( js, jsp1 )
                       z( 4, 4 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( is, jsp1 )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( is, jsp1 )
                       ! solve z**t * x = rhs
                       call stdlib_dgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_dgesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( is, jsp1 ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( is, jsp1 ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          call stdlib_daxpy( js-1, rhs( 1 ), b( 1, js ), 1,f( is, 1 ), ldf )
                                    
                          call stdlib_daxpy( js-1, rhs( 2 ), b( 1, jsp1 ), 1,f( is, 1 ), ldf )
                                    
                          call stdlib_daxpy( js-1, rhs( 3 ), e( 1, js ), 1,f( is, 1 ), ldf )
                                    
                          call stdlib_daxpy( js-1, rhs( 4 ), e( 1, jsp1 ), 1,f( is, 1 ), ldf )
                                    
                       end if
                       if( i<p ) then
                          call stdlib_dger( m-ie, nb, -one, a( is, ie+1 ), lda,rhs( 1 ), 1, c( ie+&
                                    1, js ), ldc )
                          call stdlib_dger( m-ie, nb, -one, d( is, ie+1 ), ldd,rhs( 3 ), 1, c( ie+&
                                    1, js ), ldc )
                       end if
                    else if( ( mb==2 ) .and. ( nb==1 ) ) then
                       ! build a 4-by-4 system z**t * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( is, isp1 )
                       z( 3, 1 ) = -b( js, js )
                       z( 4, 1 ) = zero
                       z( 1, 2 ) = a( isp1, is )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 3, 2 ) = zero
                       z( 4, 2 ) = -b( js, js )
                       z( 1, 3 ) = d( is, is )
                       z( 2, 3 ) = d( is, isp1 )
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = zero
                       z( 1, 4 ) = zero
                       z( 2, 4 ) = d( isp1, isp1 )
                       z( 3, 4 ) = zero
                       z( 4, 4 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( isp1, js )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( isp1, js )
                       ! solve z**t * x = rhs
                       call stdlib_dgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_dgesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( isp1, js ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( isp1, js ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          call stdlib_dger( mb, js-1, one, rhs( 1 ), 1, b( 1, js ),1, f( is, 1 ), &
                                    ldf )
                          call stdlib_dger( mb, js-1, one, rhs( 3 ), 1, e( 1, js ),1, f( is, 1 ), &
                                    ldf )
                       end if
                       if( i<p ) then
                          call stdlib_dgemv( 'T', mb, m-ie, -one, a( is, ie+1 ),lda, rhs( 1 ), 1, &
                                    one, c( ie+1, js ),1 )
                          call stdlib_dgemv( 'T', mb, m-ie, -one, d( is, ie+1 ),ldd, rhs( 3 ), 1, &
                                    one, c( ie+1, js ),1 )
                       end if
                    else if( ( mb==2 ) .and. ( nb==2 ) ) then
                       ! build an 8-by-8 system z**t * x = rhs
                       call stdlib_dlaset( 'F', ldz, ldz, zero, zero, z, ldz )
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( is, isp1 )
                       z( 5, 1 ) = -b( js, js )
                       z( 7, 1 ) = -b( jsp1, js )
                       z( 1, 2 ) = a( isp1, is )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 6, 2 ) = -b( js, js )
                       z( 8, 2 ) = -b( jsp1, js )
                       z( 3, 3 ) = a( is, is )
                       z( 4, 3 ) = a( is, isp1 )
                       z( 5, 3 ) = -b( js, jsp1 )
                       z( 7, 3 ) = -b( jsp1, jsp1 )
                       z( 3, 4 ) = a( isp1, is )
                       z( 4, 4 ) = a( isp1, isp1 )
                       z( 6, 4 ) = -b( js, jsp1 )
                       z( 8, 4 ) = -b( jsp1, jsp1 )
                       z( 1, 5 ) = d( is, is )
                       z( 2, 5 ) = d( is, isp1 )
                       z( 5, 5 ) = -e( js, js )
                       z( 2, 6 ) = d( isp1, isp1 )
                       z( 6, 6 ) = -e( js, js )
                       z( 3, 7 ) = d( is, is )
                       z( 4, 7 ) = d( is, isp1 )
                       z( 5, 7 ) = -e( js, jsp1 )
                       z( 7, 7 ) = -e( jsp1, jsp1 )
                       z( 4, 8 ) = d( isp1, isp1 )
                       z( 6, 8 ) = -e( js, jsp1 )
                       z( 8, 8 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_dcopy( mb, c( is, js+jj ), 1, rhs( k ), 1 )
                          call stdlib_dcopy( mb, f( is, js+jj ), 1, rhs( ii ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! solve z**t * x = rhs
                       call stdlib_dgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_dgesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_dcopy( mb, rhs( k ), 1, c( is, js+jj ), 1 )
                          call stdlib_dcopy( mb, rhs( ii ), 1, f( is, js+jj ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          call stdlib_dgemm( 'N', 'T', mb, js-1, nb, one,c( is, js ), ldc, b( 1, &
                                    js ), ldb, one,f( is, 1 ), ldf )
                          call stdlib_dgemm( 'N', 'T', mb, js-1, nb, one,f( is, js ), ldf, e( 1, &
                                    js ), lde, one,f( is, 1 ), ldf )
                       end if
                       if( i<p ) then
                          call stdlib_dgemm( 'T', 'N', m-ie, nb, mb, -one,a( is, ie+1 ), lda, c( &
                                    is, js ), ldc,one, c( ie+1, js ), ldc )
                          call stdlib_dgemm( 'T', 'N', m-ie, nb, mb, -one,d( is, ie+1 ), ldd, f( &
                                    is, js ), ldf,one, c( ie+1, js ), ldc )
                       end if
                    end if
                 end do loop_190
              end do loop_200
           end if
           return
     end subroutine stdlib_dtgsy2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$tgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! DTGSY2: solves the generalized Sylvester equation:
     !! A * R - L * B = scale * C                (1)
     !! D * R - L * E = scale * F,
     !! using Level 1 and 2 BLAS. where R and L are unknown M-by-N matrices,
     !! (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
     !! N-by-N and M-by-N, respectively, with real entries. (A, D) and (B, E)
     !! must be in generalized Schur canonical form, i.e. A, B are upper
     !! quasi triangular and D, E are upper triangular. The solution (R, L)
     !! overwrites (C, F). 0 <= SCALE <= 1 is an output scaling factor
     !! chosen to avoid overflow.
     !! In matrix notation solving equation (1) corresponds to solve
     !! Z*x = scale*b, where Z is defined as
     !! Z = [ kron(In, A)  -kron(B**T, Im) ]             (2)
     !! [ kron(In, D)  -kron(E**T, Im) ],
     !! Ik is the identity matrix of size k and X**T is the transpose of X.
     !! kron(X, Y) is the Kronecker product between the matrices X and Y.
     !! In the process of solving (1), we solve a number of such systems
     !! where Dim(In), Dim(In) = 1 or 2.
     !! If TRANS = 'T', solve the transposed system Z**T*y = scale*b for y,
     !! which is equivalent to solve for R and L in
     !! A**T * R  + D**T * L   = scale * C           (3)
     !! R  * B**T + L  * E**T  = scale * -F
     !! This case is used to compute an estimate of Dif[(A, D), (B, E)] =
     !! sigma_min(Z) using reverse communication with DLACON.
     !! DTGSY2 also (IJOB >= 1) contributes to the computation in DTGSYL
     !! of an upper bound on the separation between to matrix pairs. Then
     !! the input (A, D), (B, E) are sub-pencils of the matrix pair in
     !! DTGSYL. See DTGSYL for details.
               ldf, scale, rdsum, rdscal,iwork, pq, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, m, n
           integer(ilp), intent(out) :: info, pq
           real(${rk}$), intent(inout) :: rdscal, rdsum
           real(${rk}$), intent(out) :: scale
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           real(${rk}$), intent(inout) :: c(ldc,*), f(ldf,*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_${ri}$copy by calls to stdlib_${ri}$laset.
        ! sven hammarling, 27/5/02.
           ! Parameters 
           integer(ilp), parameter :: ldz = 8
           
           
           ! Local Scalars 
           logical(lk) :: notran
           integer(ilp) :: i, ie, ierr, ii, is, isp1, j, je, jj, js, jsp1, k, mb, nb, p, q, &
                     zdim
           real(${rk}$) :: alpha, scaloc
           ! Local Arrays 
           integer(ilp) :: ipiv(ldz), jpiv(ldz)
           real(${rk}$) :: rhs(ldz), z(ldz,ldz)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           ierr = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>2 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSY2', -info )
              return
           end if
           ! determine block structure of a
           pq = 0
           p = 0
           i = 1
           10 continue
           if( i>m )go to 20
           p = p + 1
           iwork( p ) = i
           if( i==m )go to 20
           if( a( i+1, i )/=zero ) then
              i = i + 2
           else
              i = i + 1
           end if
           go to 10
           20 continue
           iwork( p+1 ) = m + 1
           ! determine block structure of b
           q = p + 1
           j = 1
           30 continue
           if( j>n )go to 40
           q = q + 1
           iwork( q ) = j
           if( j==n )go to 40
           if( b( j+1, j )/=zero ) then
              j = j + 2
           else
              j = j + 1
           end if
           go to 30
           40 continue
           iwork( q+1 ) = n + 1
           pq = p*( q-p-1 )
           if( notran ) then
              ! solve (i, j) - subsystem
                 ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                 ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
              ! for i = p, p - 1, ..., 1; j = 1, 2, ..., q
              scale = one
              scaloc = one
              loop_120: do j = p + 2, q
                 js = iwork( j )
                 jsp1 = js + 1
                 je = iwork( j+1 ) - 1
                 nb = je - js + 1
                 loop_110: do i = p, 1, -1
                    is = iwork( i )
                    isp1 = is + 1
                    ie = iwork( i+1 ) - 1
                    mb = ie - is + 1
                    zdim = mb*nb*2
                    if( ( mb==1 ) .and. ( nb==1 ) ) then
                       ! build a 2-by-2 system z * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = d( is, is )
                       z( 1, 2 ) = -b( js, js )
                       z( 2, 2 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = f( is, js )
                       ! solve z * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_${ri}$latdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       f( is, js ) = rhs( 2 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          alpha = -rhs( 1 )
                          call stdlib_${ri}$axpy( is-1, alpha, a( 1, is ), 1, c( 1, js ),1 )
                          call stdlib_${ri}$axpy( is-1, alpha, d( 1, is ), 1, f( 1, js ),1 )
                       end if
                       if( j<q ) then
                          call stdlib_${ri}$axpy( n-je, rhs( 2 ), b( js, je+1 ), ldb,c( is, je+1 ), &
                                    ldc )
                          call stdlib_${ri}$axpy( n-je, rhs( 2 ), e( js, je+1 ), lde,f( is, je+1 ), &
                                    ldf )
                       end if
                    else if( ( mb==1 ) .and. ( nb==2 ) ) then
                       ! build a 4-by-4 system z * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = zero
                       z( 3, 1 ) = d( is, is )
                       z( 4, 1 ) = zero
                       z( 1, 2 ) = zero
                       z( 2, 2 ) = a( is, is )
                       z( 3, 2 ) = zero
                       z( 4, 2 ) = d( is, is )
                       z( 1, 3 ) = -b( js, js )
                       z( 2, 3 ) = -b( js, jsp1 )
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = -e( js, jsp1 )
                       z( 1, 4 ) = -b( jsp1, js )
                       z( 2, 4 ) = -b( jsp1, jsp1 )
                       z( 3, 4 ) = zero
                       z( 4, 4 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( is, jsp1 )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( is, jsp1 )
                       ! solve z * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_${ri}$latdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( is, jsp1 ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( is, jsp1 ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_${ri}$ger( is-1, nb, -one, a( 1, is ), 1, rhs( 1 ),1, c( 1, js ),&
                                     ldc )
                          call stdlib_${ri}$ger( is-1, nb, -one, d( 1, is ), 1, rhs( 1 ),1, f( 1, js ),&
                                     ldf )
                       end if
                       if( j<q ) then
                          call stdlib_${ri}$axpy( n-je, rhs( 3 ), b( js, je+1 ), ldb,c( is, je+1 ), &
                                    ldc )
                          call stdlib_${ri}$axpy( n-je, rhs( 3 ), e( js, je+1 ), lde,f( is, je+1 ), &
                                    ldf )
                          call stdlib_${ri}$axpy( n-je, rhs( 4 ), b( jsp1, je+1 ), ldb,c( is, je+1 ), &
                                    ldc )
                          call stdlib_${ri}$axpy( n-je, rhs( 4 ), e( jsp1, je+1 ), lde,f( is, je+1 ), &
                                    ldf )
                       end if
                    else if( ( mb==2 ) .and. ( nb==1 ) ) then
                       ! build a 4-by-4 system z * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( isp1, is )
                       z( 3, 1 ) = d( is, is )
                       z( 4, 1 ) = zero
                       z( 1, 2 ) = a( is, isp1 )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 3, 2 ) = d( is, isp1 )
                       z( 4, 2 ) = d( isp1, isp1 )
                       z( 1, 3 ) = -b( js, js )
                       z( 2, 3 ) = zero
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = zero
                       z( 1, 4 ) = zero
                       z( 2, 4 ) = -b( js, js )
                       z( 3, 4 ) = zero
                       z( 4, 4 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( isp1, js )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( isp1, js )
                       ! solve z * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_${ri}$latdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( isp1, js ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( isp1, js ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_${ri}$gemv( 'N', is-1, mb, -one, a( 1, is ), lda,rhs( 1 ), 1, &
                                    one, c( 1, js ), 1 )
                          call stdlib_${ri}$gemv( 'N', is-1, mb, -one, d( 1, is ), ldd,rhs( 1 ), 1, &
                                    one, f( 1, js ), 1 )
                       end if
                       if( j<q ) then
                          call stdlib_${ri}$ger( mb, n-je, one, rhs( 3 ), 1,b( js, je+1 ), ldb, c( is, &
                                    je+1 ), ldc )
                          call stdlib_${ri}$ger( mb, n-je, one, rhs( 3 ), 1,e( js, je+1 ), lde, f( is, &
                                    je+1 ), ldf )
                       end if
                    else if( ( mb==2 ) .and. ( nb==2 ) ) then
                       ! build an 8-by-8 system z * x = rhs
                       call stdlib_${ri}$laset( 'F', ldz, ldz, zero, zero, z, ldz )
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( isp1, is )
                       z( 5, 1 ) = d( is, is )
                       z( 1, 2 ) = a( is, isp1 )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 5, 2 ) = d( is, isp1 )
                       z( 6, 2 ) = d( isp1, isp1 )
                       z( 3, 3 ) = a( is, is )
                       z( 4, 3 ) = a( isp1, is )
                       z( 7, 3 ) = d( is, is )
                       z( 3, 4 ) = a( is, isp1 )
                       z( 4, 4 ) = a( isp1, isp1 )
                       z( 7, 4 ) = d( is, isp1 )
                       z( 8, 4 ) = d( isp1, isp1 )
                       z( 1, 5 ) = -b( js, js )
                       z( 3, 5 ) = -b( js, jsp1 )
                       z( 5, 5 ) = -e( js, js )
                       z( 7, 5 ) = -e( js, jsp1 )
                       z( 2, 6 ) = -b( js, js )
                       z( 4, 6 ) = -b( js, jsp1 )
                       z( 6, 6 ) = -e( js, js )
                       z( 8, 6 ) = -e( js, jsp1 )
                       z( 1, 7 ) = -b( jsp1, js )
                       z( 3, 7 ) = -b( jsp1, jsp1 )
                       z( 7, 7 ) = -e( jsp1, jsp1 )
                       z( 2, 8 ) = -b( jsp1, js )
                       z( 4, 8 ) = -b( jsp1, jsp1 )
                       z( 8, 8 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_${ri}$copy( mb, c( is, js+jj ), 1, rhs( k ), 1 )
                          call stdlib_${ri}$copy( mb, f( is, js+jj ), 1, rhs( ii ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! solve z * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_${ri}$latdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_${ri}$copy( mb, rhs( k ), 1, c( is, js+jj ), 1 )
                          call stdlib_${ri}$copy( mb, rhs( ii ), 1, f( is, js+jj ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_${ri}$gemm( 'N', 'N', is-1, nb, mb, -one,a( 1, is ), lda, rhs( 1 &
                                    ), mb, one,c( 1, js ), ldc )
                          call stdlib_${ri}$gemm( 'N', 'N', is-1, nb, mb, -one,d( 1, is ), ldd, rhs( 1 &
                                    ), mb, one,f( 1, js ), ldf )
                       end if
                       if( j<q ) then
                          k = mb*nb + 1
                          call stdlib_${ri}$gemm( 'N', 'N', mb, n-je, nb, one, rhs( k ),mb, b( js, je+&
                                    1 ), ldb, one,c( is, je+1 ), ldc )
                          call stdlib_${ri}$gemm( 'N', 'N', mb, n-je, nb, one, rhs( k ),mb, e( js, je+&
                                    1 ), lde, one,f( is, je+1 ), ldf )
                       end if
                    end if
                 end do loop_110
              end do loop_120
           else
              ! solve (i, j) - subsystem
                   ! a(i, i)**t * r(i, j) + d(i, i)**t * l(j, j)  =  c(i, j)
                   ! r(i, i)  * b(j, j) + l(i, j)  * e(j, j)  = -f(i, j)
              ! for i = 1, 2, ..., p, j = q, q - 1, ..., 1
              scale = one
              scaloc = one
              loop_200: do i = 1, p
                 is = iwork( i )
                 isp1 = is + 1
                 ie = iwork ( i+1 ) - 1
                 mb = ie - is + 1
                 loop_190: do j = q, p + 2, -1
                    js = iwork( j )
                    jsp1 = js + 1
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    zdim = mb*nb*2
                    if( ( mb==1 ) .and. ( nb==1 ) ) then
                       ! build a 2-by-2 system z**t * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = -b( js, js )
                       z( 1, 2 ) = d( is, is )
                       z( 2, 2 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = f( is, js )
                       ! solve z**t * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       f( is, js ) = rhs( 2 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          alpha = rhs( 1 )
                          call stdlib_${ri}$axpy( js-1, alpha, b( 1, js ), 1, f( is, 1 ),ldf )
                          alpha = rhs( 2 )
                          call stdlib_${ri}$axpy( js-1, alpha, e( 1, js ), 1, f( is, 1 ),ldf )
                       end if
                       if( i<p ) then
                          alpha = -rhs( 1 )
                          call stdlib_${ri}$axpy( m-ie, alpha, a( is, ie+1 ), lda,c( ie+1, js ), 1 )
                                    
                          alpha = -rhs( 2 )
                          call stdlib_${ri}$axpy( m-ie, alpha, d( is, ie+1 ), ldd,c( ie+1, js ), 1 )
                                    
                       end if
                    else if( ( mb==1 ) .and. ( nb==2 ) ) then
                       ! build a 4-by-4 system z**t * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = zero
                       z( 3, 1 ) = -b( js, js )
                       z( 4, 1 ) = -b( jsp1, js )
                       z( 1, 2 ) = zero
                       z( 2, 2 ) = a( is, is )
                       z( 3, 2 ) = -b( js, jsp1 )
                       z( 4, 2 ) = -b( jsp1, jsp1 )
                       z( 1, 3 ) = d( is, is )
                       z( 2, 3 ) = zero
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = zero
                       z( 1, 4 ) = zero
                       z( 2, 4 ) = d( is, is )
                       z( 3, 4 ) = -e( js, jsp1 )
                       z( 4, 4 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( is, jsp1 )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( is, jsp1 )
                       ! solve z**t * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( is, jsp1 ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( is, jsp1 ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          call stdlib_${ri}$axpy( js-1, rhs( 1 ), b( 1, js ), 1,f( is, 1 ), ldf )
                                    
                          call stdlib_${ri}$axpy( js-1, rhs( 2 ), b( 1, jsp1 ), 1,f( is, 1 ), ldf )
                                    
                          call stdlib_${ri}$axpy( js-1, rhs( 3 ), e( 1, js ), 1,f( is, 1 ), ldf )
                                    
                          call stdlib_${ri}$axpy( js-1, rhs( 4 ), e( 1, jsp1 ), 1,f( is, 1 ), ldf )
                                    
                       end if
                       if( i<p ) then
                          call stdlib_${ri}$ger( m-ie, nb, -one, a( is, ie+1 ), lda,rhs( 1 ), 1, c( ie+&
                                    1, js ), ldc )
                          call stdlib_${ri}$ger( m-ie, nb, -one, d( is, ie+1 ), ldd,rhs( 3 ), 1, c( ie+&
                                    1, js ), ldc )
                       end if
                    else if( ( mb==2 ) .and. ( nb==1 ) ) then
                       ! build a 4-by-4 system z**t * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( is, isp1 )
                       z( 3, 1 ) = -b( js, js )
                       z( 4, 1 ) = zero
                       z( 1, 2 ) = a( isp1, is )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 3, 2 ) = zero
                       z( 4, 2 ) = -b( js, js )
                       z( 1, 3 ) = d( is, is )
                       z( 2, 3 ) = d( is, isp1 )
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = zero
                       z( 1, 4 ) = zero
                       z( 2, 4 ) = d( isp1, isp1 )
                       z( 3, 4 ) = zero
                       z( 4, 4 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( isp1, js )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( isp1, js )
                       ! solve z**t * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( isp1, js ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( isp1, js ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          call stdlib_${ri}$ger( mb, js-1, one, rhs( 1 ), 1, b( 1, js ),1, f( is, 1 ), &
                                    ldf )
                          call stdlib_${ri}$ger( mb, js-1, one, rhs( 3 ), 1, e( 1, js ),1, f( is, 1 ), &
                                    ldf )
                       end if
                       if( i<p ) then
                          call stdlib_${ri}$gemv( 'T', mb, m-ie, -one, a( is, ie+1 ),lda, rhs( 1 ), 1, &
                                    one, c( ie+1, js ),1 )
                          call stdlib_${ri}$gemv( 'T', mb, m-ie, -one, d( is, ie+1 ),ldd, rhs( 3 ), 1, &
                                    one, c( ie+1, js ),1 )
                       end if
                    else if( ( mb==2 ) .and. ( nb==2 ) ) then
                       ! build an 8-by-8 system z**t * x = rhs
                       call stdlib_${ri}$laset( 'F', ldz, ldz, zero, zero, z, ldz )
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( is, isp1 )
                       z( 5, 1 ) = -b( js, js )
                       z( 7, 1 ) = -b( jsp1, js )
                       z( 1, 2 ) = a( isp1, is )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 6, 2 ) = -b( js, js )
                       z( 8, 2 ) = -b( jsp1, js )
                       z( 3, 3 ) = a( is, is )
                       z( 4, 3 ) = a( is, isp1 )
                       z( 5, 3 ) = -b( js, jsp1 )
                       z( 7, 3 ) = -b( jsp1, jsp1 )
                       z( 3, 4 ) = a( isp1, is )
                       z( 4, 4 ) = a( isp1, isp1 )
                       z( 6, 4 ) = -b( js, jsp1 )
                       z( 8, 4 ) = -b( jsp1, jsp1 )
                       z( 1, 5 ) = d( is, is )
                       z( 2, 5 ) = d( is, isp1 )
                       z( 5, 5 ) = -e( js, js )
                       z( 2, 6 ) = d( isp1, isp1 )
                       z( 6, 6 ) = -e( js, js )
                       z( 3, 7 ) = d( is, is )
                       z( 4, 7 ) = d( is, isp1 )
                       z( 5, 7 ) = -e( js, jsp1 )
                       z( 7, 7 ) = -e( jsp1, jsp1 )
                       z( 4, 8 ) = d( isp1, isp1 )
                       z( 6, 8 ) = -e( js, jsp1 )
                       z( 8, 8 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_${ri}$copy( mb, c( is, js+jj ), 1, rhs( k ), 1 )
                          call stdlib_${ri}$copy( mb, f( is, js+jj ), 1, rhs( ii ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! solve z**t * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_${ri}$copy( mb, rhs( k ), 1, c( is, js+jj ), 1 )
                          call stdlib_${ri}$copy( mb, rhs( ii ), 1, f( is, js+jj ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          call stdlib_${ri}$gemm( 'N', 'T', mb, js-1, nb, one,c( is, js ), ldc, b( 1, &
                                    js ), ldb, one,f( is, 1 ), ldf )
                          call stdlib_${ri}$gemm( 'N', 'T', mb, js-1, nb, one,f( is, js ), ldf, e( 1, &
                                    js ), lde, one,f( is, 1 ), ldf )
                       end if
                       if( i<p ) then
                          call stdlib_${ri}$gemm( 'T', 'N', m-ie, nb, mb, -one,a( is, ie+1 ), lda, c( &
                                    is, js ), ldc,one, c( ie+1, js ), ldc )
                          call stdlib_${ri}$gemm( 'T', 'N', m-ie, nb, mb, -one,d( is, ie+1 ), ldd, f( &
                                    is, js ), ldf,one, c( ie+1, js ), ldc )
                       end if
                    end if
                 end do loop_190
              end do loop_200
           end if
           return
     end subroutine stdlib_${ri}$tgsy2

#:endif
#:endfor

     module pure subroutine stdlib_ctgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! CTGSY2 solves the generalized Sylvester equation
     !! A * R - L * B = scale *  C               (1)
     !! D * R - L * E = scale * F
     !! using Level 1 and 2 BLAS, where R and L are unknown M-by-N matrices,
     !! (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
     !! N-by-N and M-by-N, respectively. A, B, D and E are upper triangular
     !! (i.e., (A,D) and (B,E) in generalized Schur form).
     !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
     !! scaling factor chosen to avoid overflow.
     !! In matrix notation solving equation (1) corresponds to solve
     !! Zx = scale * b, where Z is defined as
     !! Z = [ kron(In, A)  -kron(B**H, Im) ]             (2)
     !! [ kron(In, D)  -kron(E**H, Im) ],
     !! Ik is the identity matrix of size k and X**H is the transpose of X.
     !! kron(X, Y) is the Kronecker product between the matrices X and Y.
     !! If TRANS = 'C', y in the conjugate transposed system Z**H*y = scale*b
     !! is solved for, which is equivalent to solve for R and L in
     !! A**H * R  + D**H * L   = scale * C           (3)
     !! R  * B**H + L  * E**H  = scale * -F
     !! This case is used to compute an estimate of Dif[(A, D), (B, E)] =
     !! = sigma_min(Z) using reverse communication with CLACON.
     !! CTGSY2 also (IJOB >= 1) contributes to the computation in CTGSYL
     !! of an upper bound on the separation between to matrix pairs. Then
     !! the input (A, D), (B, E) are sub-pencils of two matrix pairs in
     !! CTGSYL.
               ldf, scale, rdsum, rdscal,info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, m, n
           integer(ilp), intent(out) :: info
           real(sp), intent(inout) :: rdscal, rdsum
           real(sp), intent(out) :: scale
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           complex(sp), intent(inout) :: c(ldc,*), f(ldf,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: ldz = 2
           
           
           ! Local Scalars 
           logical(lk) :: notran
           integer(ilp) :: i, ierr, j, k
           real(sp) :: scaloc
           complex(sp) :: alpha
           ! Local Arrays 
           integer(ilp) :: ipiv(ldz), jpiv(ldz)
           complex(sp) :: rhs(ldz), z(ldz,ldz)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           ierr = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>2 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGSY2', -info )
              return
           end if
           if( notran ) then
              ! solve (i, j) - system
                 ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                 ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
              ! for i = m, m - 1, ..., 1; j = 1, 2, ..., n
              scale = one
              scaloc = one
              loop_30: do j = 1, n
                 loop_20: do i = m, 1, -1
                    ! build 2 by 2 system
                    z( 1, 1 ) = a( i, i )
                    z( 2, 1 ) = d( i, i )
                    z( 1, 2 ) = -b( j, j )
                    z( 2, 2 ) = -e( j, j )
                    ! set up right hand side(s)
                    rhs( 1 ) = c( i, j )
                    rhs( 2 ) = f( i, j )
                    ! solve z * x = rhs
                    call stdlib_cgetc2( ldz, z, ldz, ipiv, jpiv, ierr )
                    if( ierr>0 )info = ierr
                    if( ijob==0 ) then
                       call stdlib_cgesc2( ldz, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), c( 1, k ),1 )
                                       
                             call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), f( 1, k ),1 )
                                       
                          end do
                          scale = scale*scaloc
                       end if
                    else
                       call stdlib_clatdf( ijob, ldz, z, ldz, rhs, rdsum, rdscal,ipiv, jpiv )
                                 
                    end if
                    ! unpack solution vector(s)
                    c( i, j ) = rhs( 1 )
                    f( i, j ) = rhs( 2 )
                    ! substitute r(i, j) and l(i, j) into remaining equation.
                    if( i>1 ) then
                       alpha = -rhs( 1 )
                       call stdlib_caxpy( i-1, alpha, a( 1, i ), 1, c( 1, j ), 1 )
                       call stdlib_caxpy( i-1, alpha, d( 1, i ), 1, f( 1, j ), 1 )
                    end if
                    if( j<n ) then
                       call stdlib_caxpy( n-j, rhs( 2 ), b( j, j+1 ), ldb,c( i, j+1 ), ldc )
                                 
                       call stdlib_caxpy( n-j, rhs( 2 ), e( j, j+1 ), lde,f( i, j+1 ), ldf )
                                 
                    end if
                 end do loop_20
              end do loop_30
           else
              ! solve transposed (i, j) - system:
                 ! a(i, i)**h * r(i, j) + d(i, i)**h * l(j, j) = c(i, j)
                 ! r(i, i) * b(j, j) + l(i, j) * e(j, j)   = -f(i, j)
              ! for i = 1, 2, ..., m, j = n, n - 1, ..., 1
              scale = one
              scaloc = one
              loop_80: do i = 1, m
                 loop_70: do j = n, 1, -1
                    ! build 2 by 2 system z**h
                    z( 1, 1 ) = conjg( a( i, i ) )
                    z( 2, 1 ) = -conjg( b( j, j ) )
                    z( 1, 2 ) = conjg( d( i, i ) )
                    z( 2, 2 ) = -conjg( e( j, j ) )
                    ! set up right hand side(s)
                    rhs( 1 ) = c( i, j )
                    rhs( 2 ) = f( i, j )
                    ! solve z**h * x = rhs
                    call stdlib_cgetc2( ldz, z, ldz, ipiv, jpiv, ierr )
                    if( ierr>0 )info = ierr
                    call stdlib_cgesc2( ldz, z, ldz, rhs, ipiv, jpiv, scaloc )
                    if( scaloc/=one ) then
                       do k = 1, n
                          call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), c( 1, k ),1 )
                                    
                          call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), f( 1, k ),1 )
                                    
                       end do
                       scale = scale*scaloc
                    end if
                    ! unpack solution vector(s)
                    c( i, j ) = rhs( 1 )
                    f( i, j ) = rhs( 2 )
                    ! substitute r(i, j) and l(i, j) into remaining equation.
                    do k = 1, j - 1
                       f( i, k ) = f( i, k ) + rhs( 1 )*conjg( b( k, j ) ) +rhs( 2 )*conjg( e( k, &
                                 j ) )
                    end do
                    do k = i + 1, m
                       c( k, j ) = c( k, j ) - conjg( a( i, k ) )*rhs( 1 ) -conjg( d( i, k ) )&
                                 *rhs( 2 )
                    end do
                 end do loop_70
              end do loop_80
           end if
           return
     end subroutine stdlib_ctgsy2

     module pure subroutine stdlib_ztgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! ZTGSY2 solves the generalized Sylvester equation
     !! A * R - L * B = scale * C               (1)
     !! D * R - L * E = scale * F
     !! using Level 1 and 2 BLAS, where R and L are unknown M-by-N matrices,
     !! (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
     !! N-by-N and M-by-N, respectively. A, B, D and E are upper triangular
     !! (i.e., (A,D) and (B,E) in generalized Schur form).
     !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
     !! scaling factor chosen to avoid overflow.
     !! In matrix notation solving equation (1) corresponds to solve
     !! Zx = scale * b, where Z is defined as
     !! Z = [ kron(In, A)  -kron(B**H, Im) ]             (2)
     !! [ kron(In, D)  -kron(E**H, Im) ],
     !! Ik is the identity matrix of size k and X**H is the conjuguate transpose of X.
     !! kron(X, Y) is the Kronecker product between the matrices X and Y.
     !! If TRANS = 'C', y in the conjugate transposed system Z**H*y = scale*b
     !! is solved for, which is equivalent to solve for R and L in
     !! A**H * R  + D**H * L   = scale * C           (3)
     !! R  * B**H + L  * E**H  = scale * -F
     !! This case is used to compute an estimate of Dif[(A, D), (B, E)] =
     !! = sigma_min(Z) using reverse communication with ZLACON.
     !! ZTGSY2 also (IJOB >= 1) contributes to the computation in ZTGSYL
     !! of an upper bound on the separation between to matrix pairs. Then
     !! the input (A, D), (B, E) are sub-pencils of two matrix pairs in
     !! ZTGSYL.
               ldf, scale, rdsum, rdscal,info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, m, n
           integer(ilp), intent(out) :: info
           real(dp), intent(inout) :: rdscal, rdsum
           real(dp), intent(out) :: scale
           ! Array Arguments 
           complex(dp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           complex(dp), intent(inout) :: c(ldc,*), f(ldf,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: ldz = 2
           
           
           ! Local Scalars 
           logical(lk) :: notran
           integer(ilp) :: i, ierr, j, k
           real(dp) :: scaloc
           complex(dp) :: alpha
           ! Local Arrays 
           integer(ilp) :: ipiv(ldz), jpiv(ldz)
           complex(dp) :: rhs(ldz), z(ldz,ldz)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           ierr = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>2 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGSY2', -info )
              return
           end if
           if( notran ) then
              ! solve (i, j) - system
                 ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                 ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
              ! for i = m, m - 1, ..., 1; j = 1, 2, ..., n
              scale = one
              scaloc = one
              loop_30: do j = 1, n
                 loop_20: do i = m, 1, -1
                    ! build 2 by 2 system
                    z( 1, 1 ) = a( i, i )
                    z( 2, 1 ) = d( i, i )
                    z( 1, 2 ) = -b( j, j )
                    z( 2, 2 ) = -e( j, j )
                    ! set up right hand side(s)
                    rhs( 1 ) = c( i, j )
                    rhs( 2 ) = f( i, j )
                    ! solve z * x = rhs
                    call stdlib_zgetc2( ldz, z, ldz, ipiv, jpiv, ierr )
                    if( ierr>0 )info = ierr
                    if( ijob==0 ) then
                       call stdlib_zgesc2( ldz, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp),c( 1, k ), 1 )
                                       
                             call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp),f( 1, k ), 1 )
                                       
                          end do
                          scale = scale*scaloc
                       end if
                    else
                       call stdlib_zlatdf( ijob, ldz, z, ldz, rhs, rdsum, rdscal,ipiv, jpiv )
                                 
                    end if
                    ! unpack solution vector(s)
                    c( i, j ) = rhs( 1 )
                    f( i, j ) = rhs( 2 )
                    ! substitute r(i, j) and l(i, j) into remaining equation.
                    if( i>1 ) then
                       alpha = -rhs( 1 )
                       call stdlib_zaxpy( i-1, alpha, a( 1, i ), 1, c( 1, j ), 1 )
                       call stdlib_zaxpy( i-1, alpha, d( 1, i ), 1, f( 1, j ), 1 )
                    end if
                    if( j<n ) then
                       call stdlib_zaxpy( n-j, rhs( 2 ), b( j, j+1 ), ldb,c( i, j+1 ), ldc )
                                 
                       call stdlib_zaxpy( n-j, rhs( 2 ), e( j, j+1 ), lde,f( i, j+1 ), ldf )
                                 
                    end if
                 end do loop_20
              end do loop_30
           else
              ! solve transposed (i, j) - system:
                 ! a(i, i)**h * r(i, j) + d(i, i)**h * l(j, j) = c(i, j)
                 ! r(i, i) * b(j, j) + l(i, j) * e(j, j)   = -f(i, j)
              ! for i = 1, 2, ..., m, j = n, n - 1, ..., 1
              scale = one
              scaloc = one
              loop_80: do i = 1, m
                 loop_70: do j = n, 1, -1
                    ! build 2 by 2 system z**h
                    z( 1, 1 ) = conjg( a( i, i ) )
                    z( 2, 1 ) = -conjg( b( j, j ) )
                    z( 1, 2 ) = conjg( d( i, i ) )
                    z( 2, 2 ) = -conjg( e( j, j ) )
                    ! set up right hand side(s)
                    rhs( 1 ) = c( i, j )
                    rhs( 2 ) = f( i, j )
                    ! solve z**h * x = rhs
                    call stdlib_zgetc2( ldz, z, ldz, ipiv, jpiv, ierr )
                    if( ierr>0 )info = ierr
                    call stdlib_zgesc2( ldz, z, ldz, rhs, ipiv, jpiv, scaloc )
                    if( scaloc/=one ) then
                       do k = 1, n
                          call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp), c( 1, k ),1 )
                                    
                          call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp), f( 1, k ),1 )
                                    
                       end do
                       scale = scale*scaloc
                    end if
                    ! unpack solution vector(s)
                    c( i, j ) = rhs( 1 )
                    f( i, j ) = rhs( 2 )
                    ! substitute r(i, j) and l(i, j) into remaining equation.
                    do k = 1, j - 1
                       f( i, k ) = f( i, k ) + rhs( 1 )*conjg( b( k, j ) ) +rhs( 2 )*conjg( e( k, &
                                 j ) )
                    end do
                    do k = i + 1, m
                       c( k, j ) = c( k, j ) - conjg( a( i, k ) )*rhs( 1 ) -conjg( d( i, k ) )&
                                 *rhs( 2 )
                    end do
                 end do loop_70
              end do loop_80
           end if
           return
     end subroutine stdlib_ztgsy2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$tgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! ZTGSY2: solves the generalized Sylvester equation
     !! A * R - L * B = scale * C               (1)
     !! D * R - L * E = scale * F
     !! using Level 1 and 2 BLAS, where R and L are unknown M-by-N matrices,
     !! (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
     !! N-by-N and M-by-N, respectively. A, B, D and E are upper triangular
     !! (i.e., (A,D) and (B,E) in generalized Schur form).
     !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
     !! scaling factor chosen to avoid overflow.
     !! In matrix notation solving equation (1) corresponds to solve
     !! Zx = scale * b, where Z is defined as
     !! Z = [ kron(In, A)  -kron(B**H, Im) ]             (2)
     !! [ kron(In, D)  -kron(E**H, Im) ],
     !! Ik is the identity matrix of size k and X**H is the conjuguate transpose of X.
     !! kron(X, Y) is the Kronecker product between the matrices X and Y.
     !! If TRANS = 'C', y in the conjugate transposed system Z**H*y = scale*b
     !! is solved for, which is equivalent to solve for R and L in
     !! A**H * R  + D**H * L   = scale * C           (3)
     !! R  * B**H + L  * E**H  = scale * -F
     !! This case is used to compute an estimate of Dif[(A, D), (B, E)] =
     !! = sigma_min(Z) using reverse communication with ZLACON.
     !! ZTGSY2 also (IJOB >= 1) contributes to the computation in ZTGSYL
     !! of an upper bound on the separation between to matrix pairs. Then
     !! the input (A, D), (B, E) are sub-pencils of two matrix pairs in
     !! ZTGSYL.
               ldf, scale, rdsum, rdscal,info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, m, n
           integer(ilp), intent(out) :: info
           real(${ck}$), intent(inout) :: rdscal, rdsum
           real(${ck}$), intent(out) :: scale
           ! Array Arguments 
           complex(${ck}$), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           complex(${ck}$), intent(inout) :: c(ldc,*), f(ldf,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: ldz = 2
           
           
           ! Local Scalars 
           logical(lk) :: notran
           integer(ilp) :: i, ierr, j, k
           real(${ck}$) :: scaloc
           complex(${ck}$) :: alpha
           ! Local Arrays 
           integer(ilp) :: ipiv(ldz), jpiv(ldz)
           complex(${ck}$) :: rhs(ldz), z(ldz,ldz)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           ierr = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>2 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGSY2', -info )
              return
           end if
           if( notran ) then
              ! solve (i, j) - system
                 ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                 ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
              ! for i = m, m - 1, ..., 1; j = 1, 2, ..., n
              scale = one
              scaloc = one
              loop_30: do j = 1, n
                 loop_20: do i = m, 1, -1
                    ! build 2 by 2 system
                    z( 1, 1 ) = a( i, i )
                    z( 2, 1 ) = d( i, i )
                    z( 1, 2 ) = -b( j, j )
                    z( 2, 2 ) = -e( j, j )
                    ! set up right hand side(s)
                    rhs( 1 ) = c( i, j )
                    rhs( 2 ) = f( i, j )
                    ! solve z * x = rhs
                    call stdlib_${ci}$getc2( ldz, z, ldz, ipiv, jpiv, ierr )
                    if( ierr>0 )info = ierr
                    if( ijob==0 ) then
                       call stdlib_${ci}$gesc2( ldz, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$),c( 1, k ), 1 )
                                       
                             call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$),f( 1, k ), 1 )
                                       
                          end do
                          scale = scale*scaloc
                       end if
                    else
                       call stdlib_${ci}$latdf( ijob, ldz, z, ldz, rhs, rdsum, rdscal,ipiv, jpiv )
                                 
                    end if
                    ! unpack solution vector(s)
                    c( i, j ) = rhs( 1 )
                    f( i, j ) = rhs( 2 )
                    ! substitute r(i, j) and l(i, j) into remaining equation.
                    if( i>1 ) then
                       alpha = -rhs( 1 )
                       call stdlib_${ci}$axpy( i-1, alpha, a( 1, i ), 1, c( 1, j ), 1 )
                       call stdlib_${ci}$axpy( i-1, alpha, d( 1, i ), 1, f( 1, j ), 1 )
                    end if
                    if( j<n ) then
                       call stdlib_${ci}$axpy( n-j, rhs( 2 ), b( j, j+1 ), ldb,c( i, j+1 ), ldc )
                                 
                       call stdlib_${ci}$axpy( n-j, rhs( 2 ), e( j, j+1 ), lde,f( i, j+1 ), ldf )
                                 
                    end if
                 end do loop_20
              end do loop_30
           else
              ! solve transposed (i, j) - system:
                 ! a(i, i)**h * r(i, j) + d(i, i)**h * l(j, j) = c(i, j)
                 ! r(i, i) * b(j, j) + l(i, j) * e(j, j)   = -f(i, j)
              ! for i = 1, 2, ..., m, j = n, n - 1, ..., 1
              scale = one
              scaloc = one
              loop_80: do i = 1, m
                 loop_70: do j = n, 1, -1
                    ! build 2 by 2 system z**h
                    z( 1, 1 ) = conjg( a( i, i ) )
                    z( 2, 1 ) = -conjg( b( j, j ) )
                    z( 1, 2 ) = conjg( d( i, i ) )
                    z( 2, 2 ) = -conjg( e( j, j ) )
                    ! set up right hand side(s)
                    rhs( 1 ) = c( i, j )
                    rhs( 2 ) = f( i, j )
                    ! solve z**h * x = rhs
                    call stdlib_${ci}$getc2( ldz, z, ldz, ipiv, jpiv, ierr )
                    if( ierr>0 )info = ierr
                    call stdlib_${ci}$gesc2( ldz, z, ldz, rhs, ipiv, jpiv, scaloc )
                    if( scaloc/=one ) then
                       do k = 1, n
                          call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$), c( 1, k ),1 )
                                    
                          call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$), f( 1, k ),1 )
                                    
                       end do
                       scale = scale*scaloc
                    end if
                    ! unpack solution vector(s)
                    c( i, j ) = rhs( 1 )
                    f( i, j ) = rhs( 2 )
                    ! substitute r(i, j) and l(i, j) into remaining equation.
                    do k = 1, j - 1
                       f( i, k ) = f( i, k ) + rhs( 1 )*conjg( b( k, j ) ) +rhs( 2 )*conjg( e( k, &
                                 j ) )
                    end do
                    do k = i + 1, m
                       c( k, j ) = c( k, j ) - conjg( a( i, k ) )*rhs( 1 ) -conjg( d( i, k ) )&
                                 *rhs( 2 )
                    end do
                 end do loop_70
              end do loop_80
           end if
           return
     end subroutine stdlib_${ci}$tgsy2

#:endif
#:endfor





     module recursive subroutine stdlib_slaqz3( ilschur, ilq, ilz, n, ilo, ihi, nw,a, lda, b, ldb, q, &
     !! SLAQZ3 performs AED
               ldq, z, ldz, ns,nd, alphar, alphai, beta, qc, ldqc,zc, ldzc, work, lwork, rec, info )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(ilp), intent( in ) :: n, ilo, ihi, nw, lda, ldb, ldq, ldz,ldqc, ldzc, lwork, &
                     rec
           real(sp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq, * ),z( ldz, * ), alphar(&
                      * ), alphai( * ), beta( * )
           integer(ilp), intent( out ) :: ns, nd, info
           real(sp), intent(inout) :: qc(ldqc,*), zc(ldzc,*)
           real(sp), intent(out) :: work(*)
           ! ================================================================
           ! local scalars
           logical(lk) :: bulge
           integer(ilp) :: jw, kwtop, kwbot, istopm, istartm, k, k2, stgexc_info, ifst, ilst, &
                     lworkreq, qz_small_info
           real(sp) :: s, smlnum, ulp, safmin, safmax, c1, s1, temp
           info = 0
           ! set up deflation window
           jw = min( nw, ihi-ilo+1 )
           kwtop = ihi-jw+1
           if ( kwtop == ilo ) then
              s = zero
           else
              s = a( kwtop, kwtop-1 )
           end if
           ! determine required workspace
           ifst = 1
           ilst = jw
           call stdlib_stgexc( .true., .true., jw, a, lda, b, ldb, qc, ldqc, zc,ldzc, ifst, ilst, &
                     work, -1, stgexc_info )
           lworkreq = int( work( 1 ),KIND=ilp)
           call stdlib_slaqz0( 'S', 'V', 'V', jw, 1, jw, a( kwtop, kwtop ), lda,b( kwtop, kwtop ),&
                      ldb, alphar, alphai, beta, qc,ldqc, zc, ldzc, work, -1, rec+1, qz_small_info )
           lworkreq = max( lworkreq, int( work( 1 ),KIND=ilp)+2*jw**2 )
           lworkreq = max( lworkreq, n*nw, 2*nw**2+n )
           if ( lwork ==-1 ) then
              ! workspace query, quick return
              work( 1 ) = lworkreq
              return
           else if ( lwork < lworkreq ) then
              info = -26
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SLAQZ3', -info )
              return
           end if
           ! get machine constants
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=sp)/ulp )
           if ( ihi == kwtop ) then
              ! 1 by 1 deflation window, just try a regular deflation
              alphar( kwtop ) = a( kwtop, kwtop )
              alphai( kwtop ) = zero
              beta( kwtop ) = b( kwtop, kwtop )
              ns = 1
              nd = 0
              if ( abs( s ) <= max( smlnum, ulp*abs( a( kwtop,kwtop ) ) ) ) then
                 ns = 0
                 nd = 1
                 if ( kwtop > ilo ) then
                    a( kwtop, kwtop-1 ) = zero
                 end if
              end if
           end if
           ! store window in case of convergence failure
           call stdlib_slacpy( 'ALL', jw, jw, a( kwtop, kwtop ), lda, work, jw )
           call stdlib_slacpy( 'ALL', jw, jw, b( kwtop, kwtop ), ldb, work( jw**2+1 ), jw )
                     
           ! transform window to real schur form
           call stdlib_slaset( 'FULL', jw, jw, zero, one, qc, ldqc )
           call stdlib_slaset( 'FULL', jw, jw, zero, one, zc, ldzc )
           call stdlib_slaqz0( 'S', 'V', 'V', jw, 1, jw, a( kwtop, kwtop ), lda,b( kwtop, kwtop ),&
            ldb, alphar, alphai, beta, qc,ldqc, zc, ldzc, work( 2*jw**2+1 ), lwork-2*jw**2,rec+1, &
                      qz_small_info )
           if( qz_small_info /= 0 ) then
              ! convergence failure, restore the window and exit
              nd = 0
              ns = jw-qz_small_info
              call stdlib_slacpy( 'ALL', jw, jw, work, jw, a( kwtop, kwtop ), lda )
              call stdlib_slacpy( 'ALL', jw, jw, work( jw**2+1 ), jw, b( kwtop,kwtop ), ldb )
                        
              return
           end if
           ! deflation detection loop
           if ( kwtop == ilo .or. s == zero ) then
              kwbot = kwtop-1
           else
              kwbot = ihi
              k = 1
              k2 = 1
              do while ( k <= jw )
                 bulge = .false.
                 if ( kwbot-kwtop+1 >= 2 ) then
                    bulge = a( kwbot, kwbot-1 ) /= zero
                 end if
                 if ( bulge ) then
                    ! try to deflate complex conjugate eigenvalue pair
                    temp = abs( a( kwbot, kwbot ) )+sqrt( abs( a( kwbot,kwbot-1 ) ) )*sqrt( abs( &
                              a( kwbot-1, kwbot ) ) )
                    if( temp == zero )then
                       temp = abs( s )
                    end if
                    if ( max( abs( s*qc( 1, kwbot-kwtop ) ), abs( s*qc( 1,kwbot-kwtop+1 ) ) ) <= &
                              max( smlnum,ulp*temp ) ) then
                       ! deflatable
                       kwbot = kwbot-2
                    else
                       ! not deflatable, move out of the way
                       ifst = kwbot-kwtop+1
                       ilst = k2
                       call stdlib_stgexc( .true., .true., jw, a( kwtop, kwtop ),lda, b( kwtop, &
                       kwtop ), ldb, qc, ldqc,zc, ldzc, ifst, ilst, work, lwork,stgexc_info )
                                 
                       k2 = k2+2
                    end if
                    k = k+2
                 else
                    ! try to deflate real eigenvalue
                    temp = abs( a( kwbot, kwbot ) )
                    if( temp == zero ) then
                       temp = abs( s )
                    end if
                    if ( ( abs( s*qc( 1, kwbot-kwtop+1 ) ) ) <= max( ulp*temp, smlnum ) ) &
                              then
                       ! deflatable
                       kwbot = kwbot-1
                    else
                       ! not deflatable, move out of the way
                       ifst = kwbot-kwtop+1
                       ilst = k2
                       call stdlib_stgexc( .true., .true., jw, a( kwtop, kwtop ),lda, b( kwtop, &
                       kwtop ), ldb, qc, ldqc,zc, ldzc, ifst, ilst, work, lwork,stgexc_info )
                                 
                       k2 = k2+1
                    end if
                    k = k+1
                 end if
              end do
           end if
           ! store eigenvalues
           nd = ihi-kwbot
           ns = jw-nd
           k = kwtop
           do while ( k <= ihi )
              bulge = .false.
              if ( k < ihi ) then
                 if ( a( k+1, k ) /= zero ) then
                    bulge = .true.
                 end if
              end if
              if ( bulge ) then
                 ! 2x2 eigenvalue block
                 call stdlib_slag2( a( k, k ), lda, b( k, k ), ldb, safmin,beta( k ), beta( k+1 ),&
                            alphar( k ),alphar( k+1 ), alphai( k ) )
                 alphai( k+1 ) = -alphai( k )
                 k = k+2
              else
                 ! 1x1 eigenvalue block
                 alphar( k ) = a( k, k )
                 alphai( k ) = zero
                 beta( k ) = b( k, k )
                 k = k+1
              end if
           end do
           if ( kwtop /= ilo .and. s /= zero ) then
              ! reflect spike back, this will create optimally packed bulges
              a( kwtop:kwbot, kwtop-1 ) = a( kwtop, kwtop-1 )*qc( 1,1:jw-nd )
              do k = kwbot-1, kwtop, -1
                 call stdlib_slartg( a( k, kwtop-1 ), a( k+1, kwtop-1 ), c1, s1,temp )
                 a( k, kwtop-1 ) = temp
                 a( k+1, kwtop-1 ) = zero
                 k2 = max( kwtop, k-1 )
                 call stdlib_srot( ihi-k2+1, a( k, k2 ), lda, a( k+1, k2 ), lda, c1,s1 )
                 call stdlib_srot( ihi-( k-1 )+1, b( k, k-1 ), ldb, b( k+1, k-1 ),ldb, c1, s1 )
                           
                 call stdlib_srot( jw, qc( 1, k-kwtop+1 ), 1, qc( 1, k+1-kwtop+1 ),1, c1, s1 )
                           
              end do
              ! chase bulges down
              istartm = kwtop
              istopm = ihi
              k = kwbot-1
              do while ( k >= kwtop )
                 if ( ( k >= kwtop+1 ) .and. a( k+1, k-1 ) /= zero ) then
                    ! move double pole block down and remove it
                    do k2 = k-1, kwbot-2
                       call stdlib_slaqz2( .true., .true., k2, kwtop, kwtop+jw-1,kwbot, a, lda, b,&
                                  ldb, jw, kwtop, qc,ldqc, jw, kwtop, zc, ldzc )
                    end do
                    k = k-2
                 else
                    ! k points to single shift
                    do k2 = k, kwbot-2
                       ! move shift down
                       call stdlib_slartg( b( k2+1, k2+1 ), b( k2+1, k2 ), c1, s1,temp )
                       b( k2+1, k2+1 ) = temp
                       b( k2+1, k2 ) = zero
                       call stdlib_srot( k2+2-istartm+1, a( istartm, k2+1 ), 1,a( istartm, k2 ), &
                                 1, c1, s1 )
                       call stdlib_srot( k2-istartm+1, b( istartm, k2+1 ), 1,b( istartm, k2 ), 1, &
                                 c1, s1 )
                       call stdlib_srot( jw, zc( 1, k2+1-kwtop+1 ), 1, zc( 1,k2-kwtop+1 ), 1, c1, &
                                 s1 )
                       call stdlib_slartg( a( k2+1, k2 ), a( k2+2, k2 ), c1, s1,temp )
                       a( k2+1, k2 ) = temp
                       a( k2+2, k2 ) = zero
                       call stdlib_srot( istopm-k2, a( k2+1, k2+1 ), lda, a( k2+2,k2+1 ), lda, c1,&
                                  s1 )
                       call stdlib_srot( istopm-k2, b( k2+1, k2+1 ), ldb, b( k2+2,k2+1 ), ldb, c1,&
                                  s1 )
                       call stdlib_srot( jw, qc( 1, k2+1-kwtop+1 ), 1, qc( 1,k2+2-kwtop+1 ), 1, &
                                 c1, s1 )
                    end do
                    ! remove the shift
                    call stdlib_slartg( b( kwbot, kwbot ), b( kwbot, kwbot-1 ), c1,s1, temp )
                              
                    b( kwbot, kwbot ) = temp
                    b( kwbot, kwbot-1 ) = zero
                    call stdlib_srot( kwbot-istartm, b( istartm, kwbot ), 1,b( istartm, kwbot-1 ),&
                               1, c1, s1 )
                    call stdlib_srot( kwbot-istartm+1, a( istartm, kwbot ), 1,a( istartm, kwbot-1 &
                              ), 1, c1, s1 )
                    call stdlib_srot( jw, zc( 1, kwbot-kwtop+1 ), 1, zc( 1,kwbot-1-kwtop+1 ), 1, &
                              c1, s1 )
                    k = k-1
                 end if
              end do
           end if
           ! apply qc and zc to rest of the matrix
           if ( ilschur ) then
              istartm = 1
              istopm = n
           else
              istartm = ilo
              istopm = ihi
           end if
           if ( istopm-ihi > 0 ) then
              call stdlib_sgemm( 'T', 'N', jw, istopm-ihi, jw, one, qc, ldqc,a( kwtop, ihi+1 ), &
                        lda, zero, work, jw )
              call stdlib_slacpy( 'ALL', jw, istopm-ihi, work, jw, a( kwtop,ihi+1 ), lda )
              call stdlib_sgemm( 'T', 'N', jw, istopm-ihi, jw, one, qc, ldqc,b( kwtop, ihi+1 ), &
                        ldb, zero, work, jw )
              call stdlib_slacpy( 'ALL', jw, istopm-ihi, work, jw, b( kwtop,ihi+1 ), ldb )
           end if
           if ( ilq ) then
              call stdlib_sgemm( 'N', 'N', n, jw, jw, one, q( 1, kwtop ), ldq, qc,ldqc, zero, &
                        work, n )
              call stdlib_slacpy( 'ALL', n, jw, work, n, q( 1, kwtop ), ldq )
           end if
           if ( kwtop-1-istartm+1 > 0 ) then
              call stdlib_sgemm( 'N', 'N', kwtop-istartm, jw, jw, one, a( istartm,kwtop ), lda, &
                        zc, ldzc, zero, work,kwtop-istartm )
              call stdlib_slacpy( 'ALL', kwtop-istartm, jw, work, kwtop-istartm,a( istartm, kwtop &
                        ), lda )
              call stdlib_sgemm( 'N', 'N', kwtop-istartm, jw, jw, one, b( istartm,kwtop ), ldb, &
                        zc, ldzc, zero, work,kwtop-istartm )
              call stdlib_slacpy( 'ALL', kwtop-istartm, jw, work, kwtop-istartm,b( istartm, kwtop &
                        ), ldb )
           end if
           if ( ilz ) then
              call stdlib_sgemm( 'N', 'N', n, jw, jw, one, z( 1, kwtop ), ldz, zc,ldzc, zero, &
                        work, n )
              call stdlib_slacpy( 'ALL', n, jw, work, n, z( 1, kwtop ), ldz )
           end if
     end subroutine stdlib_slaqz3

     module recursive subroutine stdlib_dlaqz3( ilschur, ilq, ilz, n, ilo, ihi, nw,a, lda, b, ldb, q, &
     !! DLAQZ3 performs AED
               ldq, z, ldz, ns,nd, alphar, alphai, beta, qc, ldqc,zc, ldzc, work, lwork, rec, info )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(ilp), intent( in ) :: n, ilo, ihi, nw, lda, ldb, ldq, ldz,ldqc, ldzc, lwork, &
                     rec
           real(dp), intent( inout ) :: a( lda, * ), b( ldb, * ),q( ldq, * ), z( ldz, * ), alphar(&
                      * ),alphai( * ), beta( * )
           integer(ilp), intent( out ) :: ns, nd, info
           real(dp), intent(inout) :: qc(ldqc,*), zc(ldzc,*)
           real(dp), intent(out) :: work(*)
           ! ================================================================
           ! local scalars
           logical(lk) :: bulge
           integer(ilp) :: jw, kwtop, kwbot, istopm, istartm, k, k2, dtgexc_info, ifst, ilst, &
                     lworkreq, qz_small_info
           real(dp) :: s, smlnum, ulp, safmin, safmax, c1, s1, temp
           info = 0
           ! set up deflation window
           jw = min( nw, ihi-ilo+1 )
           kwtop = ihi-jw+1
           if ( kwtop == ilo ) then
              s = zero
           else
              s = a( kwtop, kwtop-1 )
           end if
           ! determine required workspace
           ifst = 1
           ilst = jw
           call stdlib_dtgexc( .true., .true., jw, a, lda, b, ldb, qc, ldqc, zc,ldzc, ifst, ilst, &
                     work, -1, dtgexc_info )
           lworkreq = int( work( 1 ),KIND=ilp)
           call stdlib_dlaqz0( 'S', 'V', 'V', jw, 1, jw, a( kwtop, kwtop ), lda,b( kwtop, kwtop ),&
                      ldb, alphar, alphai, beta, qc,ldqc, zc, ldzc, work, -1, rec+1, qz_small_info )
           lworkreq = max( lworkreq, int( work( 1 ),KIND=ilp)+2*jw**2 )
           lworkreq = max( lworkreq, n*nw, 2*nw**2+n )
           if ( lwork ==-1 ) then
              ! workspace query, quick return
              work( 1 ) = lworkreq
              return
           else if ( lwork < lworkreq ) then
              info = -26
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAQZ3', -info )
              return
           end if
           ! get machine constants
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_dlabad( safmin, safmax )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=dp)/ulp )
           if ( ihi == kwtop ) then
              ! 1 by 1 deflation window, just try a regular deflation
              alphar( kwtop ) = a( kwtop, kwtop )
              alphai( kwtop ) = zero
              beta( kwtop ) = b( kwtop, kwtop )
              ns = 1
              nd = 0
              if ( abs( s ) <= max( smlnum, ulp*abs( a( kwtop,kwtop ) ) ) ) then
                 ns = 0
                 nd = 1
                 if ( kwtop > ilo ) then
                    a( kwtop, kwtop-1 ) = zero
                 end if
              end if
           end if
           ! store window in case of convergence failure
           call stdlib_dlacpy( 'ALL', jw, jw, a( kwtop, kwtop ), lda, work, jw )
           call stdlib_dlacpy( 'ALL', jw, jw, b( kwtop, kwtop ), ldb, work( jw**2+1 ), jw )
                     
           ! transform window to real schur form
           call stdlib_dlaset( 'FULL', jw, jw, zero, one, qc, ldqc )
           call stdlib_dlaset( 'FULL', jw, jw, zero, one, zc, ldzc )
           call stdlib_dlaqz0( 'S', 'V', 'V', jw, 1, jw, a( kwtop, kwtop ), lda,b( kwtop, kwtop ),&
            ldb, alphar, alphai, beta, qc,ldqc, zc, ldzc, work( 2*jw**2+1 ), lwork-2*jw**2,rec+1, &
                      qz_small_info )
           if( qz_small_info /= 0 ) then
              ! convergence failure, restore the window and exit
              nd = 0
              ns = jw-qz_small_info
              call stdlib_dlacpy( 'ALL', jw, jw, work, jw, a( kwtop, kwtop ), lda )
              call stdlib_dlacpy( 'ALL', jw, jw, work( jw**2+1 ), jw, b( kwtop,kwtop ), ldb )
                        
              return
           end if
           ! deflation detection loop
           if ( kwtop == ilo .or. s == zero ) then
              kwbot = kwtop-1
           else
              kwbot = ihi
              k = 1
              k2 = 1
              do while ( k <= jw )
                 bulge = .false.
                 if ( kwbot-kwtop+1 >= 2 ) then
                    bulge = a( kwbot, kwbot-1 ) /= zero
                 end if
                 if ( bulge ) then
                    ! try to deflate complex conjugate eigenvalue pair
                    temp = abs( a( kwbot, kwbot ) )+sqrt( abs( a( kwbot,kwbot-1 ) ) )*sqrt( abs( &
                              a( kwbot-1, kwbot ) ) )
                    if( temp == zero )then
                       temp = abs( s )
                    end if
                    if ( max( abs( s*qc( 1, kwbot-kwtop ) ), abs( s*qc( 1,kwbot-kwtop+1 ) ) ) <= &
                              max( smlnum,ulp*temp ) ) then
                       ! deflatable
                       kwbot = kwbot-2
                    else
                       ! not deflatable, move out of the way
                       ifst = kwbot-kwtop+1
                       ilst = k2
                       call stdlib_dtgexc( .true., .true., jw, a( kwtop, kwtop ),lda, b( kwtop, &
                       kwtop ), ldb, qc, ldqc,zc, ldzc, ifst, ilst, work, lwork,dtgexc_info )
                                 
                       k2 = k2+2
                    end if
                    k = k+2
                 else
                    ! try to deflate real eigenvalue
                    temp = abs( a( kwbot, kwbot ) )
                    if( temp == zero ) then
                       temp = abs( s )
                    end if
                    if ( ( abs( s*qc( 1, kwbot-kwtop+1 ) ) ) <= max( ulp*temp, smlnum ) ) &
                              then
                       ! deflatable
                       kwbot = kwbot-1
                    else
                       ! not deflatable, move out of the way
                       ifst = kwbot-kwtop+1
                       ilst = k2
                       call stdlib_dtgexc( .true., .true., jw, a( kwtop, kwtop ),lda, b( kwtop, &
                       kwtop ), ldb, qc, ldqc,zc, ldzc, ifst, ilst, work, lwork,dtgexc_info )
                                 
                       k2 = k2+1
                    end if
                    k = k+1
                 end if
              end do
           end if
           ! store eigenvalues
           nd = ihi-kwbot
           ns = jw-nd
           k = kwtop
           do while ( k <= ihi )
              bulge = .false.
              if ( k < ihi ) then
                 if ( a( k+1, k ) /= zero ) then
                    bulge = .true.
                 end if
              end if
              if ( bulge ) then
                 ! 2x2 eigenvalue block
                 call stdlib_dlag2( a( k, k ), lda, b( k, k ), ldb, safmin,beta( k ), beta( k+1 ),&
                            alphar( k ),alphar( k+1 ), alphai( k ) )
                 alphai( k+1 ) = -alphai( k )
                 k = k+2
              else
                 ! 1x1 eigenvalue block
                 alphar( k ) = a( k, k )
                 alphai( k ) = zero
                 beta( k ) = b( k, k )
                 k = k+1
              end if
           end do
           if ( kwtop /= ilo .and. s /= zero ) then
              ! reflect spike back, this will create optimally packed bulges
              a( kwtop:kwbot, kwtop-1 ) = a( kwtop, kwtop-1 )*qc( 1,1:jw-nd )
              do k = kwbot-1, kwtop, -1
                 call stdlib_dlartg( a( k, kwtop-1 ), a( k+1, kwtop-1 ), c1, s1,temp )
                 a( k, kwtop-1 ) = temp
                 a( k+1, kwtop-1 ) = zero
                 k2 = max( kwtop, k-1 )
                 call stdlib_drot( ihi-k2+1, a( k, k2 ), lda, a( k+1, k2 ), lda, c1,s1 )
                 call stdlib_drot( ihi-( k-1 )+1, b( k, k-1 ), ldb, b( k+1, k-1 ),ldb, c1, s1 )
                           
                 call stdlib_drot( jw, qc( 1, k-kwtop+1 ), 1, qc( 1, k+1-kwtop+1 ),1, c1, s1 )
                           
              end do
              ! chase bulges down
              istartm = kwtop
              istopm = ihi
              k = kwbot-1
              do while ( k >= kwtop )
                 if ( ( k >= kwtop+1 ) .and. a( k+1, k-1 ) /= zero ) then
                    ! move double pole block down and remove it
                    do k2 = k-1, kwbot-2
                       call stdlib_dlaqz2( .true., .true., k2, kwtop, kwtop+jw-1,kwbot, a, lda, b,&
                                  ldb, jw, kwtop, qc,ldqc, jw, kwtop, zc, ldzc )
                    end do
                    k = k-2
                 else
                    ! k points to single shift
                    do k2 = k, kwbot-2
                       ! move shift down
                       call stdlib_dlartg( b( k2+1, k2+1 ), b( k2+1, k2 ), c1, s1,temp )
                       b( k2+1, k2+1 ) = temp
                       b( k2+1, k2 ) = zero
                       call stdlib_drot( k2+2-istartm+1, a( istartm, k2+1 ), 1,a( istartm, k2 ), &
                                 1, c1, s1 )
                       call stdlib_drot( k2-istartm+1, b( istartm, k2+1 ), 1,b( istartm, k2 ), 1, &
                                 c1, s1 )
                       call stdlib_drot( jw, zc( 1, k2+1-kwtop+1 ), 1, zc( 1,k2-kwtop+1 ), 1, c1, &
                                 s1 )
                       call stdlib_dlartg( a( k2+1, k2 ), a( k2+2, k2 ), c1, s1,temp )
                       a( k2+1, k2 ) = temp
                       a( k2+2, k2 ) = zero
                       call stdlib_drot( istopm-k2, a( k2+1, k2+1 ), lda, a( k2+2,k2+1 ), lda, c1,&
                                  s1 )
                       call stdlib_drot( istopm-k2, b( k2+1, k2+1 ), ldb, b( k2+2,k2+1 ), ldb, c1,&
                                  s1 )
                       call stdlib_drot( jw, qc( 1, k2+1-kwtop+1 ), 1, qc( 1,k2+2-kwtop+1 ), 1, &
                                 c1, s1 )
                    end do
                    ! remove the shift
                    call stdlib_dlartg( b( kwbot, kwbot ), b( kwbot, kwbot-1 ), c1,s1, temp )
                              
                    b( kwbot, kwbot ) = temp
                    b( kwbot, kwbot-1 ) = zero
                    call stdlib_drot( kwbot-istartm, b( istartm, kwbot ), 1,b( istartm, kwbot-1 ),&
                               1, c1, s1 )
                    call stdlib_drot( kwbot-istartm+1, a( istartm, kwbot ), 1,a( istartm, kwbot-1 &
                              ), 1, c1, s1 )
                    call stdlib_drot( jw, zc( 1, kwbot-kwtop+1 ), 1, zc( 1,kwbot-1-kwtop+1 ), 1, &
                              c1, s1 )
                    k = k-1
                 end if
              end do
           end if
           ! apply qc and zc to rest of the matrix
           if ( ilschur ) then
              istartm = 1
              istopm = n
           else
              istartm = ilo
              istopm = ihi
           end if
           if ( istopm-ihi > 0 ) then
              call stdlib_dgemm( 'T', 'N', jw, istopm-ihi, jw, one, qc, ldqc,a( kwtop, ihi+1 ), &
                        lda, zero, work, jw )
              call stdlib_dlacpy( 'ALL', jw, istopm-ihi, work, jw, a( kwtop,ihi+1 ), lda )
              call stdlib_dgemm( 'T', 'N', jw, istopm-ihi, jw, one, qc, ldqc,b( kwtop, ihi+1 ), &
                        ldb, zero, work, jw )
              call stdlib_dlacpy( 'ALL', jw, istopm-ihi, work, jw, b( kwtop,ihi+1 ), ldb )
           end if
           if ( ilq ) then
              call stdlib_dgemm( 'N', 'N', n, jw, jw, one, q( 1, kwtop ), ldq, qc,ldqc, zero, &
                        work, n )
              call stdlib_dlacpy( 'ALL', n, jw, work, n, q( 1, kwtop ), ldq )
           end if
           if ( kwtop-1-istartm+1 > 0 ) then
              call stdlib_dgemm( 'N', 'N', kwtop-istartm, jw, jw, one, a( istartm,kwtop ), lda, &
                        zc, ldzc, zero, work,kwtop-istartm )
              call stdlib_dlacpy( 'ALL', kwtop-istartm, jw, work, kwtop-istartm,a( istartm, kwtop &
                        ), lda )
              call stdlib_dgemm( 'N', 'N', kwtop-istartm, jw, jw, one, b( istartm,kwtop ), ldb, &
                        zc, ldzc, zero, work,kwtop-istartm )
              call stdlib_dlacpy( 'ALL', kwtop-istartm, jw, work, kwtop-istartm,b( istartm, kwtop &
                        ), ldb )
           end if
           if ( ilz ) then
              call stdlib_dgemm( 'N', 'N', n, jw, jw, one, z( 1, kwtop ), ldz, zc,ldzc, zero, &
                        work, n )
              call stdlib_dlacpy( 'ALL', n, jw, work, n, z( 1, kwtop ), ldz )
           end if
     end subroutine stdlib_dlaqz3

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module recursive subroutine stdlib_${ri}$laqz3( ilschur, ilq, ilz, n, ilo, ihi, nw,a, lda, b, ldb, q, &
     !! DLAQZ3: performs AED
               ldq, z, ldz, ns,nd, alphar, alphai, beta, qc, ldqc,zc, ldzc, work, lwork, rec, info )
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(ilp), intent( in ) :: n, ilo, ihi, nw, lda, ldb, ldq, ldz,ldqc, ldzc, lwork, &
                     rec
           real(${rk}$), intent( inout ) :: a( lda, * ), b( ldb, * ),q( ldq, * ), z( ldz, * ), alphar(&
                      * ),alphai( * ), beta( * )
           integer(ilp), intent( out ) :: ns, nd, info
           real(${rk}$), intent(inout) :: qc(ldqc,*), zc(ldzc,*)
           real(${rk}$), intent(out) :: work(*)
           ! ================================================================
           ! local scalars
           logical(lk) :: bulge
           integer(ilp) :: jw, kwtop, kwbot, istopm, istartm, k, k2, dtgexc_info, ifst, ilst, &
                     lworkreq, qz_small_info
           real(${rk}$) :: s, smlnum, ulp, safmin, safmax, c1, s1, temp
           info = 0
           ! set up deflation window
           jw = min( nw, ihi-ilo+1 )
           kwtop = ihi-jw+1
           if ( kwtop == ilo ) then
              s = zero
           else
              s = a( kwtop, kwtop-1 )
           end if
           ! determine required workspace
           ifst = 1
           ilst = jw
           call stdlib_${ri}$tgexc( .true., .true., jw, a, lda, b, ldb, qc, ldqc, zc,ldzc, ifst, ilst, &
                     work, -1, dtgexc_info )
           lworkreq = int( work( 1 ),KIND=ilp)
           call stdlib_${ri}$laqz0( 'S', 'V', 'V', jw, 1, jw, a( kwtop, kwtop ), lda,b( kwtop, kwtop ),&
                      ldb, alphar, alphai, beta, qc,ldqc, zc, ldzc, work, -1, rec+1, qz_small_info )
           lworkreq = max( lworkreq, int( work( 1 ),KIND=ilp)+2*jw**2 )
           lworkreq = max( lworkreq, n*nw, 2*nw**2+n )
           if ( lwork ==-1 ) then
              ! workspace query, quick return
              work( 1 ) = lworkreq
              return
           else if ( lwork < lworkreq ) then
              info = -26
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAQZ3', -info )
              return
           end if
           ! get machine constants
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_${ri}$labad( safmin, safmax )
           ulp = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=${rk}$)/ulp )
           if ( ihi == kwtop ) then
              ! 1 by 1 deflation window, just try a regular deflation
              alphar( kwtop ) = a( kwtop, kwtop )
              alphai( kwtop ) = zero
              beta( kwtop ) = b( kwtop, kwtop )
              ns = 1
              nd = 0
              if ( abs( s ) <= max( smlnum, ulp*abs( a( kwtop,kwtop ) ) ) ) then
                 ns = 0
                 nd = 1
                 if ( kwtop > ilo ) then
                    a( kwtop, kwtop-1 ) = zero
                 end if
              end if
           end if
           ! store window in case of convergence failure
           call stdlib_${ri}$lacpy( 'ALL', jw, jw, a( kwtop, kwtop ), lda, work, jw )
           call stdlib_${ri}$lacpy( 'ALL', jw, jw, b( kwtop, kwtop ), ldb, work( jw**2+1 ), jw )
                     
           ! transform window to real schur form
           call stdlib_${ri}$laset( 'FULL', jw, jw, zero, one, qc, ldqc )
           call stdlib_${ri}$laset( 'FULL', jw, jw, zero, one, zc, ldzc )
           call stdlib_${ri}$laqz0( 'S', 'V', 'V', jw, 1, jw, a( kwtop, kwtop ), lda,b( kwtop, kwtop ),&
            ldb, alphar, alphai, beta, qc,ldqc, zc, ldzc, work( 2*jw**2+1 ), lwork-2*jw**2,rec+1, &
                      qz_small_info )
           if( qz_small_info /= 0 ) then
              ! convergence failure, restore the window and exit
              nd = 0
              ns = jw-qz_small_info
              call stdlib_${ri}$lacpy( 'ALL', jw, jw, work, jw, a( kwtop, kwtop ), lda )
              call stdlib_${ri}$lacpy( 'ALL', jw, jw, work( jw**2+1 ), jw, b( kwtop,kwtop ), ldb )
                        
              return
           end if
           ! deflation detection loop
           if ( kwtop == ilo .or. s == zero ) then
              kwbot = kwtop-1
           else
              kwbot = ihi
              k = 1
              k2 = 1
              do while ( k <= jw )
                 bulge = .false.
                 if ( kwbot-kwtop+1 >= 2 ) then
                    bulge = a( kwbot, kwbot-1 ) /= zero
                 end if
                 if ( bulge ) then
                    ! try to deflate complex conjugate eigenvalue pair
                    temp = abs( a( kwbot, kwbot ) )+sqrt( abs( a( kwbot,kwbot-1 ) ) )*sqrt( abs( &
                              a( kwbot-1, kwbot ) ) )
                    if( temp == zero )then
                       temp = abs( s )
                    end if
                    if ( max( abs( s*qc( 1, kwbot-kwtop ) ), abs( s*qc( 1,kwbot-kwtop+1 ) ) ) <= &
                              max( smlnum,ulp*temp ) ) then
                       ! deflatable
                       kwbot = kwbot-2
                    else
                       ! not deflatable, move out of the way
                       ifst = kwbot-kwtop+1
                       ilst = k2
                       call stdlib_${ri}$tgexc( .true., .true., jw, a( kwtop, kwtop ),lda, b( kwtop, &
                       kwtop ), ldb, qc, ldqc,zc, ldzc, ifst, ilst, work, lwork,dtgexc_info )
                                 
                       k2 = k2+2
                    end if
                    k = k+2
                 else
                    ! try to deflate real eigenvalue
                    temp = abs( a( kwbot, kwbot ) )
                    if( temp == zero ) then
                       temp = abs( s )
                    end if
                    if ( ( abs( s*qc( 1, kwbot-kwtop+1 ) ) ) <= max( ulp*temp, smlnum ) ) &
                              then
                       ! deflatable
                       kwbot = kwbot-1
                    else
                       ! not deflatable, move out of the way
                       ifst = kwbot-kwtop+1
                       ilst = k2
                       call stdlib_${ri}$tgexc( .true., .true., jw, a( kwtop, kwtop ),lda, b( kwtop, &
                       kwtop ), ldb, qc, ldqc,zc, ldzc, ifst, ilst, work, lwork,dtgexc_info )
                                 
                       k2 = k2+1
                    end if
                    k = k+1
                 end if
              end do
           end if
           ! store eigenvalues
           nd = ihi-kwbot
           ns = jw-nd
           k = kwtop
           do while ( k <= ihi )
              bulge = .false.
              if ( k < ihi ) then
                 if ( a( k+1, k ) /= zero ) then
                    bulge = .true.
                 end if
              end if
              if ( bulge ) then
                 ! 2x2 eigenvalue block
                 call stdlib_${ri}$lag2( a( k, k ), lda, b( k, k ), ldb, safmin,beta( k ), beta( k+1 ),&
                            alphar( k ),alphar( k+1 ), alphai( k ) )
                 alphai( k+1 ) = -alphai( k )
                 k = k+2
              else
                 ! 1x1 eigenvalue block
                 alphar( k ) = a( k, k )
                 alphai( k ) = zero
                 beta( k ) = b( k, k )
                 k = k+1
              end if
           end do
           if ( kwtop /= ilo .and. s /= zero ) then
              ! reflect spike back, this will create optimally packed bulges
              a( kwtop:kwbot, kwtop-1 ) = a( kwtop, kwtop-1 )*qc( 1,1:jw-nd )
              do k = kwbot-1, kwtop, -1
                 call stdlib_${ri}$lartg( a( k, kwtop-1 ), a( k+1, kwtop-1 ), c1, s1,temp )
                 a( k, kwtop-1 ) = temp
                 a( k+1, kwtop-1 ) = zero
                 k2 = max( kwtop, k-1 )
                 call stdlib_${ri}$rot( ihi-k2+1, a( k, k2 ), lda, a( k+1, k2 ), lda, c1,s1 )
                 call stdlib_${ri}$rot( ihi-( k-1 )+1, b( k, k-1 ), ldb, b( k+1, k-1 ),ldb, c1, s1 )
                           
                 call stdlib_${ri}$rot( jw, qc( 1, k-kwtop+1 ), 1, qc( 1, k+1-kwtop+1 ),1, c1, s1 )
                           
              end do
              ! chase bulges down
              istartm = kwtop
              istopm = ihi
              k = kwbot-1
              do while ( k >= kwtop )
                 if ( ( k >= kwtop+1 ) .and. a( k+1, k-1 ) /= zero ) then
                    ! move double pole block down and remove it
                    do k2 = k-1, kwbot-2
                       call stdlib_${ri}$laqz2( .true., .true., k2, kwtop, kwtop+jw-1,kwbot, a, lda, b,&
                                  ldb, jw, kwtop, qc,ldqc, jw, kwtop, zc, ldzc )
                    end do
                    k = k-2
                 else
                    ! k points to single shift
                    do k2 = k, kwbot-2
                       ! move shift down
                       call stdlib_${ri}$lartg( b( k2+1, k2+1 ), b( k2+1, k2 ), c1, s1,temp )
                       b( k2+1, k2+1 ) = temp
                       b( k2+1, k2 ) = zero
                       call stdlib_${ri}$rot( k2+2-istartm+1, a( istartm, k2+1 ), 1,a( istartm, k2 ), &
                                 1, c1, s1 )
                       call stdlib_${ri}$rot( k2-istartm+1, b( istartm, k2+1 ), 1,b( istartm, k2 ), 1, &
                                 c1, s1 )
                       call stdlib_${ri}$rot( jw, zc( 1, k2+1-kwtop+1 ), 1, zc( 1,k2-kwtop+1 ), 1, c1, &
                                 s1 )
                       call stdlib_${ri}$lartg( a( k2+1, k2 ), a( k2+2, k2 ), c1, s1,temp )
                       a( k2+1, k2 ) = temp
                       a( k2+2, k2 ) = zero
                       call stdlib_${ri}$rot( istopm-k2, a( k2+1, k2+1 ), lda, a( k2+2,k2+1 ), lda, c1,&
                                  s1 )
                       call stdlib_${ri}$rot( istopm-k2, b( k2+1, k2+1 ), ldb, b( k2+2,k2+1 ), ldb, c1,&
                                  s1 )
                       call stdlib_${ri}$rot( jw, qc( 1, k2+1-kwtop+1 ), 1, qc( 1,k2+2-kwtop+1 ), 1, &
                                 c1, s1 )
                    end do
                    ! remove the shift
                    call stdlib_${ri}$lartg( b( kwbot, kwbot ), b( kwbot, kwbot-1 ), c1,s1, temp )
                              
                    b( kwbot, kwbot ) = temp
                    b( kwbot, kwbot-1 ) = zero
                    call stdlib_${ri}$rot( kwbot-istartm, b( istartm, kwbot ), 1,b( istartm, kwbot-1 ),&
                               1, c1, s1 )
                    call stdlib_${ri}$rot( kwbot-istartm+1, a( istartm, kwbot ), 1,a( istartm, kwbot-1 &
                              ), 1, c1, s1 )
                    call stdlib_${ri}$rot( jw, zc( 1, kwbot-kwtop+1 ), 1, zc( 1,kwbot-1-kwtop+1 ), 1, &
                              c1, s1 )
                    k = k-1
                 end if
              end do
           end if
           ! apply qc and zc to rest of the matrix
           if ( ilschur ) then
              istartm = 1
              istopm = n
           else
              istartm = ilo
              istopm = ihi
           end if
           if ( istopm-ihi > 0 ) then
              call stdlib_${ri}$gemm( 'T', 'N', jw, istopm-ihi, jw, one, qc, ldqc,a( kwtop, ihi+1 ), &
                        lda, zero, work, jw )
              call stdlib_${ri}$lacpy( 'ALL', jw, istopm-ihi, work, jw, a( kwtop,ihi+1 ), lda )
              call stdlib_${ri}$gemm( 'T', 'N', jw, istopm-ihi, jw, one, qc, ldqc,b( kwtop, ihi+1 ), &
                        ldb, zero, work, jw )
              call stdlib_${ri}$lacpy( 'ALL', jw, istopm-ihi, work, jw, b( kwtop,ihi+1 ), ldb )
           end if
           if ( ilq ) then
              call stdlib_${ri}$gemm( 'N', 'N', n, jw, jw, one, q( 1, kwtop ), ldq, qc,ldqc, zero, &
                        work, n )
              call stdlib_${ri}$lacpy( 'ALL', n, jw, work, n, q( 1, kwtop ), ldq )
           end if
           if ( kwtop-1-istartm+1 > 0 ) then
              call stdlib_${ri}$gemm( 'N', 'N', kwtop-istartm, jw, jw, one, a( istartm,kwtop ), lda, &
                        zc, ldzc, zero, work,kwtop-istartm )
              call stdlib_${ri}$lacpy( 'ALL', kwtop-istartm, jw, work, kwtop-istartm,a( istartm, kwtop &
                        ), lda )
              call stdlib_${ri}$gemm( 'N', 'N', kwtop-istartm, jw, jw, one, b( istartm,kwtop ), ldb, &
                        zc, ldzc, zero, work,kwtop-istartm )
              call stdlib_${ri}$lacpy( 'ALL', kwtop-istartm, jw, work, kwtop-istartm,b( istartm, kwtop &
                        ), ldb )
           end if
           if ( ilz ) then
              call stdlib_${ri}$gemm( 'N', 'N', n, jw, jw, one, z( 1, kwtop ), ldz, zc,ldzc, zero, &
                        work, n )
              call stdlib_${ri}$lacpy( 'ALL', n, jw, work, n, z( 1, kwtop ), ldz )
           end if
     end subroutine stdlib_${ri}$laqz3

#:endif
#:endfor

     module pure subroutine stdlib_claqz3( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_desired, alpha,&
     !! CLAQZ3 Executes a single multishift QZ sweep
                beta, a, lda, b, ldb,q, ldq, z, ldz, qc, ldqc, zc, ldzc, work,lwork, info )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! function arguments
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(ilp), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,nshifts, &
                     nblock_desired, ldqc, ldzc
           complex(sp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq, * ),z( ldz, * ), qc( &
                     ldqc, * ), zc( ldzc, * ), work( * ),alpha( * ), beta( * )
           integer(ilp), intent( out ) :: info
           
           ! ================================================================
           ! local scalars
           integer(ilp) :: i, j, ns, istartm, istopm, sheight, swidth, k, np, istartb, istopb, &
                     ishift, nblock, npos
           real(sp) :: safmin, safmax, c, scale
           complex(sp) :: temp, temp2, temp3, s
           info = 0
           if ( nblock_desired < nshifts+1 ) then
              info = -8
           end if
           if ( lwork ==-1 ) then
              ! workspace query, quick return
              work( 1 ) = n*nblock_desired
              return
           else if ( lwork < n*nblock_desired ) then
              info = -25
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLAQZ3', -info )
              return
           end if
           ! executable statements
           ! get machine constants
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_slabad( safmin, safmax )
           if ( ilo >= ihi ) then
              return
           end if
           if ( ilschur ) then
              istartm = 1
              istopm = n
           else
              istartm = ilo
              istopm = ihi
           end if
           ns = nshifts
           npos = max( nblock_desired-ns, 1 )
           ! the following block introduces the shifts and chases
           ! them down one by one just enough to make space for
           ! the other shifts. the near-the-diagonal block is
           ! of size (ns+1) x ns.
           call stdlib_claset( 'FULL', ns+1, ns+1, czero, cone, qc, ldqc )
           call stdlib_claset( 'FULL', ns, ns, czero, cone, zc, ldzc )
           do i = 1, ns
              ! introduce the shift
              scale = sqrt( abs( alpha( i ) ) ) * sqrt( abs( beta( i ) ) )
              if( scale >= safmin .and. scale <= safmax ) then
                 alpha( i ) = alpha( i )/scale
                 beta( i ) = beta( i )/scale
              end if
              temp2 = beta( i )*a( ilo, ilo )-alpha( i )*b( ilo, ilo )
              temp3 = beta( i )*a( ilo+1, ilo )
              if ( abs( temp2 ) > safmax .or.abs( temp3 ) > safmax ) then
                 temp2 = cone
                 temp3 = czero
              end if
              call stdlib_clartg( temp2, temp3, c, s, temp )
              call stdlib_crot( ns, a( ilo, ilo ), lda, a( ilo+1, ilo ), lda, c,s )
              call stdlib_crot( ns, b( ilo, ilo ), ldb, b( ilo+1, ilo ), ldb, c,s )
              call stdlib_crot( ns+1, qc( 1, 1 ), 1, qc( 1, 2 ), 1, c, conjg( s ) )
              ! chase the shift down
              do j = 1, ns-i
                 call stdlib_claqz1( .true., .true., j, 1, ns, ihi-ilo+1, a( ilo,ilo ), lda, b( &
                           ilo, ilo ), ldb, ns+1, 1, qc,ldqc, ns, 1, zc, ldzc )
              end do
           end do
           ! update the rest of the pencil
           ! update a(ilo:ilo+ns,ilo+ns:istopm) and b(ilo:ilo+ns,ilo+ns:istopm)
           ! from the left with qc(1:ns+1,1:ns+1)'
           sheight = ns+1
           swidth = istopm-( ilo+ns )+1
           if ( swidth > 0 ) then
              call stdlib_cgemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,a( ilo, ilo+&
                        ns ), lda, czero, work, sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, a( ilo,ilo+ns ), lda )
                        
              call stdlib_cgemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,b( ilo, ilo+&
                        ns ), ldb, czero, work, sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, b( ilo,ilo+ns ), ldb )
                        
           end if
           if ( ilq ) then
             call stdlib_cgemm( 'N', 'N', n, sheight, sheight, cone, q( 1, ilo ),ldq, qc, ldqc, &
                       czero, work, n )
              call stdlib_clacpy( 'ALL', n, sheight, work, n, q( 1, ilo ), ldq )
           end if
           ! update a(istartm:ilo-1,ilo:ilo+ns-1) and b(istartm:ilo-1,ilo:ilo+ns-1)
           ! from the right with zc(1:ns,1:ns)
           sheight = ilo-1-istartm+1
           swidth = ns
           if ( sheight > 0 ) then
              call stdlib_cgemm( 'N', 'N', sheight, swidth, swidth, cone,a( istartm, ilo ), lda, &
                        zc, ldzc, czero, work,sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ilo ), lda )
                        
              call stdlib_cgemm( 'N', 'N', sheight, swidth, swidth, cone,b( istartm, ilo ), ldb, &
                        zc, ldzc, czero, work,sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ilo ), ldb )
                        
           end if
           if ( ilz ) then
              call stdlib_cgemm( 'N', 'N', n, swidth, swidth, cone, z( 1, ilo ),ldz, zc, ldzc, &
                        czero, work, n )
              call stdlib_clacpy( 'ALL', n, swidth, work, n, z( 1, ilo ), ldz )
           end if
           ! the following block chases the shifts down to the bottom
           ! right block. if possible, a shift is moved down npos
           ! positions at a time
           k = ilo
           do while ( k < ihi-ns )
              np = min( ihi-ns-k, npos )
              ! size of the near-the-diagonal block
              nblock = ns+np
              ! istartb points to the first row we will be updating
              istartb = k+1
              ! istopb points to the last column we will be updating
              istopb = k+nblock-1
              call stdlib_claset( 'FULL', ns+np, ns+np, czero, cone, qc, ldqc )
              call stdlib_claset( 'FULL', ns+np, ns+np, czero, cone, zc, ldzc )
              ! near the diagonal shift chase
              do i = ns-1, 0, -1
                 do j = 0, np-1
                    ! move down the block with index k+i+j, updating
                    ! the (ns+np x ns+np) block:
                    ! (k:k+ns+np,k:k+ns+np-1)
                    call stdlib_claqz1( .true., .true., k+i+j, istartb, istopb, ihi,a, lda, b, &
                              ldb, nblock, k+1, qc, ldqc,nblock, k, zc, ldzc )
                 end do
              end do
              ! update rest of the pencil
              ! update a(k+1:k+ns+np, k+ns+np:istopm) and
              ! b(k+1:k+ns+np, k+ns+np:istopm)
              ! from the left with qc(1:ns+np,1:ns+np)'
              sheight = ns+np
              swidth = istopm-( k+ns+np )+1
              if ( swidth > 0 ) then
                 call stdlib_cgemm( 'C', 'N', sheight, swidth, sheight, cone, qc,ldqc, a( k+1, k+&
                           ns+np ), lda, czero, work,sheight )
                 call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, a( k+1,k+ns+np ), lda &
                           )
                 call stdlib_cgemm( 'C', 'N', sheight, swidth, sheight, cone, qc,ldqc, b( k+1, k+&
                           ns+np ), ldb, czero, work,sheight )
                 call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, b( k+1,k+ns+np ), ldb &
                           )
              end if
              if ( ilq ) then
                 call stdlib_cgemm( 'N', 'N', n, nblock, nblock, cone, q( 1, k+1 ),ldq, qc, ldqc, &
                           czero, work, n )
                 call stdlib_clacpy( 'ALL', n, nblock, work, n, q( 1, k+1 ), ldq )
              end if
              ! update a(istartm:k,k:k+ns+npos-1) and b(istartm:k,k:k+ns+npos-1)
              ! from the right with zc(1:ns+np,1:ns+np)
              sheight = k-istartm+1
              swidth = nblock
              if ( sheight > 0 ) then
                 call stdlib_cgemm( 'N', 'N', sheight, swidth, swidth, cone,a( istartm, k ), lda, &
                           zc, ldzc, czero, work,sheight )
                 call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight,a( istartm, k ), lda )
                           
                 call stdlib_cgemm( 'N', 'N', sheight, swidth, swidth, cone,b( istartm, k ), ldb, &
                           zc, ldzc, czero, work,sheight )
                 call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight,b( istartm, k ), ldb )
                           
              end if
              if ( ilz ) then
                 call stdlib_cgemm( 'N', 'N', n, nblock, nblock, cone, z( 1, k ),ldz, zc, ldzc, &
                           czero, work, n )
                 call stdlib_clacpy( 'ALL', n, nblock, work, n, z( 1, k ), ldz )
              end if
              k = k+np
           end do
           ! the following block removes the shifts from the bottom right corner
           ! one by one. updates are initially applied to a(ihi-ns+1:ihi,ihi-ns:ihi).
           call stdlib_claset( 'FULL', ns, ns, czero, cone, qc, ldqc )
           call stdlib_claset( 'FULL', ns+1, ns+1, czero, cone, zc, ldzc )
           ! istartb points to the first row we will be updating
           istartb = ihi-ns+1
           ! istopb points to the last column we will be updating
           istopb = ihi
           do i = 1, ns
              ! chase the shift down to the bottom right corner
              do ishift = ihi-i, ihi-1
                 call stdlib_claqz1( .true., .true., ishift, istartb, istopb, ihi,a, lda, b, ldb, &
                           ns, ihi-ns+1, qc, ldqc, ns+1,ihi-ns, zc, ldzc )
              end do
           end do
           ! update rest of the pencil
           ! update a(ihi-ns+1:ihi, ihi+1:istopm)
           ! from the left with qc(1:ns,1:ns)'
           sheight = ns
           swidth = istopm-( ihi+1 )+1
           if ( swidth > 0 ) then
              call stdlib_cgemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,a( ihi-ns+1, &
                        ihi+1 ), lda, czero, work, sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight,a( ihi-ns+1, ihi+1 ), lda &
                        )
              call stdlib_cgemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,b( ihi-ns+1, &
                        ihi+1 ), ldb, czero, work, sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight,b( ihi-ns+1, ihi+1 ), ldb &
                        )
           end if
           if ( ilq ) then
              call stdlib_cgemm( 'N', 'N', n, ns, ns, cone, q( 1, ihi-ns+1 ), ldq,qc, ldqc, czero,&
                         work, n )
              call stdlib_clacpy( 'ALL', n, ns, work, n, q( 1, ihi-ns+1 ), ldq )
           end if
           ! update a(istartm:ihi-ns,ihi-ns:ihi)
           ! from the right with zc(1:ns+1,1:ns+1)
           sheight = ihi-ns-istartm+1
           swidth = ns+1
           if ( sheight > 0 ) then
              call stdlib_cgemm( 'N', 'N', sheight, swidth, swidth, cone,a( istartm, ihi-ns ), &
                        lda, zc, ldzc, czero, work,sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ihi-ns ), lda &
                        )
              call stdlib_cgemm( 'N', 'N', sheight, swidth, swidth, cone,b( istartm, ihi-ns ), &
                        ldb, zc, ldzc, czero, work,sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ihi-ns ), ldb &
                        )
           end if
           if ( ilz ) then
              call stdlib_cgemm( 'N', 'N', n, ns+1, ns+1, cone, z( 1, ihi-ns ), ldz,zc, ldzc, &
                        czero, work, n )
              call stdlib_clacpy( 'ALL', n, ns+1, work, n, z( 1, ihi-ns ), ldz )
           end if
     end subroutine stdlib_claqz3

     module pure subroutine stdlib_zlaqz3( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_desired, alpha,&
     !! ZLAQZ3 Executes a single multishift QZ sweep
                beta, a, lda, b, ldb,q, ldq, z, ldz, qc, ldqc, zc, ldzc, work,lwork, info )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! function arguments
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(ilp), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,nshifts, &
                     nblock_desired, ldqc, ldzc
           complex(dp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq,* ), z( ldz, * ), qc( &
                     ldqc, * ), zc( ldzc, * ), work( * ),alpha( * ), beta( * )
           integer(ilp), intent( out ) :: info
           
           ! ================================================================
           ! local scalars
           integer(ilp) :: i, j, ns, istartm, istopm, sheight, swidth, k, np, istartb, istopb, &
                     ishift, nblock, npos
           real(dp) :: safmin, safmax, c, scale
           complex(dp) :: temp, temp2, temp3, s
           info = 0
           if ( nblock_desired < nshifts+1 ) then
              info = -8
           end if
           if ( lwork ==-1 ) then
              ! workspace query, quick return
              work( 1 ) = n*nblock_desired
              return
           else if ( lwork < n*nblock_desired ) then
              info = -25
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZLAQZ3', -info )
              return
           end if
           ! executable statements
           ! get machine constants
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_dlabad( safmin, safmax )
           if ( ilo >= ihi ) then
              return
           end if
           if ( ilschur ) then
              istartm = 1
              istopm = n
           else
              istartm = ilo
              istopm = ihi
           end if
           ns = nshifts
           npos = max( nblock_desired-ns, 1 )
           ! the following block introduces the shifts and chases
           ! them down one by one just enough to make space for
           ! the other shifts. the near-the-diagonal block is
           ! of size (ns+1) x ns.
           call stdlib_zlaset( 'FULL', ns+1, ns+1, czero, cone, qc, ldqc )
           call stdlib_zlaset( 'FULL', ns, ns, czero, cone, zc, ldzc )
           do i = 1, ns
              ! introduce the shift
              scale = sqrt( abs( alpha( i ) ) ) * sqrt( abs( beta( i ) ) )
              if( scale >= safmin .and. scale <= safmax ) then
                 alpha( i ) = alpha( i )/scale
                 beta( i ) = beta( i )/scale
              end if
              temp2 = beta( i )*a( ilo, ilo )-alpha( i )*b( ilo, ilo )
              temp3 = beta( i )*a( ilo+1, ilo )
              if ( abs( temp2 ) > safmax .or.abs( temp3 ) > safmax ) then
                 temp2 = cone
                 temp3 = czero
              end if
              call stdlib_zlartg( temp2, temp3, c, s, temp )
              call stdlib_zrot( ns, a( ilo, ilo ), lda, a( ilo+1, ilo ), lda, c,s )
              call stdlib_zrot( ns, b( ilo, ilo ), ldb, b( ilo+1, ilo ), ldb, c,s )
              call stdlib_zrot( ns+1, qc( 1, 1 ), 1, qc( 1, 2 ), 1, c,conjg( s ) )
              ! chase the shift down
              do j = 1, ns-i
                 call stdlib_zlaqz1( .true., .true., j, 1, ns, ihi-ilo+1, a( ilo,ilo ), lda, b( &
                           ilo, ilo ), ldb, ns+1, 1, qc,ldqc, ns, 1, zc, ldzc )
              end do
           end do
           ! update the rest of the pencil
           ! update a(ilo:ilo+ns,ilo+ns:istopm) and b(ilo:ilo+ns,ilo+ns:istopm)
           ! from the left with qc(1:ns+1,1:ns+1)'
           sheight = ns+1
           swidth = istopm-( ilo+ns )+1
           if ( swidth > 0 ) then
              call stdlib_zgemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,a( ilo, ilo+&
                        ns ), lda, czero, work, sheight )
              call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight, a( ilo,ilo+ns ), lda )
                        
              call stdlib_zgemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,b( ilo, ilo+&
                        ns ), ldb, czero, work, sheight )
              call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight, b( ilo,ilo+ns ), ldb )
                        
           end if
           if ( ilq ) then
              call stdlib_zgemm( 'N', 'N', n, sheight, sheight, cone, q( 1, ilo ),ldq, qc, ldqc, &
                        czero, work, n )
              call stdlib_zlacpy( 'ALL', n, sheight, work, n, q( 1, ilo ), ldq )
           end if
           ! update a(istartm:ilo-1,ilo:ilo+ns-1) and b(istartm:ilo-1,ilo:ilo+ns-1)
           ! from the right with zc(1:ns,1:ns)
           sheight = ilo-1-istartm+1
           swidth = ns
           if ( sheight > 0 ) then
              call stdlib_zgemm( 'N', 'N', sheight, swidth, swidth, cone,a( istartm, ilo ), lda, &
                        zc, ldzc, czero, work,sheight )
              call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ilo ), lda )
                        
              call stdlib_zgemm( 'N', 'N', sheight, swidth, swidth, cone,b( istartm, ilo ), ldb, &
                        zc, ldzc, czero, work,sheight )
              call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ilo ), ldb )
                        
           end if
           if ( ilz ) then
              call stdlib_zgemm( 'N', 'N', n, swidth, swidth, cone, z( 1, ilo ),ldz, zc, ldzc, &
                        czero, work, n )
              call stdlib_zlacpy( 'ALL', n, swidth, work, n, z( 1, ilo ), ldz )
           end if
           ! the following block chases the shifts down to the bottom
           ! right block. if possible, a shift is moved down npos
           ! positions at a time
           k = ilo
           do while ( k < ihi-ns )
              np = min( ihi-ns-k, npos )
              ! size of the near-the-diagonal block
              nblock = ns+np
              ! istartb points to the first row we will be updating
              istartb = k+1
              ! istopb points to the last column we will be updating
              istopb = k+nblock-1
              call stdlib_zlaset( 'FULL', ns+np, ns+np, czero, cone, qc, ldqc )
              call stdlib_zlaset( 'FULL', ns+np, ns+np, czero, cone, zc, ldzc )
              ! near the diagonal shift chase
              do i = ns-1, 0, -1
                 do j = 0, np-1
                    ! move down the block with index k+i+j, updating
                    ! the (ns+np x ns+np) block:
                    ! (k:k+ns+np,k:k+ns+np-1)
                    call stdlib_zlaqz1( .true., .true., k+i+j, istartb, istopb, ihi,a, lda, b, &
                              ldb, nblock, k+1, qc, ldqc,nblock, k, zc, ldzc )
                 end do
              end do
              ! update rest of the pencil
              ! update a(k+1:k+ns+np, k+ns+np:istopm) and
              ! b(k+1:k+ns+np, k+ns+np:istopm)
              ! from the left with qc(1:ns+np,1:ns+np)'
              sheight = ns+np
              swidth = istopm-( k+ns+np )+1
              if ( swidth > 0 ) then
                 call stdlib_zgemm( 'C', 'N', sheight, swidth, sheight, cone, qc,ldqc, a( k+1, k+&
                           ns+np ), lda, czero, work,sheight )
                 call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight, a( k+1,k+ns+np ), lda &
                           )
                 call stdlib_zgemm( 'C', 'N', sheight, swidth, sheight, cone, qc,ldqc, b( k+1, k+&
                           ns+np ), ldb, czero, work,sheight )
                 call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight, b( k+1,k+ns+np ), ldb &
                           )
              end if
              if ( ilq ) then
                 call stdlib_zgemm( 'N', 'N', n, nblock, nblock, cone, q( 1, k+1 ),ldq, qc, ldqc, &
                           czero, work, n )
                 call stdlib_zlacpy( 'ALL', n, nblock, work, n, q( 1, k+1 ), ldq )
              end if
              ! update a(istartm:k,k:k+ns+npos-1) and b(istartm:k,k:k+ns+npos-1)
              ! from the right with zc(1:ns+np,1:ns+np)
              sheight = k-istartm+1
              swidth = nblock
              if ( sheight > 0 ) then
                 call stdlib_zgemm( 'N', 'N', sheight, swidth, swidth, cone,a( istartm, k ), lda, &
                           zc, ldzc, czero, work,sheight )
                 call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight,a( istartm, k ), lda )
                           
                 call stdlib_zgemm( 'N', 'N', sheight, swidth, swidth, cone,b( istartm, k ), ldb, &
                           zc, ldzc, czero, work,sheight )
                 call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight,b( istartm, k ), ldb )
                           
              end if
              if ( ilz ) then
                 call stdlib_zgemm( 'N', 'N', n, nblock, nblock, cone, z( 1, k ),ldz, zc, ldzc, &
                           czero, work, n )
                 call stdlib_zlacpy( 'ALL', n, nblock, work, n, z( 1, k ), ldz )
              end if
              k = k+np
           end do
           ! the following block removes the shifts from the bottom right corner
           ! one by one. updates are initially applied to a(ihi-ns+1:ihi,ihi-ns:ihi).
           call stdlib_zlaset( 'FULL', ns, ns, czero, cone, qc, ldqc )
           call stdlib_zlaset( 'FULL', ns+1, ns+1, czero, cone, zc, ldzc )
           ! istartb points to the first row we will be updating
           istartb = ihi-ns+1
           ! istopb points to the last column we will be updating
           istopb = ihi
           do i = 1, ns
              ! chase the shift down to the bottom right corner
              do ishift = ihi-i, ihi-1
                 call stdlib_zlaqz1( .true., .true., ishift, istartb, istopb, ihi,a, lda, b, ldb, &
                           ns, ihi-ns+1, qc, ldqc, ns+1,ihi-ns, zc, ldzc )
              end do
           end do
           ! update rest of the pencil
           ! update a(ihi-ns+1:ihi, ihi+1:istopm)
           ! from the left with qc(1:ns,1:ns)'
           sheight = ns
           swidth = istopm-( ihi+1 )+1
           if ( swidth > 0 ) then
              call stdlib_zgemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,a( ihi-ns+1, &
                        ihi+1 ), lda, czero, work, sheight )
              call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight,a( ihi-ns+1, ihi+1 ), lda &
                        )
              call stdlib_zgemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,b( ihi-ns+1, &
                        ihi+1 ), ldb, czero, work, sheight )
              call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight,b( ihi-ns+1, ihi+1 ), ldb &
                        )
           end if
           if ( ilq ) then
              call stdlib_zgemm( 'N', 'N', n, ns, ns, cone, q( 1, ihi-ns+1 ), ldq,qc, ldqc, czero,&
                         work, n )
              call stdlib_zlacpy( 'ALL', n, ns, work, n, q( 1, ihi-ns+1 ), ldq )
           end if
           ! update a(istartm:ihi-ns,ihi-ns:ihi)
           ! from the right with zc(1:ns+1,1:ns+1)
           sheight = ihi-ns-istartm+1
           swidth = ns+1
           if ( sheight > 0 ) then
              call stdlib_zgemm( 'N', 'N', sheight, swidth, swidth, cone,a( istartm, ihi-ns ), &
                        lda, zc, ldzc, czero, work,sheight )
              call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ihi-ns ), lda &
                        )
              call stdlib_zgemm( 'N', 'N', sheight, swidth, swidth, cone,b( istartm, ihi-ns ), &
                        ldb, zc, ldzc, czero, work,sheight )
              call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ihi-ns ), ldb &
                        )
           end if
           if ( ilz ) then
              call stdlib_zgemm( 'N', 'N', n, ns+1, ns+1, cone, z( 1, ihi-ns ), ldz,zc, ldzc, &
                        czero, work, n )
              call stdlib_zlacpy( 'ALL', n, ns+1, work, n, z( 1, ihi-ns ), ldz )
           end if
     end subroutine stdlib_zlaqz3

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$laqz3( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_qesired, alpha,&
     !! ZLAQZ3: Executes a single multishift QZ sweep
                beta, a, lda, b, ldb,q, ldq, z, ldz, qc, ldqc, zc, ldzc, work,lwork, info )
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! function arguments
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(ilp), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,nshifts, &
                     nblock_qesired, ldqc, ldzc
           complex(${ck}$), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq,* ), z( ldz, * ), qc( &
                     ldqc, * ), zc( ldzc, * ), work( * ),alpha( * ), beta( * )
           integer(ilp), intent( out ) :: info
           
           ! ================================================================
           ! local scalars
           integer(ilp) :: i, j, ns, istartm, istopm, sheight, swidth, k, np, istartb, istopb, &
                     ishift, nblock, npos
           real(${ck}$) :: safmin, safmax, c, scale
           complex(${ck}$) :: temp, temp2, temp3, s
           info = 0
           if ( nblock_qesired < nshifts+1 ) then
              info = -8
           end if
           if ( lwork ==-1 ) then
              ! workspace query, quick return
              work( 1 ) = n*nblock_qesired
              return
           else if ( lwork < n*nblock_qesired ) then
              info = -25
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZLAQZ3', -info )
              return
           end if
           ! executable statements
           ! get machine constants
           safmin = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_${c2ri(ci)}$labad( safmin, safmax )
           if ( ilo >= ihi ) then
              return
           end if
           if ( ilschur ) then
              istartm = 1
              istopm = n
           else
              istartm = ilo
              istopm = ihi
           end if
           ns = nshifts
           npos = max( nblock_qesired-ns, 1 )
           ! the following block introduces the shifts and chases
           ! them down one by one just enough to make space for
           ! the other shifts. the near-the-diagonal block is
           ! of size (ns+1) x ns.
           call stdlib_${ci}$laset( 'FULL', ns+1, ns+1, czero, cone, qc, ldqc )
           call stdlib_${ci}$laset( 'FULL', ns, ns, czero, cone, zc, ldzc )
           do i = 1, ns
              ! introduce the shift
              scale = sqrt( abs( alpha( i ) ) ) * sqrt( abs( beta( i ) ) )
              if( scale >= safmin .and. scale <= safmax ) then
                 alpha( i ) = alpha( i )/scale
                 beta( i ) = beta( i )/scale
              end if
              temp2 = beta( i )*a( ilo, ilo )-alpha( i )*b( ilo, ilo )
              temp3 = beta( i )*a( ilo+1, ilo )
              if ( abs( temp2 ) > safmax .or.abs( temp3 ) > safmax ) then
                 temp2 = cone
                 temp3 = czero
              end if
              call stdlib_${ci}$lartg( temp2, temp3, c, s, temp )
              call stdlib_${ci}$rot( ns, a( ilo, ilo ), lda, a( ilo+1, ilo ), lda, c,s )
              call stdlib_${ci}$rot( ns, b( ilo, ilo ), ldb, b( ilo+1, ilo ), ldb, c,s )
              call stdlib_${ci}$rot( ns+1, qc( 1, 1 ), 1, qc( 1, 2 ), 1, c,conjg( s ) )
              ! chase the shift down
              do j = 1, ns-i
                 call stdlib_${ci}$laqz1( .true., .true., j, 1, ns, ihi-ilo+1, a( ilo,ilo ), lda, b( &
                           ilo, ilo ), ldb, ns+1, 1, qc,ldqc, ns, 1, zc, ldzc )
              end do
           end do
           ! update the rest of the pencil
           ! update a(ilo:ilo+ns,ilo+ns:istopm) and b(ilo:ilo+ns,ilo+ns:istopm)
           ! from the left with qc(1:ns+1,1:ns+1)'
           sheight = ns+1
           swidth = istopm-( ilo+ns )+1
           if ( swidth > 0 ) then
              call stdlib_${ci}$gemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,a( ilo, ilo+&
                        ns ), lda, czero, work, sheight )
              call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight, a( ilo,ilo+ns ), lda )
                        
              call stdlib_${ci}$gemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,b( ilo, ilo+&
                        ns ), ldb, czero, work, sheight )
              call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight, b( ilo,ilo+ns ), ldb )
                        
           end if
           if ( ilq ) then
              call stdlib_${ci}$gemm( 'N', 'N', n, sheight, sheight, cone, q( 1, ilo ),ldq, qc, ldqc, &
                        czero, work, n )
              call stdlib_${ci}$lacpy( 'ALL', n, sheight, work, n, q( 1, ilo ), ldq )
           end if
           ! update a(istartm:ilo-1,ilo:ilo+ns-1) and b(istartm:ilo-1,ilo:ilo+ns-1)
           ! from the right with zc(1:ns,1:ns)
           sheight = ilo-1-istartm+1
           swidth = ns
           if ( sheight > 0 ) then
              call stdlib_${ci}$gemm( 'N', 'N', sheight, swidth, swidth, cone,a( istartm, ilo ), lda, &
                        zc, ldzc, czero, work,sheight )
              call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ilo ), lda )
                        
              call stdlib_${ci}$gemm( 'N', 'N', sheight, swidth, swidth, cone,b( istartm, ilo ), ldb, &
                        zc, ldzc, czero, work,sheight )
              call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ilo ), ldb )
                        
           end if
           if ( ilz ) then
              call stdlib_${ci}$gemm( 'N', 'N', n, swidth, swidth, cone, z( 1, ilo ),ldz, zc, ldzc, &
                        czero, work, n )
              call stdlib_${ci}$lacpy( 'ALL', n, swidth, work, n, z( 1, ilo ), ldz )
           end if
           ! the following block chases the shifts down to the bottom
           ! right block. if possible, a shift is moved down npos
           ! positions at a time
           k = ilo
           do while ( k < ihi-ns )
              np = min( ihi-ns-k, npos )
              ! size of the near-the-diagonal block
              nblock = ns+np
              ! istartb points to the first row we will be updating
              istartb = k+1
              ! istopb points to the last column we will be updating
              istopb = k+nblock-1
              call stdlib_${ci}$laset( 'FULL', ns+np, ns+np, czero, cone, qc, ldqc )
              call stdlib_${ci}$laset( 'FULL', ns+np, ns+np, czero, cone, zc, ldzc )
              ! near the diagonal shift chase
              do i = ns-1, 0, -1
                 do j = 0, np-1
                    ! move down the block with index k+i+j, updating
                    ! the (ns+np x ns+np) block:
                    ! (k:k+ns+np,k:k+ns+np-1)
                    call stdlib_${ci}$laqz1( .true., .true., k+i+j, istartb, istopb, ihi,a, lda, b, &
                              ldb, nblock, k+1, qc, ldqc,nblock, k, zc, ldzc )
                 end do
              end do
              ! update rest of the pencil
              ! update a(k+1:k+ns+np, k+ns+np:istopm) and
              ! b(k+1:k+ns+np, k+ns+np:istopm)
              ! from the left with qc(1:ns+np,1:ns+np)'
              sheight = ns+np
              swidth = istopm-( k+ns+np )+1
              if ( swidth > 0 ) then
                 call stdlib_${ci}$gemm( 'C', 'N', sheight, swidth, sheight, cone, qc,ldqc, a( k+1, k+&
                           ns+np ), lda, czero, work,sheight )
                 call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight, a( k+1,k+ns+np ), lda &
                           )
                 call stdlib_${ci}$gemm( 'C', 'N', sheight, swidth, sheight, cone, qc,ldqc, b( k+1, k+&
                           ns+np ), ldb, czero, work,sheight )
                 call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight, b( k+1,k+ns+np ), ldb &
                           )
              end if
              if ( ilq ) then
                 call stdlib_${ci}$gemm( 'N', 'N', n, nblock, nblock, cone, q( 1, k+1 ),ldq, qc, ldqc, &
                           czero, work, n )
                 call stdlib_${ci}$lacpy( 'ALL', n, nblock, work, n, q( 1, k+1 ), ldq )
              end if
              ! update a(istartm:k,k:k+ns+npos-1) and b(istartm:k,k:k+ns+npos-1)
              ! from the right with zc(1:ns+np,1:ns+np)
              sheight = k-istartm+1
              swidth = nblock
              if ( sheight > 0 ) then
                 call stdlib_${ci}$gemm( 'N', 'N', sheight, swidth, swidth, cone,a( istartm, k ), lda, &
                           zc, ldzc, czero, work,sheight )
                 call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight,a( istartm, k ), lda )
                           
                 call stdlib_${ci}$gemm( 'N', 'N', sheight, swidth, swidth, cone,b( istartm, k ), ldb, &
                           zc, ldzc, czero, work,sheight )
                 call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight,b( istartm, k ), ldb )
                           
              end if
              if ( ilz ) then
                 call stdlib_${ci}$gemm( 'N', 'N', n, nblock, nblock, cone, z( 1, k ),ldz, zc, ldzc, &
                           czero, work, n )
                 call stdlib_${ci}$lacpy( 'ALL', n, nblock, work, n, z( 1, k ), ldz )
              end if
              k = k+np
           end do
           ! the following block removes the shifts from the bottom right corner
           ! one by one. updates are initially applied to a(ihi-ns+1:ihi,ihi-ns:ihi).
           call stdlib_${ci}$laset( 'FULL', ns, ns, czero, cone, qc, ldqc )
           call stdlib_${ci}$laset( 'FULL', ns+1, ns+1, czero, cone, zc, ldzc )
           ! istartb points to the first row we will be updating
           istartb = ihi-ns+1
           ! istopb points to the last column we will be updating
           istopb = ihi
           do i = 1, ns
              ! chase the shift down to the bottom right corner
              do ishift = ihi-i, ihi-1
                 call stdlib_${ci}$laqz1( .true., .true., ishift, istartb, istopb, ihi,a, lda, b, ldb, &
                           ns, ihi-ns+1, qc, ldqc, ns+1,ihi-ns, zc, ldzc )
              end do
           end do
           ! update rest of the pencil
           ! update a(ihi-ns+1:ihi, ihi+1:istopm)
           ! from the left with qc(1:ns,1:ns)'
           sheight = ns
           swidth = istopm-( ihi+1 )+1
           if ( swidth > 0 ) then
              call stdlib_${ci}$gemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,a( ihi-ns+1, &
                        ihi+1 ), lda, czero, work, sheight )
              call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight,a( ihi-ns+1, ihi+1 ), lda &
                        )
              call stdlib_${ci}$gemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,b( ihi-ns+1, &
                        ihi+1 ), ldb, czero, work, sheight )
              call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight,b( ihi-ns+1, ihi+1 ), ldb &
                        )
           end if
           if ( ilq ) then
              call stdlib_${ci}$gemm( 'N', 'N', n, ns, ns, cone, q( 1, ihi-ns+1 ), ldq,qc, ldqc, czero,&
                         work, n )
              call stdlib_${ci}$lacpy( 'ALL', n, ns, work, n, q( 1, ihi-ns+1 ), ldq )
           end if
           ! update a(istartm:ihi-ns,ihi-ns:ihi)
           ! from the right with zc(1:ns+1,1:ns+1)
           sheight = ihi-ns-istartm+1
           swidth = ns+1
           if ( sheight > 0 ) then
              call stdlib_${ci}$gemm( 'N', 'N', sheight, swidth, swidth, cone,a( istartm, ihi-ns ), &
                        lda, zc, ldzc, czero, work,sheight )
              call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ihi-ns ), lda &
                        )
              call stdlib_${ci}$gemm( 'N', 'N', sheight, swidth, swidth, cone,b( istartm, ihi-ns ), &
                        ldb, zc, ldzc, czero, work,sheight )
              call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ihi-ns ), ldb &
                        )
           end if
           if ( ilz ) then
              call stdlib_${ci}$gemm( 'N', 'N', n, ns+1, ns+1, cone, z( 1, ihi-ns ), ldz,zc, ldzc, &
                        czero, work, n )
              call stdlib_${ci}$lacpy( 'ALL', n, ns+1, work, n, z( 1, ihi-ns ), ldz )
           end if
     end subroutine stdlib_${ci}$laqz3

#:endif
#:endfor



     module pure subroutine stdlib_sgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! SGEHRD reduces a real general matrix A to upper Hessenberg form H by
     !! an orthogonal similarity transformation:  Q**T * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iwt, j, ldwork, lwkopt, nb, nbmin, nh, nx
           real(sp) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
             ! compute the workspace requirements
              nb = min( nbmax, stdlib_ilaenv( 1, 'SGEHRD', ' ', n, ilo, ihi, -1 ) )
              lwkopt = n*nb + tsize
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGEHRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! set elements 1:ilo-1 and ihi:n-1 of tau to zero
           do i = 1, ilo - 1
              tau( i ) = zero
           end do
           do i = max( 1, ihi ), n - 1
              tau( i ) = zero
           end do
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = 1
              return
           end if
           ! determine the block size
           nb = min( nbmax, stdlib_ilaenv( 1, 'SGEHRD', ' ', n, ilo, ihi, -1 ) )
           nbmin = 2
           if( nb>1 .and. nb<nh ) then
              ! determine when to cross over from blocked to unblocked code
              ! (last block is always handled by unblocked code)
              nx = max( nb, stdlib_ilaenv( 3, 'SGEHRD', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code
                 if( lwork<n*nb+tsize ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code
                    nbmin = max( 2, stdlib_ilaenv( 2, 'SGEHRD', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=(n*nbmin + tsize) ) then
                       nb = (lwork-tsize) / n
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           ldwork = n
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              i = ilo
           else
              ! use blocked code
              iwt = 1 + n*nb
              do i = ilo, ihi - 1 - nx, nb
                 ib = min( nb, ihi-i )
                 ! reduce columns i:i+ib-1 to hessenberg form, returning the
                 ! matrices v and t of the block reflector h = i - v*t*v**t
                 ! which performs the reduction, and also the matrix y = a*v*t
                 call stdlib_slahr2( ihi, i, ib, a( 1, i ), lda, tau( i ),work( iwt ), ldt, work, &
                           ldwork )
                 ! apply the block reflector h to a(1:ihi,i+ib:ihi) from the
                 ! right, computing  a := a - y * v**t. v(i+ib,ib-1) must be set
                 ! to 1
                 ei = a( i+ib, i+ib-1 )
                 a( i+ib, i+ib-1 ) = one
                 call stdlib_sgemm( 'NO TRANSPOSE', 'TRANSPOSE',ihi, ihi-i-ib+1,ib, -one, work, &
                           ldwork, a( i+ib, i ), lda, one,a( 1, i+ib ), lda )
                 a( i+ib, i+ib-1 ) = ei
                 ! apply the block reflector h to a(1:i,i+1:i+ib-1) from the
                 ! right
                 call stdlib_strmm( 'RIGHT', 'LOWER', 'TRANSPOSE','UNIT', i, ib-1,one, a( i+1, i )&
                           , lda, work, ldwork )
                 do j = 0, ib-2
                    call stdlib_saxpy( i, -one, work( ldwork*j+1 ), 1,a( 1, i+j+1 ), 1 )
                 end do
                 ! apply the block reflector h to a(i+1:ihi,i+ib:n) from the
                 ! left
                 call stdlib_slarfb( 'LEFT', 'TRANSPOSE', 'FORWARD','COLUMNWISE',ihi-i, n-i-ib+1, &
                           ib, a( i+1, i ), lda,work( iwt ), ldt, a( i+1, i+ib ), lda,work, ldwork )
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           call stdlib_sgehd2( n, i, ihi, a, lda, tau, work, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_sgehrd

     module pure subroutine stdlib_dgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! DGEHRD reduces a real general matrix A to upper Hessenberg form H by
     !! an orthogonal similarity transformation:  Q**T * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iwt, j, ldwork, lwkopt, nb, nbmin, nh, nx
           real(dp) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              nb = min( nbmax, stdlib_ilaenv( 1, 'DGEHRD', ' ', n, ilo, ihi, -1 ) )
              lwkopt = n*nb + tsize
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEHRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! set elements 1:ilo-1 and ihi:n-1 of tau to zero
           do i = 1, ilo - 1
              tau( i ) = zero
           end do
           do i = max( 1, ihi ), n - 1
              tau( i ) = zero
           end do
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = 1
              return
           end if
           ! determine the block size
           nb = min( nbmax, stdlib_ilaenv( 1, 'DGEHRD', ' ', n, ilo, ihi, -1 ) )
           nbmin = 2
           if( nb>1 .and. nb<nh ) then
              ! determine when to cross over from blocked to unblocked code
              ! (last block is always handled by unblocked code)
              nx = max( nb, stdlib_ilaenv( 3, 'DGEHRD', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code
                 if( lwork<n*nb+tsize ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code
                    nbmin = max( 2, stdlib_ilaenv( 2, 'DGEHRD', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=(n*nbmin + tsize) ) then
                       nb = (lwork-tsize) / n
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           ldwork = n
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              i = ilo
           else
              ! use blocked code
              iwt = 1 + n*nb
              do i = ilo, ihi - 1 - nx, nb
                 ib = min( nb, ihi-i )
                 ! reduce columns i:i+ib-1 to hessenberg form, returning the
                 ! matrices v and t of the block reflector h = i - v*t*v**t
                 ! which performs the reduction, and also the matrix y = a*v*t
                 call stdlib_dlahr2( ihi, i, ib, a( 1, i ), lda, tau( i ),work( iwt ), ldt, work, &
                           ldwork )
                 ! apply the block reflector h to a(1:ihi,i+ib:ihi) from the
                 ! right, computing  a := a - y * v**t. v(i+ib,ib-1) must be set
                 ! to 1
                 ei = a( i+ib, i+ib-1 )
                 a( i+ib, i+ib-1 ) = one
                 call stdlib_dgemm( 'NO TRANSPOSE', 'TRANSPOSE',ihi, ihi-i-ib+1,ib, -one, work, &
                           ldwork, a( i+ib, i ), lda, one,a( 1, i+ib ), lda )
                 a( i+ib, i+ib-1 ) = ei
                 ! apply the block reflector h to a(1:i,i+1:i+ib-1) from the
                 ! right
                 call stdlib_dtrmm( 'RIGHT', 'LOWER', 'TRANSPOSE','UNIT', i, ib-1,one, a( i+1, i )&
                           , lda, work, ldwork )
                 do j = 0, ib-2
                    call stdlib_daxpy( i, -one, work( ldwork*j+1 ), 1,a( 1, i+j+1 ), 1 )
                 end do
                 ! apply the block reflector h to a(i+1:ihi,i+ib:n) from the
                 ! left
                 call stdlib_dlarfb( 'LEFT', 'TRANSPOSE', 'FORWARD','COLUMNWISE',ihi-i, n-i-ib+1, &
                           ib, a( i+1, i ), lda,work( iwt ), ldt, a( i+1, i+ib ), lda,work, ldwork )
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           call stdlib_dgehd2( n, i, ihi, a, lda, tau, work, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dgehrd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$gehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! DGEHRD: reduces a real general matrix A to upper Hessenberg form H by
     !! an orthogonal similarity transformation:  Q**T * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iwt, j, ldwork, lwkopt, nb, nbmin, nh, nx
           real(${rk}$) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              nb = min( nbmax, stdlib_ilaenv( 1, 'DGEHRD', ' ', n, ilo, ihi, -1 ) )
              lwkopt = n*nb + tsize
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEHRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! set elements 1:ilo-1 and ihi:n-1 of tau to zero
           do i = 1, ilo - 1
              tau( i ) = zero
           end do
           do i = max( 1, ihi ), n - 1
              tau( i ) = zero
           end do
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = 1
              return
           end if
           ! determine the block size
           nb = min( nbmax, stdlib_ilaenv( 1, 'DGEHRD', ' ', n, ilo, ihi, -1 ) )
           nbmin = 2
           if( nb>1 .and. nb<nh ) then
              ! determine when to cross over from blocked to unblocked code
              ! (last block is always handled by unblocked code)
              nx = max( nb, stdlib_ilaenv( 3, 'DGEHRD', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code
                 if( lwork<n*nb+tsize ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code
                    nbmin = max( 2, stdlib_ilaenv( 2, 'DGEHRD', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=(n*nbmin + tsize) ) then
                       nb = (lwork-tsize) / n
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           ldwork = n
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              i = ilo
           else
              ! use blocked code
              iwt = 1 + n*nb
              do i = ilo, ihi - 1 - nx, nb
                 ib = min( nb, ihi-i )
                 ! reduce columns i:i+ib-1 to hessenberg form, returning the
                 ! matrices v and t of the block reflector h = i - v*t*v**t
                 ! which performs the reduction, and also the matrix y = a*v*t
                 call stdlib_${ri}$lahr2( ihi, i, ib, a( 1, i ), lda, tau( i ),work( iwt ), ldt, work, &
                           ldwork )
                 ! apply the block reflector h to a(1:ihi,i+ib:ihi) from the
                 ! right, computing  a := a - y * v**t. v(i+ib,ib-1) must be set
                 ! to 1
                 ei = a( i+ib, i+ib-1 )
                 a( i+ib, i+ib-1 ) = one
                 call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE',ihi, ihi-i-ib+1,ib, -one, work, &
                           ldwork, a( i+ib, i ), lda, one,a( 1, i+ib ), lda )
                 a( i+ib, i+ib-1 ) = ei
                 ! apply the block reflector h to a(1:i,i+1:i+ib-1) from the
                 ! right
                 call stdlib_${ri}$trmm( 'RIGHT', 'LOWER', 'TRANSPOSE','UNIT', i, ib-1,one, a( i+1, i )&
                           , lda, work, ldwork )
                 do j = 0, ib-2
                    call stdlib_${ri}$axpy( i, -one, work( ldwork*j+1 ), 1,a( 1, i+j+1 ), 1 )
                 end do
                 ! apply the block reflector h to a(i+1:ihi,i+ib:n) from the
                 ! left
                 call stdlib_${ri}$larfb( 'LEFT', 'TRANSPOSE', 'FORWARD','COLUMNWISE',ihi-i, n-i-ib+1, &
                           ib, a( i+1, i ), lda,work( iwt ), ldt, a( i+1, i+ib ), lda,work, ldwork )
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           call stdlib_${ri}$gehd2( n, i, ihi, a, lda, tau, work, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$gehrd

#:endif
#:endfor

     module pure subroutine stdlib_cgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! CGEHRD reduces a complex general matrix A to upper Hessenberg form H by
     !! an unitary similarity transformation:  Q**H * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iwt, j, ldwork, lwkopt, nb, nbmin, nh, nx
           complex(sp) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              nb = min( nbmax, stdlib_ilaenv( 1, 'CGEHRD', ' ', n, ilo, ihi, -1 ) )
              lwkopt = n*nb + tsize
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEHRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! set elements 1:ilo-1 and ihi:n-1 of tau to czero
           do i = 1, ilo - 1
              tau( i ) = czero
           end do
           do i = max( 1, ihi ), n - 1
              tau( i ) = czero
           end do
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = 1
              return
           end if
           ! determine the block size
           nb = min( nbmax, stdlib_ilaenv( 1, 'CGEHRD', ' ', n, ilo, ihi, -1 ) )
           nbmin = 2
           if( nb>1 .and. nb<nh ) then
              ! determine when to cross over from blocked to unblocked code
              ! (last block is always handled by unblocked code)
              nx = max( nb, stdlib_ilaenv( 3, 'CGEHRD', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code
                 if( lwork<n*nb+tsize ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code
                    nbmin = max( 2, stdlib_ilaenv( 2, 'CGEHRD', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=(n*nbmin+tsize) ) then
                       nb = (lwork-tsize) / n
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           ldwork = n
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              i = ilo
           else
              ! use blocked code
              iwt = 1 + n*nb
              do i = ilo, ihi - 1 - nx, nb
                 ib = min( nb, ihi-i )
                 ! reduce columns i:i+ib-1 to hessenberg form, returning the
                 ! matrices v and t of the block reflector h = i - v*t*v**h
                 ! which performs the reduction, and also the matrix y = a*v*t
                 call stdlib_clahr2( ihi, i, ib, a( 1, i ), lda, tau( i ),work( iwt ), ldt, work, &
                           ldwork )
                 ! apply the block reflector h to a(1:ihi,i+ib:ihi) from the
                 ! right, computing  a := a - y * v**h. v(i+ib,ib-1) must be set
                 ! to 1
                 ei = a( i+ib, i+ib-1 )
                 a( i+ib, i+ib-1 ) = cone
                 call stdlib_cgemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE',ihi, ihi-i-ib+1,ib, -&
                           cone, work, ldwork, a( i+ib, i ), lda, cone,a( 1, i+ib ), lda )
                 a( i+ib, i+ib-1 ) = ei
                 ! apply the block reflector h to a(1:i,i+1:i+ib-1) from the
                 ! right
                 call stdlib_ctrmm( 'RIGHT', 'LOWER', 'CONJUGATE TRANSPOSE','UNIT', i, ib-1,cone, &
                           a( i+1, i ), lda, work, ldwork )
                 do j = 0, ib-2
                    call stdlib_caxpy( i, -cone, work( ldwork*j+1 ), 1,a( 1, i+j+1 ), 1 )
                 end do
                 ! apply the block reflector h to a(i+1:ihi,i+ib:n) from the
                 ! left
                 call stdlib_clarfb( 'LEFT', 'CONJUGATE TRANSPOSE', 'FORWARD','COLUMNWISE',ihi-i, &
                 n-i-ib+1, ib, a( i+1, i ), lda,work( iwt ), ldt, a( i+1, i+ib ), lda,work, &
                           ldwork )
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           call stdlib_cgehd2( n, i, ihi, a, lda, tau, work, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cgehrd

     module pure subroutine stdlib_zgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! ZGEHRD reduces a complex general matrix A to upper Hessenberg form H by
     !! an unitary similarity transformation:  Q**H * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iwt, j, ldwork, lwkopt, nb, nbmin, nh, nx
           complex(dp) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              nb = min( nbmax, stdlib_ilaenv( 1, 'ZGEHRD', ' ', n, ilo, ihi, -1 ) )
              lwkopt = n*nb + tsize
              work( 1 ) = lwkopt
           endif
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEHRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! set elements 1:ilo-1 and ihi:n-1 of tau to czero
           do i = 1, ilo - 1
              tau( i ) = czero
           end do
           do i = max( 1, ihi ), n - 1
              tau( i ) = czero
           end do
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = 1
              return
           end if
           ! determine the block size
           nb = min( nbmax, stdlib_ilaenv( 1, 'ZGEHRD', ' ', n, ilo, ihi, -1 ) )
           nbmin = 2
           if( nb>1 .and. nb<nh ) then
              ! determine when to cross over from blocked to unblocked code
              ! (last block is always handled by unblocked code)
              nx = max( nb, stdlib_ilaenv( 3, 'ZGEHRD', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code
                 if( lwork<n*nb+tsize ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code
                    nbmin = max( 2, stdlib_ilaenv( 2, 'ZGEHRD', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=(n*nbmin + tsize) ) then
                       nb = (lwork-tsize) / n
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           ldwork = n
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              i = ilo
           else
              ! use blocked code
              iwt = 1 + n*nb
              do i = ilo, ihi - 1 - nx, nb
                 ib = min( nb, ihi-i )
                 ! reduce columns i:i+ib-1 to hessenberg form, returning the
                 ! matrices v and t of the block reflector h = i - v*t*v**h
                 ! which performs the reduction, and also the matrix y = a*v*t
                 call stdlib_zlahr2( ihi, i, ib, a( 1, i ), lda, tau( i ),work( iwt ), ldt, work, &
                           ldwork )
                 ! apply the block reflector h to a(1:ihi,i+ib:ihi) from the
                 ! right, computing  a := a - y * v**h. v(i+ib,ib-1) must be set
                 ! to 1
                 ei = a( i+ib, i+ib-1 )
                 a( i+ib, i+ib-1 ) = cone
                 call stdlib_zgemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE',ihi, ihi-i-ib+1,ib, -&
                           cone, work, ldwork, a( i+ib, i ), lda, cone,a( 1, i+ib ), lda )
                 a( i+ib, i+ib-1 ) = ei
                 ! apply the block reflector h to a(1:i,i+1:i+ib-1) from the
                 ! right
                 call stdlib_ztrmm( 'RIGHT', 'LOWER', 'CONJUGATE TRANSPOSE','UNIT', i, ib-1,cone, &
                           a( i+1, i ), lda, work, ldwork )
                 do j = 0, ib-2
                    call stdlib_zaxpy( i, -cone, work( ldwork*j+1 ), 1,a( 1, i+j+1 ), 1 )
                 end do
                 ! apply the block reflector h to a(i+1:ihi,i+ib:n) from the
                 ! left
                 call stdlib_zlarfb( 'LEFT', 'CONJUGATE TRANSPOSE', 'FORWARD','COLUMNWISE',ihi-i, &
                 n-i-ib+1, ib, a( i+1, i ), lda,work( iwt ), ldt, a( i+1, i+ib ), lda,work, &
                           ldwork )
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           call stdlib_zgehd2( n, i, ihi, a, lda, tau, work, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zgehrd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$gehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! ZGEHRD: reduces a complex general matrix A to upper Hessenberg form H by
     !! an unitary similarity transformation:  Q**H * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iwt, j, ldwork, lwkopt, nb, nbmin, nh, nx
           complex(${ck}$) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              nb = min( nbmax, stdlib_ilaenv( 1, 'ZGEHRD', ' ', n, ilo, ihi, -1 ) )
              lwkopt = n*nb + tsize
              work( 1 ) = lwkopt
           endif
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEHRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! set elements 1:ilo-1 and ihi:n-1 of tau to czero
           do i = 1, ilo - 1
              tau( i ) = czero
           end do
           do i = max( 1, ihi ), n - 1
              tau( i ) = czero
           end do
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = 1
              return
           end if
           ! determine the block size
           nb = min( nbmax, stdlib_ilaenv( 1, 'ZGEHRD', ' ', n, ilo, ihi, -1 ) )
           nbmin = 2
           if( nb>1 .and. nb<nh ) then
              ! determine when to cross over from blocked to unblocked code
              ! (last block is always handled by unblocked code)
              nx = max( nb, stdlib_ilaenv( 3, 'ZGEHRD', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code
                 if( lwork<n*nb+tsize ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code
                    nbmin = max( 2, stdlib_ilaenv( 2, 'ZGEHRD', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=(n*nbmin + tsize) ) then
                       nb = (lwork-tsize) / n
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           ldwork = n
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              i = ilo
           else
              ! use blocked code
              iwt = 1 + n*nb
              do i = ilo, ihi - 1 - nx, nb
                 ib = min( nb, ihi-i )
                 ! reduce columns i:i+ib-1 to hessenberg form, returning the
                 ! matrices v and t of the block reflector h = i - v*t*v**h
                 ! which performs the reduction, and also the matrix y = a*v*t
                 call stdlib_${ci}$lahr2( ihi, i, ib, a( 1, i ), lda, tau( i ),work( iwt ), ldt, work, &
                           ldwork )
                 ! apply the block reflector h to a(1:ihi,i+ib:ihi) from the
                 ! right, computing  a := a - y * v**h. v(i+ib,ib-1) must be set
                 ! to 1
                 ei = a( i+ib, i+ib-1 )
                 a( i+ib, i+ib-1 ) = cone
                 call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE',ihi, ihi-i-ib+1,ib, -&
                           cone, work, ldwork, a( i+ib, i ), lda, cone,a( 1, i+ib ), lda )
                 a( i+ib, i+ib-1 ) = ei
                 ! apply the block reflector h to a(1:i,i+1:i+ib-1) from the
                 ! right
                 call stdlib_${ci}$trmm( 'RIGHT', 'LOWER', 'CONJUGATE TRANSPOSE','UNIT', i, ib-1,cone, &
                           a( i+1, i ), lda, work, ldwork )
                 do j = 0, ib-2
                    call stdlib_${ci}$axpy( i, -cone, work( ldwork*j+1 ), 1,a( 1, i+j+1 ), 1 )
                 end do
                 ! apply the block reflector h to a(i+1:ihi,i+ib:n) from the
                 ! left
                 call stdlib_${ci}$larfb( 'LEFT', 'CONJUGATE TRANSPOSE', 'FORWARD','COLUMNWISE',ihi-i, &
                 n-i-ib+1, ib, a( i+1, i ), lda,work( iwt ), ldt, a( i+1, i+ib ), lda,work, &
                           ldwork )
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           call stdlib_${ci}$gehd2( n, i, ihi, a, lda, tau, work, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$gehrd

#:endif
#:endfor



     module pure subroutine stdlib_sgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
     !! SGEBAK forms the right or left eigenvectors of a real general matrix
     !! by backward transformation on the computed eigenvectors of the
     !! balanced matrix output by SGEBAL.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(inout) :: v(ldv,*)
           real(sp), intent(in) :: scale(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, ii, k
           real(sp) :: s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( m<0 ) then
              info = -7
           else if( ldv<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGEBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 do i = ilo, ihi
                    s = scale( i )
                    call stdlib_sscal( m, s, v( i, 1 ), ldv )
                 end do
              end if
              if( leftv ) then
                 do i = ilo, ihi
                    s = one / scale( i )
                    call stdlib_sscal( m, s, v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           ! for  i = ilo-1 step -1 until 1,
                    ! ihi+1 step 1 until n do --
                    30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 loop_40: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_40
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_40
                    call stdlib_sswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
              end if
              if( leftv ) then
                 loop_50: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_50
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_50
                    call stdlib_sswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_50
              end if
           end if
           return
     end subroutine stdlib_sgebak

     module pure subroutine stdlib_dgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
     !! DGEBAK forms the right or left eigenvectors of a real general matrix
     !! by backward transformation on the computed eigenvectors of the
     !! balanced matrix output by DGEBAL.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(in) :: scale(*)
           real(dp), intent(inout) :: v(ldv,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, ii, k
           real(dp) :: s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( m<0 ) then
              info = -7
           else if( ldv<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 do i = ilo, ihi
                    s = scale( i )
                    call stdlib_dscal( m, s, v( i, 1 ), ldv )
                 end do
              end if
              if( leftv ) then
                 do i = ilo, ihi
                    s = one / scale( i )
                    call stdlib_dscal( m, s, v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           ! for  i = ilo-1 step -1 until 1,
                    ! ihi+1 step 1 until n do --
                    30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 loop_40: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_40
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_40
                    call stdlib_dswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
              end if
              if( leftv ) then
                 loop_50: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_50
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_50
                    call stdlib_dswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_50
              end if
           end if
           return
     end subroutine stdlib_dgebak

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$gebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
     !! DGEBAK: forms the right or left eigenvectors of a real general matrix
     !! by backward transformation on the computed eigenvectors of the
     !! balanced matrix output by DGEBAL.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(in) :: scale(*)
           real(${rk}$), intent(inout) :: v(ldv,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, ii, k
           real(${rk}$) :: s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( m<0 ) then
              info = -7
           else if( ldv<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 do i = ilo, ihi
                    s = scale( i )
                    call stdlib_${ri}$scal( m, s, v( i, 1 ), ldv )
                 end do
              end if
              if( leftv ) then
                 do i = ilo, ihi
                    s = one / scale( i )
                    call stdlib_${ri}$scal( m, s, v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           ! for  i = ilo-1 step -1 until 1,
                    ! ihi+1 step 1 until n do --
                    30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 loop_40: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_40
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_40
                    call stdlib_${ri}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
              end if
              if( leftv ) then
                 loop_50: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_50
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_50
                    call stdlib_${ri}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_50
              end if
           end if
           return
     end subroutine stdlib_${ri}$gebak

#:endif
#:endfor

     module pure subroutine stdlib_cgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
     !! CGEBAK forms the right or left eigenvectors of a complex general
     !! matrix by backward transformation on the computed eigenvectors of the
     !! balanced matrix output by CGEBAL.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(in) :: scale(*)
           complex(sp), intent(inout) :: v(ldv,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, ii, k
           real(sp) :: s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( m<0 ) then
              info = -7
           else if( ldv<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 do i = ilo, ihi
                    s = scale( i )
                    call stdlib_csscal( m, s, v( i, 1 ), ldv )
                 end do
              end if
              if( leftv ) then
                 do i = ilo, ihi
                    s = one / scale( i )
                    call stdlib_csscal( m, s, v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           ! for  i = ilo-1 step -1 until 1,
                    ! ihi+1 step 1 until n do --
                    30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 loop_40: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_40
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_40
                    call stdlib_cswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
              end if
              if( leftv ) then
                 loop_50: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_50
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_50
                    call stdlib_cswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_50
              end if
           end if
           return
     end subroutine stdlib_cgebak

     module pure subroutine stdlib_zgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
     !! ZGEBAK forms the right or left eigenvectors of a complex general
     !! matrix by backward transformation on the computed eigenvectors of the
     !! balanced matrix output by ZGEBAL.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(in) :: scale(*)
           complex(dp), intent(inout) :: v(ldv,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, ii, k
           real(dp) :: s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( m<0 ) then
              info = -7
           else if( ldv<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 do i = ilo, ihi
                    s = scale( i )
                    call stdlib_zdscal( m, s, v( i, 1 ), ldv )
                 end do
              end if
              if( leftv ) then
                 do i = ilo, ihi
                    s = one / scale( i )
                    call stdlib_zdscal( m, s, v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           ! for  i = ilo-1 step -1 until 1,
                    ! ihi+1 step 1 until n do --
                    30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 loop_40: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_40
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_40
                    call stdlib_zswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
              end if
              if( leftv ) then
                 loop_50: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_50
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_50
                    call stdlib_zswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_50
              end if
           end if
           return
     end subroutine stdlib_zgebak

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$gebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
     !! ZGEBAK: forms the right or left eigenvectors of a complex general
     !! matrix by backward transformation on the computed eigenvectors of the
     !! balanced matrix output by ZGEBAL.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${ck}$), intent(in) :: scale(*)
           complex(${ck}$), intent(inout) :: v(ldv,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, ii, k
           real(${ck}$) :: s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( m<0 ) then
              info = -7
           else if( ldv<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 do i = ilo, ihi
                    s = scale( i )
                    call stdlib_${ci}$dscal( m, s, v( i, 1 ), ldv )
                 end do
              end if
              if( leftv ) then
                 do i = ilo, ihi
                    s = one / scale( i )
                    call stdlib_${ci}$dscal( m, s, v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           ! for  i = ilo-1 step -1 until 1,
                    ! ihi+1 step 1 until n do --
                    30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 loop_40: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_40
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_40
                    call stdlib_${ci}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
              end if
              if( leftv ) then
                 loop_50: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_50
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_50
                    call stdlib_${ci}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_50
              end if
           end if
           return
     end subroutine stdlib_${ci}$gebak

#:endif
#:endfor



     module pure subroutine stdlib_strevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
     !! STREVC computes some or all of the right and/or left eigenvectors of
     !! a real upper quasi-triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a real general matrix:  A = Q*T*Q**T, as computed by SHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**H)*T = w*(y**H)
     !! where y**H denotes the conjugate transpose of y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal blocks of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix.  If Q is the orthogonal factor that reduces a matrix
     !! A to Schur form T, then Q*X and Q*Y are the matrices of right and
     !! left eigenvectors of A.
               work, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(inout) :: select(*)
           real(sp), intent(in) :: t(ldt,*)
           real(sp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, over, pair, rightv, somev
           integer(ilp) :: i, ierr, ii, ip, is, j, j1, j2, jnxt, k, ki, n2
           real(sp) :: beta, bignum, emax, ovfl, rec, remax, scale, smin, smlnum, ulp, unfl, &
                     vcrit, vmax, wi, wr, xnorm
           ! Intrinsic Functions 
           ! Local Arrays 
           real(sp) :: x(2,2)
           ! Executable Statements 
           ! decode and test the input parameters
           bothv = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv = stdlib_lsame( side, 'L' ) .or. bothv
           allv = stdlib_lsame( howmny, 'A' )
           over = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           info = 0
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else
              ! set m to the number of columns required to store the selected
              ! eigenvectors, standardize the array select if necessary, and
              ! test mm.
              if( somev ) then
                 m = 0
                 pair = .false.
                 do j = 1, n
                    if( pair ) then
                       pair = .false.
                       select( j ) = .false.
                    else
                       if( j<n ) then
                          if( t( j+1, j )==zero ) then
                             if( select( j ) )m = m + 1
                          else
                             pair = .true.
                             if( select( j ) .or. select( j+1 ) ) then
                                select( j ) = .true.
                                m = m + 2
                             end if
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( mm<m ) then
                 info = -11
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STREVC', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! set the constants to control overflow.
           unfl = stdlib_slamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_slabad( unfl, ovfl )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           bignum = ( one-ulp ) / smlnum
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           work( 1 ) = zero
           do j = 2, n
              work( j ) = zero
              do i = 1, j - 1
                 work( j ) = work( j ) + abs( t( i, j ) )
              end do
           end do
           ! index ip is used to specify the real or complex eigenvalue:
             ! ip = 0, real eigenvalue,
                  ! 1, first of conjugate complex pair: (wr,wi)
                 ! -1, second of conjugate complex pair: (wr,wi)
           n2 = 2*n
           if( rightv ) then
              ! compute right eigenvectors.
              ip = 0
              is = m
              loop_140: do ki = n, 1, -1
                 if( ip==1 )go to 130
                 if( ki==1 )go to 40
                 if( t( ki, ki-1 )==zero )go to 40
                 ip = -1
                 40 continue
                 if( somev ) then
                    if( ip==0 ) then
                       if( .not.select( ki ) )go to 130
                    else
                       if( .not.select( ki-1 ) )go to 130
                    end if
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki-1 ) ) )*sqrt( abs( t( ki-1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! real right eigenvector
                    work( ki+n ) = one
                    ! form right-hand side
                    do k = 1, ki - 1
                       work( k+n ) = -t( k, ki )
                    end do
                    ! solve the upper quasi-triangular system:
                       ! (t(1:ki-1,1:ki-1) - wr)*x = scale*work.
                    jnxt = ki - 1
                    loop_60: do j = ki - 1, 1, -1
                       if( j>jnxt )cycle loop_60
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1 = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_slaln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_sscal( ki, scale, work( 1+n ), 1 )
                          work( j+n ) = x( 1, 1 )
                          ! update right-hand side
                          call stdlib_saxpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_slaln2( .false., 2, 1, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+n ), n, wr, zero, x, 2,scale, xnorm, ierr )
                          ! scale x(1,1) and x(2,1) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 2, 1 ) = x( 2, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_sscal( ki, scale, work( 1+n ), 1 )
                          work( j-1+n ) = x( 1, 1 )
                          work( j+n ) = x( 2, 1 )
                          ! update right-hand side
                          call stdlib_saxpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_saxpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                       end if
                    end do loop_60
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       call stdlib_scopy( ki, work( 1+n ), 1, vr( 1, is ), 1 )
                       ii = stdlib_isamax( ki, vr( 1, is ), 1 )
                       remax = one / abs( vr( ii, is ) )
                       call stdlib_sscal( ki, remax, vr( 1, is ), 1 )
                       do k = ki + 1, n
                          vr( k, is ) = zero
                       end do
                    else
                       if( ki>1 )call stdlib_sgemv( 'N', n, ki-1, one, vr, ldvr,work( 1+n ), 1, &
                                 work( ki+n ),vr( 1, ki ), 1 )
                       ii = stdlib_isamax( n, vr( 1, ki ), 1 )
                       remax = one / abs( vr( ii, ki ) )
                       call stdlib_sscal( n, remax, vr( 1, ki ), 1 )
                    end if
                 else
                    ! complex right eigenvector.
                    ! initial solve
                      ! [ (t(ki-1,ki-1) t(ki-1,ki) ) - (wr + i* wi)]*x = 0.
                      ! [ (t(ki,ki-1)   t(ki,ki)   )               ]
                    if( abs( t( ki-1, ki ) )>=abs( t( ki, ki-1 ) ) ) then
                       work( ki-1+n ) = one
                       work( ki+n2 ) = wi / t( ki-1, ki )
                    else
                       work( ki-1+n ) = -wi / t( ki, ki-1 )
                       work( ki+n2 ) = one
                    end if
                    work( ki+n ) = zero
                    work( ki-1+n2 ) = zero
                    ! form right-hand side
                    do k = 1, ki - 2
                       work( k+n ) = -work( ki-1+n )*t( k, ki-1 )
                       work( k+n2 ) = -work( ki+n2 )*t( k, ki )
                    end do
                    ! solve upper quasi-triangular system:
                    ! (t(1:ki-2,1:ki-2) - (wr+i*wi))*x = scale*(work+i*work2)
                    jnxt = ki - 2
                    loop_90: do j = ki - 2, 1, -1
                       if( j>jnxt )cycle loop_90
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1 = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_slaln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr, wi,x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) and x(1,2) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 1, 2 ) = x( 1, 2 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_sscal( ki, scale, work( 1+n ), 1 )
                             call stdlib_sscal( ki, scale, work( 1+n2 ), 1 )
                          end if
                          work( j+n ) = x( 1, 1 )
                          work( j+n2 ) = x( 1, 2 )
                          ! update the right-hand side
                          call stdlib_saxpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_saxpy( j-1, -x( 1, 2 ), t( 1, j ), 1,work( 1+n2 ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_slaln2( .false., 2, 2, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+n ), n, wr, wi, x, 2, scale,xnorm, ierr )
                          ! scale x to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                rec = one / xnorm
                                x( 1, 1 ) = x( 1, 1 )*rec
                                x( 1, 2 ) = x( 1, 2 )*rec
                                x( 2, 1 ) = x( 2, 1 )*rec
                                x( 2, 2 ) = x( 2, 2 )*rec
                                scale = scale*rec
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_sscal( ki, scale, work( 1+n ), 1 )
                             call stdlib_sscal( ki, scale, work( 1+n2 ), 1 )
                          end if
                          work( j-1+n ) = x( 1, 1 )
                          work( j+n ) = x( 2, 1 )
                          work( j-1+n2 ) = x( 1, 2 )
                          work( j+n2 ) = x( 2, 2 )
                          ! update the right-hand side
                          call stdlib_saxpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_saxpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_saxpy( j-2, -x( 1, 2 ), t( 1, j-1 ), 1,work( 1+n2 ), 1 )
                                    
                          call stdlib_saxpy( j-2, -x( 2, 2 ), t( 1, j ), 1,work( 1+n2 ), 1 )
                                    
                       end if
                    end do loop_90
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       call stdlib_scopy( ki, work( 1+n ), 1, vr( 1, is-1 ), 1 )
                       call stdlib_scopy( ki, work( 1+n2 ), 1, vr( 1, is ), 1 )
                       emax = zero
                       do k = 1, ki
                          emax = max( emax, abs( vr( k, is-1 ) )+abs( vr( k, is ) ) )
                       end do
                       remax = one / emax
                       call stdlib_sscal( ki, remax, vr( 1, is-1 ), 1 )
                       call stdlib_sscal( ki, remax, vr( 1, is ), 1 )
                       do k = ki + 1, n
                          vr( k, is-1 ) = zero
                          vr( k, is ) = zero
                       end do
                    else
                       if( ki>2 ) then
                          call stdlib_sgemv( 'N', n, ki-2, one, vr, ldvr,work( 1+n ), 1, work( ki-&
                                    1+n ),vr( 1, ki-1 ), 1 )
                          call stdlib_sgemv( 'N', n, ki-2, one, vr, ldvr,work( 1+n2 ), 1, work( &
                                    ki+n2 ),vr( 1, ki ), 1 )
                       else
                          call stdlib_sscal( n, work( ki-1+n ), vr( 1, ki-1 ), 1 )
                          call stdlib_sscal( n, work( ki+n2 ), vr( 1, ki ), 1 )
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vr( k, ki-1 ) )+abs( vr( k, ki ) ) )
                       end do
                       remax = one / emax
                       call stdlib_sscal( n, remax, vr( 1, ki-1 ), 1 )
                       call stdlib_sscal( n, remax, vr( 1, ki ), 1 )
                    end if
                 end if
                 is = is - 1
                 if( ip/=0 )is = is - 1
                 130 continue
                 if( ip==1 )ip = 0
                 if( ip==-1 )ip = 1
              end do loop_140
           end if
           if( leftv ) then
              ! compute left eigenvectors.
              ip = 0
              is = 1
              loop_260: do ki = 1, n
                 if( ip==-1 )go to 250
                 if( ki==n )go to 150
                 if( t( ki+1, ki )==zero )go to 150
                 ip = 1
                 150 continue
                 if( somev ) then
                    if( .not.select( ki ) )go to 250
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki+1 ) ) )*sqrt( abs( t( ki+1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! real left eigenvector.
                    work( ki+n ) = one
                    ! form right-hand side
                    do k = ki + 1, n
                       work( k+n ) = -t( ki, k )
                    end do
                    ! solve the quasi-triangular system:
                       ! (t(ki+1:n,ki+1:n) - wr)**t*x = scale*work
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 1
                    loop_170: do j = ki + 1, n
                       if( j<jnxt )cycle loop_170
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_sscal( n-ki+1, rec, work( ki+n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_sdot( j-ki-1, t( ki+1, j ), 1,work( &
                                    ki+1+n ), 1 )
                          ! solve (t(j,j)-wr)**t*x = work
                          call stdlib_slaln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_sscal( n-ki+1, scale, work( ki+n ), 1 )
                                    
                          work( j+n ) = x( 1, 1 )
                          vmax = max( abs( work( j+n ) ), vmax )
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_sscal( n-ki+1, rec, work( ki+n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_sdot( j-ki-1, t( ki+1, j ), 1,work( &
                                    ki+1+n ), 1 )
                          work( j+1+n ) = work( j+1+n ) -stdlib_sdot( j-ki-1, t( ki+1, j+1 ), 1,&
                                    work( ki+1+n ), 1 )
                          ! solve
                            ! [t(j,j)-wr   t(j,j+1)     ]**t* x = scale*( work1 )
                            ! [t(j+1,j)    t(j+1,j+1)-wr]               ( work2 )
                          call stdlib_slaln2( .true., 2, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_sscal( n-ki+1, scale, work( ki+n ), 1 )
                                    
                          work( j+n ) = x( 1, 1 )
                          work( j+1+n ) = x( 2, 1 )
                          vmax = max( abs( work( j+n ) ),abs( work( j+1+n ) ), vmax )
                          vcrit = bignum / vmax
                       end if
                    end do loop_170
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       call stdlib_scopy( n-ki+1, work( ki+n ), 1, vl( ki, is ), 1 )
                       ii = stdlib_isamax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                       remax = one / abs( vl( ii, is ) )
                       call stdlib_sscal( n-ki+1, remax, vl( ki, is ), 1 )
                       do k = 1, ki - 1
                          vl( k, is ) = zero
                       end do
                    else
                       if( ki<n )call stdlib_sgemv( 'N', n, n-ki, one, vl( 1, ki+1 ), ldvl,work( &
                                 ki+1+n ), 1, work( ki+n ),vl( 1, ki ), 1 )
                       ii = stdlib_isamax( n, vl( 1, ki ), 1 )
                       remax = one / abs( vl( ii, ki ) )
                       call stdlib_sscal( n, remax, vl( 1, ki ), 1 )
                    end if
                 else
                    ! complex left eigenvector.
                     ! initial solve:
                       ! ((t(ki,ki)    t(ki,ki+1) )**t - (wr - i* wi))*x = 0.
                       ! ((t(ki+1,ki) t(ki+1,ki+1))                )
                    if( abs( t( ki, ki+1 ) )>=abs( t( ki+1, ki ) ) ) then
                       work( ki+n ) = wi / t( ki, ki+1 )
                       work( ki+1+n2 ) = one
                    else
                       work( ki+n ) = one
                       work( ki+1+n2 ) = -wi / t( ki+1, ki )
                    end if
                    work( ki+1+n ) = zero
                    work( ki+n2 ) = zero
                    ! form right-hand side
                    do k = ki + 2, n
                       work( k+n ) = -work( ki+n )*t( ki, k )
                       work( k+n2 ) = -work( ki+1+n2 )*t( ki+1, k )
                    end do
                    ! solve complex quasi-triangular system:
                    ! ( t(ki+2,n:ki+2,n) - (wr-i*wi) )*x = work1+i*work2
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 2
                    loop_200: do j = ki + 2, n
                       if( j<jnxt )cycle loop_200
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when
                          ! forming the right-hand side elements.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_sscal( n-ki+1, rec, work( ki+n ), 1 )
                             call stdlib_sscal( n-ki+1, rec, work( ki+n2 ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_sdot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n ), 1 )
                          work( j+n2 ) = work( j+n2 ) -stdlib_sdot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n2 ), 1 )
                          ! solve (t(j,j)-(wr-i*wi))*(x11+i*x12)= wk+i*wk2
                          call stdlib_slaln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_sscal( n-ki+1, scale, work( ki+n ), 1 )
                             call stdlib_sscal( n-ki+1, scale, work( ki+n2 ), 1 )
                          end if
                          work( j+n ) = x( 1, 1 )
                          work( j+n2 ) = x( 1, 2 )
                          vmax = max( abs( work( j+n ) ),abs( work( j+n2 ) ), vmax )
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side elements.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_sscal( n-ki+1, rec, work( ki+n ), 1 )
                             call stdlib_sscal( n-ki+1, rec, work( ki+n2 ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_sdot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n ), 1 )
                          work( j+n2 ) = work( j+n2 ) -stdlib_sdot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n2 ), 1 )
                          work( j+1+n ) = work( j+1+n ) -stdlib_sdot( j-ki-2, t( ki+2, j+1 ), 1,&
                                    work( ki+2+n ), 1 )
                          work( j+1+n2 ) = work( j+1+n2 ) -stdlib_sdot( j-ki-2, t( ki+2, j+1 ), 1,&
                                    work( ki+2+n2 ), 1 )
                          ! solve 2-by-2 complex linear equation
                            ! ([t(j,j)   t(j,j+1)  ]**t-(wr-i*wi)*i)*x = scale*b
                            ! ([t(j+1,j) t(j+1,j+1)]               )
                          call stdlib_slaln2( .true., 2, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_sscal( n-ki+1, scale, work( ki+n ), 1 )
                             call stdlib_sscal( n-ki+1, scale, work( ki+n2 ), 1 )
                          end if
                          work( j+n ) = x( 1, 1 )
                          work( j+n2 ) = x( 1, 2 )
                          work( j+1+n ) = x( 2, 1 )
                          work( j+1+n2 ) = x( 2, 2 )
                          vmax = max( abs( x( 1, 1 ) ), abs( x( 1, 2 ) ),abs( x( 2, 1 ) ), abs( x(&
                                     2, 2 ) ), vmax )
                          vcrit = bignum / vmax
                       end if
                    end do loop_200
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       call stdlib_scopy( n-ki+1, work( ki+n ), 1, vl( ki, is ), 1 )
                       call stdlib_scopy( n-ki+1, work( ki+n2 ), 1, vl( ki, is+1 ),1 )
                       emax = zero
                       do k = ki, n
                          emax = max( emax, abs( vl( k, is ) )+abs( vl( k, is+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_sscal( n-ki+1, remax, vl( ki, is ), 1 )
                       call stdlib_sscal( n-ki+1, remax, vl( ki, is+1 ), 1 )
                       do k = 1, ki - 1
                          vl( k, is ) = zero
                          vl( k, is+1 ) = zero
                       end do
                    else
                       if( ki<n-1 ) then
                          call stdlib_sgemv( 'N', n, n-ki-1, one, vl( 1, ki+2 ),ldvl, work( ki+2+&
                                    n ), 1, work( ki+n ),vl( 1, ki ), 1 )
                          call stdlib_sgemv( 'N', n, n-ki-1, one, vl( 1, ki+2 ),ldvl, work( ki+2+&
                                    n2 ), 1,work( ki+1+n2 ), vl( 1, ki+1 ), 1 )
                       else
                          call stdlib_sscal( n, work( ki+n ), vl( 1, ki ), 1 )
                          call stdlib_sscal( n, work( ki+1+n2 ), vl( 1, ki+1 ), 1 )
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vl( k, ki ) )+abs( vl( k, ki+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_sscal( n, remax, vl( 1, ki ), 1 )
                       call stdlib_sscal( n, remax, vl( 1, ki+1 ), 1 )
                    end if
                 end if
                 is = is + 1
                 if( ip/=0 )is = is + 1
                 250 continue
                 if( ip==-1 )ip = 0
                 if( ip==1 )ip = -1
              end do loop_260
           end if
           return
     end subroutine stdlib_strevc

     module pure subroutine stdlib_dtrevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
     !! DTREVC computes some or all of the right and/or left eigenvectors of
     !! a real upper quasi-triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a real general matrix:  A = Q*T*Q**T, as computed by DHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**H)*T = w*(y**H)
     !! where y**H denotes the conjugate transpose of y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal blocks of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix.  If Q is the orthogonal factor that reduces a matrix
     !! A to Schur form T, then Q*X and Q*Y are the matrices of right and
     !! left eigenvectors of A.
               work, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(inout) :: select(*)
           real(dp), intent(in) :: t(ldt,*)
           real(dp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, over, pair, rightv, somev
           integer(ilp) :: i, ierr, ii, ip, is, j, j1, j2, jnxt, k, ki, n2
           real(dp) :: beta, bignum, emax, ovfl, rec, remax, scale, smin, smlnum, ulp, unfl, &
                     vcrit, vmax, wi, wr, xnorm
           ! Intrinsic Functions 
           ! Local Arrays 
           real(dp) :: x(2,2)
           ! Executable Statements 
           ! decode and test the input parameters
           bothv = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv = stdlib_lsame( side, 'L' ) .or. bothv
           allv = stdlib_lsame( howmny, 'A' )
           over = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           info = 0
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else
              ! set m to the number of columns required to store the selected
              ! eigenvectors, standardize the array select if necessary, and
              ! test mm.
              if( somev ) then
                 m = 0
                 pair = .false.
                 do j = 1, n
                    if( pair ) then
                       pair = .false.
                       select( j ) = .false.
                    else
                       if( j<n ) then
                          if( t( j+1, j )==zero ) then
                             if( select( j ) )m = m + 1
                          else
                             pair = .true.
                             if( select( j ) .or. select( j+1 ) ) then
                                select( j ) = .true.
                                m = m + 2
                             end if
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( mm<m ) then
                 info = -11
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTREVC', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! set the constants to control overflow.
           unfl = stdlib_dlamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_dlabad( unfl, ovfl )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           bignum = ( one-ulp ) / smlnum
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           work( 1 ) = zero
           do j = 2, n
              work( j ) = zero
              do i = 1, j - 1
                 work( j ) = work( j ) + abs( t( i, j ) )
              end do
           end do
           ! index ip is used to specify the real or complex eigenvalue:
             ! ip = 0, real eigenvalue,
                  ! 1, first of conjugate complex pair: (wr,wi)
                 ! -1, second of conjugate complex pair: (wr,wi)
           n2 = 2*n
           if( rightv ) then
              ! compute right eigenvectors.
              ip = 0
              is = m
              loop_140: do ki = n, 1, -1
                 if( ip==1 )go to 130
                 if( ki==1 )go to 40
                 if( t( ki, ki-1 )==zero )go to 40
                 ip = -1
                 40 continue
                 if( somev ) then
                    if( ip==0 ) then
                       if( .not.select( ki ) )go to 130
                    else
                       if( .not.select( ki-1 ) )go to 130
                    end if
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki-1 ) ) )*sqrt( abs( t( ki-1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! real right eigenvector
                    work( ki+n ) = one
                    ! form right-hand side
                    do k = 1, ki - 1
                       work( k+n ) = -t( k, ki )
                    end do
                    ! solve the upper quasi-triangular system:
                       ! (t(1:ki-1,1:ki-1) - wr)*x = scale*work.
                    jnxt = ki - 1
                    loop_60: do j = ki - 1, 1, -1
                       if( j>jnxt )cycle loop_60
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1 = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_dlaln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_dscal( ki, scale, work( 1+n ), 1 )
                          work( j+n ) = x( 1, 1 )
                          ! update right-hand side
                          call stdlib_daxpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_dlaln2( .false., 2, 1, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+n ), n, wr, zero, x, 2,scale, xnorm, ierr )
                          ! scale x(1,1) and x(2,1) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 2, 1 ) = x( 2, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_dscal( ki, scale, work( 1+n ), 1 )
                          work( j-1+n ) = x( 1, 1 )
                          work( j+n ) = x( 2, 1 )
                          ! update right-hand side
                          call stdlib_daxpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_daxpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                       end if
                    end do loop_60
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       call stdlib_dcopy( ki, work( 1+n ), 1, vr( 1, is ), 1 )
                       ii = stdlib_idamax( ki, vr( 1, is ), 1 )
                       remax = one / abs( vr( ii, is ) )
                       call stdlib_dscal( ki, remax, vr( 1, is ), 1 )
                       do k = ki + 1, n
                          vr( k, is ) = zero
                       end do
                    else
                       if( ki>1 )call stdlib_dgemv( 'N', n, ki-1, one, vr, ldvr,work( 1+n ), 1, &
                                 work( ki+n ),vr( 1, ki ), 1 )
                       ii = stdlib_idamax( n, vr( 1, ki ), 1 )
                       remax = one / abs( vr( ii, ki ) )
                       call stdlib_dscal( n, remax, vr( 1, ki ), 1 )
                    end if
                 else
                    ! complex right eigenvector.
                    ! initial solve
                      ! [ (t(ki-1,ki-1) t(ki-1,ki) ) - (wr + i* wi)]*x = 0.
                      ! [ (t(ki,ki-1)   t(ki,ki)   )               ]
                    if( abs( t( ki-1, ki ) )>=abs( t( ki, ki-1 ) ) ) then
                       work( ki-1+n ) = one
                       work( ki+n2 ) = wi / t( ki-1, ki )
                    else
                       work( ki-1+n ) = -wi / t( ki, ki-1 )
                       work( ki+n2 ) = one
                    end if
                    work( ki+n ) = zero
                    work( ki-1+n2 ) = zero
                    ! form right-hand side
                    do k = 1, ki - 2
                       work( k+n ) = -work( ki-1+n )*t( k, ki-1 )
                       work( k+n2 ) = -work( ki+n2 )*t( k, ki )
                    end do
                    ! solve upper quasi-triangular system:
                    ! (t(1:ki-2,1:ki-2) - (wr+i*wi))*x = scale*(work+i*work2)
                    jnxt = ki - 2
                    loop_90: do j = ki - 2, 1, -1
                       if( j>jnxt )cycle loop_90
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1 = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_dlaln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr, wi,x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) and x(1,2) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 1, 2 ) = x( 1, 2 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_dscal( ki, scale, work( 1+n ), 1 )
                             call stdlib_dscal( ki, scale, work( 1+n2 ), 1 )
                          end if
                          work( j+n ) = x( 1, 1 )
                          work( j+n2 ) = x( 1, 2 )
                          ! update the right-hand side
                          call stdlib_daxpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_daxpy( j-1, -x( 1, 2 ), t( 1, j ), 1,work( 1+n2 ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_dlaln2( .false., 2, 2, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+n ), n, wr, wi, x, 2, scale,xnorm, ierr )
                          ! scale x to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                rec = one / xnorm
                                x( 1, 1 ) = x( 1, 1 )*rec
                                x( 1, 2 ) = x( 1, 2 )*rec
                                x( 2, 1 ) = x( 2, 1 )*rec
                                x( 2, 2 ) = x( 2, 2 )*rec
                                scale = scale*rec
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_dscal( ki, scale, work( 1+n ), 1 )
                             call stdlib_dscal( ki, scale, work( 1+n2 ), 1 )
                          end if
                          work( j-1+n ) = x( 1, 1 )
                          work( j+n ) = x( 2, 1 )
                          work( j-1+n2 ) = x( 1, 2 )
                          work( j+n2 ) = x( 2, 2 )
                          ! update the right-hand side
                          call stdlib_daxpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_daxpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_daxpy( j-2, -x( 1, 2 ), t( 1, j-1 ), 1,work( 1+n2 ), 1 )
                                    
                          call stdlib_daxpy( j-2, -x( 2, 2 ), t( 1, j ), 1,work( 1+n2 ), 1 )
                                    
                       end if
                    end do loop_90
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       call stdlib_dcopy( ki, work( 1+n ), 1, vr( 1, is-1 ), 1 )
                       call stdlib_dcopy( ki, work( 1+n2 ), 1, vr( 1, is ), 1 )
                       emax = zero
                       do k = 1, ki
                          emax = max( emax, abs( vr( k, is-1 ) )+abs( vr( k, is ) ) )
                       end do
                       remax = one / emax
                       call stdlib_dscal( ki, remax, vr( 1, is-1 ), 1 )
                       call stdlib_dscal( ki, remax, vr( 1, is ), 1 )
                       do k = ki + 1, n
                          vr( k, is-1 ) = zero
                          vr( k, is ) = zero
                       end do
                    else
                       if( ki>2 ) then
                          call stdlib_dgemv( 'N', n, ki-2, one, vr, ldvr,work( 1+n ), 1, work( ki-&
                                    1+n ),vr( 1, ki-1 ), 1 )
                          call stdlib_dgemv( 'N', n, ki-2, one, vr, ldvr,work( 1+n2 ), 1, work( &
                                    ki+n2 ),vr( 1, ki ), 1 )
                       else
                          call stdlib_dscal( n, work( ki-1+n ), vr( 1, ki-1 ), 1 )
                          call stdlib_dscal( n, work( ki+n2 ), vr( 1, ki ), 1 )
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vr( k, ki-1 ) )+abs( vr( k, ki ) ) )
                       end do
                       remax = one / emax
                       call stdlib_dscal( n, remax, vr( 1, ki-1 ), 1 )
                       call stdlib_dscal( n, remax, vr( 1, ki ), 1 )
                    end if
                 end if
                 is = is - 1
                 if( ip/=0 )is = is - 1
                 130 continue
                 if( ip==1 )ip = 0
                 if( ip==-1 )ip = 1
              end do loop_140
           end if
           if( leftv ) then
              ! compute left eigenvectors.
              ip = 0
              is = 1
              loop_260: do ki = 1, n
                 if( ip==-1 )go to 250
                 if( ki==n )go to 150
                 if( t( ki+1, ki )==zero )go to 150
                 ip = 1
                 150 continue
                 if( somev ) then
                    if( .not.select( ki ) )go to 250
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki+1 ) ) )*sqrt( abs( t( ki+1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! real left eigenvector.
                    work( ki+n ) = one
                    ! form right-hand side
                    do k = ki + 1, n
                       work( k+n ) = -t( ki, k )
                    end do
                    ! solve the quasi-triangular system:
                       ! (t(ki+1:n,ki+1:n) - wr)**t*x = scale*work
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 1
                    loop_170: do j = ki + 1, n
                       if( j<jnxt )cycle loop_170
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_dscal( n-ki+1, rec, work( ki+n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_ddot( j-ki-1, t( ki+1, j ), 1,work( &
                                    ki+1+n ), 1 )
                          ! solve (t(j,j)-wr)**t*x = work
                          call stdlib_dlaln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_dscal( n-ki+1, scale, work( ki+n ), 1 )
                                    
                          work( j+n ) = x( 1, 1 )
                          vmax = max( abs( work( j+n ) ), vmax )
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_dscal( n-ki+1, rec, work( ki+n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_ddot( j-ki-1, t( ki+1, j ), 1,work( &
                                    ki+1+n ), 1 )
                          work( j+1+n ) = work( j+1+n ) -stdlib_ddot( j-ki-1, t( ki+1, j+1 ), 1,&
                                    work( ki+1+n ), 1 )
                          ! solve
                            ! [t(j,j)-wr   t(j,j+1)     ]**t * x = scale*( work1 )
                            ! [t(j+1,j)    t(j+1,j+1)-wr]                ( work2 )
                          call stdlib_dlaln2( .true., 2, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_dscal( n-ki+1, scale, work( ki+n ), 1 )
                                    
                          work( j+n ) = x( 1, 1 )
                          work( j+1+n ) = x( 2, 1 )
                          vmax = max( abs( work( j+n ) ),abs( work( j+1+n ) ), vmax )
                          vcrit = bignum / vmax
                       end if
                    end do loop_170
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       call stdlib_dcopy( n-ki+1, work( ki+n ), 1, vl( ki, is ), 1 )
                       ii = stdlib_idamax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                       remax = one / abs( vl( ii, is ) )
                       call stdlib_dscal( n-ki+1, remax, vl( ki, is ), 1 )
                       do k = 1, ki - 1
                          vl( k, is ) = zero
                       end do
                    else
                       if( ki<n )call stdlib_dgemv( 'N', n, n-ki, one, vl( 1, ki+1 ), ldvl,work( &
                                 ki+1+n ), 1, work( ki+n ),vl( 1, ki ), 1 )
                       ii = stdlib_idamax( n, vl( 1, ki ), 1 )
                       remax = one / abs( vl( ii, ki ) )
                       call stdlib_dscal( n, remax, vl( 1, ki ), 1 )
                    end if
                 else
                    ! complex left eigenvector.
                     ! initial solve:
                       ! ((t(ki,ki)    t(ki,ki+1) )**t - (wr - i* wi))*x = 0.
                       ! ((t(ki+1,ki) t(ki+1,ki+1))                )
                    if( abs( t( ki, ki+1 ) )>=abs( t( ki+1, ki ) ) ) then
                       work( ki+n ) = wi / t( ki, ki+1 )
                       work( ki+1+n2 ) = one
                    else
                       work( ki+n ) = one
                       work( ki+1+n2 ) = -wi / t( ki+1, ki )
                    end if
                    work( ki+1+n ) = zero
                    work( ki+n2 ) = zero
                    ! form right-hand side
                    do k = ki + 2, n
                       work( k+n ) = -work( ki+n )*t( ki, k )
                       work( k+n2 ) = -work( ki+1+n2 )*t( ki+1, k )
                    end do
                    ! solve complex quasi-triangular system:
                    ! ( t(ki+2,n:ki+2,n) - (wr-i*wi) )*x = work1+i*work2
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 2
                    loop_200: do j = ki + 2, n
                       if( j<jnxt )cycle loop_200
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when
                          ! forming the right-hand side elements.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_dscal( n-ki+1, rec, work( ki+n ), 1 )
                             call stdlib_dscal( n-ki+1, rec, work( ki+n2 ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_ddot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n ), 1 )
                          work( j+n2 ) = work( j+n2 ) -stdlib_ddot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n2 ), 1 )
                          ! solve (t(j,j)-(wr-i*wi))*(x11+i*x12)= wk+i*wk2
                          call stdlib_dlaln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_dscal( n-ki+1, scale, work( ki+n ), 1 )
                             call stdlib_dscal( n-ki+1, scale, work( ki+n2 ), 1 )
                          end if
                          work( j+n ) = x( 1, 1 )
                          work( j+n2 ) = x( 1, 2 )
                          vmax = max( abs( work( j+n ) ),abs( work( j+n2 ) ), vmax )
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side elements.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_dscal( n-ki+1, rec, work( ki+n ), 1 )
                             call stdlib_dscal( n-ki+1, rec, work( ki+n2 ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_ddot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n ), 1 )
                          work( j+n2 ) = work( j+n2 ) -stdlib_ddot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n2 ), 1 )
                          work( j+1+n ) = work( j+1+n ) -stdlib_ddot( j-ki-2, t( ki+2, j+1 ), 1,&
                                    work( ki+2+n ), 1 )
                          work( j+1+n2 ) = work( j+1+n2 ) -stdlib_ddot( j-ki-2, t( ki+2, j+1 ), 1,&
                                    work( ki+2+n2 ), 1 )
                          ! solve 2-by-2 complex linear equation
                            ! ([t(j,j)   t(j,j+1)  ]**t-(wr-i*wi)*i)*x = scale*b
                            ! ([t(j+1,j) t(j+1,j+1)]               )
                          call stdlib_dlaln2( .true., 2, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_dscal( n-ki+1, scale, work( ki+n ), 1 )
                             call stdlib_dscal( n-ki+1, scale, work( ki+n2 ), 1 )
                          end if
                          work( j+n ) = x( 1, 1 )
                          work( j+n2 ) = x( 1, 2 )
                          work( j+1+n ) = x( 2, 1 )
                          work( j+1+n2 ) = x( 2, 2 )
                          vmax = max( abs( x( 1, 1 ) ), abs( x( 1, 2 ) ),abs( x( 2, 1 ) ), abs( x(&
                                     2, 2 ) ), vmax )
                          vcrit = bignum / vmax
                       end if
                    end do loop_200
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       call stdlib_dcopy( n-ki+1, work( ki+n ), 1, vl( ki, is ), 1 )
                       call stdlib_dcopy( n-ki+1, work( ki+n2 ), 1, vl( ki, is+1 ),1 )
                       emax = zero
                       do k = ki, n
                          emax = max( emax, abs( vl( k, is ) )+abs( vl( k, is+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_dscal( n-ki+1, remax, vl( ki, is ), 1 )
                       call stdlib_dscal( n-ki+1, remax, vl( ki, is+1 ), 1 )
                       do k = 1, ki - 1
                          vl( k, is ) = zero
                          vl( k, is+1 ) = zero
                       end do
                    else
                       if( ki<n-1 ) then
                          call stdlib_dgemv( 'N', n, n-ki-1, one, vl( 1, ki+2 ),ldvl, work( ki+2+&
                                    n ), 1, work( ki+n ),vl( 1, ki ), 1 )
                          call stdlib_dgemv( 'N', n, n-ki-1, one, vl( 1, ki+2 ),ldvl, work( ki+2+&
                                    n2 ), 1,work( ki+1+n2 ), vl( 1, ki+1 ), 1 )
                       else
                          call stdlib_dscal( n, work( ki+n ), vl( 1, ki ), 1 )
                          call stdlib_dscal( n, work( ki+1+n2 ), vl( 1, ki+1 ), 1 )
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vl( k, ki ) )+abs( vl( k, ki+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_dscal( n, remax, vl( 1, ki ), 1 )
                       call stdlib_dscal( n, remax, vl( 1, ki+1 ), 1 )
                    end if
                 end if
                 is = is + 1
                 if( ip/=0 )is = is + 1
                 250 continue
                 if( ip==-1 )ip = 0
                 if( ip==1 )ip = -1
              end do loop_260
           end if
           return
     end subroutine stdlib_dtrevc

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$trevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
     !! DTREVC: computes some or all of the right and/or left eigenvectors of
     !! a real upper quasi-triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a real general matrix:  A = Q*T*Q**T, as computed by DHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**H)*T = w*(y**H)
     !! where y**H denotes the conjugate transpose of y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal blocks of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix.  If Q is the orthogonal factor that reduces a matrix
     !! A to Schur form T, then Q*X and Q*Y are the matrices of right and
     !! left eigenvectors of A.
               work, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(inout) :: select(*)
           real(${rk}$), intent(in) :: t(ldt,*)
           real(${rk}$), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, over, pair, rightv, somev
           integer(ilp) :: i, ierr, ii, ip, is, j, j1, j2, jnxt, k, ki, n2
           real(${rk}$) :: beta, bignum, emax, ovfl, rec, remax, scale, smin, smlnum, ulp, unfl, &
                     vcrit, vmax, wi, wr, xnorm
           ! Intrinsic Functions 
           ! Local Arrays 
           real(${rk}$) :: x(2,2)
           ! Executable Statements 
           ! decode and test the input parameters
           bothv = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv = stdlib_lsame( side, 'L' ) .or. bothv
           allv = stdlib_lsame( howmny, 'A' )
           over = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           info = 0
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else
              ! set m to the number of columns required to store the selected
              ! eigenvectors, standardize the array select if necessary, and
              ! test mm.
              if( somev ) then
                 m = 0
                 pair = .false.
                 do j = 1, n
                    if( pair ) then
                       pair = .false.
                       select( j ) = .false.
                    else
                       if( j<n ) then
                          if( t( j+1, j )==zero ) then
                             if( select( j ) )m = m + 1
                          else
                             pair = .true.
                             if( select( j ) .or. select( j+1 ) ) then
                                select( j ) = .true.
                                m = m + 2
                             end if
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( mm<m ) then
                 info = -11
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTREVC', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! set the constants to control overflow.
           unfl = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_${ri}$labad( unfl, ovfl )
           ulp = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           bignum = ( one-ulp ) / smlnum
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           work( 1 ) = zero
           do j = 2, n
              work( j ) = zero
              do i = 1, j - 1
                 work( j ) = work( j ) + abs( t( i, j ) )
              end do
           end do
           ! index ip is used to specify the real or complex eigenvalue:
             ! ip = 0, real eigenvalue,
                  ! 1, first of conjugate complex pair: (wr,wi)
                 ! -1, second of conjugate complex pair: (wr,wi)
           n2 = 2*n
           if( rightv ) then
              ! compute right eigenvectors.
              ip = 0
              is = m
              loop_140: do ki = n, 1, -1
                 if( ip==1 )go to 130
                 if( ki==1 )go to 40
                 if( t( ki, ki-1 )==zero )go to 40
                 ip = -1
                 40 continue
                 if( somev ) then
                    if( ip==0 ) then
                       if( .not.select( ki ) )go to 130
                    else
                       if( .not.select( ki-1 ) )go to 130
                    end if
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki-1 ) ) )*sqrt( abs( t( ki-1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! real right eigenvector
                    work( ki+n ) = one
                    ! form right-hand side
                    do k = 1, ki - 1
                       work( k+n ) = -t( k, ki )
                    end do
                    ! solve the upper quasi-triangular system:
                       ! (t(1:ki-1,1:ki-1) - wr)*x = scale*work.
                    jnxt = ki - 1
                    loop_60: do j = ki - 1, 1, -1
                       if( j>jnxt )cycle loop_60
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1 = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_${ri}$laln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( ki, scale, work( 1+n ), 1 )
                          work( j+n ) = x( 1, 1 )
                          ! update right-hand side
                          call stdlib_${ri}$axpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_${ri}$laln2( .false., 2, 1, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+n ), n, wr, zero, x, 2,scale, xnorm, ierr )
                          ! scale x(1,1) and x(2,1) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 2, 1 ) = x( 2, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( ki, scale, work( 1+n ), 1 )
                          work( j-1+n ) = x( 1, 1 )
                          work( j+n ) = x( 2, 1 )
                          ! update right-hand side
                          call stdlib_${ri}$axpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_${ri}$axpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                       end if
                    end do loop_60
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       call stdlib_${ri}$copy( ki, work( 1+n ), 1, vr( 1, is ), 1 )
                       ii = stdlib_i${ri}$amax( ki, vr( 1, is ), 1 )
                       remax = one / abs( vr( ii, is ) )
                       call stdlib_${ri}$scal( ki, remax, vr( 1, is ), 1 )
                       do k = ki + 1, n
                          vr( k, is ) = zero
                       end do
                    else
                       if( ki>1 )call stdlib_${ri}$gemv( 'N', n, ki-1, one, vr, ldvr,work( 1+n ), 1, &
                                 work( ki+n ),vr( 1, ki ), 1 )
                       ii = stdlib_i${ri}$amax( n, vr( 1, ki ), 1 )
                       remax = one / abs( vr( ii, ki ) )
                       call stdlib_${ri}$scal( n, remax, vr( 1, ki ), 1 )
                    end if
                 else
                    ! complex right eigenvector.
                    ! initial solve
                      ! [ (t(ki-1,ki-1) t(ki-1,ki) ) - (wr + i* wi)]*x = 0.
                      ! [ (t(ki,ki-1)   t(ki,ki)   )               ]
                    if( abs( t( ki-1, ki ) )>=abs( t( ki, ki-1 ) ) ) then
                       work( ki-1+n ) = one
                       work( ki+n2 ) = wi / t( ki-1, ki )
                    else
                       work( ki-1+n ) = -wi / t( ki, ki-1 )
                       work( ki+n2 ) = one
                    end if
                    work( ki+n ) = zero
                    work( ki-1+n2 ) = zero
                    ! form right-hand side
                    do k = 1, ki - 2
                       work( k+n ) = -work( ki-1+n )*t( k, ki-1 )
                       work( k+n2 ) = -work( ki+n2 )*t( k, ki )
                    end do
                    ! solve upper quasi-triangular system:
                    ! (t(1:ki-2,1:ki-2) - (wr+i*wi))*x = scale*(work+i*work2)
                    jnxt = ki - 2
                    loop_90: do j = ki - 2, 1, -1
                       if( j>jnxt )cycle loop_90
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1 = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_${ri}$laln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr, wi,x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) and x(1,2) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 1, 2 ) = x( 1, 2 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( ki, scale, work( 1+n ), 1 )
                             call stdlib_${ri}$scal( ki, scale, work( 1+n2 ), 1 )
                          end if
                          work( j+n ) = x( 1, 1 )
                          work( j+n2 ) = x( 1, 2 )
                          ! update the right-hand side
                          call stdlib_${ri}$axpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_${ri}$axpy( j-1, -x( 1, 2 ), t( 1, j ), 1,work( 1+n2 ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_${ri}$laln2( .false., 2, 2, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+n ), n, wr, wi, x, 2, scale,xnorm, ierr )
                          ! scale x to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                rec = one / xnorm
                                x( 1, 1 ) = x( 1, 1 )*rec
                                x( 1, 2 ) = x( 1, 2 )*rec
                                x( 2, 1 ) = x( 2, 1 )*rec
                                x( 2, 2 ) = x( 2, 2 )*rec
                                scale = scale*rec
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( ki, scale, work( 1+n ), 1 )
                             call stdlib_${ri}$scal( ki, scale, work( 1+n2 ), 1 )
                          end if
                          work( j-1+n ) = x( 1, 1 )
                          work( j+n ) = x( 2, 1 )
                          work( j-1+n2 ) = x( 1, 2 )
                          work( j+n2 ) = x( 2, 2 )
                          ! update the right-hand side
                          call stdlib_${ri}$axpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_${ri}$axpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_${ri}$axpy( j-2, -x( 1, 2 ), t( 1, j-1 ), 1,work( 1+n2 ), 1 )
                                    
                          call stdlib_${ri}$axpy( j-2, -x( 2, 2 ), t( 1, j ), 1,work( 1+n2 ), 1 )
                                    
                       end if
                    end do loop_90
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       call stdlib_${ri}$copy( ki, work( 1+n ), 1, vr( 1, is-1 ), 1 )
                       call stdlib_${ri}$copy( ki, work( 1+n2 ), 1, vr( 1, is ), 1 )
                       emax = zero
                       do k = 1, ki
                          emax = max( emax, abs( vr( k, is-1 ) )+abs( vr( k, is ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( ki, remax, vr( 1, is-1 ), 1 )
                       call stdlib_${ri}$scal( ki, remax, vr( 1, is ), 1 )
                       do k = ki + 1, n
                          vr( k, is-1 ) = zero
                          vr( k, is ) = zero
                       end do
                    else
                       if( ki>2 ) then
                          call stdlib_${ri}$gemv( 'N', n, ki-2, one, vr, ldvr,work( 1+n ), 1, work( ki-&
                                    1+n ),vr( 1, ki-1 ), 1 )
                          call stdlib_${ri}$gemv( 'N', n, ki-2, one, vr, ldvr,work( 1+n2 ), 1, work( &
                                    ki+n2 ),vr( 1, ki ), 1 )
                       else
                          call stdlib_${ri}$scal( n, work( ki-1+n ), vr( 1, ki-1 ), 1 )
                          call stdlib_${ri}$scal( n, work( ki+n2 ), vr( 1, ki ), 1 )
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vr( k, ki-1 ) )+abs( vr( k, ki ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( n, remax, vr( 1, ki-1 ), 1 )
                       call stdlib_${ri}$scal( n, remax, vr( 1, ki ), 1 )
                    end if
                 end if
                 is = is - 1
                 if( ip/=0 )is = is - 1
                 130 continue
                 if( ip==1 )ip = 0
                 if( ip==-1 )ip = 1
              end do loop_140
           end if
           if( leftv ) then
              ! compute left eigenvectors.
              ip = 0
              is = 1
              loop_260: do ki = 1, n
                 if( ip==-1 )go to 250
                 if( ki==n )go to 150
                 if( t( ki+1, ki )==zero )go to 150
                 ip = 1
                 150 continue
                 if( somev ) then
                    if( .not.select( ki ) )go to 250
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki+1 ) ) )*sqrt( abs( t( ki+1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! real left eigenvector.
                    work( ki+n ) = one
                    ! form right-hand side
                    do k = ki + 1, n
                       work( k+n ) = -t( ki, k )
                    end do
                    ! solve the quasi-triangular system:
                       ! (t(ki+1:n,ki+1:n) - wr)**t*x = scale*work
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 1
                    loop_170: do j = ki + 1, n
                       if( j<jnxt )cycle loop_170
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_${ri}$dot( j-ki-1, t( ki+1, j ), 1,work( &
                                    ki+1+n ), 1 )
                          ! solve (t(j,j)-wr)**t*x = work
                          call stdlib_${ri}$laln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( n-ki+1, scale, work( ki+n ), 1 )
                                    
                          work( j+n ) = x( 1, 1 )
                          vmax = max( abs( work( j+n ) ), vmax )
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_${ri}$dot( j-ki-1, t( ki+1, j ), 1,work( &
                                    ki+1+n ), 1 )
                          work( j+1+n ) = work( j+1+n ) -stdlib_${ri}$dot( j-ki-1, t( ki+1, j+1 ), 1,&
                                    work( ki+1+n ), 1 )
                          ! solve
                            ! [t(j,j)-wr   t(j,j+1)     ]**t * x = scale*( work1 )
                            ! [t(j+1,j)    t(j+1,j+1)-wr]                ( work2 )
                          call stdlib_${ri}$laln2( .true., 2, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( n-ki+1, scale, work( ki+n ), 1 )
                                    
                          work( j+n ) = x( 1, 1 )
                          work( j+1+n ) = x( 2, 1 )
                          vmax = max( abs( work( j+n ) ),abs( work( j+1+n ) ), vmax )
                          vcrit = bignum / vmax
                       end if
                    end do loop_170
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       call stdlib_${ri}$copy( n-ki+1, work( ki+n ), 1, vl( ki, is ), 1 )
                       ii = stdlib_i${ri}$amax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                       remax = one / abs( vl( ii, is ) )
                       call stdlib_${ri}$scal( n-ki+1, remax, vl( ki, is ), 1 )
                       do k = 1, ki - 1
                          vl( k, is ) = zero
                       end do
                    else
                       if( ki<n )call stdlib_${ri}$gemv( 'N', n, n-ki, one, vl( 1, ki+1 ), ldvl,work( &
                                 ki+1+n ), 1, work( ki+n ),vl( 1, ki ), 1 )
                       ii = stdlib_i${ri}$amax( n, vl( 1, ki ), 1 )
                       remax = one / abs( vl( ii, ki ) )
                       call stdlib_${ri}$scal( n, remax, vl( 1, ki ), 1 )
                    end if
                 else
                    ! complex left eigenvector.
                     ! initial solve:
                       ! ((t(ki,ki)    t(ki,ki+1) )**t - (wr - i* wi))*x = 0.
                       ! ((t(ki+1,ki) t(ki+1,ki+1))                )
                    if( abs( t( ki, ki+1 ) )>=abs( t( ki+1, ki ) ) ) then
                       work( ki+n ) = wi / t( ki, ki+1 )
                       work( ki+1+n2 ) = one
                    else
                       work( ki+n ) = one
                       work( ki+1+n2 ) = -wi / t( ki+1, ki )
                    end if
                    work( ki+1+n ) = zero
                    work( ki+n2 ) = zero
                    ! form right-hand side
                    do k = ki + 2, n
                       work( k+n ) = -work( ki+n )*t( ki, k )
                       work( k+n2 ) = -work( ki+1+n2 )*t( ki+1, k )
                    end do
                    ! solve complex quasi-triangular system:
                    ! ( t(ki+2,n:ki+2,n) - (wr-i*wi) )*x = work1+i*work2
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 2
                    loop_200: do j = ki + 2, n
                       if( j<jnxt )cycle loop_200
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when
                          ! forming the right-hand side elements.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+n ), 1 )
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+n2 ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n ), 1 )
                          work( j+n2 ) = work( j+n2 ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n2 ), 1 )
                          ! solve (t(j,j)-(wr-i*wi))*(x11+i*x12)= wk+i*wk2
                          call stdlib_${ri}$laln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( n-ki+1, scale, work( ki+n ), 1 )
                             call stdlib_${ri}$scal( n-ki+1, scale, work( ki+n2 ), 1 )
                          end if
                          work( j+n ) = x( 1, 1 )
                          work( j+n2 ) = x( 1, 2 )
                          vmax = max( abs( work( j+n ) ),abs( work( j+n2 ) ), vmax )
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side elements.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+n ), 1 )
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+n2 ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n ), 1 )
                          work( j+n2 ) = work( j+n2 ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n2 ), 1 )
                          work( j+1+n ) = work( j+1+n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, j+1 ), 1,&
                                    work( ki+2+n ), 1 )
                          work( j+1+n2 ) = work( j+1+n2 ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, j+1 ), 1,&
                                    work( ki+2+n2 ), 1 )
                          ! solve 2-by-2 complex linear equation
                            ! ([t(j,j)   t(j,j+1)  ]**t-(wr-i*wi)*i)*x = scale*b
                            ! ([t(j+1,j) t(j+1,j+1)]               )
                          call stdlib_${ri}$laln2( .true., 2, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( n-ki+1, scale, work( ki+n ), 1 )
                             call stdlib_${ri}$scal( n-ki+1, scale, work( ki+n2 ), 1 )
                          end if
                          work( j+n ) = x( 1, 1 )
                          work( j+n2 ) = x( 1, 2 )
                          work( j+1+n ) = x( 2, 1 )
                          work( j+1+n2 ) = x( 2, 2 )
                          vmax = max( abs( x( 1, 1 ) ), abs( x( 1, 2 ) ),abs( x( 2, 1 ) ), abs( x(&
                                     2, 2 ) ), vmax )
                          vcrit = bignum / vmax
                       end if
                    end do loop_200
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       call stdlib_${ri}$copy( n-ki+1, work( ki+n ), 1, vl( ki, is ), 1 )
                       call stdlib_${ri}$copy( n-ki+1, work( ki+n2 ), 1, vl( ki, is+1 ),1 )
                       emax = zero
                       do k = ki, n
                          emax = max( emax, abs( vl( k, is ) )+abs( vl( k, is+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( n-ki+1, remax, vl( ki, is ), 1 )
                       call stdlib_${ri}$scal( n-ki+1, remax, vl( ki, is+1 ), 1 )
                       do k = 1, ki - 1
                          vl( k, is ) = zero
                          vl( k, is+1 ) = zero
                       end do
                    else
                       if( ki<n-1 ) then
                          call stdlib_${ri}$gemv( 'N', n, n-ki-1, one, vl( 1, ki+2 ),ldvl, work( ki+2+&
                                    n ), 1, work( ki+n ),vl( 1, ki ), 1 )
                          call stdlib_${ri}$gemv( 'N', n, n-ki-1, one, vl( 1, ki+2 ),ldvl, work( ki+2+&
                                    n2 ), 1,work( ki+1+n2 ), vl( 1, ki+1 ), 1 )
                       else
                          call stdlib_${ri}$scal( n, work( ki+n ), vl( 1, ki ), 1 )
                          call stdlib_${ri}$scal( n, work( ki+1+n2 ), vl( 1, ki+1 ), 1 )
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vl( k, ki ) )+abs( vl( k, ki+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( n, remax, vl( 1, ki ), 1 )
                       call stdlib_${ri}$scal( n, remax, vl( 1, ki+1 ), 1 )
                    end if
                 end if
                 is = is + 1
                 if( ip/=0 )is = is + 1
                 250 continue
                 if( ip==-1 )ip = 0
                 if( ip==1 )ip = -1
              end do loop_260
           end if
           return
     end subroutine stdlib_${ri}$trevc

#:endif
#:endfor

     module pure subroutine stdlib_ctrevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
     !! CTREVC computes some or all of the right and/or left eigenvectors of
     !! a complex upper triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a complex general matrix:  A = Q*T*Q**H, as computed by CHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**H)*T = w*(y**H)
     !! where y**H denotes the conjugate transpose of the vector y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix.  If Q is the unitary factor that reduces a matrix A to
     !! Schur form T, then Q*X and Q*Y are the matrices of right and left
     !! eigenvectors of A.
               work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           complex(sp), parameter :: cmzero = (0.0e+0_sp,0.0e+0_sp)
           complex(sp), parameter :: cmone = (1.0e+0_sp,0.0e+0_sp)
           
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, over, rightv, somev
           integer(ilp) :: i, ii, is, j, k, ki
           real(sp) :: ovfl, remax, scale, smin, smlnum, ulp, unfl
           complex(sp) :: cdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters
           bothv = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv = stdlib_lsame( side, 'L' ) .or. bothv
           allv = stdlib_lsame( howmny, 'A' )
           over = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           ! set m to the number of columns required to store the selected
           ! eigenvectors.
           if( somev ) then
              m = 0
              do j = 1, n
                 if( select( j ) )m = m + 1
              end do
           else
              m = n
           end if
           info = 0
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else if( mm<m ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTREVC', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! set the constants to control overflow.
           unfl = stdlib_slamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_slabad( unfl, ovfl )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           ! store the diagonal elements of t in working array work.
           do i = 1, n
              work( i+n ) = t( i, i )
           end do
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           rwork( 1 ) = zero
           do j = 2, n
              rwork( j ) = stdlib_scasum( j-1, t( 1, j ), 1 )
           end do
           if( rightv ) then
              ! compute right eigenvectors.
              is = m
              loop_80: do ki = n, 1, -1
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_80
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 work( 1 ) = cmone
                 ! form right-hand side.
                 do k = 1, ki - 1
                    work( k ) = -t( k, ki )
                 end do
                 ! solve the triangular system:
                    ! (t(1:ki-1,1:ki-1) - t(ki,ki))*x = scale*work.
                 do k = 1, ki - 1
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki>1 ) then
                    call stdlib_clatrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', 'Y',ki-1, t, ldt, &
                              work( 1 ), scale, rwork,info )
                    work( ki ) = scale
                 end if
                 ! copy the vector x or q*x to vr and normalize.
                 if( .not.over ) then
                    call stdlib_ccopy( ki, work( 1 ), 1, vr( 1, is ), 1 )
                    ii = stdlib_icamax( ki, vr( 1, is ), 1 )
                    remax = one / cabs1( vr( ii, is ) )
                    call stdlib_csscal( ki, remax, vr( 1, is ), 1 )
                    do k = ki + 1, n
                       vr( k, is ) = cmzero
                    end do
                 else
                    if( ki>1 )call stdlib_cgemv( 'N', n, ki-1, cmone, vr, ldvr, work( 1 ),1, &
                              cmplx( scale,KIND=sp), vr( 1, ki ), 1 )
                    ii = stdlib_icamax( n, vr( 1, ki ), 1 )
                    remax = one / cabs1( vr( ii, ki ) )
                    call stdlib_csscal( n, remax, vr( 1, ki ), 1 )
                 end if
                 ! set back the original diagonal elements of t.
                 do k = 1, ki - 1
                    t( k, k ) = work( k+n )
                 end do
                 is = is - 1
              end do loop_80
           end if
           if( leftv ) then
              ! compute left eigenvectors.
              is = 1
              loop_130: do ki = 1, n
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_130
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 work( n ) = cmone
                 ! form right-hand side.
                 do k = ki + 1, n
                    work( k ) = -conjg( t( ki, k ) )
                 end do
                 ! solve the triangular system:
                    ! (t(ki+1:n,ki+1:n) - t(ki,ki))**h*x = scale*work.
                 do k = ki + 1, n
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki<n ) then
                    call stdlib_clatrs( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT','Y', n-ki, t( &
                              ki+1, ki+1 ), ldt,work( ki+1 ), scale, rwork, info )
                    work( ki ) = scale
                 end if
                 ! copy the vector x or q*x to vl and normalize.
                 if( .not.over ) then
                    call stdlib_ccopy( n-ki+1, work( ki ), 1, vl( ki, is ), 1 )
                    ii = stdlib_icamax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                    remax = one / cabs1( vl( ii, is ) )
                    call stdlib_csscal( n-ki+1, remax, vl( ki, is ), 1 )
                    do k = 1, ki - 1
                       vl( k, is ) = cmzero
                    end do
                 else
                    if( ki<n )call stdlib_cgemv( 'N', n, n-ki, cmone, vl( 1, ki+1 ), ldvl,work( &
                              ki+1 ), 1, cmplx( scale,KIND=sp),vl( 1, ki ), 1 )
                    ii = stdlib_icamax( n, vl( 1, ki ), 1 )
                    remax = one / cabs1( vl( ii, ki ) )
                    call stdlib_csscal( n, remax, vl( 1, ki ), 1 )
                 end if
                 ! set back the original diagonal elements of t.
                 do k = ki + 1, n
                    t( k, k ) = work( k+n )
                 end do
                 is = is + 1
              end do loop_130
           end if
           return
     end subroutine stdlib_ctrevc

     module pure subroutine stdlib_ztrevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
     !! ZTREVC computes some or all of the right and/or left eigenvectors of
     !! a complex upper triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a complex general matrix:  A = Q*T*Q**H, as computed by ZHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**H)*T = w*(y**H)
     !! where y**H denotes the conjugate transpose of the vector y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix.  If Q is the unitary factor that reduces a matrix A to
     !! Schur form T, then Q*X and Q*Y are the matrices of right and left
     !! eigenvectors of A.
               work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           complex(dp), parameter :: cmzero = (0.0e+0_dp,0.0e+0_dp)
           complex(dp), parameter :: cmone = (1.0e+0_dp,0.0e+0_dp)
           
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, over, rightv, somev
           integer(ilp) :: i, ii, is, j, k, ki
           real(dp) :: ovfl, remax, scale, smin, smlnum, ulp, unfl
           complex(dp) :: cdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters
           bothv = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv = stdlib_lsame( side, 'L' ) .or. bothv
           allv = stdlib_lsame( howmny, 'A' )
           over = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           ! set m to the number of columns required to store the selected
           ! eigenvectors.
           if( somev ) then
              m = 0
              do j = 1, n
                 if( select( j ) )m = m + 1
              end do
           else
              m = n
           end if
           info = 0
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else if( mm<m ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTREVC', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! set the constants to control overflow.
           unfl = stdlib_dlamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_dlabad( unfl, ovfl )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           ! store the diagonal elements of t in working array work.
           do i = 1, n
              work( i+n ) = t( i, i )
           end do
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           rwork( 1 ) = zero
           do j = 2, n
              rwork( j ) = stdlib_dzasum( j-1, t( 1, j ), 1 )
           end do
           if( rightv ) then
              ! compute right eigenvectors.
              is = m
              loop_80: do ki = n, 1, -1
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_80
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 work( 1 ) = cmone
                 ! form right-hand side.
                 do k = 1, ki - 1
                    work( k ) = -t( k, ki )
                 end do
                 ! solve the triangular system:
                    ! (t(1:ki-1,1:ki-1) - t(ki,ki))*x = scale*work.
                 do k = 1, ki - 1
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki>1 ) then
                    call stdlib_zlatrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', 'Y',ki-1, t, ldt, &
                              work( 1 ), scale, rwork,info )
                    work( ki ) = scale
                 end if
                 ! copy the vector x or q*x to vr and normalize.
                 if( .not.over ) then
                    call stdlib_zcopy( ki, work( 1 ), 1, vr( 1, is ), 1 )
                    ii = stdlib_izamax( ki, vr( 1, is ), 1 )
                    remax = one / cabs1( vr( ii, is ) )
                    call stdlib_zdscal( ki, remax, vr( 1, is ), 1 )
                    do k = ki + 1, n
                       vr( k, is ) = cmzero
                    end do
                 else
                    if( ki>1 )call stdlib_zgemv( 'N', n, ki-1, cmone, vr, ldvr, work( 1 ),1, &
                              cmplx( scale,KIND=dp), vr( 1, ki ), 1 )
                    ii = stdlib_izamax( n, vr( 1, ki ), 1 )
                    remax = one / cabs1( vr( ii, ki ) )
                    call stdlib_zdscal( n, remax, vr( 1, ki ), 1 )
                 end if
                 ! set back the original diagonal elements of t.
                 do k = 1, ki - 1
                    t( k, k ) = work( k+n )
                 end do
                 is = is - 1
              end do loop_80
           end if
           if( leftv ) then
              ! compute left eigenvectors.
              is = 1
              loop_130: do ki = 1, n
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_130
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 work( n ) = cmone
                 ! form right-hand side.
                 do k = ki + 1, n
                    work( k ) = -conjg( t( ki, k ) )
                 end do
                 ! solve the triangular system:
                    ! (t(ki+1:n,ki+1:n) - t(ki,ki))**h * x = scale*work.
                 do k = ki + 1, n
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki<n ) then
                    call stdlib_zlatrs( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT','Y', n-ki, t( &
                              ki+1, ki+1 ), ldt,work( ki+1 ), scale, rwork, info )
                    work( ki ) = scale
                 end if
                 ! copy the vector x or q*x to vl and normalize.
                 if( .not.over ) then
                    call stdlib_zcopy( n-ki+1, work( ki ), 1, vl( ki, is ), 1 )
                    ii = stdlib_izamax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                    remax = one / cabs1( vl( ii, is ) )
                    call stdlib_zdscal( n-ki+1, remax, vl( ki, is ), 1 )
                    do k = 1, ki - 1
                       vl( k, is ) = cmzero
                    end do
                 else
                    if( ki<n )call stdlib_zgemv( 'N', n, n-ki, cmone, vl( 1, ki+1 ), ldvl,work( &
                              ki+1 ), 1, cmplx( scale,KIND=dp),vl( 1, ki ), 1 )
                    ii = stdlib_izamax( n, vl( 1, ki ), 1 )
                    remax = one / cabs1( vl( ii, ki ) )
                    call stdlib_zdscal( n, remax, vl( 1, ki ), 1 )
                 end if
                 ! set back the original diagonal elements of t.
                 do k = ki + 1, n
                    t( k, k ) = work( k+n )
                 end do
                 is = is + 1
              end do loop_130
           end if
           return
     end subroutine stdlib_ztrevc

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$trevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
     !! ZTREVC: computes some or all of the right and/or left eigenvectors of
     !! a complex upper triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a complex general matrix:  A = Q*T*Q**H, as computed by ZHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**H)*T = w*(y**H)
     !! where y**H denotes the conjugate transpose of the vector y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix.  If Q is the unitary factor that reduces a matrix A to
     !! Schur form T, then Q*X and Q*Y are the matrices of right and left
     !! eigenvectors of A.
               work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           complex(${ck}$), parameter :: cmzero = (0.0e+0_${ck}$,0.0e+0_${ck}$)
           complex(${ck}$), parameter :: cmone = (1.0e+0_${ck}$,0.0e+0_${ck}$)
           
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, over, rightv, somev
           integer(ilp) :: i, ii, is, j, k, ki
           real(${ck}$) :: ovfl, remax, scale, smin, smlnum, ulp, unfl
           complex(${ck}$) :: cdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters
           bothv = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv = stdlib_lsame( side, 'L' ) .or. bothv
           allv = stdlib_lsame( howmny, 'A' )
           over = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           ! set m to the number of columns required to store the selected
           ! eigenvectors.
           if( somev ) then
              m = 0
              do j = 1, n
                 if( select( j ) )m = m + 1
              end do
           else
              m = n
           end if
           info = 0
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else if( mm<m ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTREVC', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! set the constants to control overflow.
           unfl = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_${c2ri(ci)}$labad( unfl, ovfl )
           ulp = stdlib_${c2ri(ci)}$lamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           ! store the diagonal elements of t in working array work.
           do i = 1, n
              work( i+n ) = t( i, i )
           end do
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           rwork( 1 ) = zero
           do j = 2, n
              rwork( j ) = stdlib_${c2ri(ci)}$zasum( j-1, t( 1, j ), 1 )
           end do
           if( rightv ) then
              ! compute right eigenvectors.
              is = m
              loop_80: do ki = n, 1, -1
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_80
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 work( 1 ) = cmone
                 ! form right-hand side.
                 do k = 1, ki - 1
                    work( k ) = -t( k, ki )
                 end do
                 ! solve the triangular system:
                    ! (t(1:ki-1,1:ki-1) - t(ki,ki))*x = scale*work.
                 do k = 1, ki - 1
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki>1 ) then
                    call stdlib_${ci}$latrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', 'Y',ki-1, t, ldt, &
                              work( 1 ), scale, rwork,info )
                    work( ki ) = scale
                 end if
                 ! copy the vector x or q*x to vr and normalize.
                 if( .not.over ) then
                    call stdlib_${ci}$copy( ki, work( 1 ), 1, vr( 1, is ), 1 )
                    ii = stdlib_i${ci}$amax( ki, vr( 1, is ), 1 )
                    remax = one / cabs1( vr( ii, is ) )
                    call stdlib_${ci}$dscal( ki, remax, vr( 1, is ), 1 )
                    do k = ki + 1, n
                       vr( k, is ) = cmzero
                    end do
                 else
                    if( ki>1 )call stdlib_${ci}$gemv( 'N', n, ki-1, cmone, vr, ldvr, work( 1 ),1, &
                              cmplx( scale,KIND=${ck}$), vr( 1, ki ), 1 )
                    ii = stdlib_i${ci}$amax( n, vr( 1, ki ), 1 )
                    remax = one / cabs1( vr( ii, ki ) )
                    call stdlib_${ci}$dscal( n, remax, vr( 1, ki ), 1 )
                 end if
                 ! set back the original diagonal elements of t.
                 do k = 1, ki - 1
                    t( k, k ) = work( k+n )
                 end do
                 is = is - 1
              end do loop_80
           end if
           if( leftv ) then
              ! compute left eigenvectors.
              is = 1
              loop_130: do ki = 1, n
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_130
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 work( n ) = cmone
                 ! form right-hand side.
                 do k = ki + 1, n
                    work( k ) = -conjg( t( ki, k ) )
                 end do
                 ! solve the triangular system:
                    ! (t(ki+1:n,ki+1:n) - t(ki,ki))**h * x = scale*work.
                 do k = ki + 1, n
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki<n ) then
                    call stdlib_${ci}$latrs( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT','Y', n-ki, t( &
                              ki+1, ki+1 ), ldt,work( ki+1 ), scale, rwork, info )
                    work( ki ) = scale
                 end if
                 ! copy the vector x or q*x to vl and normalize.
                 if( .not.over ) then
                    call stdlib_${ci}$copy( n-ki+1, work( ki ), 1, vl( ki, is ), 1 )
                    ii = stdlib_i${ci}$amax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                    remax = one / cabs1( vl( ii, is ) )
                    call stdlib_${ci}$dscal( n-ki+1, remax, vl( ki, is ), 1 )
                    do k = 1, ki - 1
                       vl( k, is ) = cmzero
                    end do
                 else
                    if( ki<n )call stdlib_${ci}$gemv( 'N', n, n-ki, cmone, vl( 1, ki+1 ), ldvl,work( &
                              ki+1 ), 1, cmplx( scale,KIND=${ck}$),vl( 1, ki ), 1 )
                    ii = stdlib_i${ci}$amax( n, vl( 1, ki ), 1 )
                    remax = one / cabs1( vl( ii, ki ) )
                    call stdlib_${ci}$dscal( n, remax, vl( 1, ki ), 1 )
                 end if
                 ! set back the original diagonal elements of t.
                 do k = ki + 1, n
                    t( k, k ) = work( k+n )
                 end do
                 is = is + 1
              end do loop_130
           end if
           return
     end subroutine stdlib_${ci}$trevc

#:endif
#:endfor





     module pure subroutine stdlib_stgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, s, &
     !! STGSNA estimates reciprocal condition numbers for specified
     !! eigenvalues and/or eigenvectors of a matrix pair (A, B) in
     !! generalized real Schur canonical form (or of any matrix pair
     !! (Q*A*Z**T, Q*B*Z**T) with orthogonal matrices Q and Z, where
     !! Z**T denotes the transpose of Z.
     !! (A, B) must be in generalized real Schur form (as returned by SGGES),
     !! i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal
     !! blocks. B is upper triangular.
               dif, mm, m, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(in) :: a(lda,*), b(ldb,*), vl(ldvl,*), vr(ldvr,*)
           real(sp), intent(out) :: dif(*), s(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: difdri = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, pair, somcon, wantbh, wantdf, wants
           integer(ilp) :: i, ierr, ifst, ilst, iz, k, ks, lwmin, n1, n2
           real(sp) :: alphai, alphar, alprqt, beta, c1, c2, cond, eps, lnrm, rnrm, root1, root2, &
                     scale, smlnum, tmpii, tmpir, tmpri, tmprr, uhav, uhavi, uhbv, uhbvi
           ! Local Arrays 
           real(sp) :: dummy(1), dummy1(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantdf = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           info = 0
           lquery = ( lwork==-1 )
           if( .not.wants .and. .not.wantdf ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( wants .and. ldvl<n ) then
              info = -10
           else if( wants .and. ldvr<n ) then
              info = -12
           else
              ! set m to the number of eigenpairs for which condition numbers
              ! are required, and test mm.
              if( somcon ) then
                 m = 0
                 pair = .false.
                 do k = 1, n
                    if( pair ) then
                       pair = .false.
                    else
                       if( k<n ) then
                          if( a( k+1, k )==zero ) then
                             if( select( k ) )m = m + 1
                          else
                             pair = .true.
                             if( select( k ) .or. select( k+1 ) )m = m + 2
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( n==0 ) then
                 lwmin = 1
              else if( stdlib_lsame( job, 'V' ) .or. stdlib_lsame( job, 'B' ) ) then
                 lwmin = 2*n*( n + 2 ) + 16
              else
                 lwmin = n
              end if
              work( 1 ) = lwmin
              if( mm<m ) then
                 info = -15
              else if( lwork<lwmin .and. .not.lquery ) then
                 info = -18
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STGSNA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' ) / eps
           ks = 0
           pair = .false.
           loop_20: do k = 1, n
              ! determine whether a(k,k) begins a 1-by-1 or 2-by-2 block.
              if( pair ) then
                 pair = .false.
                 cycle loop_20
              else
                 if( k<n )pair = a( k+1, k )/=zero
              end if
              ! determine whether condition numbers are required for the k-th
              ! eigenpair.
              if( somcon ) then
                 if( pair ) then
                    if( .not.select( k ) .and. .not.select( k+1 ) )cycle loop_20
                 else
                    if( .not.select( k ) )cycle loop_20
                 end if
              end if
              ks = ks + 1
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 if( pair ) then
                    ! complex eigenvalue pair.
                    rnrm = stdlib_slapy2( stdlib_snrm2( n, vr( 1, ks ), 1 ),stdlib_snrm2( n, vr( &
                              1, ks+1 ), 1 ) )
                    lnrm = stdlib_slapy2( stdlib_snrm2( n, vl( 1, ks ), 1 ),stdlib_snrm2( n, vl( &
                              1, ks+1 ), 1 ) )
                    call stdlib_sgemv( 'N', n, n, one, a, lda, vr( 1, ks ), 1, zero,work, 1 )
                              
                    tmprr = stdlib_sdot( n, work, 1, vl( 1, ks ), 1 )
                    tmpri = stdlib_sdot( n, work, 1, vl( 1, ks+1 ), 1 )
                    call stdlib_sgemv( 'N', n, n, one, a, lda, vr( 1, ks+1 ), 1,zero, work, 1 )
                              
                    tmpii = stdlib_sdot( n, work, 1, vl( 1, ks+1 ), 1 )
                    tmpir = stdlib_sdot( n, work, 1, vl( 1, ks ), 1 )
                    uhav = tmprr + tmpii
                    uhavi = tmpir - tmpri
                    call stdlib_sgemv( 'N', n, n, one, b, ldb, vr( 1, ks ), 1, zero,work, 1 )
                              
                    tmprr = stdlib_sdot( n, work, 1, vl( 1, ks ), 1 )
                    tmpri = stdlib_sdot( n, work, 1, vl( 1, ks+1 ), 1 )
                    call stdlib_sgemv( 'N', n, n, one, b, ldb, vr( 1, ks+1 ), 1,zero, work, 1 )
                              
                    tmpii = stdlib_sdot( n, work, 1, vl( 1, ks+1 ), 1 )
                    tmpir = stdlib_sdot( n, work, 1, vl( 1, ks ), 1 )
                    uhbv = tmprr + tmpii
                    uhbvi = tmpir - tmpri
                    uhav = stdlib_slapy2( uhav, uhavi )
                    uhbv = stdlib_slapy2( uhbv, uhbvi )
                    cond = stdlib_slapy2( uhav, uhbv )
                    s( ks ) = cond / ( rnrm*lnrm )
                    s( ks+1 ) = s( ks )
                 else
                    ! real eigenvalue.
                    rnrm = stdlib_snrm2( n, vr( 1, ks ), 1 )
                    lnrm = stdlib_snrm2( n, vl( 1, ks ), 1 )
                    call stdlib_sgemv( 'N', n, n, one, a, lda, vr( 1, ks ), 1, zero,work, 1 )
                              
                    uhav = stdlib_sdot( n, work, 1, vl( 1, ks ), 1 )
                    call stdlib_sgemv( 'N', n, n, one, b, ldb, vr( 1, ks ), 1, zero,work, 1 )
                              
                    uhbv = stdlib_sdot( n, work, 1, vl( 1, ks ), 1 )
                    cond = stdlib_slapy2( uhav, uhbv )
                    if( cond==zero ) then
                       s( ks ) = -one
                    else
                       s( ks ) = cond / ( rnrm*lnrm )
                    end if
                 end if
              end if
              if( wantdf ) then
                 if( n==1 ) then
                    dif( ks ) = stdlib_slapy2( a( 1, 1 ), b( 1, 1 ) )
                    cycle loop_20
                 end if
                 ! estimate the reciprocal condition number of the k-th
                 ! eigenvectors.
                 if( pair ) then
                    ! copy the  2-by 2 pencil beginning at (a(k,k), b(k, k)).
                    ! compute the eigenvalue(s) at position k.
                    work( 1 ) = a( k, k )
                    work( 2 ) = a( k+1, k )
                    work( 3 ) = a( k, k+1 )
                    work( 4 ) = a( k+1, k+1 )
                    work( 5 ) = b( k, k )
                    work( 6 ) = b( k+1, k )
                    work( 7 ) = b( k, k+1 )
                    work( 8 ) = b( k+1, k+1 )
                    call stdlib_slag2( work, 2, work( 5 ), 2, smlnum*eps, beta,dummy1( 1 ), &
                              alphar, dummy( 1 ), alphai )
                    alprqt = one
                    c1 = two*( alphar*alphar+alphai*alphai+beta*beta )
                    c2 = four*beta*beta*alphai*alphai
                    root1 = c1 + sqrt( c1*c1-4.0_sp*c2 )
                    root2 = c2 / root1
                    root1 = root1 / two
                    cond = min( sqrt( root1 ), sqrt( root2 ) )
                 end if
                 ! copy the matrix (a, b) to the array work and swap the
                 ! diagonal block beginning at a(k,k) to the (1,1) position.
                 call stdlib_slacpy( 'FULL', n, n, a, lda, work, n )
                 call stdlib_slacpy( 'FULL', n, n, b, ldb, work( n*n+1 ), n )
                 ifst = k
                 ilst = 1
                 call stdlib_stgexc( .false., .false., n, work, n, work( n*n+1 ), n,dummy, 1, &
                           dummy1, 1, ifst, ilst,work( n*n*2+1 ), lwork-2*n*n, ierr )
                 if( ierr>0 ) then
                    ! ill-conditioned problem - swap rejected.
                    dif( ks ) = zero
                 else
                    ! reordering successful, solve generalized sylvester
                    ! equation for r and l,
                               ! a22 * r - l * a11 = a12
                               ! b22 * r - l * b11 = b12,
                    ! and compute estimate of difl((a11,b11), (a22, b22)).
                    n1 = 1
                    if( work( 2 )/=zero )n1 = 2
                    n2 = n - n1
                    if( n2==0 ) then
                       dif( ks ) = cond
                    else
                       i = n*n + 1
                       iz = 2*n*n + 1
                       call stdlib_stgsyl( 'N', difdri, n2, n1, work( n*n1+n1+1 ),n, work, n, &
                       work( n1+1 ), n,work( n*n1+n1+i ), n, work( i ), n,work( n1+i ), n, scale, &
                                 dif( ks ),work( iz+1 ), lwork-2*n*n, iwork, ierr )
                       if( pair )dif( ks ) = min( max( one, alprqt )*dif( ks ),cond )
                    end if
                 end if
                 if( pair )dif( ks+1 ) = dif( ks )
              end if
              if( pair )ks = ks + 1
           end do loop_20
           work( 1 ) = lwmin
           return
     end subroutine stdlib_stgsna

     module pure subroutine stdlib_dtgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, s, &
     !! DTGSNA estimates reciprocal condition numbers for specified
     !! eigenvalues and/or eigenvectors of a matrix pair (A, B) in
     !! generalized real Schur canonical form (or of any matrix pair
     !! (Q*A*Z**T, Q*B*Z**T) with orthogonal matrices Q and Z, where
     !! Z**T denotes the transpose of Z.
     !! (A, B) must be in generalized real Schur form (as returned by DGGES),
     !! i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal
     !! blocks. B is upper triangular.
               dif, mm, m, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(in) :: a(lda,*), b(ldb,*), vl(ldvl,*), vr(ldvr,*)
           real(dp), intent(out) :: dif(*), s(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: difdri = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, pair, somcon, wantbh, wantdf, wants
           integer(ilp) :: i, ierr, ifst, ilst, iz, k, ks, lwmin, n1, n2
           real(dp) :: alphai, alphar, alprqt, beta, c1, c2, cond, eps, lnrm, rnrm, root1, root2, &
                     scale, smlnum, tmpii, tmpir, tmpri, tmprr, uhav, uhavi, uhbv, uhbvi
           ! Local Arrays 
           real(dp) :: dummy(1), dummy1(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantdf = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           info = 0
           lquery = ( lwork==-1 )
           if( .not.wants .and. .not.wantdf ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( wants .and. ldvl<n ) then
              info = -10
           else if( wants .and. ldvr<n ) then
              info = -12
           else
              ! set m to the number of eigenpairs for which condition numbers
              ! are required, and test mm.
              if( somcon ) then
                 m = 0
                 pair = .false.
                 do k = 1, n
                    if( pair ) then
                       pair = .false.
                    else
                       if( k<n ) then
                          if( a( k+1, k )==zero ) then
                             if( select( k ) )m = m + 1
                          else
                             pair = .true.
                             if( select( k ) .or. select( k+1 ) )m = m + 2
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( n==0 ) then
                 lwmin = 1
              else if( stdlib_lsame( job, 'V' ) .or. stdlib_lsame( job, 'B' ) ) then
                 lwmin = 2*n*( n + 2 ) + 16
              else
                 lwmin = n
              end if
              work( 1 ) = lwmin
              if( mm<m ) then
                 info = -15
              else if( lwork<lwmin .and. .not.lquery ) then
                 info = -18
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSNA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' ) / eps
           ks = 0
           pair = .false.
           loop_20: do k = 1, n
              ! determine whether a(k,k) begins a 1-by-1 or 2-by-2 block.
              if( pair ) then
                 pair = .false.
                 cycle loop_20
              else
                 if( k<n )pair = a( k+1, k )/=zero
              end if
              ! determine whether condition numbers are required for the k-th
              ! eigenpair.
              if( somcon ) then
                 if( pair ) then
                    if( .not.select( k ) .and. .not.select( k+1 ) )cycle loop_20
                 else
                    if( .not.select( k ) )cycle loop_20
                 end if
              end if
              ks = ks + 1
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 if( pair ) then
                    ! complex eigenvalue pair.
                    rnrm = stdlib_dlapy2( stdlib_dnrm2( n, vr( 1, ks ), 1 ),stdlib_dnrm2( n, vr( &
                              1, ks+1 ), 1 ) )
                    lnrm = stdlib_dlapy2( stdlib_dnrm2( n, vl( 1, ks ), 1 ),stdlib_dnrm2( n, vl( &
                              1, ks+1 ), 1 ) )
                    call stdlib_dgemv( 'N', n, n, one, a, lda, vr( 1, ks ), 1, zero,work, 1 )
                              
                    tmprr = stdlib_ddot( n, work, 1, vl( 1, ks ), 1 )
                    tmpri = stdlib_ddot( n, work, 1, vl( 1, ks+1 ), 1 )
                    call stdlib_dgemv( 'N', n, n, one, a, lda, vr( 1, ks+1 ), 1,zero, work, 1 )
                              
                    tmpii = stdlib_ddot( n, work, 1, vl( 1, ks+1 ), 1 )
                    tmpir = stdlib_ddot( n, work, 1, vl( 1, ks ), 1 )
                    uhav = tmprr + tmpii
                    uhavi = tmpir - tmpri
                    call stdlib_dgemv( 'N', n, n, one, b, ldb, vr( 1, ks ), 1, zero,work, 1 )
                              
                    tmprr = stdlib_ddot( n, work, 1, vl( 1, ks ), 1 )
                    tmpri = stdlib_ddot( n, work, 1, vl( 1, ks+1 ), 1 )
                    call stdlib_dgemv( 'N', n, n, one, b, ldb, vr( 1, ks+1 ), 1,zero, work, 1 )
                              
                    tmpii = stdlib_ddot( n, work, 1, vl( 1, ks+1 ), 1 )
                    tmpir = stdlib_ddot( n, work, 1, vl( 1, ks ), 1 )
                    uhbv = tmprr + tmpii
                    uhbvi = tmpir - tmpri
                    uhav = stdlib_dlapy2( uhav, uhavi )
                    uhbv = stdlib_dlapy2( uhbv, uhbvi )
                    cond = stdlib_dlapy2( uhav, uhbv )
                    s( ks ) = cond / ( rnrm*lnrm )
                    s( ks+1 ) = s( ks )
                 else
                    ! real eigenvalue.
                    rnrm = stdlib_dnrm2( n, vr( 1, ks ), 1 )
                    lnrm = stdlib_dnrm2( n, vl( 1, ks ), 1 )
                    call stdlib_dgemv( 'N', n, n, one, a, lda, vr( 1, ks ), 1, zero,work, 1 )
                              
                    uhav = stdlib_ddot( n, work, 1, vl( 1, ks ), 1 )
                    call stdlib_dgemv( 'N', n, n, one, b, ldb, vr( 1, ks ), 1, zero,work, 1 )
                              
                    uhbv = stdlib_ddot( n, work, 1, vl( 1, ks ), 1 )
                    cond = stdlib_dlapy2( uhav, uhbv )
                    if( cond==zero ) then
                       s( ks ) = -one
                    else
                       s( ks ) = cond / ( rnrm*lnrm )
                    end if
                 end if
              end if
              if( wantdf ) then
                 if( n==1 ) then
                    dif( ks ) = stdlib_dlapy2( a( 1, 1 ), b( 1, 1 ) )
                    cycle loop_20
                 end if
                 ! estimate the reciprocal condition number of the k-th
                 ! eigenvectors.
                 if( pair ) then
                    ! copy the  2-by 2 pencil beginning at (a(k,k), b(k, k)).
                    ! compute the eigenvalue(s) at position k.
                    work( 1 ) = a( k, k )
                    work( 2 ) = a( k+1, k )
                    work( 3 ) = a( k, k+1 )
                    work( 4 ) = a( k+1, k+1 )
                    work( 5 ) = b( k, k )
                    work( 6 ) = b( k+1, k )
                    work( 7 ) = b( k, k+1 )
                    work( 8 ) = b( k+1, k+1 )
                    call stdlib_dlag2( work, 2, work( 5 ), 2, smlnum*eps, beta,dummy1( 1 ), &
                              alphar, dummy( 1 ), alphai )
                    alprqt = one
                    c1 = two*( alphar*alphar+alphai*alphai+beta*beta )
                    c2 = four*beta*beta*alphai*alphai
                    root1 = c1 + sqrt( c1*c1-4.0_dp*c2 )
                    root2 = c2 / root1
                    root1 = root1 / two
                    cond = min( sqrt( root1 ), sqrt( root2 ) )
                 end if
                 ! copy the matrix (a, b) to the array work and swap the
                 ! diagonal block beginning at a(k,k) to the (1,1) position.
                 call stdlib_dlacpy( 'FULL', n, n, a, lda, work, n )
                 call stdlib_dlacpy( 'FULL', n, n, b, ldb, work( n*n+1 ), n )
                 ifst = k
                 ilst = 1
                 call stdlib_dtgexc( .false., .false., n, work, n, work( n*n+1 ), n,dummy, 1, &
                           dummy1, 1, ifst, ilst,work( n*n*2+1 ), lwork-2*n*n, ierr )
                 if( ierr>0 ) then
                    ! ill-conditioned problem - swap rejected.
                    dif( ks ) = zero
                 else
                    ! reordering successful, solve generalized sylvester
                    ! equation for r and l,
                               ! a22 * r - l * a11 = a12
                               ! b22 * r - l * b11 = b12,
                    ! and compute estimate of difl((a11,b11), (a22, b22)).
                    n1 = 1
                    if( work( 2 )/=zero )n1 = 2
                    n2 = n - n1
                    if( n2==0 ) then
                       dif( ks ) = cond
                    else
                       i = n*n + 1
                       iz = 2*n*n + 1
                       call stdlib_dtgsyl( 'N', difdri, n2, n1, work( n*n1+n1+1 ),n, work, n, &
                       work( n1+1 ), n,work( n*n1+n1+i ), n, work( i ), n,work( n1+i ), n, scale, &
                                 dif( ks ),work( iz+1 ), lwork-2*n*n, iwork, ierr )
                       if( pair )dif( ks ) = min( max( one, alprqt )*dif( ks ),cond )
                    end if
                 end if
                 if( pair )dif( ks+1 ) = dif( ks )
              end if
              if( pair )ks = ks + 1
           end do loop_20
           work( 1 ) = lwmin
           return
     end subroutine stdlib_dtgsna

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$tgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, s, &
     !! DTGSNA: estimates reciprocal condition numbers for specified
     !! eigenvalues and/or eigenvectors of a matrix pair (A, B) in
     !! generalized real Schur canonical form (or of any matrix pair
     !! (Q*A*Z**T, Q*B*Z**T) with orthogonal matrices Q and Z, where
     !! Z**T denotes the transpose of Z.
     !! (A, B) must be in generalized real Schur form (as returned by DGGES),
     !! i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal
     !! blocks. B is upper triangular.
               dif, mm, m, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*), vl(ldvl,*), vr(ldvr,*)
           real(${rk}$), intent(out) :: dif(*), s(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: difdri = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, pair, somcon, wantbh, wantdf, wants
           integer(ilp) :: i, ierr, ifst, ilst, iz, k, ks, lwmin, n1, n2
           real(${rk}$) :: alphai, alphar, alprqt, beta, c1, c2, cond, eps, lnrm, rnrm, root1, root2, &
                     scale, smlnum, tmpii, tmpir, tmpri, tmprr, uhav, uhavi, uhbv, uhbvi
           ! Local Arrays 
           real(${rk}$) :: dummy(1), dummy1(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantdf = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           info = 0
           lquery = ( lwork==-1 )
           if( .not.wants .and. .not.wantdf ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( wants .and. ldvl<n ) then
              info = -10
           else if( wants .and. ldvr<n ) then
              info = -12
           else
              ! set m to the number of eigenpairs for which condition numbers
              ! are required, and test mm.
              if( somcon ) then
                 m = 0
                 pair = .false.
                 do k = 1, n
                    if( pair ) then
                       pair = .false.
                    else
                       if( k<n ) then
                          if( a( k+1, k )==zero ) then
                             if( select( k ) )m = m + 1
                          else
                             pair = .true.
                             if( select( k ) .or. select( k+1 ) )m = m + 2
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( n==0 ) then
                 lwmin = 1
              else if( stdlib_lsame( job, 'V' ) .or. stdlib_lsame( job, 'B' ) ) then
                 lwmin = 2*n*( n + 2 ) + 16
              else
                 lwmin = n
              end if
              work( 1 ) = lwmin
              if( mm<m ) then
                 info = -15
              else if( lwork<lwmin .and. .not.lquery ) then
                 info = -18
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSNA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' ) / eps
           ks = 0
           pair = .false.
           loop_20: do k = 1, n
              ! determine whether a(k,k) begins a 1-by-1 or 2-by-2 block.
              if( pair ) then
                 pair = .false.
                 cycle loop_20
              else
                 if( k<n )pair = a( k+1, k )/=zero
              end if
              ! determine whether condition numbers are required for the k-th
              ! eigenpair.
              if( somcon ) then
                 if( pair ) then
                    if( .not.select( k ) .and. .not.select( k+1 ) )cycle loop_20
                 else
                    if( .not.select( k ) )cycle loop_20
                 end if
              end if
              ks = ks + 1
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 if( pair ) then
                    ! complex eigenvalue pair.
                    rnrm = stdlib_${ri}$lapy2( stdlib_${ri}$nrm2( n, vr( 1, ks ), 1 ),stdlib_${ri}$nrm2( n, vr( &
                              1, ks+1 ), 1 ) )
                    lnrm = stdlib_${ri}$lapy2( stdlib_${ri}$nrm2( n, vl( 1, ks ), 1 ),stdlib_${ri}$nrm2( n, vl( &
                              1, ks+1 ), 1 ) )
                    call stdlib_${ri}$gemv( 'N', n, n, one, a, lda, vr( 1, ks ), 1, zero,work, 1 )
                              
                    tmprr = stdlib_${ri}$dot( n, work, 1, vl( 1, ks ), 1 )
                    tmpri = stdlib_${ri}$dot( n, work, 1, vl( 1, ks+1 ), 1 )
                    call stdlib_${ri}$gemv( 'N', n, n, one, a, lda, vr( 1, ks+1 ), 1,zero, work, 1 )
                              
                    tmpii = stdlib_${ri}$dot( n, work, 1, vl( 1, ks+1 ), 1 )
                    tmpir = stdlib_${ri}$dot( n, work, 1, vl( 1, ks ), 1 )
                    uhav = tmprr + tmpii
                    uhavi = tmpir - tmpri
                    call stdlib_${ri}$gemv( 'N', n, n, one, b, ldb, vr( 1, ks ), 1, zero,work, 1 )
                              
                    tmprr = stdlib_${ri}$dot( n, work, 1, vl( 1, ks ), 1 )
                    tmpri = stdlib_${ri}$dot( n, work, 1, vl( 1, ks+1 ), 1 )
                    call stdlib_${ri}$gemv( 'N', n, n, one, b, ldb, vr( 1, ks+1 ), 1,zero, work, 1 )
                              
                    tmpii = stdlib_${ri}$dot( n, work, 1, vl( 1, ks+1 ), 1 )
                    tmpir = stdlib_${ri}$dot( n, work, 1, vl( 1, ks ), 1 )
                    uhbv = tmprr + tmpii
                    uhbvi = tmpir - tmpri
                    uhav = stdlib_${ri}$lapy2( uhav, uhavi )
                    uhbv = stdlib_${ri}$lapy2( uhbv, uhbvi )
                    cond = stdlib_${ri}$lapy2( uhav, uhbv )
                    s( ks ) = cond / ( rnrm*lnrm )
                    s( ks+1 ) = s( ks )
                 else
                    ! real eigenvalue.
                    rnrm = stdlib_${ri}$nrm2( n, vr( 1, ks ), 1 )
                    lnrm = stdlib_${ri}$nrm2( n, vl( 1, ks ), 1 )
                    call stdlib_${ri}$gemv( 'N', n, n, one, a, lda, vr( 1, ks ), 1, zero,work, 1 )
                              
                    uhav = stdlib_${ri}$dot( n, work, 1, vl( 1, ks ), 1 )
                    call stdlib_${ri}$gemv( 'N', n, n, one, b, ldb, vr( 1, ks ), 1, zero,work, 1 )
                              
                    uhbv = stdlib_${ri}$dot( n, work, 1, vl( 1, ks ), 1 )
                    cond = stdlib_${ri}$lapy2( uhav, uhbv )
                    if( cond==zero ) then
                       s( ks ) = -one
                    else
                       s( ks ) = cond / ( rnrm*lnrm )
                    end if
                 end if
              end if
              if( wantdf ) then
                 if( n==1 ) then
                    dif( ks ) = stdlib_${ri}$lapy2( a( 1, 1 ), b( 1, 1 ) )
                    cycle loop_20
                 end if
                 ! estimate the reciprocal condition number of the k-th
                 ! eigenvectors.
                 if( pair ) then
                    ! copy the  2-by 2 pencil beginning at (a(k,k), b(k, k)).
                    ! compute the eigenvalue(s) at position k.
                    work( 1 ) = a( k, k )
                    work( 2 ) = a( k+1, k )
                    work( 3 ) = a( k, k+1 )
                    work( 4 ) = a( k+1, k+1 )
                    work( 5 ) = b( k, k )
                    work( 6 ) = b( k+1, k )
                    work( 7 ) = b( k, k+1 )
                    work( 8 ) = b( k+1, k+1 )
                    call stdlib_${ri}$lag2( work, 2, work( 5 ), 2, smlnum*eps, beta,dummy1( 1 ), &
                              alphar, dummy( 1 ), alphai )
                    alprqt = one
                    c1 = two*( alphar*alphar+alphai*alphai+beta*beta )
                    c2 = four*beta*beta*alphai*alphai
                    root1 = c1 + sqrt( c1*c1-4.0_${rk}$*c2 )
                    root2 = c2 / root1
                    root1 = root1 / two
                    cond = min( sqrt( root1 ), sqrt( root2 ) )
                 end if
                 ! copy the matrix (a, b) to the array work and swap the
                 ! diagonal block beginning at a(k,k) to the (1,1) position.
                 call stdlib_${ri}$lacpy( 'FULL', n, n, a, lda, work, n )
                 call stdlib_${ri}$lacpy( 'FULL', n, n, b, ldb, work( n*n+1 ), n )
                 ifst = k
                 ilst = 1
                 call stdlib_${ri}$tgexc( .false., .false., n, work, n, work( n*n+1 ), n,dummy, 1, &
                           dummy1, 1, ifst, ilst,work( n*n*2+1 ), lwork-2*n*n, ierr )
                 if( ierr>0 ) then
                    ! ill-conditioned problem - swap rejected.
                    dif( ks ) = zero
                 else
                    ! reordering successful, solve generalized sylvester
                    ! equation for r and l,
                               ! a22 * r - l * a11 = a12
                               ! b22 * r - l * b11 = b12,
                    ! and compute estimate of difl((a11,b11), (a22, b22)).
                    n1 = 1
                    if( work( 2 )/=zero )n1 = 2
                    n2 = n - n1
                    if( n2==0 ) then
                       dif( ks ) = cond
                    else
                       i = n*n + 1
                       iz = 2*n*n + 1
                       call stdlib_${ri}$tgsyl( 'N', difdri, n2, n1, work( n*n1+n1+1 ),n, work, n, &
                       work( n1+1 ), n,work( n*n1+n1+i ), n, work( i ), n,work( n1+i ), n, scale, &
                                 dif( ks ),work( iz+1 ), lwork-2*n*n, iwork, ierr )
                       if( pair )dif( ks ) = min( max( one, alprqt )*dif( ks ),cond )
                    end if
                 end if
                 if( pair )dif( ks+1 ) = dif( ks )
              end if
              if( pair )ks = ks + 1
           end do loop_20
           work( 1 ) = lwmin
           return
     end subroutine stdlib_${ri}$tgsna

#:endif
#:endfor

     module pure subroutine stdlib_ctgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, s, &
     !! CTGSNA estimates reciprocal condition numbers for specified
     !! eigenvalues and/or eigenvectors of a matrix pair (A, B).
     !! (A, B) must be in generalized Schur canonical form, that is, A and
     !! B are both upper triangular.
               dif, mm, m, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(out) :: dif(*), s(*)
           complex(sp), intent(in) :: a(lda,*), b(ldb,*), vl(ldvl,*), vr(ldvr,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: idifjb = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, somcon, wantbh, wantdf, wants
           integer(ilp) :: i, ierr, ifst, ilst, k, ks, lwmin, n1, n2
           real(sp) :: bignum, cond, eps, lnrm, rnrm, scale, smlnum
           complex(sp) :: yhax, yhbx
           ! Local Arrays 
           complex(sp) :: dummy(1), dummy1(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantdf = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           info = 0
           lquery = ( lwork==-1 )
           if( .not.wants .and. .not.wantdf ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( wants .and. ldvl<n ) then
              info = -10
           else if( wants .and. ldvr<n ) then
              info = -12
           else
              ! set m to the number of eigenpairs for which condition numbers
              ! are required, and test mm.
              if( somcon ) then
                 m = 0
                 do k = 1, n
                    if( select( k ) )m = m + 1
                 end do
              else
                 m = n
              end if
              if( n==0 ) then
                 lwmin = 1
              else if( stdlib_lsame( job, 'V' ) .or. stdlib_lsame( job, 'B' ) ) then
                 lwmin = 2*n*n
              else
                 lwmin = n
              end if
              work( 1 ) = lwmin
              if( mm<m ) then
                 info = -15
              else if( lwork<lwmin .and. .not.lquery ) then
                 info = -18
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGSNA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' ) / eps
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           ks = 0
           loop_20: do k = 1, n
              ! determine whether condition numbers are required for the k-th
              ! eigenpair.
              if( somcon ) then
                 if( .not.select( k ) )cycle loop_20
              end if
              ks = ks + 1
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 rnrm = stdlib_scnrm2( n, vr( 1, ks ), 1 )
                 lnrm = stdlib_scnrm2( n, vl( 1, ks ), 1 )
                 call stdlib_cgemv( 'N', n, n, cmplx( one, zero,KIND=sp), a, lda,vr( 1, ks ), 1, &
                           cmplx( zero, zero,KIND=sp), work, 1 )
                 yhax = stdlib_cdotc( n, work, 1, vl( 1, ks ), 1 )
                 call stdlib_cgemv( 'N', n, n, cmplx( one, zero,KIND=sp), b, ldb,vr( 1, ks ), 1, &
                           cmplx( zero, zero,KIND=sp), work, 1 )
                 yhbx = stdlib_cdotc( n, work, 1, vl( 1, ks ), 1 )
                 cond = stdlib_slapy2( abs( yhax ), abs( yhbx ) )
                 if( cond==zero ) then
                    s( ks ) = -one
                 else
                    s( ks ) = cond / ( rnrm*lnrm )
                 end if
              end if
              if( wantdf ) then
                 if( n==1 ) then
                    dif( ks ) = stdlib_slapy2( abs( a( 1, 1 ) ), abs( b( 1, 1 ) ) )
                 else
                    ! estimate the reciprocal condition number of the k-th
                    ! eigenvectors.
                    ! copy the matrix (a, b) to the array work and move the
                    ! (k,k)th pair to the (1,1) position.
                    call stdlib_clacpy( 'FULL', n, n, a, lda, work, n )
                    call stdlib_clacpy( 'FULL', n, n, b, ldb, work( n*n+1 ), n )
                    ifst = k
                    ilst = 1
                    call stdlib_ctgexc( .false., .false., n, work, n, work( n*n+1 ),n, dummy, 1, &
                              dummy1, 1, ifst, ilst, ierr )
                    if( ierr>0 ) then
                       ! ill-conditioned problem - swap rejected.
                       dif( ks ) = zero
                    else
                       ! reordering successful, solve generalized sylvester
                       ! equation for r and l,
                                  ! a22 * r - l * a11 = a12
                                  ! b22 * r - l * b11 = b12,
                       ! and compute estimate of difl[(a11,b11), (a22, b22)].
                       n1 = 1
                       n2 = n - n1
                       i = n*n + 1
                       call stdlib_ctgsyl( 'N', idifjb, n2, n1, work( n*n1+n1+1 ),n, work, n, &
                       work( n1+1 ), n,work( n*n1+n1+i ), n, work( i ), n,work( n1+i ), n, scale, &
                                 dif( ks ), dummy,1, iwork, ierr )
                    end if
                 end if
              end if
           end do loop_20
           work( 1 ) = lwmin
           return
     end subroutine stdlib_ctgsna

     module pure subroutine stdlib_ztgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, s, &
     !! ZTGSNA estimates reciprocal condition numbers for specified
     !! eigenvalues and/or eigenvectors of a matrix pair (A, B).
     !! (A, B) must be in generalized Schur canonical form, that is, A and
     !! B are both upper triangular.
               dif, mm, m, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(out) :: dif(*), s(*)
           complex(dp), intent(in) :: a(lda,*), b(ldb,*), vl(ldvl,*), vr(ldvr,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: idifjb = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, somcon, wantbh, wantdf, wants
           integer(ilp) :: i, ierr, ifst, ilst, k, ks, lwmin, n1, n2
           real(dp) :: bignum, cond, eps, lnrm, rnrm, scale, smlnum
           complex(dp) :: yhax, yhbx
           ! Local Arrays 
           complex(dp) :: dummy(1), dummy1(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantdf = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           info = 0
           lquery = ( lwork==-1 )
           if( .not.wants .and. .not.wantdf ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( wants .and. ldvl<n ) then
              info = -10
           else if( wants .and. ldvr<n ) then
              info = -12
           else
              ! set m to the number of eigenpairs for which condition numbers
              ! are required, and test mm.
              if( somcon ) then
                 m = 0
                 do k = 1, n
                    if( select( k ) )m = m + 1
                 end do
              else
                 m = n
              end if
              if( n==0 ) then
                 lwmin = 1
              else if( stdlib_lsame( job, 'V' ) .or. stdlib_lsame( job, 'B' ) ) then
                 lwmin = 2*n*n
              else
                 lwmin = n
              end if
              work( 1 ) = lwmin
              if( mm<m ) then
                 info = -15
              else if( lwork<lwmin .and. .not.lquery ) then
                 info = -18
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGSNA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' ) / eps
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           ks = 0
           loop_20: do k = 1, n
              ! determine whether condition numbers are required for the k-th
              ! eigenpair.
              if( somcon ) then
                 if( .not.select( k ) )cycle loop_20
              end if
              ks = ks + 1
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 rnrm = stdlib_dznrm2( n, vr( 1, ks ), 1 )
                 lnrm = stdlib_dznrm2( n, vl( 1, ks ), 1 )
                 call stdlib_zgemv( 'N', n, n, cmplx( one, zero,KIND=dp), a, lda,vr( 1, ks ), 1, &
                           cmplx( zero, zero,KIND=dp), work, 1 )
                 yhax = stdlib_zdotc( n, work, 1, vl( 1, ks ), 1 )
                 call stdlib_zgemv( 'N', n, n, cmplx( one, zero,KIND=dp), b, ldb,vr( 1, ks ), 1, &
                           cmplx( zero, zero,KIND=dp), work, 1 )
                 yhbx = stdlib_zdotc( n, work, 1, vl( 1, ks ), 1 )
                 cond = stdlib_dlapy2( abs( yhax ), abs( yhbx ) )
                 if( cond==zero ) then
                    s( ks ) = -one
                 else
                    s( ks ) = cond / ( rnrm*lnrm )
                 end if
              end if
              if( wantdf ) then
                 if( n==1 ) then
                    dif( ks ) = stdlib_dlapy2( abs( a( 1, 1 ) ), abs( b( 1, 1 ) ) )
                 else
                    ! estimate the reciprocal condition number of the k-th
                    ! eigenvectors.
                    ! copy the matrix (a, b) to the array work and move the
                    ! (k,k)th pair to the (1,1) position.
                    call stdlib_zlacpy( 'FULL', n, n, a, lda, work, n )
                    call stdlib_zlacpy( 'FULL', n, n, b, ldb, work( n*n+1 ), n )
                    ifst = k
                    ilst = 1
                    call stdlib_ztgexc( .false., .false., n, work, n, work( n*n+1 ),n, dummy, 1, &
                              dummy1, 1, ifst, ilst, ierr )
                    if( ierr>0 ) then
                       ! ill-conditioned problem - swap rejected.
                       dif( ks ) = zero
                    else
                       ! reordering successful, solve generalized sylvester
                       ! equation for r and l,
                                  ! a22 * r - l * a11 = a12
                                  ! b22 * r - l * b11 = b12,
                       ! and compute estimate of difl[(a11,b11), (a22, b22)].
                       n1 = 1
                       n2 = n - n1
                       i = n*n + 1
                       call stdlib_ztgsyl( 'N', idifjb, n2, n1, work( n*n1+n1+1 ),n, work, n, &
                       work( n1+1 ), n,work( n*n1+n1+i ), n, work( i ), n,work( n1+i ), n, scale, &
                                 dif( ks ), dummy,1, iwork, ierr )
                    end if
                 end if
              end if
           end do loop_20
           work( 1 ) = lwmin
           return
     end subroutine stdlib_ztgsna

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$tgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, s, &
     !! ZTGSNA: estimates reciprocal condition numbers for specified
     !! eigenvalues and/or eigenvectors of a matrix pair (A, B).
     !! (A, B) must be in generalized Schur canonical form, that is, A and
     !! B are both upper triangular.
               dif, mm, m, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${ck}$), intent(out) :: dif(*), s(*)
           complex(${ck}$), intent(in) :: a(lda,*), b(ldb,*), vl(ldvl,*), vr(ldvr,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: idifjb = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, somcon, wantbh, wantdf, wants
           integer(ilp) :: i, ierr, ifst, ilst, k, ks, lwmin, n1, n2
           real(${ck}$) :: bignum, cond, eps, lnrm, rnrm, scale, smlnum
           complex(${ck}$) :: yhax, yhbx
           ! Local Arrays 
           complex(${ck}$) :: dummy(1), dummy1(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantdf = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           info = 0
           lquery = ( lwork==-1 )
           if( .not.wants .and. .not.wantdf ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( wants .and. ldvl<n ) then
              info = -10
           else if( wants .and. ldvr<n ) then
              info = -12
           else
              ! set m to the number of eigenpairs for which condition numbers
              ! are required, and test mm.
              if( somcon ) then
                 m = 0
                 do k = 1, n
                    if( select( k ) )m = m + 1
                 end do
              else
                 m = n
              end if
              if( n==0 ) then
                 lwmin = 1
              else if( stdlib_lsame( job, 'V' ) .or. stdlib_lsame( job, 'B' ) ) then
                 lwmin = 2*n*n
              else
                 lwmin = n
              end if
              work( 1 ) = lwmin
              if( mm<m ) then
                 info = -15
              else if( lwork<lwmin .and. .not.lquery ) then
                 info = -18
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGSNA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_${c2ri(ci)}$lamch( 'P' )
           smlnum = stdlib_${c2ri(ci)}$lamch( 'S' ) / eps
           bignum = one / smlnum
           call stdlib_${c2ri(ci)}$labad( smlnum, bignum )
           ks = 0
           loop_20: do k = 1, n
              ! determine whether condition numbers are required for the k-th
              ! eigenpair.
              if( somcon ) then
                 if( .not.select( k ) )cycle loop_20
              end if
              ks = ks + 1
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 rnrm = stdlib_${c2ri(ci)}$znrm2( n, vr( 1, ks ), 1 )
                 lnrm = stdlib_${c2ri(ci)}$znrm2( n, vl( 1, ks ), 1 )
                 call stdlib_${ci}$gemv( 'N', n, n, cmplx( one, zero,KIND=${ck}$), a, lda,vr( 1, ks ), 1, &
                           cmplx( zero, zero,KIND=${ck}$), work, 1 )
                 yhax = stdlib_${ci}$dotc( n, work, 1, vl( 1, ks ), 1 )
                 call stdlib_${ci}$gemv( 'N', n, n, cmplx( one, zero,KIND=${ck}$), b, ldb,vr( 1, ks ), 1, &
                           cmplx( zero, zero,KIND=${ck}$), work, 1 )
                 yhbx = stdlib_${ci}$dotc( n, work, 1, vl( 1, ks ), 1 )
                 cond = stdlib_${c2ri(ci)}$lapy2( abs( yhax ), abs( yhbx ) )
                 if( cond==zero ) then
                    s( ks ) = -one
                 else
                    s( ks ) = cond / ( rnrm*lnrm )
                 end if
              end if
              if( wantdf ) then
                 if( n==1 ) then
                    dif( ks ) = stdlib_${c2ri(ci)}$lapy2( abs( a( 1, 1 ) ), abs( b( 1, 1 ) ) )
                 else
                    ! estimate the reciprocal condition number of the k-th
                    ! eigenvectors.
                    ! copy the matrix (a, b) to the array work and move the
                    ! (k,k)th pair to the (1,1) position.
                    call stdlib_${ci}$lacpy( 'FULL', n, n, a, lda, work, n )
                    call stdlib_${ci}$lacpy( 'FULL', n, n, b, ldb, work( n*n+1 ), n )
                    ifst = k
                    ilst = 1
                    call stdlib_${ci}$tgexc( .false., .false., n, work, n, work( n*n+1 ),n, dummy, 1, &
                              dummy1, 1, ifst, ilst, ierr )
                    if( ierr>0 ) then
                       ! ill-conditioned problem - swap rejected.
                       dif( ks ) = zero
                    else
                       ! reordering successful, solve generalized sylvester
                       ! equation for r and l,
                                  ! a22 * r - l * a11 = a12
                                  ! b22 * r - l * b11 = b12,
                       ! and compute estimate of difl[(a11,b11), (a22, b22)].
                       n1 = 1
                       n2 = n - n1
                       i = n*n + 1
                       call stdlib_${ci}$tgsyl( 'N', idifjb, n2, n1, work( n*n1+n1+1 ),n, work, n, &
                       work( n1+1 ), n,work( n*n1+n1+i ), n, work( i ), n,work( n1+i ), n, scale, &
                                 dif( ks ), dummy,1, iwork, ierr )
                    end if
                 end if
              end if
           end do loop_20
           work( 1 ) = lwmin
           return
     end subroutine stdlib_${ci}$tgsna

#:endif
#:endfor





     module pure subroutine stdlib_cunghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! CUNGHR generates a complex unitary matrix Q which is defined as the
     !! product of IHI-ILO elementary reflectors of order N, as returned by
     !! CGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, iinfo, j, lwkopt, nb, nh
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, nh ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              nb = stdlib_ilaenv( 1, 'CUNGQR', ' ', nh, nh, nh, -1 )
              lwkopt = max( 1, nh )*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNGHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           ! shift the vectors which define the elementary reflectors cone
           ! column to the right, and set the first ilo and the last n-ihi
           ! rows and columns to those of the unit matrix
           do j = ihi, ilo + 1, -1
              do i = 1, j - 1
                 a( i, j ) = czero
              end do
              do i = j + 1, ihi
                 a( i, j ) = a( i, j-1 )
              end do
              do i = ihi + 1, n
                 a( i, j ) = czero
              end do
           end do
           do j = 1, ilo
              do i = 1, n
                 a( i, j ) = czero
              end do
              a( j, j ) = cone
           end do
           do j = ihi + 1, n
              do i = 1, n
                 a( i, j ) = czero
              end do
              a( j, j ) = cone
           end do
           if( nh>0 ) then
              ! generate q(ilo+1:ihi,ilo+1:ihi)
              call stdlib_cungqr( nh, nh, nh, a( ilo+1, ilo+1 ), lda, tau( ilo ),work, lwork, &
                        iinfo )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cunghr

     module pure subroutine stdlib_zunghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! ZUNGHR generates a complex unitary matrix Q which is defined as the
     !! product of IHI-ILO elementary reflectors of order N, as returned by
     !! ZGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(in) :: tau(*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, iinfo, j, lwkopt, nb, nh
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, nh ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              nb = stdlib_ilaenv( 1, 'ZUNGQR', ' ', nh, nh, nh, -1 )
              lwkopt = max( 1, nh )*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZUNGHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           ! shift the vectors which define the elementary reflectors cone
           ! column to the right, and set the first ilo and the last n-ihi
           ! rows and columns to those of the unit matrix
           do j = ihi, ilo + 1, -1
              do i = 1, j - 1
                 a( i, j ) = czero
              end do
              do i = j + 1, ihi
                 a( i, j ) = a( i, j-1 )
              end do
              do i = ihi + 1, n
                 a( i, j ) = czero
              end do
           end do
           do j = 1, ilo
              do i = 1, n
                 a( i, j ) = czero
              end do
              a( j, j ) = cone
           end do
           do j = ihi + 1, n
              do i = 1, n
                 a( i, j ) = czero
              end do
              a( j, j ) = cone
           end do
           if( nh>0 ) then
              ! generate q(ilo+1:ihi,ilo+1:ihi)
              call stdlib_zungqr( nh, nh, nh, a( ilo+1, ilo+1 ), lda, tau( ilo ),work, lwork, &
                        iinfo )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zunghr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$unghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! ZUNGHR: generates a complex unitary matrix Q which is defined as the
     !! product of IHI-ILO elementary reflectors of order N, as returned by
     !! ZGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(in) :: tau(*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, iinfo, j, lwkopt, nb, nh
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, nh ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              nb = stdlib_ilaenv( 1, 'ZUNGQR', ' ', nh, nh, nh, -1 )
              lwkopt = max( 1, nh )*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZUNGHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           ! shift the vectors which define the elementary reflectors cone
           ! column to the right, and set the first ilo and the last n-ihi
           ! rows and columns to those of the unit matrix
           do j = ihi, ilo + 1, -1
              do i = 1, j - 1
                 a( i, j ) = czero
              end do
              do i = j + 1, ihi
                 a( i, j ) = a( i, j-1 )
              end do
              do i = ihi + 1, n
                 a( i, j ) = czero
              end do
           end do
           do j = 1, ilo
              do i = 1, n
                 a( i, j ) = czero
              end do
              a( j, j ) = cone
           end do
           do j = ihi + 1, n
              do i = 1, n
                 a( i, j ) = czero
              end do
              a( j, j ) = cone
           end do
           if( nh>0 ) then
              ! generate q(ilo+1:ihi,ilo+1:ihi)
              call stdlib_${ci}$ungqr( nh, nh, nh, a( ilo+1, ilo+1 ), lda, tau( ilo ),work, lwork, &
                        iinfo )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$unghr

#:endif
#:endfor



     module subroutine stdlib_slaqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, ns, nd,&
     !! Aggressive early deflation:
     !! SLAQR3 accepts as input an upper Hessenberg matrix
     !! H and performs an orthogonal similarity transformation
     !! designed to detect and deflate fully converged eigenvalues from
     !! a trailing principal submatrix.  On output H has been over-
     !! written by a new Hessenberg matrix that is a perturbation of
     !! an orthogonal similarity transformation of H.  It is to be
     !! hoped that the final version of H has many zero subdiagonal
     !! entries.
                sr, si, v, ldv, nh, t,ldt, nv, wv, ldwv, work, lwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(ilp), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(sp), intent(out) :: si(*), sr(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
        ! ================================================================
           
           ! Local Scalars 
           real(sp) :: aa, bb, beta, cc, cs, dd, evi, evk, foo, s, safmax, safmin, smlnum, sn, &
                     tau, ulp
           integer(ilp) :: i, ifst, ilst, info, infqr, j, jw, k, kcol, kend, kln, krow, kwtop, &
                     ltop, lwk1, lwk2, lwk3, lwkopt, nmin
           logical(lk) :: bulge, sorted
           ! Intrinsic Functions 
           ! Executable Statements 
           ! ==== estimate optimal workspace. ====
           jw = min( nw, kbot-ktop+1 )
           if( jw<=2 ) then
              lwkopt = 1
           else
              ! ==== workspace query call to stdlib_sgehrd ====
              call stdlib_sgehrd( jw, 1, jw-1, t, ldt, work, work, -1, info )
              lwk1 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_sormhr ====
              call stdlib_sormhr( 'R', 'N', jw, jw, 1, jw-1, t, ldt, work, v, ldv,work, -1, info )
                        
              lwk2 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_slaqr4 ====
              call stdlib_slaqr4( .true., .true., jw, 1, jw, t, ldt, sr, si, 1, jw,v, ldv, work, -&
                        1, infqr )
              lwk3 = int( work( 1 ),KIND=ilp)
              ! ==== optimal workspace ====
              lwkopt = max( jw+max( lwk1, lwk2 ), lwk3 )
           end if
           ! ==== quick return in case of workspace query. ====
           if( lwork==-1 ) then
              work( 1 ) = real( lwkopt,KIND=sp)
              return
           end if
           ! ==== nothing to do ...
           ! ... for an empty active block ... ====
           ns = 0
           nd = 0
           work( 1 ) = one
           if( ktop>kbot )return
           ! ... nor for an empty deflation window. ====
           if( nw<1 )return
           ! ==== machine constants ====
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = one / safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=sp) / ulp )
           ! ==== setup deflation window ====
           jw = min( nw, kbot-ktop+1 )
           kwtop = kbot - jw + 1
           if( kwtop==ktop ) then
              s = zero
           else
              s = h( kwtop, kwtop-1 )
           end if
           if( kbot==kwtop ) then
              ! ==== 1-by-1 deflation window: not much to do ====
              sr( kwtop ) = h( kwtop, kwtop )
              si( kwtop ) = zero
              ns = 1
              nd = 0
              if( abs( s )<=max( smlnum, ulp*abs( h( kwtop, kwtop ) ) ) )then
                 ns = 0
                 nd = 1
                 if( kwtop>ktop )h( kwtop, kwtop-1 ) = zero
              end if
              work( 1 ) = one
              return
           end if
           ! ==== convert to spike-triangular form.  (in case of a
           ! .    rare qr failure, this routine continues to do
           ! .    aggressive early deflation using that part of
           ! .    the deflation window that converged using infqr
           ! .    here and there to keep track.) ====
           call stdlib_slacpy( 'U', jw, jw, h( kwtop, kwtop ), ldh, t, ldt )
           call stdlib_scopy( jw-1, h( kwtop+1, kwtop ), ldh+1, t( 2, 1 ), ldt+1 )
           call stdlib_slaset( 'A', jw, jw, zero, one, v, ldv )
           nmin = stdlib_ilaenv( 12, 'SLAQR3', 'SV', jw, 1, jw, lwork )
           if( jw>nmin ) then
              call stdlib_slaqr4( .true., .true., jw, 1, jw, t, ldt, sr( kwtop ),si( kwtop ), 1, &
                        jw, v, ldv, work, lwork, infqr )
           else
              call stdlib_slahqr( .true., .true., jw, 1, jw, t, ldt, sr( kwtop ),si( kwtop ), 1, &
                        jw, v, ldv, infqr )
           end if
           ! ==== stdlib_strexc needs a clean margin near the diagonal ====
           do j = 1, jw - 3
              t( j+2, j ) = zero
              t( j+3, j ) = zero
           end do
           if( jw>2 )t( jw, jw-2 ) = zero
           ! ==== deflation detection loop ====
           ns = jw
           ilst = infqr + 1
           20 continue
           if( ilst<=ns ) then
              if( ns==1 ) then
                 bulge = .false.
              else
                 bulge = t( ns, ns-1 )/=zero
              end if
              ! ==== small spike tip test for deflation ====
              if( .not. bulge ) then
                 ! ==== real eigenvalue ====
                 foo = abs( t( ns, ns ) )
                 if( foo==zero )foo = abs( s )
                 if( abs( s*v( 1, ns ) )<=max( smlnum, ulp*foo ) ) then
                    ! ==== deflatable ====
                    ns = ns - 1
                 else
                    ! ==== undeflatable.   move it up out of the way.
                    ! .    (stdlib_strexc can not fail in this case.) ====
                    ifst = ns
                    call stdlib_strexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    ilst = ilst + 1
                 end if
              else
                 ! ==== complex conjugate pair ====
                 foo = abs( t( ns, ns ) ) + sqrt( abs( t( ns, ns-1 ) ) )*sqrt( abs( t( ns-1, ns ) &
                           ) )
                 if( foo==zero )foo = abs( s )
                 if( max( abs( s*v( 1, ns ) ), abs( s*v( 1, ns-1 ) ) )<=max( smlnum, ulp*foo ) ) &
                           then
                    ! ==== deflatable ====
                    ns = ns - 2
                 else
                    ! ==== undeflatable. move them up out of the way.
                    ! .    fortunately, stdlib_strexc does the right thing with
                    ! .    ilst in case of a rare exchange failure. ====
                    ifst = ns
                    call stdlib_strexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    ilst = ilst + 2
                 end if
              end if
              ! ==== end deflation detection loop ====
              go to 20
           end if
              ! ==== return to hessenberg form ====
           if( ns==0 )s = zero
           if( ns<jw ) then
              ! ==== sorting diagonal blocks of t improves accuracy for
              ! .    graded matrices.  bubble sort deals well with
              ! .    exchange failures. ====
              sorted = .false.
              i = ns + 1
              30 continue
              if( sorted )go to 50
              sorted = .true.
              kend = i - 1
              i = infqr + 1
              if( i==ns ) then
                 k = i + 1
              else if( t( i+1, i )==zero ) then
                 k = i + 1
              else
                 k = i + 2
              end if
              40 continue
              if( k<=kend ) then
                 if( k==i+1 ) then
                    evi = abs( t( i, i ) )
                 else
                    evi = abs( t( i, i ) ) + sqrt( abs( t( i+1, i ) ) )*sqrt( abs( t( i, i+1 ) ) )
                              
                 end if
                 if( k==kend ) then
                    evk = abs( t( k, k ) )
                 else if( t( k+1, k )==zero ) then
                    evk = abs( t( k, k ) )
                 else
                    evk = abs( t( k, k ) ) + sqrt( abs( t( k+1, k ) ) )*sqrt( abs( t( k, k+1 ) ) )
                              
                 end if
                 if( evi>=evk ) then
                    i = k
                 else
                    sorted = .false.
                    ifst = i
                    ilst = k
                    call stdlib_strexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    if( info==0 ) then
                       i = ilst
                    else
                       i = k
                    end if
                 end if
                 if( i==kend ) then
                    k = i + 1
                 else if( t( i+1, i )==zero ) then
                    k = i + 1
                 else
                    k = i + 2
                 end if
                 go to 40
              end if
              go to 30
              50 continue
           end if
           ! ==== restore shift/eigenvalue array from t ====
           i = jw
           60 continue
           if( i>=infqr+1 ) then
              if( i==infqr+1 ) then
                 sr( kwtop+i-1 ) = t( i, i )
                 si( kwtop+i-1 ) = zero
                 i = i - 1
              else if( t( i, i-1 )==zero ) then
                 sr( kwtop+i-1 ) = t( i, i )
                 si( kwtop+i-1 ) = zero
                 i = i - 1
              else
                 aa = t( i-1, i-1 )
                 cc = t( i, i-1 )
                 bb = t( i-1, i )
                 dd = t( i, i )
                 call stdlib_slanv2( aa, bb, cc, dd, sr( kwtop+i-2 ),si( kwtop+i-2 ), sr( kwtop+i-&
                           1 ),si( kwtop+i-1 ), cs, sn )
                 i = i - 2
              end if
              go to 60
           end if
           if( ns<jw .or. s==zero ) then
              if( ns>1 .and. s/=zero ) then
                 ! ==== reflect spike back into lower triangle ====
                 call stdlib_scopy( ns, v, ldv, work, 1 )
                 beta = work( 1 )
                 call stdlib_slarfg( ns, beta, work( 2 ), 1, tau )
                 work( 1 ) = one
                 call stdlib_slaset( 'L', jw-2, jw-2, zero, zero, t( 3, 1 ), ldt )
                 call stdlib_slarf( 'L', ns, jw, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_slarf( 'R', ns, ns, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_slarf( 'R', jw, ns, work, 1, tau, v, ldv,work( jw+1 ) )
                 call stdlib_sgehrd( jw, 1, ns, t, ldt, work, work( jw+1 ),lwork-jw, info )
                           
              end if
              ! ==== copy updated reduced window into place ====
              if( kwtop>1 )h( kwtop, kwtop-1 ) = s*v( 1, 1 )
              call stdlib_slacpy( 'U', jw, jw, t, ldt, h( kwtop, kwtop ), ldh )
              call stdlib_scopy( jw-1, t( 2, 1 ), ldt+1, h( kwtop+1, kwtop ),ldh+1 )
              ! ==== accumulate orthogonal matrix in order update
              ! .    h and z, if requested.  ====
              if( ns>1 .and. s/=zero )call stdlib_sormhr( 'R', 'N', jw, ns, 1, ns, t, ldt, work, &
                        v, ldv,work( jw+1 ), lwork-jw, info )
              ! ==== update vertical slab in h ====
              if( wantt ) then
                 ltop = 1
              else
                 ltop = ktop
              end if
              do krow = ltop, kwtop - 1, nv
                 kln = min( nv, kwtop-krow )
                 call stdlib_sgemm( 'N', 'N', kln, jw, jw, one, h( krow, kwtop ),ldh, v, ldv, &
                           zero, wv, ldwv )
                 call stdlib_slacpy( 'A', kln, jw, wv, ldwv, h( krow, kwtop ), ldh )
              end do
              ! ==== update horizontal slab in h ====
              if( wantt ) then
                 do kcol = kbot + 1, n, nh
                    kln = min( nh, n-kcol+1 )
                    call stdlib_sgemm( 'C', 'N', jw, kln, jw, one, v, ldv,h( kwtop, kcol ), ldh, &
                              zero, t, ldt )
                    call stdlib_slacpy( 'A', jw, kln, t, ldt, h( kwtop, kcol ),ldh )
                 end do
              end if
              ! ==== update vertical slab in z ====
              if( wantz ) then
                 do krow = iloz, ihiz, nv
                    kln = min( nv, ihiz-krow+1 )
                    call stdlib_sgemm( 'N', 'N', kln, jw, jw, one, z( krow, kwtop ),ldz, v, ldv, &
                              zero, wv, ldwv )
                    call stdlib_slacpy( 'A', kln, jw, wv, ldwv, z( krow, kwtop ),ldz )
                 end do
              end if
           end if
           ! ==== return the number of deflations ... ====
           nd = jw - ns
           ! ==== ... and the number of shifts. (subtracting
           ! .    infqr from the spike length takes care
           ! .    of the case of a rare qr failure while
           ! .    calculating eigenvalues of the deflation
           ! .    window.)  ====
           ns = ns - infqr
            ! ==== return optimal workspace. ====
           work( 1 ) = real( lwkopt,KIND=sp)
     end subroutine stdlib_slaqr3

     module subroutine stdlib_dlaqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, ns, nd,&
     !! Aggressive early deflation:
     !! DLAQR3 accepts as input an upper Hessenberg matrix
     !! H and performs an orthogonal similarity transformation
     !! designed to detect and deflate fully converged eigenvalues from
     !! a trailing principal submatrix.  On output H has been over-
     !! written by a new Hessenberg matrix that is a perturbation of
     !! an orthogonal similarity transformation of H.  It is to be
     !! hoped that the final version of H has many zero subdiagonal
     !! entries.
                sr, si, v, ldv, nh, t,ldt, nv, wv, ldwv, work, lwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(ilp), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(dp), intent(out) :: si(*), sr(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
        ! ================================================================
           
           ! Local Scalars 
           real(dp) :: aa, bb, beta, cc, cs, dd, evi, evk, foo, s, safmax, safmin, smlnum, sn, &
                     tau, ulp
           integer(ilp) :: i, ifst, ilst, info, infqr, j, jw, k, kcol, kend, kln, krow, kwtop, &
                     ltop, lwk1, lwk2, lwk3, lwkopt, nmin
           logical(lk) :: bulge, sorted
           ! Intrinsic Functions 
           ! Executable Statements 
           ! ==== estimate optimal workspace. ====
           jw = min( nw, kbot-ktop+1 )
           if( jw<=2 ) then
              lwkopt = 1
           else
              ! ==== workspace query call to stdlib_dgehrd ====
              call stdlib_dgehrd( jw, 1, jw-1, t, ldt, work, work, -1, info )
              lwk1 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_dormhr ====
              call stdlib_dormhr( 'R', 'N', jw, jw, 1, jw-1, t, ldt, work, v, ldv,work, -1, info )
                        
              lwk2 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_dlaqr4 ====
              call stdlib_dlaqr4( .true., .true., jw, 1, jw, t, ldt, sr, si, 1, jw,v, ldv, work, -&
                        1, infqr )
              lwk3 = int( work( 1 ),KIND=ilp)
              ! ==== optimal workspace ====
              lwkopt = max( jw+max( lwk1, lwk2 ), lwk3 )
           end if
           ! ==== quick return in case of workspace query. ====
           if( lwork==-1 ) then
              work( 1 ) = real( lwkopt,KIND=dp)
              return
           end if
           ! ==== nothing to do ...
           ! ... for an empty active block ... ====
           ns = 0
           nd = 0
           work( 1 ) = one
           if( ktop>kbot )return
           ! ... nor for an empty deflation window. ====
           if( nw<1 )return
           ! ==== machine constants ====
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safmax = one / safmin
           call stdlib_dlabad( safmin, safmax )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=dp) / ulp )
           ! ==== setup deflation window ====
           jw = min( nw, kbot-ktop+1 )
           kwtop = kbot - jw + 1
           if( kwtop==ktop ) then
              s = zero
           else
              s = h( kwtop, kwtop-1 )
           end if
           if( kbot==kwtop ) then
              ! ==== 1-by-1 deflation window: not much to do ====
              sr( kwtop ) = h( kwtop, kwtop )
              si( kwtop ) = zero
              ns = 1
              nd = 0
              if( abs( s )<=max( smlnum, ulp*abs( h( kwtop, kwtop ) ) ) )then
                 ns = 0
                 nd = 1
                 if( kwtop>ktop )h( kwtop, kwtop-1 ) = zero
              end if
              work( 1 ) = one
              return
           end if
           ! ==== convert to spike-triangular form.  (in case of a
           ! .    rare qr failure, this routine continues to do
           ! .    aggressive early deflation using that part of
           ! .    the deflation window that converged using infqr
           ! .    here and there to keep track.) ====
           call stdlib_dlacpy( 'U', jw, jw, h( kwtop, kwtop ), ldh, t, ldt )
           call stdlib_dcopy( jw-1, h( kwtop+1, kwtop ), ldh+1, t( 2, 1 ), ldt+1 )
           call stdlib_dlaset( 'A', jw, jw, zero, one, v, ldv )
           nmin = stdlib_ilaenv( 12, 'DLAQR3', 'SV', jw, 1, jw, lwork )
           if( jw>nmin ) then
              call stdlib_dlaqr4( .true., .true., jw, 1, jw, t, ldt, sr( kwtop ),si( kwtop ), 1, &
                        jw, v, ldv, work, lwork, infqr )
           else
              call stdlib_dlahqr( .true., .true., jw, 1, jw, t, ldt, sr( kwtop ),si( kwtop ), 1, &
                        jw, v, ldv, infqr )
           end if
           ! ==== stdlib_dtrexc needs a clean margin near the diagonal ====
           do j = 1, jw - 3
              t( j+2, j ) = zero
              t( j+3, j ) = zero
           end do
           if( jw>2 )t( jw, jw-2 ) = zero
           ! ==== deflation detection loop ====
           ns = jw
           ilst = infqr + 1
           20 continue
           if( ilst<=ns ) then
              if( ns==1 ) then
                 bulge = .false.
              else
                 bulge = t( ns, ns-1 )/=zero
              end if
              ! ==== small spike tip test for deflation ====
              if( .not. bulge ) then
                 ! ==== real eigenvalue ====
                 foo = abs( t( ns, ns ) )
                 if( foo==zero )foo = abs( s )
                 if( abs( s*v( 1, ns ) )<=max( smlnum, ulp*foo ) ) then
                    ! ==== deflatable ====
                    ns = ns - 1
                 else
                    ! ==== undeflatable.   move it up out of the way.
                    ! .    (stdlib_dtrexc can not fail in this case.) ====
                    ifst = ns
                    call stdlib_dtrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    ilst = ilst + 1
                 end if
              else
                 ! ==== complex conjugate pair ====
                 foo = abs( t( ns, ns ) ) + sqrt( abs( t( ns, ns-1 ) ) )*sqrt( abs( t( ns-1, ns ) &
                           ) )
                 if( foo==zero )foo = abs( s )
                 if( max( abs( s*v( 1, ns ) ), abs( s*v( 1, ns-1 ) ) )<=max( smlnum, ulp*foo ) ) &
                           then
                    ! ==== deflatable ====
                    ns = ns - 2
                 else
                    ! ==== undeflatable. move them up out of the way.
                    ! .    fortunately, stdlib_dtrexc does the right thing with
                    ! .    ilst in case of a rare exchange failure. ====
                    ifst = ns
                    call stdlib_dtrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    ilst = ilst + 2
                 end if
              end if
              ! ==== end deflation detection loop ====
              go to 20
           end if
              ! ==== return to hessenberg form ====
           if( ns==0 )s = zero
           if( ns<jw ) then
              ! ==== sorting diagonal blocks of t improves accuracy for
              ! .    graded matrices.  bubble sort deals well with
              ! .    exchange failures. ====
              sorted = .false.
              i = ns + 1
              30 continue
              if( sorted )go to 50
              sorted = .true.
              kend = i - 1
              i = infqr + 1
              if( i==ns ) then
                 k = i + 1
              else if( t( i+1, i )==zero ) then
                 k = i + 1
              else
                 k = i + 2
              end if
              40 continue
              if( k<=kend ) then
                 if( k==i+1 ) then
                    evi = abs( t( i, i ) )
                 else
                    evi = abs( t( i, i ) ) + sqrt( abs( t( i+1, i ) ) )*sqrt( abs( t( i, i+1 ) ) )
                              
                 end if
                 if( k==kend ) then
                    evk = abs( t( k, k ) )
                 else if( t( k+1, k )==zero ) then
                    evk = abs( t( k, k ) )
                 else
                    evk = abs( t( k, k ) ) + sqrt( abs( t( k+1, k ) ) )*sqrt( abs( t( k, k+1 ) ) )
                              
                 end if
                 if( evi>=evk ) then
                    i = k
                 else
                    sorted = .false.
                    ifst = i
                    ilst = k
                    call stdlib_dtrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    if( info==0 ) then
                       i = ilst
                    else
                       i = k
                    end if
                 end if
                 if( i==kend ) then
                    k = i + 1
                 else if( t( i+1, i )==zero ) then
                    k = i + 1
                 else
                    k = i + 2
                 end if
                 go to 40
              end if
              go to 30
              50 continue
           end if
           ! ==== restore shift/eigenvalue array from t ====
           i = jw
           60 continue
           if( i>=infqr+1 ) then
              if( i==infqr+1 ) then
                 sr( kwtop+i-1 ) = t( i, i )
                 si( kwtop+i-1 ) = zero
                 i = i - 1
              else if( t( i, i-1 )==zero ) then
                 sr( kwtop+i-1 ) = t( i, i )
                 si( kwtop+i-1 ) = zero
                 i = i - 1
              else
                 aa = t( i-1, i-1 )
                 cc = t( i, i-1 )
                 bb = t( i-1, i )
                 dd = t( i, i )
                 call stdlib_dlanv2( aa, bb, cc, dd, sr( kwtop+i-2 ),si( kwtop+i-2 ), sr( kwtop+i-&
                           1 ),si( kwtop+i-1 ), cs, sn )
                 i = i - 2
              end if
              go to 60
           end if
           if( ns<jw .or. s==zero ) then
              if( ns>1 .and. s/=zero ) then
                 ! ==== reflect spike back into lower triangle ====
                 call stdlib_dcopy( ns, v, ldv, work, 1 )
                 beta = work( 1 )
                 call stdlib_dlarfg( ns, beta, work( 2 ), 1, tau )
                 work( 1 ) = one
                 call stdlib_dlaset( 'L', jw-2, jw-2, zero, zero, t( 3, 1 ), ldt )
                 call stdlib_dlarf( 'L', ns, jw, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_dlarf( 'R', ns, ns, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_dlarf( 'R', jw, ns, work, 1, tau, v, ldv,work( jw+1 ) )
                 call stdlib_dgehrd( jw, 1, ns, t, ldt, work, work( jw+1 ),lwork-jw, info )
                           
              end if
              ! ==== copy updated reduced window into place ====
              if( kwtop>1 )h( kwtop, kwtop-1 ) = s*v( 1, 1 )
              call stdlib_dlacpy( 'U', jw, jw, t, ldt, h( kwtop, kwtop ), ldh )
              call stdlib_dcopy( jw-1, t( 2, 1 ), ldt+1, h( kwtop+1, kwtop ),ldh+1 )
              ! ==== accumulate orthogonal matrix in order update
              ! .    h and z, if requested.  ====
              if( ns>1 .and. s/=zero )call stdlib_dormhr( 'R', 'N', jw, ns, 1, ns, t, ldt, work, &
                        v, ldv,work( jw+1 ), lwork-jw, info )
              ! ==== update vertical slab in h ====
              if( wantt ) then
                 ltop = 1
              else
                 ltop = ktop
              end if
              do krow = ltop, kwtop - 1, nv
                 kln = min( nv, kwtop-krow )
                 call stdlib_dgemm( 'N', 'N', kln, jw, jw, one, h( krow, kwtop ),ldh, v, ldv, &
                           zero, wv, ldwv )
                 call stdlib_dlacpy( 'A', kln, jw, wv, ldwv, h( krow, kwtop ), ldh )
              end do
              ! ==== update horizontal slab in h ====
              if( wantt ) then
                 do kcol = kbot + 1, n, nh
                    kln = min( nh, n-kcol+1 )
                    call stdlib_dgemm( 'C', 'N', jw, kln, jw, one, v, ldv,h( kwtop, kcol ), ldh, &
                              zero, t, ldt )
                    call stdlib_dlacpy( 'A', jw, kln, t, ldt, h( kwtop, kcol ),ldh )
                 end do
              end if
              ! ==== update vertical slab in z ====
              if( wantz ) then
                 do krow = iloz, ihiz, nv
                    kln = min( nv, ihiz-krow+1 )
                    call stdlib_dgemm( 'N', 'N', kln, jw, jw, one, z( krow, kwtop ),ldz, v, ldv, &
                              zero, wv, ldwv )
                    call stdlib_dlacpy( 'A', kln, jw, wv, ldwv, z( krow, kwtop ),ldz )
                 end do
              end if
           end if
           ! ==== return the number of deflations ... ====
           nd = jw - ns
           ! ==== ... and the number of shifts. (subtracting
           ! .    infqr from the spike length takes care
           ! .    of the case of a rare qr failure while
           ! .    calculating eigenvalues of the deflation
           ! .    window.)  ====
           ns = ns - infqr
            ! ==== return optimal workspace. ====
           work( 1 ) = real( lwkopt,KIND=dp)
     end subroutine stdlib_dlaqr3

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$laqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, ns, nd,&
     !! Aggressive early deflation:
     !! DLAQR3: accepts as input an upper Hessenberg matrix
     !! H and performs an orthogonal similarity transformation
     !! designed to detect and deflate fully converged eigenvalues from
     !! a trailing principal submatrix.  On output H has been over-
     !! written by a new Hessenberg matrix that is a perturbation of
     !! an orthogonal similarity transformation of H.  It is to be
     !! hoped that the final version of H has many zero subdiagonal
     !! entries.
                sr, si, v, ldv, nh, t,ldt, nv, wv, ldwv, work, lwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(ilp), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(${rk}$), intent(inout) :: h(ldh,*), z(ldz,*)
           real(${rk}$), intent(out) :: si(*), sr(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
        ! ================================================================
           
           ! Local Scalars 
           real(${rk}$) :: aa, bb, beta, cc, cs, dd, evi, evk, foo, s, safmax, safmin, smlnum, sn, &
                     tau, ulp
           integer(ilp) :: i, ifst, ilst, info, infqr, j, jw, k, kcol, kend, kln, krow, kwtop, &
                     ltop, lwk1, lwk2, lwk3, lwkopt, nmin
           logical(lk) :: bulge, sorted
           ! Intrinsic Functions 
           ! Executable Statements 
           ! ==== estimate optimal workspace. ====
           jw = min( nw, kbot-ktop+1 )
           if( jw<=2 ) then
              lwkopt = 1
           else
              ! ==== workspace query call to stdlib_${ri}$gehrd ====
              call stdlib_${ri}$gehrd( jw, 1, jw-1, t, ldt, work, work, -1, info )
              lwk1 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_${ri}$ormhr ====
              call stdlib_${ri}$ormhr( 'R', 'N', jw, jw, 1, jw-1, t, ldt, work, v, ldv,work, -1, info )
                        
              lwk2 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_${ri}$laqr4 ====
              call stdlib_${ri}$laqr4( .true., .true., jw, 1, jw, t, ldt, sr, si, 1, jw,v, ldv, work, -&
                        1, infqr )
              lwk3 = int( work( 1 ),KIND=ilp)
              ! ==== optimal workspace ====
              lwkopt = max( jw+max( lwk1, lwk2 ), lwk3 )
           end if
           ! ==== quick return in case of workspace query. ====
           if( lwork==-1 ) then
              work( 1 ) = real( lwkopt,KIND=${rk}$)
              return
           end if
           ! ==== nothing to do ...
           ! ... for an empty active block ... ====
           ns = 0
           nd = 0
           work( 1 ) = one
           if( ktop>kbot )return
           ! ... nor for an empty deflation window. ====
           if( nw<1 )return
           ! ==== machine constants ====
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safmax = one / safmin
           call stdlib_${ri}$labad( safmin, safmax )
           ulp = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=${rk}$) / ulp )
           ! ==== setup deflation window ====
           jw = min( nw, kbot-ktop+1 )
           kwtop = kbot - jw + 1
           if( kwtop==ktop ) then
              s = zero
           else
              s = h( kwtop, kwtop-1 )
           end if
           if( kbot==kwtop ) then
              ! ==== 1-by-1 deflation window: not much to do ====
              sr( kwtop ) = h( kwtop, kwtop )
              si( kwtop ) = zero
              ns = 1
              nd = 0
              if( abs( s )<=max( smlnum, ulp*abs( h( kwtop, kwtop ) ) ) )then
                 ns = 0
                 nd = 1
                 if( kwtop>ktop )h( kwtop, kwtop-1 ) = zero
              end if
              work( 1 ) = one
              return
           end if
           ! ==== convert to spike-triangular form.  (in case of a
           ! .    rare qr failure, this routine continues to do
           ! .    aggressive early deflation using that part of
           ! .    the deflation window that converged using infqr
           ! .    here and there to keep track.) ====
           call stdlib_${ri}$lacpy( 'U', jw, jw, h( kwtop, kwtop ), ldh, t, ldt )
           call stdlib_${ri}$copy( jw-1, h( kwtop+1, kwtop ), ldh+1, t( 2, 1 ), ldt+1 )
           call stdlib_${ri}$laset( 'A', jw, jw, zero, one, v, ldv )
           nmin = stdlib_ilaenv( 12, 'DLAQR3', 'SV', jw, 1, jw, lwork )
           if( jw>nmin ) then
              call stdlib_${ri}$laqr4( .true., .true., jw, 1, jw, t, ldt, sr( kwtop ),si( kwtop ), 1, &
                        jw, v, ldv, work, lwork, infqr )
           else
              call stdlib_${ri}$lahqr( .true., .true., jw, 1, jw, t, ldt, sr( kwtop ),si( kwtop ), 1, &
                        jw, v, ldv, infqr )
           end if
           ! ==== stdlib_${ri}$trexc needs a clean margin near the diagonal ====
           do j = 1, jw - 3
              t( j+2, j ) = zero
              t( j+3, j ) = zero
           end do
           if( jw>2 )t( jw, jw-2 ) = zero
           ! ==== deflation detection loop ====
           ns = jw
           ilst = infqr + 1
           20 continue
           if( ilst<=ns ) then
              if( ns==1 ) then
                 bulge = .false.
              else
                 bulge = t( ns, ns-1 )/=zero
              end if
              ! ==== small spike tip test for deflation ====
              if( .not. bulge ) then
                 ! ==== real eigenvalue ====
                 foo = abs( t( ns, ns ) )
                 if( foo==zero )foo = abs( s )
                 if( abs( s*v( 1, ns ) )<=max( smlnum, ulp*foo ) ) then
                    ! ==== deflatable ====
                    ns = ns - 1
                 else
                    ! ==== undeflatable.   move it up out of the way.
                    ! .    (stdlib_${ri}$trexc can not fail in this case.) ====
                    ifst = ns
                    call stdlib_${ri}$trexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    ilst = ilst + 1
                 end if
              else
                 ! ==== complex conjugate pair ====
                 foo = abs( t( ns, ns ) ) + sqrt( abs( t( ns, ns-1 ) ) )*sqrt( abs( t( ns-1, ns ) &
                           ) )
                 if( foo==zero )foo = abs( s )
                 if( max( abs( s*v( 1, ns ) ), abs( s*v( 1, ns-1 ) ) )<=max( smlnum, ulp*foo ) ) &
                           then
                    ! ==== deflatable ====
                    ns = ns - 2
                 else
                    ! ==== undeflatable. move them up out of the way.
                    ! .    fortunately, stdlib_${ri}$trexc does the right thing with
                    ! .    ilst in case of a rare exchange failure. ====
                    ifst = ns
                    call stdlib_${ri}$trexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    ilst = ilst + 2
                 end if
              end if
              ! ==== end deflation detection loop ====
              go to 20
           end if
              ! ==== return to hessenberg form ====
           if( ns==0 )s = zero
           if( ns<jw ) then
              ! ==== sorting diagonal blocks of t improves accuracy for
              ! .    graded matrices.  bubble sort deals well with
              ! .    exchange failures. ====
              sorted = .false.
              i = ns + 1
              30 continue
              if( sorted )go to 50
              sorted = .true.
              kend = i - 1
              i = infqr + 1
              if( i==ns ) then
                 k = i + 1
              else if( t( i+1, i )==zero ) then
                 k = i + 1
              else
                 k = i + 2
              end if
              40 continue
              if( k<=kend ) then
                 if( k==i+1 ) then
                    evi = abs( t( i, i ) )
                 else
                    evi = abs( t( i, i ) ) + sqrt( abs( t( i+1, i ) ) )*sqrt( abs( t( i, i+1 ) ) )
                              
                 end if
                 if( k==kend ) then
                    evk = abs( t( k, k ) )
                 else if( t( k+1, k )==zero ) then
                    evk = abs( t( k, k ) )
                 else
                    evk = abs( t( k, k ) ) + sqrt( abs( t( k+1, k ) ) )*sqrt( abs( t( k, k+1 ) ) )
                              
                 end if
                 if( evi>=evk ) then
                    i = k
                 else
                    sorted = .false.
                    ifst = i
                    ilst = k
                    call stdlib_${ri}$trexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, work,info )
                    if( info==0 ) then
                       i = ilst
                    else
                       i = k
                    end if
                 end if
                 if( i==kend ) then
                    k = i + 1
                 else if( t( i+1, i )==zero ) then
                    k = i + 1
                 else
                    k = i + 2
                 end if
                 go to 40
              end if
              go to 30
              50 continue
           end if
           ! ==== restore shift/eigenvalue array from t ====
           i = jw
           60 continue
           if( i>=infqr+1 ) then
              if( i==infqr+1 ) then
                 sr( kwtop+i-1 ) = t( i, i )
                 si( kwtop+i-1 ) = zero
                 i = i - 1
              else if( t( i, i-1 )==zero ) then
                 sr( kwtop+i-1 ) = t( i, i )
                 si( kwtop+i-1 ) = zero
                 i = i - 1
              else
                 aa = t( i-1, i-1 )
                 cc = t( i, i-1 )
                 bb = t( i-1, i )
                 dd = t( i, i )
                 call stdlib_${ri}$lanv2( aa, bb, cc, dd, sr( kwtop+i-2 ),si( kwtop+i-2 ), sr( kwtop+i-&
                           1 ),si( kwtop+i-1 ), cs, sn )
                 i = i - 2
              end if
              go to 60
           end if
           if( ns<jw .or. s==zero ) then
              if( ns>1 .and. s/=zero ) then
                 ! ==== reflect spike back into lower triangle ====
                 call stdlib_${ri}$copy( ns, v, ldv, work, 1 )
                 beta = work( 1 )
                 call stdlib_${ri}$larfg( ns, beta, work( 2 ), 1, tau )
                 work( 1 ) = one
                 call stdlib_${ri}$laset( 'L', jw-2, jw-2, zero, zero, t( 3, 1 ), ldt )
                 call stdlib_${ri}$larf( 'L', ns, jw, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_${ri}$larf( 'R', ns, ns, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_${ri}$larf( 'R', jw, ns, work, 1, tau, v, ldv,work( jw+1 ) )
                 call stdlib_${ri}$gehrd( jw, 1, ns, t, ldt, work, work( jw+1 ),lwork-jw, info )
                           
              end if
              ! ==== copy updated reduced window into place ====
              if( kwtop>1 )h( kwtop, kwtop-1 ) = s*v( 1, 1 )
              call stdlib_${ri}$lacpy( 'U', jw, jw, t, ldt, h( kwtop, kwtop ), ldh )
              call stdlib_${ri}$copy( jw-1, t( 2, 1 ), ldt+1, h( kwtop+1, kwtop ),ldh+1 )
              ! ==== accumulate orthogonal matrix in order update
              ! .    h and z, if requested.  ====
              if( ns>1 .and. s/=zero )call stdlib_${ri}$ormhr( 'R', 'N', jw, ns, 1, ns, t, ldt, work, &
                        v, ldv,work( jw+1 ), lwork-jw, info )
              ! ==== update vertical slab in h ====
              if( wantt ) then
                 ltop = 1
              else
                 ltop = ktop
              end if
              do krow = ltop, kwtop - 1, nv
                 kln = min( nv, kwtop-krow )
                 call stdlib_${ri}$gemm( 'N', 'N', kln, jw, jw, one, h( krow, kwtop ),ldh, v, ldv, &
                           zero, wv, ldwv )
                 call stdlib_${ri}$lacpy( 'A', kln, jw, wv, ldwv, h( krow, kwtop ), ldh )
              end do
              ! ==== update horizontal slab in h ====
              if( wantt ) then
                 do kcol = kbot + 1, n, nh
                    kln = min( nh, n-kcol+1 )
                    call stdlib_${ri}$gemm( 'C', 'N', jw, kln, jw, one, v, ldv,h( kwtop, kcol ), ldh, &
                              zero, t, ldt )
                    call stdlib_${ri}$lacpy( 'A', jw, kln, t, ldt, h( kwtop, kcol ),ldh )
                 end do
              end if
              ! ==== update vertical slab in z ====
              if( wantz ) then
                 do krow = iloz, ihiz, nv
                    kln = min( nv, ihiz-krow+1 )
                    call stdlib_${ri}$gemm( 'N', 'N', kln, jw, jw, one, z( krow, kwtop ),ldz, v, ldv, &
                              zero, wv, ldwv )
                    call stdlib_${ri}$lacpy( 'A', kln, jw, wv, ldwv, z( krow, kwtop ),ldz )
                 end do
              end if
           end if
           ! ==== return the number of deflations ... ====
           nd = jw - ns
           ! ==== ... and the number of shifts. (subtracting
           ! .    infqr from the spike length takes care
           ! .    of the case of a rare qr failure while
           ! .    calculating eigenvalues of the deflation
           ! .    window.)  ====
           ns = ns - infqr
            ! ==== return optimal workspace. ====
           work( 1 ) = real( lwkopt,KIND=${rk}$)
     end subroutine stdlib_${ri}$laqr3

#:endif
#:endfor

     module pure subroutine stdlib_claqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
     !! Aggressive early deflation:
     !! CLAQR3 accepts as input an upper Hessenberg matrix
     !! H and performs an unitary similarity transformation
     !! designed to detect and deflate fully converged eigenvalues from
     !! a trailing principal submatrix.  On output H has been over-
     !! written by a new Hessenberg matrix that is a perturbation of
     !! an unitary similarity transformation of H.  It is to be
     !! hoped that the final version of H has many zero subdiagonal
     !! entries.
               ns, nd, sh, v, ldv, nh, t, ldt,nv, wv, ldwv, work, lwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(ilp), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: sh(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
        ! ================================================================
           ! Parameters 
           real(sp), parameter :: rzero = 0.0_sp
           real(sp), parameter :: rone = 1.0_sp
           
           
           ! Local Scalars 
           complex(sp) :: beta, cdum, s, tau
           real(sp) :: foo, safmax, safmin, smlnum, ulp
           integer(ilp) :: i, ifst, ilst, info, infqr, j, jw, kcol, kln, knt, krow, kwtop, ltop, &
                     lwk1, lwk2, lwk3, lwkopt, nmin
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! ==== estimate optimal workspace. ====
           jw = min( nw, kbot-ktop+1 )
           if( jw<=2 ) then
              lwkopt = 1
           else
              ! ==== workspace query call to stdlib_cgehrd ====
              call stdlib_cgehrd( jw, 1, jw-1, t, ldt, work, work, -1, info )
              lwk1 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_cunmhr ====
              call stdlib_cunmhr( 'R', 'N', jw, jw, 1, jw-1, t, ldt, work, v, ldv,work, -1, info )
                        
              lwk2 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_claqr4 ====
              call stdlib_claqr4( .true., .true., jw, 1, jw, t, ldt, sh, 1, jw, v,ldv, work, -1, &
                        infqr )
              lwk3 = int( work( 1 ),KIND=ilp)
              ! ==== optimal workspace ====
              lwkopt = max( jw+max( lwk1, lwk2 ), lwk3 )
           end if
           ! ==== quick return in case of workspace query. ====
           if( lwork==-1 ) then
              work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
              return
           end if
           ! ==== nothing to do ...
           ! ... for an empty active block ... ====
           ns = 0
           nd = 0
           work( 1 ) = cone
           if( ktop>kbot )return
           ! ... nor for an empty deflation window. ====
           if( nw<1 )return
           ! ==== machine constants ====
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=sp) / ulp )
           ! ==== setup deflation window ====
           jw = min( nw, kbot-ktop+1 )
           kwtop = kbot - jw + 1
           if( kwtop==ktop ) then
              s = czero
           else
              s = h( kwtop, kwtop-1 )
           end if
           if( kbot==kwtop ) then
              ! ==== 1-by-1 deflation window: not much to do ====
              sh( kwtop ) = h( kwtop, kwtop )
              ns = 1
              nd = 0
              if( cabs1( s )<=max( smlnum, ulp*cabs1( h( kwtop,kwtop ) ) ) ) then
                 ns = 0
                 nd = 1
                 if( kwtop>ktop )h( kwtop, kwtop-1 ) = czero
              end if
              work( 1 ) = cone
              return
           end if
           ! ==== convert to spike-triangular form.  (in case of a
           ! .    rare qr failure, this routine continues to do
           ! .    aggressive early deflation using that part of
           ! .    the deflation window that converged using infqr
           ! .    here and there to keep track.) ====
           call stdlib_clacpy( 'U', jw, jw, h( kwtop, kwtop ), ldh, t, ldt )
           call stdlib_ccopy( jw-1, h( kwtop+1, kwtop ), ldh+1, t( 2, 1 ), ldt+1 )
           call stdlib_claset( 'A', jw, jw, czero, cone, v, ldv )
           nmin = stdlib_ilaenv( 12, 'CLAQR3', 'SV', jw, 1, jw, lwork )
           if( jw>nmin ) then
              call stdlib_claqr4( .true., .true., jw, 1, jw, t, ldt, sh( kwtop ), 1,jw, v, ldv, &
                        work, lwork, infqr )
           else
              call stdlib_clahqr( .true., .true., jw, 1, jw, t, ldt, sh( kwtop ), 1,jw, v, ldv, &
                        infqr )
           end if
           ! ==== deflation detection loop ====
           ns = jw
           ilst = infqr + 1
           do knt = infqr + 1, jw
              ! ==== small spike tip deflation test ====
              foo = cabs1( t( ns, ns ) )
              if( foo==rzero )foo = cabs1( s )
              if( cabs1( s )*cabs1( v( 1, ns ) )<=max( smlnum, ulp*foo ) )then
                 ! ==== cone more converged eigenvalue ====
                 ns = ns - 1
              else
                 ! ==== cone undeflatable eigenvalue.  move it up out of the
                 ! .    way.   (stdlib_ctrexc can not fail in this case.) ====
                 ifst = ns
                 call stdlib_ctrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                 ilst = ilst + 1
              end if
           end do
              ! ==== return to hessenberg form ====
           if( ns==0 )s = czero
           if( ns<jw ) then
              ! ==== sorting the diagonal of t improves accuracy for
              ! .    graded matrices.  ====
              do i = infqr + 1, ns
                 ifst = i
                 do j = i + 1, ns
                    if( cabs1( t( j, j ) )>cabs1( t( ifst, ifst ) ) )ifst = j
                 end do
                 ilst = i
                 if( ifst/=ilst )call stdlib_ctrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                           
              end do
           end if
           ! ==== restore shift/eigenvalue array from t ====
           do i = infqr + 1, jw
              sh( kwtop+i-1 ) = t( i, i )
           end do
           if( ns<jw .or. s==czero ) then
              if( ns>1 .and. s/=czero ) then
                 ! ==== reflect spike back into lower triangle ====
                 call stdlib_ccopy( ns, v, ldv, work, 1 )
                 do i = 1, ns
                    work( i ) = conjg( work( i ) )
                 end do
                 beta = work( 1 )
                 call stdlib_clarfg( ns, beta, work( 2 ), 1, tau )
                 work( 1 ) = cone
                 call stdlib_claset( 'L', jw-2, jw-2, czero, czero, t( 3, 1 ), ldt )
                 call stdlib_clarf( 'L', ns, jw, work, 1, conjg( tau ), t, ldt,work( jw+1 ) )
                           
                 call stdlib_clarf( 'R', ns, ns, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_clarf( 'R', jw, ns, work, 1, tau, v, ldv,work( jw+1 ) )
                 call stdlib_cgehrd( jw, 1, ns, t, ldt, work, work( jw+1 ),lwork-jw, info )
                           
              end if
              ! ==== copy updated reduced window into place ====
              if( kwtop>1 )h( kwtop, kwtop-1 ) = s*conjg( v( 1, 1 ) )
              call stdlib_clacpy( 'U', jw, jw, t, ldt, h( kwtop, kwtop ), ldh )
              call stdlib_ccopy( jw-1, t( 2, 1 ), ldt+1, h( kwtop+1, kwtop ),ldh+1 )
              ! ==== accumulate orthogonal matrix in order update
              ! .    h and z, if requested.  ====
              if( ns>1 .and. s/=czero )call stdlib_cunmhr( 'R', 'N', jw, ns, 1, ns, t, ldt, work, &
                        v, ldv,work( jw+1 ), lwork-jw, info )
              ! ==== update vertical slab in h ====
              if( wantt ) then
                 ltop = 1
              else
                 ltop = ktop
              end if
              do krow = ltop, kwtop - 1, nv
                 kln = min( nv, kwtop-krow )
                 call stdlib_cgemm( 'N', 'N', kln, jw, jw, cone, h( krow, kwtop ),ldh, v, ldv, &
                           czero, wv, ldwv )
                 call stdlib_clacpy( 'A', kln, jw, wv, ldwv, h( krow, kwtop ), ldh )
              end do
              ! ==== update horizontal slab in h ====
              if( wantt ) then
                 do kcol = kbot + 1, n, nh
                    kln = min( nh, n-kcol+1 )
                    call stdlib_cgemm( 'C', 'N', jw, kln, jw, cone, v, ldv,h( kwtop, kcol ), ldh, &
                              czero, t, ldt )
                    call stdlib_clacpy( 'A', jw, kln, t, ldt, h( kwtop, kcol ),ldh )
                 end do
              end if
              ! ==== update vertical slab in z ====
              if( wantz ) then
                 do krow = iloz, ihiz, nv
                    kln = min( nv, ihiz-krow+1 )
                    call stdlib_cgemm( 'N', 'N', kln, jw, jw, cone, z( krow, kwtop ),ldz, v, ldv, &
                              czero, wv, ldwv )
                    call stdlib_clacpy( 'A', kln, jw, wv, ldwv, z( krow, kwtop ),ldz )
                 end do
              end if
           end if
           ! ==== return the number of deflations ... ====
           nd = jw - ns
           ! ==== ... and the number of shifts. (subtracting
           ! .    infqr from the spike length takes care
           ! .    of the case of a rare qr failure while
           ! .    calculating eigenvalues of the deflation
           ! .    window.)  ====
           ns = ns - infqr
            ! ==== return optimal workspace. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
     end subroutine stdlib_claqr3

     module pure subroutine stdlib_zlaqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
     !! Aggressive early deflation:
     !! ZLAQR3 accepts as input an upper Hessenberg matrix
     !! H and performs an unitary similarity transformation
     !! designed to detect and deflate fully converged eigenvalues from
     !! a trailing principal submatrix.  On output H has been over-
     !! written by a new Hessenberg matrix that is a perturbation of
     !! an unitary similarity transformation of H.  It is to be
     !! hoped that the final version of H has many zero subdiagonal
     !! entries.
               ns, nd, sh, v, ldv, nh, t, ldt,nv, wv, ldwv, work, lwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(ilp), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(dp), intent(out) :: sh(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
        ! ================================================================
           ! Parameters 
           real(dp), parameter :: rzero = 0.0_dp
           real(dp), parameter :: rone = 1.0_dp
           
           
           ! Local Scalars 
           complex(dp) :: beta, cdum, s, tau
           real(dp) :: foo, safmax, safmin, smlnum, ulp
           integer(ilp) :: i, ifst, ilst, info, infqr, j, jw, kcol, kln, knt, krow, kwtop, ltop, &
                     lwk1, lwk2, lwk3, lwkopt, nmin
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! ==== estimate optimal workspace. ====
           jw = min( nw, kbot-ktop+1 )
           if( jw<=2 ) then
              lwkopt = 1
           else
              ! ==== workspace query call to stdlib_zgehrd ====
              call stdlib_zgehrd( jw, 1, jw-1, t, ldt, work, work, -1, info )
              lwk1 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_zunmhr ====
              call stdlib_zunmhr( 'R', 'N', jw, jw, 1, jw-1, t, ldt, work, v, ldv,work, -1, info )
                        
              lwk2 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_zlaqr4 ====
              call stdlib_zlaqr4( .true., .true., jw, 1, jw, t, ldt, sh, 1, jw, v,ldv, work, -1, &
                        infqr )
              lwk3 = int( work( 1 ),KIND=ilp)
              ! ==== optimal workspace ====
              lwkopt = max( jw+max( lwk1, lwk2 ), lwk3 )
           end if
           ! ==== quick return in case of workspace query. ====
           if( lwork==-1 ) then
              work( 1 ) = cmplx( lwkopt, 0,KIND=dp)
              return
           end if
           ! ==== nothing to do ...
           ! ... for an empty active block ... ====
           ns = 0
           nd = 0
           work( 1 ) = cone
           if( ktop>kbot )return
           ! ... nor for an empty deflation window. ====
           if( nw<1 )return
           ! ==== machine constants ====
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_dlabad( safmin, safmax )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=dp) / ulp )
           ! ==== setup deflation window ====
           jw = min( nw, kbot-ktop+1 )
           kwtop = kbot - jw + 1
           if( kwtop==ktop ) then
              s = czero
           else
              s = h( kwtop, kwtop-1 )
           end if
           if( kbot==kwtop ) then
              ! ==== 1-by-1 deflation window: not much to do ====
              sh( kwtop ) = h( kwtop, kwtop )
              ns = 1
              nd = 0
              if( cabs1( s )<=max( smlnum, ulp*cabs1( h( kwtop,kwtop ) ) ) ) then
                 ns = 0
                 nd = 1
                 if( kwtop>ktop )h( kwtop, kwtop-1 ) = czero
              end if
              work( 1 ) = cone
              return
           end if
           ! ==== convert to spike-triangular form.  (in case of a
           ! .    rare qr failure, this routine continues to do
           ! .    aggressive early deflation using that part of
           ! .    the deflation window that converged using infqr
           ! .    here and there to keep track.) ====
           call stdlib_zlacpy( 'U', jw, jw, h( kwtop, kwtop ), ldh, t, ldt )
           call stdlib_zcopy( jw-1, h( kwtop+1, kwtop ), ldh+1, t( 2, 1 ), ldt+1 )
           call stdlib_zlaset( 'A', jw, jw, czero, cone, v, ldv )
           nmin = stdlib_ilaenv( 12, 'ZLAQR3', 'SV', jw, 1, jw, lwork )
           if( jw>nmin ) then
              call stdlib_zlaqr4( .true., .true., jw, 1, jw, t, ldt, sh( kwtop ), 1,jw, v, ldv, &
                        work, lwork, infqr )
           else
              call stdlib_zlahqr( .true., .true., jw, 1, jw, t, ldt, sh( kwtop ), 1,jw, v, ldv, &
                        infqr )
           end if
           ! ==== deflation detection loop ====
           ns = jw
           ilst = infqr + 1
           do knt = infqr + 1, jw
              ! ==== small spike tip deflation test ====
              foo = cabs1( t( ns, ns ) )
              if( foo==rzero )foo = cabs1( s )
              if( cabs1( s )*cabs1( v( 1, ns ) )<=max( smlnum, ulp*foo ) )then
                 ! ==== cone more converged eigenvalue ====
                 ns = ns - 1
              else
                 ! ==== cone undeflatable eigenvalue.  move it up out of the
                 ! .    way.   (stdlib_ztrexc can not fail in this case.) ====
                 ifst = ns
                 call stdlib_ztrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                 ilst = ilst + 1
              end if
           end do
              ! ==== return to hessenberg form ====
           if( ns==0 )s = czero
           if( ns<jw ) then
              ! ==== sorting the diagonal of t improves accuracy for
              ! .    graded matrices.  ====
              do i = infqr + 1, ns
                 ifst = i
                 do j = i + 1, ns
                    if( cabs1( t( j, j ) )>cabs1( t( ifst, ifst ) ) )ifst = j
                 end do
                 ilst = i
                 if( ifst/=ilst )call stdlib_ztrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                           
              end do
           end if
           ! ==== restore shift/eigenvalue array from t ====
           do i = infqr + 1, jw
              sh( kwtop+i-1 ) = t( i, i )
           end do
           if( ns<jw .or. s==czero ) then
              if( ns>1 .and. s/=czero ) then
                 ! ==== reflect spike back into lower triangle ====
                 call stdlib_zcopy( ns, v, ldv, work, 1 )
                 do i = 1, ns
                    work( i ) = conjg( work( i ) )
                 end do
                 beta = work( 1 )
                 call stdlib_zlarfg( ns, beta, work( 2 ), 1, tau )
                 work( 1 ) = cone
                 call stdlib_zlaset( 'L', jw-2, jw-2, czero, czero, t( 3, 1 ), ldt )
                 call stdlib_zlarf( 'L', ns, jw, work, 1, conjg( tau ), t, ldt,work( jw+1 ) )
                           
                 call stdlib_zlarf( 'R', ns, ns, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_zlarf( 'R', jw, ns, work, 1, tau, v, ldv,work( jw+1 ) )
                 call stdlib_zgehrd( jw, 1, ns, t, ldt, work, work( jw+1 ),lwork-jw, info )
                           
              end if
              ! ==== copy updated reduced window into place ====
              if( kwtop>1 )h( kwtop, kwtop-1 ) = s*conjg( v( 1, 1 ) )
              call stdlib_zlacpy( 'U', jw, jw, t, ldt, h( kwtop, kwtop ), ldh )
              call stdlib_zcopy( jw-1, t( 2, 1 ), ldt+1, h( kwtop+1, kwtop ),ldh+1 )
              ! ==== accumulate orthogonal matrix in order update
              ! .    h and z, if requested.  ====
              if( ns>1 .and. s/=czero )call stdlib_zunmhr( 'R', 'N', jw, ns, 1, ns, t, ldt, work, &
                        v, ldv,work( jw+1 ), lwork-jw, info )
              ! ==== update vertical slab in h ====
              if( wantt ) then
                 ltop = 1
              else
                 ltop = ktop
              end if
              do krow = ltop, kwtop - 1, nv
                 kln = min( nv, kwtop-krow )
                 call stdlib_zgemm( 'N', 'N', kln, jw, jw, cone, h( krow, kwtop ),ldh, v, ldv, &
                           czero, wv, ldwv )
                 call stdlib_zlacpy( 'A', kln, jw, wv, ldwv, h( krow, kwtop ), ldh )
              end do
              ! ==== update horizontal slab in h ====
              if( wantt ) then
                 do kcol = kbot + 1, n, nh
                    kln = min( nh, n-kcol+1 )
                    call stdlib_zgemm( 'C', 'N', jw, kln, jw, cone, v, ldv,h( kwtop, kcol ), ldh, &
                              czero, t, ldt )
                    call stdlib_zlacpy( 'A', jw, kln, t, ldt, h( kwtop, kcol ),ldh )
                 end do
              end if
              ! ==== update vertical slab in z ====
              if( wantz ) then
                 do krow = iloz, ihiz, nv
                    kln = min( nv, ihiz-krow+1 )
                    call stdlib_zgemm( 'N', 'N', kln, jw, jw, cone, z( krow, kwtop ),ldz, v, ldv, &
                              czero, wv, ldwv )
                    call stdlib_zlacpy( 'A', kln, jw, wv, ldwv, z( krow, kwtop ),ldz )
                 end do
              end if
           end if
           ! ==== return the number of deflations ... ====
           nd = jw - ns
           ! ==== ... and the number of shifts. (subtracting
           ! .    infqr from the spike length takes care
           ! .    of the case of a rare qr failure while
           ! .    calculating eigenvalues of the deflation
           ! .    window.)  ====
           ns = ns - infqr
            ! ==== return optimal workspace. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=dp)
     end subroutine stdlib_zlaqr3

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$laqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
     !! Aggressive early deflation:
     !! ZLAQR3: accepts as input an upper Hessenberg matrix
     !! H and performs an unitary similarity transformation
     !! designed to detect and deflate fully converged eigenvalues from
     !! a trailing principal submatrix.  On output H has been over-
     !! written by a new Hessenberg matrix that is a perturbation of
     !! an unitary similarity transformation of H.  It is to be
     !! hoped that the final version of H has many zero subdiagonal
     !! entries.
               ns, nd, sh, v, ldv, nh, t, ldt,nv, wv, ldwv, work, lwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(ilp), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(${ck}$), intent(out) :: sh(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
        ! ================================================================
           ! Parameters 
           real(${ck}$), parameter :: rzero = 0.0_${ck}$
           real(${ck}$), parameter :: rone = 1.0_${ck}$
           
           
           ! Local Scalars 
           complex(${ck}$) :: beta, cdum, s, tau
           real(${ck}$) :: foo, safmax, safmin, smlnum, ulp
           integer(ilp) :: i, ifst, ilst, info, infqr, j, jw, kcol, kln, knt, krow, kwtop, ltop, &
                     lwk1, lwk2, lwk3, lwkopt, nmin
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! ==== estimate optimal workspace. ====
           jw = min( nw, kbot-ktop+1 )
           if( jw<=2 ) then
              lwkopt = 1
           else
              ! ==== workspace query call to stdlib_${ci}$gehrd ====
              call stdlib_${ci}$gehrd( jw, 1, jw-1, t, ldt, work, work, -1, info )
              lwk1 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_${ci}$unmhr ====
              call stdlib_${ci}$unmhr( 'R', 'N', jw, jw, 1, jw-1, t, ldt, work, v, ldv,work, -1, info )
                        
              lwk2 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_${ci}$laqr4 ====
              call stdlib_${ci}$laqr4( .true., .true., jw, 1, jw, t, ldt, sh, 1, jw, v,ldv, work, -1, &
                        infqr )
              lwk3 = int( work( 1 ),KIND=ilp)
              ! ==== optimal workspace ====
              lwkopt = max( jw+max( lwk1, lwk2 ), lwk3 )
           end if
           ! ==== quick return in case of workspace query. ====
           if( lwork==-1 ) then
              work( 1 ) = cmplx( lwkopt, 0,KIND=${ck}$)
              return
           end if
           ! ==== nothing to do ...
           ! ... for an empty active block ... ====
           ns = 0
           nd = 0
           work( 1 ) = cone
           if( ktop>kbot )return
           ! ... nor for an empty deflation window. ====
           if( nw<1 )return
           ! ==== machine constants ====
           safmin = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_${c2ri(ci)}$labad( safmin, safmax )
           ulp = stdlib_${c2ri(ci)}$lamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=${ck}$) / ulp )
           ! ==== setup deflation window ====
           jw = min( nw, kbot-ktop+1 )
           kwtop = kbot - jw + 1
           if( kwtop==ktop ) then
              s = czero
           else
              s = h( kwtop, kwtop-1 )
           end if
           if( kbot==kwtop ) then
              ! ==== 1-by-1 deflation window: not much to do ====
              sh( kwtop ) = h( kwtop, kwtop )
              ns = 1
              nd = 0
              if( cabs1( s )<=max( smlnum, ulp*cabs1( h( kwtop,kwtop ) ) ) ) then
                 ns = 0
                 nd = 1
                 if( kwtop>ktop )h( kwtop, kwtop-1 ) = czero
              end if
              work( 1 ) = cone
              return
           end if
           ! ==== convert to spike-triangular form.  (in case of a
           ! .    rare qr failure, this routine continues to do
           ! .    aggressive early deflation using that part of
           ! .    the deflation window that converged using infqr
           ! .    here and there to keep track.) ====
           call stdlib_${ci}$lacpy( 'U', jw, jw, h( kwtop, kwtop ), ldh, t, ldt )
           call stdlib_${ci}$copy( jw-1, h( kwtop+1, kwtop ), ldh+1, t( 2, 1 ), ldt+1 )
           call stdlib_${ci}$laset( 'A', jw, jw, czero, cone, v, ldv )
           nmin = stdlib_ilaenv( 12, 'ZLAQR3', 'SV', jw, 1, jw, lwork )
           if( jw>nmin ) then
              call stdlib_${ci}$laqr4( .true., .true., jw, 1, jw, t, ldt, sh( kwtop ), 1,jw, v, ldv, &
                        work, lwork, infqr )
           else
              call stdlib_${ci}$lahqr( .true., .true., jw, 1, jw, t, ldt, sh( kwtop ), 1,jw, v, ldv, &
                        infqr )
           end if
           ! ==== deflation detection loop ====
           ns = jw
           ilst = infqr + 1
           do knt = infqr + 1, jw
              ! ==== small spike tip deflation test ====
              foo = cabs1( t( ns, ns ) )
              if( foo==rzero )foo = cabs1( s )
              if( cabs1( s )*cabs1( v( 1, ns ) )<=max( smlnum, ulp*foo ) )then
                 ! ==== cone more converged eigenvalue ====
                 ns = ns - 1
              else
                 ! ==== cone undeflatable eigenvalue.  move it up out of the
                 ! .    way.   (stdlib_${ci}$trexc can not fail in this case.) ====
                 ifst = ns
                 call stdlib_${ci}$trexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                 ilst = ilst + 1
              end if
           end do
              ! ==== return to hessenberg form ====
           if( ns==0 )s = czero
           if( ns<jw ) then
              ! ==== sorting the diagonal of t improves accuracy for
              ! .    graded matrices.  ====
              do i = infqr + 1, ns
                 ifst = i
                 do j = i + 1, ns
                    if( cabs1( t( j, j ) )>cabs1( t( ifst, ifst ) ) )ifst = j
                 end do
                 ilst = i
                 if( ifst/=ilst )call stdlib_${ci}$trexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                           
              end do
           end if
           ! ==== restore shift/eigenvalue array from t ====
           do i = infqr + 1, jw
              sh( kwtop+i-1 ) = t( i, i )
           end do
           if( ns<jw .or. s==czero ) then
              if( ns>1 .and. s/=czero ) then
                 ! ==== reflect spike back into lower triangle ====
                 call stdlib_${ci}$copy( ns, v, ldv, work, 1 )
                 do i = 1, ns
                    work( i ) = conjg( work( i ) )
                 end do
                 beta = work( 1 )
                 call stdlib_${ci}$larfg( ns, beta, work( 2 ), 1, tau )
                 work( 1 ) = cone
                 call stdlib_${ci}$laset( 'L', jw-2, jw-2, czero, czero, t( 3, 1 ), ldt )
                 call stdlib_${ci}$larf( 'L', ns, jw, work, 1, conjg( tau ), t, ldt,work( jw+1 ) )
                           
                 call stdlib_${ci}$larf( 'R', ns, ns, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_${ci}$larf( 'R', jw, ns, work, 1, tau, v, ldv,work( jw+1 ) )
                 call stdlib_${ci}$gehrd( jw, 1, ns, t, ldt, work, work( jw+1 ),lwork-jw, info )
                           
              end if
              ! ==== copy updated reduced window into place ====
              if( kwtop>1 )h( kwtop, kwtop-1 ) = s*conjg( v( 1, 1 ) )
              call stdlib_${ci}$lacpy( 'U', jw, jw, t, ldt, h( kwtop, kwtop ), ldh )
              call stdlib_${ci}$copy( jw-1, t( 2, 1 ), ldt+1, h( kwtop+1, kwtop ),ldh+1 )
              ! ==== accumulate orthogonal matrix in order update
              ! .    h and z, if requested.  ====
              if( ns>1 .and. s/=czero )call stdlib_${ci}$unmhr( 'R', 'N', jw, ns, 1, ns, t, ldt, work, &
                        v, ldv,work( jw+1 ), lwork-jw, info )
              ! ==== update vertical slab in h ====
              if( wantt ) then
                 ltop = 1
              else
                 ltop = ktop
              end if
              do krow = ltop, kwtop - 1, nv
                 kln = min( nv, kwtop-krow )
                 call stdlib_${ci}$gemm( 'N', 'N', kln, jw, jw, cone, h( krow, kwtop ),ldh, v, ldv, &
                           czero, wv, ldwv )
                 call stdlib_${ci}$lacpy( 'A', kln, jw, wv, ldwv, h( krow, kwtop ), ldh )
              end do
              ! ==== update horizontal slab in h ====
              if( wantt ) then
                 do kcol = kbot + 1, n, nh
                    kln = min( nh, n-kcol+1 )
                    call stdlib_${ci}$gemm( 'C', 'N', jw, kln, jw, cone, v, ldv,h( kwtop, kcol ), ldh, &
                              czero, t, ldt )
                    call stdlib_${ci}$lacpy( 'A', jw, kln, t, ldt, h( kwtop, kcol ),ldh )
                 end do
              end if
              ! ==== update vertical slab in z ====
              if( wantz ) then
                 do krow = iloz, ihiz, nv
                    kln = min( nv, ihiz-krow+1 )
                    call stdlib_${ci}$gemm( 'N', 'N', kln, jw, jw, cone, z( krow, kwtop ),ldz, v, ldv, &
                              czero, wv, ldwv )
                    call stdlib_${ci}$lacpy( 'A', kln, jw, wv, ldwv, z( krow, kwtop ),ldz )
                 end do
              end if
           end if
           ! ==== return the number of deflations ... ====
           nd = jw - ns
           ! ==== ... and the number of shifts. (subtracting
           ! .    infqr from the spike length takes care
           ! .    of the case of a rare qr failure while
           ! .    calculating eigenvalues of the deflation
           ! .    window.)  ====
           ns = ns - infqr
            ! ==== return optimal workspace. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=${ck}$)
     end subroutine stdlib_${ci}$laqr3

#:endif
#:endfor





     module subroutine stdlib_sgeev( jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr,ldvr, work, lwork, &
     !! SGEEV computes for an N-by-N real nonsymmetric matrix A, the
     !! eigenvalues and, optionally, the left and/or right eigenvectors.
     !! The right eigenvector v(j) of A satisfies
     !! A * v(j) = lambda(j) * v(j)
     !! where lambda(j) is its eigenvalue.
     !! The left eigenvector u(j) of A satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H
     !! where u(j)**H denotes the conjugate-transpose of u(j).
     !! The computed eigenvectors are normalized to have Euclidean norm
     !! equal to 1 and largest component real.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: vl(ldvl,*), vr(ldvr,*), wi(*), work(*), wr(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantvl, wantvr
           character :: side
           integer(ilp) :: hswork, i, ibal, ierr, ihi, ilo, itau, iwrk, k, lwork_trevc, maxwrk, &
                     minwrk, nout
           real(sp) :: anrm, bignum, cs, cscale, eps, r, scl, smlnum, sn
           ! Local Arrays 
           logical(lk) :: select(1)
           real(sp) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvl = stdlib_lsame( jobvl, 'V' )
           wantvr = stdlib_lsame( jobvr, 'V' )
           if( ( .not.wantvl ) .and. ( .not.stdlib_lsame( jobvl, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantvr ) .and. ( .not.stdlib_lsame( jobvr, 'N' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldvl<1 .or. ( wantvl .and. ldvl<n ) ) then
              info = -9
           else if( ldvr<1 .or. ( wantvr .and. ldvr<n ) ) then
              info = -11
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_shseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = 2*n + n*stdlib_ilaenv( 1, 'SGEHRD', ' ', n, 1, n, 0 )
                 if( wantvl ) then
                    minwrk = 4*n
                    maxwrk = max( maxwrk, 2*n + ( n - 1 )*stdlib_ilaenv( 1,'SORGHR', ' ', n, 1, n,&
                               -1 ) )
                    call stdlib_shseqr( 'S', 'V', n, 1, n, a, lda, wr, wi, vl, ldvl,work, -1, &
                              info )
                    hswork = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + 1, n + hswork )
                    call stdlib_strevc3( 'L', 'B', select, n, a, lda,vl, ldvl, vr, ldvr, n, nout,&
                              work, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    maxwrk = max( maxwrk, 4*n )
                 else if( wantvr ) then
                    minwrk = 4*n
                    maxwrk = max( maxwrk, 2*n + ( n - 1 )*stdlib_ilaenv( 1,'SORGHR', ' ', n, 1, n,&
                               -1 ) )
                    call stdlib_shseqr( 'S', 'V', n, 1, n, a, lda, wr, wi, vr, ldvr,work, -1, &
                              info )
                    hswork = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + 1, n + hswork )
                    call stdlib_strevc3( 'R', 'B', select, n, a, lda,vl, ldvl, vr, ldvr, n, nout,&
                              work, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    maxwrk = max( maxwrk, 4*n )
                 else
                    minwrk = 3*n
                    call stdlib_shseqr( 'E', 'N', n, 1, n, a, lda, wr, wi, vr, ldvr,work, -1, &
                              info )
                    hswork = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + 1, n + hswork )
                 end if
                 maxwrk = max( maxwrk, minwrk )
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -13
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGEEV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_slange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_slascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! balance the matrix
           ! (workspace: need n)
           ibal = 1
           call stdlib_sgebal( 'B', n, a, lda, ilo, ihi, work( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (workspace: need 3*n, prefer 2*n+n*nb)
           itau = ibal + n
           iwrk = itau + n
           call stdlib_sgehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvl ) then
              ! want left eigenvectors
              ! copy householder vectors to vl
              side = 'L'
              call stdlib_slacpy( 'L', n, n, a, lda, vl, ldvl )
              ! generate orthogonal matrix in vl
              ! (workspace: need 3*n-1, prefer 2*n+(n-1)*nb)
              call stdlib_sorghr( n, ilo, ihi, vl, ldvl, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vl
              ! (workspace: need n+1, prefer n+hswork (see comments) )
              iwrk = itau
              call stdlib_shseqr( 'S', 'V', n, ilo, ihi, a, lda, wr, wi, vl, ldvl,work( iwrk ), &
                        lwork-iwrk+1, info )
              if( wantvr ) then
                 ! want left and right eigenvectors
                 ! copy schur vectors to vr
                 side = 'B'
                 call stdlib_slacpy( 'F', n, n, vl, ldvl, vr, ldvr )
              end if
           else if( wantvr ) then
              ! want right eigenvectors
              ! copy householder vectors to vr
              side = 'R'
              call stdlib_slacpy( 'L', n, n, a, lda, vr, ldvr )
              ! generate orthogonal matrix in vr
              ! (workspace: need 3*n-1, prefer 2*n+(n-1)*nb)
              call stdlib_sorghr( n, ilo, ihi, vr, ldvr, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vr
              ! (workspace: need n+1, prefer n+hswork (see comments) )
              iwrk = itau
              call stdlib_shseqr( 'S', 'V', n, ilo, ihi, a, lda, wr, wi, vr, ldvr,work( iwrk ), &
                        lwork-iwrk+1, info )
           else
              ! compute eigenvalues only
              ! (workspace: need n+1, prefer n+hswork (see comments) )
              iwrk = itau
              call stdlib_shseqr( 'E', 'N', n, ilo, ihi, a, lda, wr, wi, vr, ldvr,work( iwrk ), &
                        lwork-iwrk+1, info )
           end if
           ! if info /= 0 from stdlib_shseqr, then quit
           if( info/=0 )go to 50
           if( wantvl .or. wantvr ) then
              ! compute left and/or right eigenvectors
              ! (workspace: need 4*n, prefer n + n + 2*n*nb)
              call stdlib_strevc3( side, 'B', select, n, a, lda, vl, ldvl, vr, ldvr,n, nout, work(&
                         iwrk ), lwork-iwrk+1, ierr )
           end if
           if( wantvl ) then
              ! undo balancing of left eigenvectors
              ! (workspace: need n)
              call stdlib_sgebak( 'B', 'L', n, ilo, ihi, work( ibal ), n, vl, ldvl,ierr )
              ! normalize left eigenvectors and make largest component real
              do i = 1, n
                 if( wi( i )==zero ) then
                    scl = one / stdlib_snrm2( n, vl( 1, i ), 1 )
                    call stdlib_sscal( n, scl, vl( 1, i ), 1 )
                 else if( wi( i )>zero ) then
                    scl = one / stdlib_slapy2( stdlib_snrm2( n, vl( 1, i ), 1 ),stdlib_snrm2( n, &
                              vl( 1, i+1 ), 1 ) )
                    call stdlib_sscal( n, scl, vl( 1, i ), 1 )
                    call stdlib_sscal( n, scl, vl( 1, i+1 ), 1 )
                    do k = 1, n
                       work( iwrk+k-1 ) = vl( k, i )**2 + vl( k, i+1 )**2
                    end do
                    k = stdlib_isamax( n, work( iwrk ), 1 )
                    call stdlib_slartg( vl( k, i ), vl( k, i+1 ), cs, sn, r )
                    call stdlib_srot( n, vl( 1, i ), 1, vl( 1, i+1 ), 1, cs, sn )
                    vl( k, i+1 ) = zero
                 end if
              end do
           end if
           if( wantvr ) then
              ! undo balancing of right eigenvectors
              ! (workspace: need n)
              call stdlib_sgebak( 'B', 'R', n, ilo, ihi, work( ibal ), n, vr, ldvr,ierr )
              ! normalize right eigenvectors and make largest component real
              do i = 1, n
                 if( wi( i )==zero ) then
                    scl = one / stdlib_snrm2( n, vr( 1, i ), 1 )
                    call stdlib_sscal( n, scl, vr( 1, i ), 1 )
                 else if( wi( i )>zero ) then
                    scl = one / stdlib_slapy2( stdlib_snrm2( n, vr( 1, i ), 1 ),stdlib_snrm2( n, &
                              vr( 1, i+1 ), 1 ) )
                    call stdlib_sscal( n, scl, vr( 1, i ), 1 )
                    call stdlib_sscal( n, scl, vr( 1, i+1 ), 1 )
                    do k = 1, n
                       work( iwrk+k-1 ) = vr( k, i )**2 + vr( k, i+1 )**2
                    end do
                    k = stdlib_isamax( n, work( iwrk ), 1 )
                    call stdlib_slartg( vr( k, i ), vr( k, i+1 ), cs, sn, r )
                    call stdlib_srot( n, vr( 1, i ), 1, vr( 1, i+1 ), 1, cs, sn )
                    vr( k, i+1 ) = zero
                 end if
              end do
           end if
           ! undo scaling if necessary
           50 continue
           if( scalea ) then
              call stdlib_slascl( 'G', 0, 0, cscale, anrm, n-info, 1, wr( info+1 ),max( n-info, 1 &
                        ), ierr )
              call stdlib_slascl( 'G', 0, 0, cscale, anrm, n-info, 1, wi( info+1 ),max( n-info, 1 &
                        ), ierr )
              if( info>0 ) then
                 call stdlib_slascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wr, n,ierr )
                 call stdlib_slascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wi, n,ierr )
              end if
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_sgeev

     module subroutine stdlib_dgeev( jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr,ldvr, work, lwork, &
     !! DGEEV computes for an N-by-N real nonsymmetric matrix A, the
     !! eigenvalues and, optionally, the left and/or right eigenvectors.
     !! The right eigenvector v(j) of A satisfies
     !! A * v(j) = lambda(j) * v(j)
     !! where lambda(j) is its eigenvalue.
     !! The left eigenvector u(j) of A satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H
     !! where u(j)**H denotes the conjugate-transpose of u(j).
     !! The computed eigenvectors are normalized to have Euclidean norm
     !! equal to 1 and largest component real.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: vl(ldvl,*), vr(ldvr,*), wi(*), work(*), wr(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantvl, wantvr
           character :: side
           integer(ilp) :: hswork, i, ibal, ierr, ihi, ilo, itau, iwrk, k, lwork_trevc, maxwrk, &
                     minwrk, nout
           real(dp) :: anrm, bignum, cs, cscale, eps, r, scl, smlnum, sn
           ! Local Arrays 
           logical(lk) :: select(1)
           real(dp) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvl = stdlib_lsame( jobvl, 'V' )
           wantvr = stdlib_lsame( jobvr, 'V' )
           if( ( .not.wantvl ) .and. ( .not.stdlib_lsame( jobvl, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantvr ) .and. ( .not.stdlib_lsame( jobvr, 'N' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldvl<1 .or. ( wantvl .and. ldvl<n ) ) then
              info = -9
           else if( ldvr<1 .or. ( wantvr .and. ldvr<n ) ) then
              info = -11
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_dhseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = 2*n + n*stdlib_ilaenv( 1, 'DGEHRD', ' ', n, 1, n, 0 )
                 if( wantvl ) then
                    minwrk = 4*n
                    maxwrk = max( maxwrk, 2*n + ( n - 1 )*stdlib_ilaenv( 1,'DORGHR', ' ', n, 1, n,&
                               -1 ) )
                    call stdlib_dhseqr( 'S', 'V', n, 1, n, a, lda, wr, wi, vl, ldvl,work, -1, &
                              info )
                    hswork = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + 1, n + hswork )
                    call stdlib_dtrevc3( 'L', 'B', select, n, a, lda,vl, ldvl, vr, ldvr, n, nout,&
                              work, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    maxwrk = max( maxwrk, 4*n )
                 else if( wantvr ) then
                    minwrk = 4*n
                    maxwrk = max( maxwrk, 2*n + ( n - 1 )*stdlib_ilaenv( 1,'DORGHR', ' ', n, 1, n,&
                               -1 ) )
                    call stdlib_dhseqr( 'S', 'V', n, 1, n, a, lda, wr, wi, vr, ldvr,work, -1, &
                              info )
                    hswork = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + 1, n + hswork )
                    call stdlib_dtrevc3( 'R', 'B', select, n, a, lda,vl, ldvl, vr, ldvr, n, nout,&
                              work, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    maxwrk = max( maxwrk, 4*n )
                 else
                    minwrk = 3*n
                    call stdlib_dhseqr( 'E', 'N', n, 1, n, a, lda, wr, wi, vr, ldvr,work, -1, &
                              info )
                    hswork = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + 1, n + hswork )
                 end if
                 maxwrk = max( maxwrk, minwrk )
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -13
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEEV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' )
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_dlange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_dlascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! balance the matrix
           ! (workspace: need n)
           ibal = 1
           call stdlib_dgebal( 'B', n, a, lda, ilo, ihi, work( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (workspace: need 3*n, prefer 2*n+n*nb)
           itau = ibal + n
           iwrk = itau + n
           call stdlib_dgehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvl ) then
              ! want left eigenvectors
              ! copy householder vectors to vl
              side = 'L'
              call stdlib_dlacpy( 'L', n, n, a, lda, vl, ldvl )
              ! generate orthogonal matrix in vl
              ! (workspace: need 3*n-1, prefer 2*n+(n-1)*nb)
              call stdlib_dorghr( n, ilo, ihi, vl, ldvl, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vl
              ! (workspace: need n+1, prefer n+hswork (see comments) )
              iwrk = itau
              call stdlib_dhseqr( 'S', 'V', n, ilo, ihi, a, lda, wr, wi, vl, ldvl,work( iwrk ), &
                        lwork-iwrk+1, info )
              if( wantvr ) then
                 ! want left and right eigenvectors
                 ! copy schur vectors to vr
                 side = 'B'
                 call stdlib_dlacpy( 'F', n, n, vl, ldvl, vr, ldvr )
              end if
           else if( wantvr ) then
              ! want right eigenvectors
              ! copy householder vectors to vr
              side = 'R'
              call stdlib_dlacpy( 'L', n, n, a, lda, vr, ldvr )
              ! generate orthogonal matrix in vr
              ! (workspace: need 3*n-1, prefer 2*n+(n-1)*nb)
              call stdlib_dorghr( n, ilo, ihi, vr, ldvr, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vr
              ! (workspace: need n+1, prefer n+hswork (see comments) )
              iwrk = itau
              call stdlib_dhseqr( 'S', 'V', n, ilo, ihi, a, lda, wr, wi, vr, ldvr,work( iwrk ), &
                        lwork-iwrk+1, info )
           else
              ! compute eigenvalues only
              ! (workspace: need n+1, prefer n+hswork (see comments) )
              iwrk = itau
              call stdlib_dhseqr( 'E', 'N', n, ilo, ihi, a, lda, wr, wi, vr, ldvr,work( iwrk ), &
                        lwork-iwrk+1, info )
           end if
           ! if info /= 0 from stdlib_dhseqr, then quit
           if( info/=0 )go to 50
           if( wantvl .or. wantvr ) then
              ! compute left and/or right eigenvectors
              ! (workspace: need 4*n, prefer n + n + 2*n*nb)
              call stdlib_dtrevc3( side, 'B', select, n, a, lda, vl, ldvl, vr, ldvr,n, nout, work(&
                         iwrk ), lwork-iwrk+1, ierr )
           end if
           if( wantvl ) then
              ! undo balancing of left eigenvectors
              ! (workspace: need n)
              call stdlib_dgebak( 'B', 'L', n, ilo, ihi, work( ibal ), n, vl, ldvl,ierr )
              ! normalize left eigenvectors and make largest component real
              do i = 1, n
                 if( wi( i )==zero ) then
                    scl = one / stdlib_dnrm2( n, vl( 1, i ), 1 )
                    call stdlib_dscal( n, scl, vl( 1, i ), 1 )
                 else if( wi( i )>zero ) then
                    scl = one / stdlib_dlapy2( stdlib_dnrm2( n, vl( 1, i ), 1 ),stdlib_dnrm2( n, &
                              vl( 1, i+1 ), 1 ) )
                    call stdlib_dscal( n, scl, vl( 1, i ), 1 )
                    call stdlib_dscal( n, scl, vl( 1, i+1 ), 1 )
                    do k = 1, n
                       work( iwrk+k-1 ) = vl( k, i )**2 + vl( k, i+1 )**2
                    end do
                    k = stdlib_idamax( n, work( iwrk ), 1 )
                    call stdlib_dlartg( vl( k, i ), vl( k, i+1 ), cs, sn, r )
                    call stdlib_drot( n, vl( 1, i ), 1, vl( 1, i+1 ), 1, cs, sn )
                    vl( k, i+1 ) = zero
                 end if
              end do
           end if
           if( wantvr ) then
              ! undo balancing of right eigenvectors
              ! (workspace: need n)
              call stdlib_dgebak( 'B', 'R', n, ilo, ihi, work( ibal ), n, vr, ldvr,ierr )
              ! normalize right eigenvectors and make largest component real
              do i = 1, n
                 if( wi( i )==zero ) then
                    scl = one / stdlib_dnrm2( n, vr( 1, i ), 1 )
                    call stdlib_dscal( n, scl, vr( 1, i ), 1 )
                 else if( wi( i )>zero ) then
                    scl = one / stdlib_dlapy2( stdlib_dnrm2( n, vr( 1, i ), 1 ),stdlib_dnrm2( n, &
                              vr( 1, i+1 ), 1 ) )
                    call stdlib_dscal( n, scl, vr( 1, i ), 1 )
                    call stdlib_dscal( n, scl, vr( 1, i+1 ), 1 )
                    do k = 1, n
                       work( iwrk+k-1 ) = vr( k, i )**2 + vr( k, i+1 )**2
                    end do
                    k = stdlib_idamax( n, work( iwrk ), 1 )
                    call stdlib_dlartg( vr( k, i ), vr( k, i+1 ), cs, sn, r )
                    call stdlib_drot( n, vr( 1, i ), 1, vr( 1, i+1 ), 1, cs, sn )
                    vr( k, i+1 ) = zero
                 end if
              end do
           end if
           ! undo scaling if necessary
           50 continue
           if( scalea ) then
              call stdlib_dlascl( 'G', 0, 0, cscale, anrm, n-info, 1, wr( info+1 ),max( n-info, 1 &
                        ), ierr )
              call stdlib_dlascl( 'G', 0, 0, cscale, anrm, n-info, 1, wi( info+1 ),max( n-info, 1 &
                        ), ierr )
              if( info>0 ) then
                 call stdlib_dlascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wr, n,ierr )
                 call stdlib_dlascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wi, n,ierr )
              end if
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_dgeev

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$geev( jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr,ldvr, work, lwork, &
     !! DGEEV: computes for an N-by-N real nonsymmetric matrix A, the
     !! eigenvalues and, optionally, the left and/or right eigenvectors.
     !! The right eigenvector v(j) of A satisfies
     !! A * v(j) = lambda(j) * v(j)
     !! where lambda(j) is its eigenvalue.
     !! The left eigenvector u(j) of A satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H
     !! where u(j)**H denotes the conjugate-transpose of u(j).
     !! The computed eigenvectors are normalized to have Euclidean norm
     !! equal to 1 and largest component real.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: vl(ldvl,*), vr(ldvr,*), wi(*), work(*), wr(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantvl, wantvr
           character :: side
           integer(ilp) :: hswork, i, ibal, ierr, ihi, ilo, itau, iwrk, k, lwork_trevc, maxwrk, &
                     minwrk, nout
           real(${rk}$) :: anrm, bignum, cs, cscale, eps, r, scl, smlnum, sn
           ! Local Arrays 
           logical(lk) :: select(1)
           real(${rk}$) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvl = stdlib_lsame( jobvl, 'V' )
           wantvr = stdlib_lsame( jobvr, 'V' )
           if( ( .not.wantvl ) .and. ( .not.stdlib_lsame( jobvl, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantvr ) .and. ( .not.stdlib_lsame( jobvr, 'N' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldvl<1 .or. ( wantvl .and. ldvl<n ) ) then
              info = -9
           else if( ldvr<1 .or. ( wantvr .and. ldvr<n ) ) then
              info = -11
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_${ri}$hseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = 2*n + n*stdlib_ilaenv( 1, 'DGEHRD', ' ', n, 1, n, 0 )
                 if( wantvl ) then
                    minwrk = 4*n
                    maxwrk = max( maxwrk, 2*n + ( n - 1 )*stdlib_ilaenv( 1,'DORGHR', ' ', n, 1, n,&
                               -1 ) )
                    call stdlib_${ri}$hseqr( 'S', 'V', n, 1, n, a, lda, wr, wi, vl, ldvl,work, -1, &
                              info )
                    hswork = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + 1, n + hswork )
                    call stdlib_${ri}$trevc3( 'L', 'B', select, n, a, lda,vl, ldvl, vr, ldvr, n, nout,&
                              work, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    maxwrk = max( maxwrk, 4*n )
                 else if( wantvr ) then
                    minwrk = 4*n
                    maxwrk = max( maxwrk, 2*n + ( n - 1 )*stdlib_ilaenv( 1,'DORGHR', ' ', n, 1, n,&
                               -1 ) )
                    call stdlib_${ri}$hseqr( 'S', 'V', n, 1, n, a, lda, wr, wi, vr, ldvr,work, -1, &
                              info )
                    hswork = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + 1, n + hswork )
                    call stdlib_${ri}$trevc3( 'R', 'B', select, n, a, lda,vl, ldvl, vr, ldvr, n, nout,&
                              work, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    maxwrk = max( maxwrk, 4*n )
                 else
                    minwrk = 3*n
                    call stdlib_${ri}$hseqr( 'E', 'N', n, 1, n, a, lda, wr, wi, vr, ldvr,work, -1, &
                              info )
                    hswork = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + 1, n + hswork )
                 end if
                 maxwrk = max( maxwrk, minwrk )
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -13
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEEV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_${ri}$lascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! balance the matrix
           ! (workspace: need n)
           ibal = 1
           call stdlib_${ri}$gebal( 'B', n, a, lda, ilo, ihi, work( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (workspace: need 3*n, prefer 2*n+n*nb)
           itau = ibal + n
           iwrk = itau + n
           call stdlib_${ri}$gehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvl ) then
              ! want left eigenvectors
              ! copy householder vectors to vl
              side = 'L'
              call stdlib_${ri}$lacpy( 'L', n, n, a, lda, vl, ldvl )
              ! generate orthogonal matrix in vl
              ! (workspace: need 3*n-1, prefer 2*n+(n-1)*nb)
              call stdlib_${ri}$orghr( n, ilo, ihi, vl, ldvl, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vl
              ! (workspace: need n+1, prefer n+hswork (see comments) )
              iwrk = itau
              call stdlib_${ri}$hseqr( 'S', 'V', n, ilo, ihi, a, lda, wr, wi, vl, ldvl,work( iwrk ), &
                        lwork-iwrk+1, info )
              if( wantvr ) then
                 ! want left and right eigenvectors
                 ! copy schur vectors to vr
                 side = 'B'
                 call stdlib_${ri}$lacpy( 'F', n, n, vl, ldvl, vr, ldvr )
              end if
           else if( wantvr ) then
              ! want right eigenvectors
              ! copy householder vectors to vr
              side = 'R'
              call stdlib_${ri}$lacpy( 'L', n, n, a, lda, vr, ldvr )
              ! generate orthogonal matrix in vr
              ! (workspace: need 3*n-1, prefer 2*n+(n-1)*nb)
              call stdlib_${ri}$orghr( n, ilo, ihi, vr, ldvr, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vr
              ! (workspace: need n+1, prefer n+hswork (see comments) )
              iwrk = itau
              call stdlib_${ri}$hseqr( 'S', 'V', n, ilo, ihi, a, lda, wr, wi, vr, ldvr,work( iwrk ), &
                        lwork-iwrk+1, info )
           else
              ! compute eigenvalues only
              ! (workspace: need n+1, prefer n+hswork (see comments) )
              iwrk = itau
              call stdlib_${ri}$hseqr( 'E', 'N', n, ilo, ihi, a, lda, wr, wi, vr, ldvr,work( iwrk ), &
                        lwork-iwrk+1, info )
           end if
           ! if info /= 0 from stdlib_${ri}$hseqr, then quit
           if( info/=0 )go to 50
           if( wantvl .or. wantvr ) then
              ! compute left and/or right eigenvectors
              ! (workspace: need 4*n, prefer n + n + 2*n*nb)
              call stdlib_${ri}$trevc3( side, 'B', select, n, a, lda, vl, ldvl, vr, ldvr,n, nout, work(&
                         iwrk ), lwork-iwrk+1, ierr )
           end if
           if( wantvl ) then
              ! undo balancing of left eigenvectors
              ! (workspace: need n)
              call stdlib_${ri}$gebak( 'B', 'L', n, ilo, ihi, work( ibal ), n, vl, ldvl,ierr )
              ! normalize left eigenvectors and make largest component real
              do i = 1, n
                 if( wi( i )==zero ) then
                    scl = one / stdlib_${ri}$nrm2( n, vl( 1, i ), 1 )
                    call stdlib_${ri}$scal( n, scl, vl( 1, i ), 1 )
                 else if( wi( i )>zero ) then
                    scl = one / stdlib_${ri}$lapy2( stdlib_${ri}$nrm2( n, vl( 1, i ), 1 ),stdlib_${ri}$nrm2( n, &
                              vl( 1, i+1 ), 1 ) )
                    call stdlib_${ri}$scal( n, scl, vl( 1, i ), 1 )
                    call stdlib_${ri}$scal( n, scl, vl( 1, i+1 ), 1 )
                    do k = 1, n
                       work( iwrk+k-1 ) = vl( k, i )**2 + vl( k, i+1 )**2
                    end do
                    k = stdlib_i${ri}$amax( n, work( iwrk ), 1 )
                    call stdlib_${ri}$lartg( vl( k, i ), vl( k, i+1 ), cs, sn, r )
                    call stdlib_${ri}$rot( n, vl( 1, i ), 1, vl( 1, i+1 ), 1, cs, sn )
                    vl( k, i+1 ) = zero
                 end if
              end do
           end if
           if( wantvr ) then
              ! undo balancing of right eigenvectors
              ! (workspace: need n)
              call stdlib_${ri}$gebak( 'B', 'R', n, ilo, ihi, work( ibal ), n, vr, ldvr,ierr )
              ! normalize right eigenvectors and make largest component real
              do i = 1, n
                 if( wi( i )==zero ) then
                    scl = one / stdlib_${ri}$nrm2( n, vr( 1, i ), 1 )
                    call stdlib_${ri}$scal( n, scl, vr( 1, i ), 1 )
                 else if( wi( i )>zero ) then
                    scl = one / stdlib_${ri}$lapy2( stdlib_${ri}$nrm2( n, vr( 1, i ), 1 ),stdlib_${ri}$nrm2( n, &
                              vr( 1, i+1 ), 1 ) )
                    call stdlib_${ri}$scal( n, scl, vr( 1, i ), 1 )
                    call stdlib_${ri}$scal( n, scl, vr( 1, i+1 ), 1 )
                    do k = 1, n
                       work( iwrk+k-1 ) = vr( k, i )**2 + vr( k, i+1 )**2
                    end do
                    k = stdlib_i${ri}$amax( n, work( iwrk ), 1 )
                    call stdlib_${ri}$lartg( vr( k, i ), vr( k, i+1 ), cs, sn, r )
                    call stdlib_${ri}$rot( n, vr( 1, i ), 1, vr( 1, i+1 ), 1, cs, sn )
                    vr( k, i+1 ) = zero
                 end if
              end do
           end if
           ! undo scaling if necessary
           50 continue
           if( scalea ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, n-info, 1, wr( info+1 ),max( n-info, 1 &
                        ), ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, n-info, 1, wi( info+1 ),max( n-info, 1 &
                        ), ierr )
              if( info>0 ) then
                 call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wr, n,ierr )
                 call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wi, n,ierr )
              end if
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_${ri}$geev

#:endif
#:endfor

     module subroutine stdlib_cgeev( jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr,work, lwork, rwork, &
     !! CGEEV computes for an N-by-N complex nonsymmetric matrix A, the
     !! eigenvalues and, optionally, the left and/or right eigenvectors.
     !! The right eigenvector v(j) of A satisfies
     !! A * v(j) = lambda(j) * v(j)
     !! where lambda(j) is its eigenvalue.
     !! The left eigenvector u(j) of A satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H
     !! where u(j)**H denotes the conjugate transpose of u(j).
     !! The computed eigenvectors are normalized to have Euclidean norm
     !! equal to 1 and largest component real.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: vl(ldvl,*), vr(ldvr,*), w(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantvl, wantvr
           character :: side
           integer(ilp) :: hswork, i, ibal, ierr, ihi, ilo, irwork, itau, iwrk, k, lwork_trevc, &
                     maxwrk, minwrk, nout
           real(sp) :: anrm, bignum, cscale, eps, scl, smlnum
           complex(sp) :: tmp
           ! Local Arrays 
           logical(lk) :: select(1)
           real(sp) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvl = stdlib_lsame( jobvl, 'V' )
           wantvr = stdlib_lsame( jobvr, 'V' )
           if( ( .not.wantvl ) .and. ( .not.stdlib_lsame( jobvl, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantvr ) .and. ( .not.stdlib_lsame( jobvr, 'N' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldvl<1 .or. ( wantvl .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( wantvr .and. ldvr<n ) ) then
              info = -10
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to real
             ! workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_chseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = n + n*stdlib_ilaenv( 1, 'CGEHRD', ' ', n, 1, n, 0 )
                 minwrk = 2*n
                 if( wantvl ) then
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'CUNGHR',' ', n, 1, n, -&
                              1 ) )
                    call stdlib_ctrevc3( 'L', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, rwork, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    call stdlib_chseqr( 'S', 'V', n, 1, n, a, lda, w, vl, ldvl,work, -1, info )
                              
                 else if( wantvr ) then
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'CUNGHR',' ', n, 1, n, -&
                              1 ) )
                    call stdlib_ctrevc3( 'R', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, rwork, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    call stdlib_chseqr( 'S', 'V', n, 1, n, a, lda, w, vr, ldvr,work, -1, info )
                              
                 else
                    call stdlib_chseqr( 'E', 'N', n, 1, n, a, lda, w, vr, ldvr,work, -1, info )
                              
                 end if
                 hswork = int( work(1),KIND=ilp)
                 maxwrk = max( maxwrk, hswork, minwrk )
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEEV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_clascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! balance the matrix
           ! (cworkspace: none)
           ! (rworkspace: need n)
           ibal = 1
           call stdlib_cgebal( 'B', n, a, lda, ilo, ihi, rwork( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (cworkspace: need 2*n, prefer n+n*nb)
           ! (rworkspace: none)
           itau = 1
           iwrk = itau + n
           call stdlib_cgehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvl ) then
              ! want left eigenvectors
              ! copy householder vectors to vl
              side = 'L'
              call stdlib_clacpy( 'L', n, n, a, lda, vl, ldvl )
              ! generate unitary matrix in vl
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_cunghr( n, ilo, ihi, vl, ldvl, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vl
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_chseqr( 'S', 'V', n, ilo, ihi, a, lda, w, vl, ldvl,work( iwrk ), lwork-&
                        iwrk+1, info )
              if( wantvr ) then
                 ! want left and right eigenvectors
                 ! copy schur vectors to vr
                 side = 'B'
                 call stdlib_clacpy( 'F', n, n, vl, ldvl, vr, ldvr )
              end if
           else if( wantvr ) then
              ! want right eigenvectors
              ! copy householder vectors to vr
              side = 'R'
              call stdlib_clacpy( 'L', n, n, a, lda, vr, ldvr )
              ! generate unitary matrix in vr
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_cunghr( n, ilo, ihi, vr, ldvr, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vr
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_chseqr( 'S', 'V', n, ilo, ihi, a, lda, w, vr, ldvr,work( iwrk ), lwork-&
                        iwrk+1, info )
           else
              ! compute eigenvalues only
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_chseqr( 'E', 'N', n, ilo, ihi, a, lda, w, vr, ldvr,work( iwrk ), lwork-&
                        iwrk+1, info )
           end if
           ! if info /= 0 from stdlib_chseqr, then quit
           if( info/=0 )go to 50
           if( wantvl .or. wantvr ) then
              ! compute left and/or right eigenvectors
              ! (cworkspace: need 2*n, prefer n + 2*n*nb)
              ! (rworkspace: need 2*n)
              irwork = ibal + n
              call stdlib_ctrevc3( side, 'B', select, n, a, lda, vl, ldvl, vr, ldvr,n, nout, work(&
                         iwrk ), lwork-iwrk+1,rwork( irwork ), n, ierr )
           end if
           if( wantvl ) then
              ! undo balancing of left eigenvectors
              ! (cworkspace: none)
              ! (rworkspace: need n)
              call stdlib_cgebak( 'B', 'L', n, ilo, ihi, rwork( ibal ), n, vl, ldvl,ierr )
              ! normalize left eigenvectors and make largest component real
              do i = 1, n
                 scl = one / stdlib_scnrm2( n, vl( 1, i ), 1 )
                 call stdlib_csscal( n, scl, vl( 1, i ), 1 )
                 do k = 1, n
                    rwork( irwork+k-1 ) = real( vl( k, i ),KIND=sp)**2 +aimag( vl( k, i ) )&
                              **2
                 end do
                 k = stdlib_isamax( n, rwork( irwork ), 1 )
                 tmp = conjg( vl( k, i ) ) / sqrt( rwork( irwork+k-1 ) )
                 call stdlib_cscal( n, tmp, vl( 1, i ), 1 )
                 vl( k, i ) = cmplx( real( vl( k, i ),KIND=sp), zero,KIND=sp)
              end do
           end if
           if( wantvr ) then
              ! undo balancing of right eigenvectors
              ! (cworkspace: none)
              ! (rworkspace: need n)
              call stdlib_cgebak( 'B', 'R', n, ilo, ihi, rwork( ibal ), n, vr, ldvr,ierr )
              ! normalize right eigenvectors and make largest component real
              do i = 1, n
                 scl = one / stdlib_scnrm2( n, vr( 1, i ), 1 )
                 call stdlib_csscal( n, scl, vr( 1, i ), 1 )
                 do k = 1, n
                    rwork( irwork+k-1 ) = real( vr( k, i ),KIND=sp)**2 +aimag( vr( k, i ) )&
                              **2
                 end do
                 k = stdlib_isamax( n, rwork( irwork ), 1 )
                 tmp = conjg( vr( k, i ) ) / sqrt( rwork( irwork+k-1 ) )
                 call stdlib_cscal( n, tmp, vr( 1, i ), 1 )
                 vr( k, i ) = cmplx( real( vr( k, i ),KIND=sp), zero,KIND=sp)
              end do
           end if
           ! undo scaling if necessary
           50 continue
           if( scalea ) then
              call stdlib_clascl( 'G', 0, 0, cscale, anrm, n-info, 1, w( info+1 ),max( n-info, 1 )&
                        , ierr )
              if( info>0 ) then
                 call stdlib_clascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, w, n, ierr )
              end if
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_cgeev

     module subroutine stdlib_zgeev( jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr,work, lwork, rwork, &
     !! ZGEEV computes for an N-by-N complex nonsymmetric matrix A, the
     !! eigenvalues and, optionally, the left and/or right eigenvectors.
     !! The right eigenvector v(j) of A satisfies
     !! A * v(j) = lambda(j) * v(j)
     !! where lambda(j) is its eigenvalue.
     !! The left eigenvector u(j) of A satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H
     !! where u(j)**H denotes the conjugate transpose of u(j).
     !! The computed eigenvectors are normalized to have Euclidean norm
     !! equal to 1 and largest component real.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: vl(ldvl,*), vr(ldvr,*), w(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantvl, wantvr
           character :: side
           integer(ilp) :: hswork, i, ibal, ierr, ihi, ilo, irwork, itau, iwrk, k, lwork_trevc, &
                     maxwrk, minwrk, nout
           real(dp) :: anrm, bignum, cscale, eps, scl, smlnum
           complex(dp) :: tmp
           ! Local Arrays 
           logical(lk) :: select(1)
           real(dp) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvl = stdlib_lsame( jobvl, 'V' )
           wantvr = stdlib_lsame( jobvr, 'V' )
           if( ( .not.wantvl ) .and. ( .not.stdlib_lsame( jobvl, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantvr ) .and. ( .not.stdlib_lsame( jobvr, 'N' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldvl<1 .or. ( wantvl .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( wantvr .and. ldvr<n ) ) then
              info = -10
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to real
             ! workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_zhseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = n + n*stdlib_ilaenv( 1, 'ZGEHRD', ' ', n, 1, n, 0 )
                 minwrk = 2*n
                 if( wantvl ) then
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'ZUNGHR',' ', n, 1, n, -&
                              1 ) )
                    call stdlib_ztrevc3( 'L', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, rwork, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    call stdlib_zhseqr( 'S', 'V', n, 1, n, a, lda, w, vl, ldvl,work, -1, info )
                              
                 else if( wantvr ) then
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'ZUNGHR',' ', n, 1, n, -&
                              1 ) )
                    call stdlib_ztrevc3( 'R', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, rwork, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    call stdlib_zhseqr( 'S', 'V', n, 1, n, a, lda, w, vr, ldvr,work, -1, info )
                              
                 else
                    call stdlib_zhseqr( 'E', 'N', n, 1, n, a, lda, w, vr, ldvr,work, -1, info )
                              
                 end if
                 hswork = int( work(1),KIND=ilp)
                 maxwrk = max( maxwrk, hswork, minwrk )
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEEV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' )
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_zlange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_zlascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! balance the matrix
           ! (cworkspace: none)
           ! (rworkspace: need n)
           ibal = 1
           call stdlib_zgebal( 'B', n, a, lda, ilo, ihi, rwork( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (cworkspace: need 2*n, prefer n+n*nb)
           ! (rworkspace: none)
           itau = 1
           iwrk = itau + n
           call stdlib_zgehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvl ) then
              ! want left eigenvectors
              ! copy householder vectors to vl
              side = 'L'
              call stdlib_zlacpy( 'L', n, n, a, lda, vl, ldvl )
              ! generate unitary matrix in vl
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_zunghr( n, ilo, ihi, vl, ldvl, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vl
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_zhseqr( 'S', 'V', n, ilo, ihi, a, lda, w, vl, ldvl,work( iwrk ), lwork-&
                        iwrk+1, info )
              if( wantvr ) then
                 ! want left and right eigenvectors
                 ! copy schur vectors to vr
                 side = 'B'
                 call stdlib_zlacpy( 'F', n, n, vl, ldvl, vr, ldvr )
              end if
           else if( wantvr ) then
              ! want right eigenvectors
              ! copy householder vectors to vr
              side = 'R'
              call stdlib_zlacpy( 'L', n, n, a, lda, vr, ldvr )
              ! generate unitary matrix in vr
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_zunghr( n, ilo, ihi, vr, ldvr, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vr
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_zhseqr( 'S', 'V', n, ilo, ihi, a, lda, w, vr, ldvr,work( iwrk ), lwork-&
                        iwrk+1, info )
           else
              ! compute eigenvalues only
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_zhseqr( 'E', 'N', n, ilo, ihi, a, lda, w, vr, ldvr,work( iwrk ), lwork-&
                        iwrk+1, info )
           end if
           ! if info /= 0 from stdlib_zhseqr, then quit
           if( info/=0 )go to 50
           if( wantvl .or. wantvr ) then
              ! compute left and/or right eigenvectors
              ! (cworkspace: need 2*n, prefer n + 2*n*nb)
              ! (rworkspace: need 2*n)
              irwork = ibal + n
              call stdlib_ztrevc3( side, 'B', select, n, a, lda, vl, ldvl, vr, ldvr,n, nout, work(&
                         iwrk ), lwork-iwrk+1,rwork( irwork ), n, ierr )
           end if
           if( wantvl ) then
              ! undo balancing of left eigenvectors
              ! (cworkspace: none)
              ! (rworkspace: need n)
              call stdlib_zgebak( 'B', 'L', n, ilo, ihi, rwork( ibal ), n, vl, ldvl,ierr )
              ! normalize left eigenvectors and make largest component real
              do i = 1, n
                 scl = one / stdlib_dznrm2( n, vl( 1, i ), 1 )
                 call stdlib_zdscal( n, scl, vl( 1, i ), 1 )
                 do k = 1, n
                    rwork( irwork+k-1 ) = real( vl( k, i ),KIND=dp)**2 +aimag( vl( k, i ) )&
                              **2
                 end do
                 k = stdlib_idamax( n, rwork( irwork ), 1 )
                 tmp = conjg( vl( k, i ) ) / sqrt( rwork( irwork+k-1 ) )
                 call stdlib_zscal( n, tmp, vl( 1, i ), 1 )
                 vl( k, i ) = cmplx( real( vl( k, i ),KIND=dp), zero,KIND=dp)
              end do
           end if
           if( wantvr ) then
              ! undo balancing of right eigenvectors
              ! (cworkspace: none)
              ! (rworkspace: need n)
              call stdlib_zgebak( 'B', 'R', n, ilo, ihi, rwork( ibal ), n, vr, ldvr,ierr )
              ! normalize right eigenvectors and make largest component real
              do i = 1, n
                 scl = one / stdlib_dznrm2( n, vr( 1, i ), 1 )
                 call stdlib_zdscal( n, scl, vr( 1, i ), 1 )
                 do k = 1, n
                    rwork( irwork+k-1 ) = real( vr( k, i ),KIND=dp)**2 +aimag( vr( k, i ) )&
                              **2
                 end do
                 k = stdlib_idamax( n, rwork( irwork ), 1 )
                 tmp = conjg( vr( k, i ) ) / sqrt( rwork( irwork+k-1 ) )
                 call stdlib_zscal( n, tmp, vr( 1, i ), 1 )
                 vr( k, i ) = cmplx( real( vr( k, i ),KIND=dp), zero,KIND=dp)
              end do
           end if
           ! undo scaling if necessary
           50 continue
           if( scalea ) then
              call stdlib_zlascl( 'G', 0, 0, cscale, anrm, n-info, 1, w( info+1 ),max( n-info, 1 )&
                        , ierr )
              if( info>0 ) then
                 call stdlib_zlascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, w, n, ierr )
              end if
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_zgeev

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$geev( jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr,work, lwork, rwork, &
     !! ZGEEV: computes for an N-by-N complex nonsymmetric matrix A, the
     !! eigenvalues and, optionally, the left and/or right eigenvectors.
     !! The right eigenvector v(j) of A satisfies
     !! A * v(j) = lambda(j) * v(j)
     !! where lambda(j) is its eigenvalue.
     !! The left eigenvector u(j) of A satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H
     !! where u(j)**H denotes the conjugate transpose of u(j).
     !! The computed eigenvectors are normalized to have Euclidean norm
     !! equal to 1 and largest component real.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: vl(ldvl,*), vr(ldvr,*), w(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantvl, wantvr
           character :: side
           integer(ilp) :: hswork, i, ibal, ierr, ihi, ilo, irwork, itau, iwrk, k, lwork_trevc, &
                     maxwrk, minwrk, nout
           real(${ck}$) :: anrm, bignum, cscale, eps, scl, smlnum
           complex(${ck}$) :: tmp
           ! Local Arrays 
           logical(lk) :: select(1)
           real(${ck}$) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvl = stdlib_lsame( jobvl, 'V' )
           wantvr = stdlib_lsame( jobvr, 'V' )
           if( ( .not.wantvl ) .and. ( .not.stdlib_lsame( jobvl, 'N' ) ) ) then
              info = -1
           else if( ( .not.wantvr ) .and. ( .not.stdlib_lsame( jobvr, 'N' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldvl<1 .or. ( wantvl .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( wantvr .and. ldvr<n ) ) then
              info = -10
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to real
             ! workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_${ci}$hseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = n + n*stdlib_ilaenv( 1, 'ZGEHRD', ' ', n, 1, n, 0 )
                 minwrk = 2*n
                 if( wantvl ) then
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'ZUNGHR',' ', n, 1, n, -&
                              1 ) )
                    call stdlib_${ci}$trevc3( 'L', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, rwork, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    call stdlib_${ci}$hseqr( 'S', 'V', n, 1, n, a, lda, w, vl, ldvl,work, -1, info )
                              
                 else if( wantvr ) then
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'ZUNGHR',' ', n, 1, n, -&
                              1 ) )
                    call stdlib_${ci}$trevc3( 'R', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, rwork, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    call stdlib_${ci}$hseqr( 'S', 'V', n, 1, n, a, lda, w, vr, ldvr,work, -1, info )
                              
                 else
                    call stdlib_${ci}$hseqr( 'E', 'N', n, 1, n, a, lda, w, vr, ldvr,work, -1, info )
                              
                 end if
                 hswork = int( work(1),KIND=ilp)
                 maxwrk = max( maxwrk, hswork, minwrk )
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEEV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_${c2ri(ci)}$lamch( 'P' )
           smlnum = stdlib_${c2ri(ci)}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${c2ri(ci)}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ci}$lange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_${ci}$lascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! balance the matrix
           ! (cworkspace: none)
           ! (rworkspace: need n)
           ibal = 1
           call stdlib_${ci}$gebal( 'B', n, a, lda, ilo, ihi, rwork( ibal ), ierr )
           ! reduce to upper hessenberg form
           ! (cworkspace: need 2*n, prefer n+n*nb)
           ! (rworkspace: none)
           itau = 1
           iwrk = itau + n
           call stdlib_${ci}$gehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvl ) then
              ! want left eigenvectors
              ! copy householder vectors to vl
              side = 'L'
              call stdlib_${ci}$lacpy( 'L', n, n, a, lda, vl, ldvl )
              ! generate unitary matrix in vl
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_${ci}$unghr( n, ilo, ihi, vl, ldvl, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vl
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_${ci}$hseqr( 'S', 'V', n, ilo, ihi, a, lda, w, vl, ldvl,work( iwrk ), lwork-&
                        iwrk+1, info )
              if( wantvr ) then
                 ! want left and right eigenvectors
                 ! copy schur vectors to vr
                 side = 'B'
                 call stdlib_${ci}$lacpy( 'F', n, n, vl, ldvl, vr, ldvr )
              end if
           else if( wantvr ) then
              ! want right eigenvectors
              ! copy householder vectors to vr
              side = 'R'
              call stdlib_${ci}$lacpy( 'L', n, n, a, lda, vr, ldvr )
              ! generate unitary matrix in vr
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_${ci}$unghr( n, ilo, ihi, vr, ldvr, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vr
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_${ci}$hseqr( 'S', 'V', n, ilo, ihi, a, lda, w, vr, ldvr,work( iwrk ), lwork-&
                        iwrk+1, info )
           else
              ! compute eigenvalues only
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_${ci}$hseqr( 'E', 'N', n, ilo, ihi, a, lda, w, vr, ldvr,work( iwrk ), lwork-&
                        iwrk+1, info )
           end if
           ! if info /= 0 from stdlib_${ci}$hseqr, then quit
           if( info/=0 )go to 50
           if( wantvl .or. wantvr ) then
              ! compute left and/or right eigenvectors
              ! (cworkspace: need 2*n, prefer n + 2*n*nb)
              ! (rworkspace: need 2*n)
              irwork = ibal + n
              call stdlib_${ci}$trevc3( side, 'B', select, n, a, lda, vl, ldvl, vr, ldvr,n, nout, work(&
                         iwrk ), lwork-iwrk+1,rwork( irwork ), n, ierr )
           end if
           if( wantvl ) then
              ! undo balancing of left eigenvectors
              ! (cworkspace: none)
              ! (rworkspace: need n)
              call stdlib_${ci}$gebak( 'B', 'L', n, ilo, ihi, rwork( ibal ), n, vl, ldvl,ierr )
              ! normalize left eigenvectors and make largest component real
              do i = 1, n
                 scl = one / stdlib_${c2ri(ci)}$znrm2( n, vl( 1, i ), 1 )
                 call stdlib_${ci}$dscal( n, scl, vl( 1, i ), 1 )
                 do k = 1, n
                    rwork( irwork+k-1 ) = real( vl( k, i ),KIND=${ck}$)**2 +aimag( vl( k, i ) )&
                              **2
                 end do
                 k = stdlib_i${c2ri(ci)}$amax( n, rwork( irwork ), 1 )
                 tmp = conjg( vl( k, i ) ) / sqrt( rwork( irwork+k-1 ) )
                 call stdlib_${ci}$scal( n, tmp, vl( 1, i ), 1 )
                 vl( k, i ) = cmplx( real( vl( k, i ),KIND=${ck}$), zero,KIND=${ck}$)
              end do
           end if
           if( wantvr ) then
              ! undo balancing of right eigenvectors
              ! (cworkspace: none)
              ! (rworkspace: need n)
              call stdlib_${ci}$gebak( 'B', 'R', n, ilo, ihi, rwork( ibal ), n, vr, ldvr,ierr )
              ! normalize right eigenvectors and make largest component real
              do i = 1, n
                 scl = one / stdlib_${c2ri(ci)}$znrm2( n, vr( 1, i ), 1 )
                 call stdlib_${ci}$dscal( n, scl, vr( 1, i ), 1 )
                 do k = 1, n
                    rwork( irwork+k-1 ) = real( vr( k, i ),KIND=${ck}$)**2 +aimag( vr( k, i ) )&
                              **2
                 end do
                 k = stdlib_i${c2ri(ci)}$amax( n, rwork( irwork ), 1 )
                 tmp = conjg( vr( k, i ) ) / sqrt( rwork( irwork+k-1 ) )
                 call stdlib_${ci}$scal( n, tmp, vr( 1, i ), 1 )
                 vr( k, i ) = cmplx( real( vr( k, i ),KIND=${ck}$), zero,KIND=${ck}$)
              end do
           end if
           ! undo scaling if necessary
           50 continue
           if( scalea ) then
              call stdlib_${ci}$lascl( 'G', 0, 0, cscale, anrm, n-info, 1, w( info+1 ),max( n-info, 1 )&
                        , ierr )
              if( info>0 ) then
                 call stdlib_${ci}$lascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, w, n, ierr )
              end if
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_${ci}$geev

#:endif
#:endfor



     module pure subroutine stdlib_slaqz2( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, qstart, &
     !! SLAQZ2 chases a 2x2 shift bulge in a matrix pencil down a single position
               q, ldq, nz, zstart, z, ldz )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           logical(lk), intent( in ) :: ilq, ilz
           integer(ilp), intent( in ) :: k, lda, ldb, ldq, ldz, istartm, istopm,nq, nz, qstart, &
                     zstart, ihi
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           ! ================================================================
           ! local variables
           real(sp) :: h(2,3), c1, s1, c2, s2, temp
           if( k+2 == ihi ) then
              ! shift is located on the edge of the matrix, remove it
              h = b( ihi-1:ihi, ihi-2:ihi )
              ! make h upper triangular
              call stdlib_slartg( h( 1, 1 ), h( 2, 1 ), c1, s1, temp )
              h( 2, 1 ) = zero
              h( 1, 1 ) = temp
              call stdlib_srot( 2, h( 1, 2 ), 2, h( 2, 2 ), 2, c1, s1 )
              call stdlib_slartg( h( 2, 3 ), h( 2, 2 ), c1, s1, temp )
              call stdlib_srot( 1, h( 1, 3 ), 1, h( 1, 2 ), 1, c1, s1 )
              call stdlib_slartg( h( 1, 2 ), h( 1, 1 ), c2, s2, temp )
              call stdlib_srot( ihi-istartm+1, b( istartm, ihi ), 1, b( istartm,ihi-1 ), 1, c1, &
                        s1 )
              call stdlib_srot( ihi-istartm+1, b( istartm, ihi-1 ), 1, b( istartm,ihi-2 ), 1, c2, &
                        s2 )
              b( ihi-1, ihi-2 ) = zero
              b( ihi, ihi-2 ) = zero
              call stdlib_srot( ihi-istartm+1, a( istartm, ihi ), 1, a( istartm,ihi-1 ), 1, c1, &
                        s1 )
              call stdlib_srot( ihi-istartm+1, a( istartm, ihi-1 ), 1, a( istartm,ihi-2 ), 1, c2, &
                        s2 )
              if ( ilz ) then
                 call stdlib_srot( nz, z( 1, ihi-zstart+1 ), 1, z( 1, ihi-1-zstart+1 ), 1, c1, s1 &
                           )
                 call stdlib_srot( nz, z( 1, ihi-1-zstart+1 ), 1, z( 1,ihi-2-zstart+1 ), 1, c2, &
                           s2 )
              end if
              call stdlib_slartg( a( ihi-1, ihi-2 ), a( ihi, ihi-2 ), c1, s1,temp )
              a( ihi-1, ihi-2 ) = temp
              a( ihi, ihi-2 ) = zero
              call stdlib_srot( istopm-ihi+2, a( ihi-1, ihi-1 ), lda, a( ihi,ihi-1 ), lda, c1, s1 &
                        )
              call stdlib_srot( istopm-ihi+2, b( ihi-1, ihi-1 ), ldb, b( ihi,ihi-1 ), ldb, c1, s1 &
                        )
              if ( ilq ) then
                 call stdlib_srot( nq, q( 1, ihi-1-qstart+1 ), 1, q( 1, ihi-qstart+1 ), 1, c1, s1 &
                           )
              end if
              call stdlib_slartg( b( ihi, ihi ), b( ihi, ihi-1 ), c1, s1, temp )
              b( ihi, ihi ) = temp
              b( ihi, ihi-1 ) = zero
              call stdlib_srot( ihi-istartm, b( istartm, ihi ), 1, b( istartm,ihi-1 ), 1, c1, s1 )
                        
              call stdlib_srot( ihi-istartm+1, a( istartm, ihi ), 1, a( istartm,ihi-1 ), 1, c1, &
                        s1 )
              if ( ilz ) then
                 call stdlib_srot( nz, z( 1, ihi-zstart+1 ), 1, z( 1, ihi-1-zstart+1 ), 1, c1, s1 &
                           )
              end if
           else
              ! normal operation, move bulge down
              h = b( k+1:k+2, k:k+2 )
              ! make h upper triangular
              call stdlib_slartg( h( 1, 1 ), h( 2, 1 ), c1, s1, temp )
              h( 2, 1 ) = zero
              h( 1, 1 ) = temp
              call stdlib_srot( 2, h( 1, 2 ), 2, h( 2, 2 ), 2, c1, s1 )
              ! calculate z1 and z2
              call stdlib_slartg( h( 2, 3 ), h( 2, 2 ), c1, s1, temp )
              call stdlib_srot( 1, h( 1, 3 ), 1, h( 1, 2 ), 1, c1, s1 )
              call stdlib_slartg( h( 1, 2 ), h( 1, 1 ), c2, s2, temp )
              ! apply transformations from the right
              call stdlib_srot( k+3-istartm+1, a( istartm, k+2 ), 1, a( istartm,k+1 ), 1, c1, s1 )
                        
              call stdlib_srot( k+3-istartm+1, a( istartm, k+1 ), 1, a( istartm,k ), 1, c2, s2 )
                        
              call stdlib_srot( k+2-istartm+1, b( istartm, k+2 ), 1, b( istartm,k+1 ), 1, c1, s1 )
                        
              call stdlib_srot( k+2-istartm+1, b( istartm, k+1 ), 1, b( istartm,k ), 1, c2, s2 )
                        
              if ( ilz ) then
                 call stdlib_srot( nz, z( 1, k+2-zstart+1 ), 1, z( 1, k+1-zstart+1 ), 1, c1, s1 )
                           
                 call stdlib_srot( nz, z( 1, k+1-zstart+1 ), 1, z( 1, k-zstart+1 ),1, c2, s2 )
                           
              end if
              b( k+1, k ) = zero
              b( k+2, k ) = zero
              ! calculate q1 and q2
              call stdlib_slartg( a( k+2, k ), a( k+3, k ), c1, s1, temp )
              a( k+2, k ) = temp
              a( k+3, k ) = zero
              call stdlib_slartg( a( k+1, k ), a( k+2, k ), c2, s2, temp )
              a( k+1, k ) = temp
              a( k+2, k ) = zero
           ! apply transformations from the left
              call stdlib_srot( istopm-k, a( k+2, k+1 ), lda, a( k+3, k+1 ), lda,c1, s1 )
              call stdlib_srot( istopm-k, a( k+1, k+1 ), lda, a( k+2, k+1 ), lda,c2, s2 )
              call stdlib_srot( istopm-k, b( k+2, k+1 ), ldb, b( k+3, k+1 ), ldb,c1, s1 )
              call stdlib_srot( istopm-k, b( k+1, k+1 ), ldb, b( k+2, k+1 ), ldb,c2, s2 )
              if ( ilq ) then
                 call stdlib_srot( nq, q( 1, k+2-qstart+1 ), 1, q( 1, k+3-qstart+1 ), 1, c1, s1 )
                           
                 call stdlib_srot( nq, q( 1, k+1-qstart+1 ), 1, q( 1, k+2-qstart+1 ), 1, c2, s2 )
                           
              end if
           end if
     end subroutine stdlib_slaqz2

     module pure subroutine stdlib_dlaqz2( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, qstart, &
     !! DLAQZ2 chases a 2x2 shift bulge in a matrix pencil down a single position
               q, ldq, nz, zstart, z, ldz )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           logical(lk), intent( in ) :: ilq, ilz
           integer(ilp), intent( in ) :: k, lda, ldb, ldq, ldz, istartm, istopm,nq, nz, qstart, &
                     zstart, ihi
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           ! ================================================================
           ! local variables
           real(dp) :: h(2,3), c1, s1, c2, s2, temp
           if( k+2 == ihi ) then
              ! shift is located on the edge of the matrix, remove it
              h = b( ihi-1:ihi, ihi-2:ihi )
              ! make h upper triangular
              call stdlib_dlartg( h( 1, 1 ), h( 2, 1 ), c1, s1, temp )
              h( 2, 1 ) = zero
              h( 1, 1 ) = temp
              call stdlib_drot( 2, h( 1, 2 ), 2, h( 2, 2 ), 2, c1, s1 )
              call stdlib_dlartg( h( 2, 3 ), h( 2, 2 ), c1, s1, temp )
              call stdlib_drot( 1, h( 1, 3 ), 1, h( 1, 2 ), 1, c1, s1 )
              call stdlib_dlartg( h( 1, 2 ), h( 1, 1 ), c2, s2, temp )
              call stdlib_drot( ihi-istartm+1, b( istartm, ihi ), 1, b( istartm,ihi-1 ), 1, c1, &
                        s1 )
              call stdlib_drot( ihi-istartm+1, b( istartm, ihi-1 ), 1, b( istartm,ihi-2 ), 1, c2, &
                        s2 )
              b( ihi-1, ihi-2 ) = zero
              b( ihi, ihi-2 ) = zero
              call stdlib_drot( ihi-istartm+1, a( istartm, ihi ), 1, a( istartm,ihi-1 ), 1, c1, &
                        s1 )
              call stdlib_drot( ihi-istartm+1, a( istartm, ihi-1 ), 1, a( istartm,ihi-2 ), 1, c2, &
                        s2 )
              if ( ilz ) then
                 call stdlib_drot( nz, z( 1, ihi-zstart+1 ), 1, z( 1, ihi-1-zstart+1 ), 1, c1, s1 &
                           )
                 call stdlib_drot( nz, z( 1, ihi-1-zstart+1 ), 1, z( 1,ihi-2-zstart+1 ), 1, c2, &
                           s2 )
              end if
              call stdlib_dlartg( a( ihi-1, ihi-2 ), a( ihi, ihi-2 ), c1, s1,temp )
              a( ihi-1, ihi-2 ) = temp
              a( ihi, ihi-2 ) = zero
              call stdlib_drot( istopm-ihi+2, a( ihi-1, ihi-1 ), lda, a( ihi,ihi-1 ), lda, c1, s1 &
                        )
              call stdlib_drot( istopm-ihi+2, b( ihi-1, ihi-1 ), ldb, b( ihi,ihi-1 ), ldb, c1, s1 &
                        )
              if ( ilq ) then
                 call stdlib_drot( nq, q( 1, ihi-1-qstart+1 ), 1, q( 1, ihi-qstart+1 ), 1, c1, s1 &
                           )
              end if
              call stdlib_dlartg( b( ihi, ihi ), b( ihi, ihi-1 ), c1, s1, temp )
              b( ihi, ihi ) = temp
              b( ihi, ihi-1 ) = zero
              call stdlib_drot( ihi-istartm, b( istartm, ihi ), 1, b( istartm,ihi-1 ), 1, c1, s1 )
                        
              call stdlib_drot( ihi-istartm+1, a( istartm, ihi ), 1, a( istartm,ihi-1 ), 1, c1, &
                        s1 )
              if ( ilz ) then
                 call stdlib_drot( nz, z( 1, ihi-zstart+1 ), 1, z( 1, ihi-1-zstart+1 ), 1, c1, s1 &
                           )
              end if
           else
              ! normal operation, move bulge down
              h = b( k+1:k+2, k:k+2 )
              ! make h upper triangular
              call stdlib_dlartg( h( 1, 1 ), h( 2, 1 ), c1, s1, temp )
              h( 2, 1 ) = zero
              h( 1, 1 ) = temp
              call stdlib_drot( 2, h( 1, 2 ), 2, h( 2, 2 ), 2, c1, s1 )
              ! calculate z1 and z2
              call stdlib_dlartg( h( 2, 3 ), h( 2, 2 ), c1, s1, temp )
              call stdlib_drot( 1, h( 1, 3 ), 1, h( 1, 2 ), 1, c1, s1 )
              call stdlib_dlartg( h( 1, 2 ), h( 1, 1 ), c2, s2, temp )
              ! apply transformations from the right
              call stdlib_drot( k+3-istartm+1, a( istartm, k+2 ), 1, a( istartm,k+1 ), 1, c1, s1 )
                        
              call stdlib_drot( k+3-istartm+1, a( istartm, k+1 ), 1, a( istartm,k ), 1, c2, s2 )
                        
              call stdlib_drot( k+2-istartm+1, b( istartm, k+2 ), 1, b( istartm,k+1 ), 1, c1, s1 )
                        
              call stdlib_drot( k+2-istartm+1, b( istartm, k+1 ), 1, b( istartm,k ), 1, c2, s2 )
                        
              if ( ilz ) then
                 call stdlib_drot( nz, z( 1, k+2-zstart+1 ), 1, z( 1, k+1-zstart+1 ), 1, c1, s1 )
                           
                 call stdlib_drot( nz, z( 1, k+1-zstart+1 ), 1, z( 1, k-zstart+1 ),1, c2, s2 )
                           
              end if
              b( k+1, k ) = zero
              b( k+2, k ) = zero
              ! calculate q1 and q2
              call stdlib_dlartg( a( k+2, k ), a( k+3, k ), c1, s1, temp )
              a( k+2, k ) = temp
              a( k+3, k ) = zero
              call stdlib_dlartg( a( k+1, k ), a( k+2, k ), c2, s2, temp )
              a( k+1, k ) = temp
              a( k+2, k ) = zero
              ! apply transformations from the left
              call stdlib_drot( istopm-k, a( k+2, k+1 ), lda, a( k+3, k+1 ), lda,c1, s1 )
              call stdlib_drot( istopm-k, a( k+1, k+1 ), lda, a( k+2, k+1 ), lda,c2, s2 )
              call stdlib_drot( istopm-k, b( k+2, k+1 ), ldb, b( k+3, k+1 ), ldb,c1, s1 )
              call stdlib_drot( istopm-k, b( k+1, k+1 ), ldb, b( k+2, k+1 ), ldb,c2, s2 )
              if ( ilq ) then
                 call stdlib_drot( nq, q( 1, k+2-qstart+1 ), 1, q( 1, k+3-qstart+1 ), 1, c1, s1 )
                           
                 call stdlib_drot( nq, q( 1, k+1-qstart+1 ), 1, q( 1, k+2-qstart+1 ), 1, c2, s2 )
                           
              end if
           end if
     end subroutine stdlib_dlaqz2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$laqz2( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, qstart, &
     !! DLAQZ2: chases a 2x2 shift bulge in a matrix pencil down a single position
               q, ldq, nz, zstart, z, ldz )
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           logical(lk), intent( in ) :: ilq, ilz
           integer(ilp), intent( in ) :: k, lda, ldb, ldq, ldz, istartm, istopm,nq, nz, qstart, &
                     zstart, ihi
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           ! ================================================================
           ! local variables
           real(${rk}$) :: h(2,3), c1, s1, c2, s2, temp
           if( k+2 == ihi ) then
              ! shift is located on the edge of the matrix, remove it
              h = b( ihi-1:ihi, ihi-2:ihi )
              ! make h upper triangular
              call stdlib_${ri}$lartg( h( 1, 1 ), h( 2, 1 ), c1, s1, temp )
              h( 2, 1 ) = zero
              h( 1, 1 ) = temp
              call stdlib_${ri}$rot( 2, h( 1, 2 ), 2, h( 2, 2 ), 2, c1, s1 )
              call stdlib_${ri}$lartg( h( 2, 3 ), h( 2, 2 ), c1, s1, temp )
              call stdlib_${ri}$rot( 1, h( 1, 3 ), 1, h( 1, 2 ), 1, c1, s1 )
              call stdlib_${ri}$lartg( h( 1, 2 ), h( 1, 1 ), c2, s2, temp )
              call stdlib_${ri}$rot( ihi-istartm+1, b( istartm, ihi ), 1, b( istartm,ihi-1 ), 1, c1, &
                        s1 )
              call stdlib_${ri}$rot( ihi-istartm+1, b( istartm, ihi-1 ), 1, b( istartm,ihi-2 ), 1, c2, &
                        s2 )
              b( ihi-1, ihi-2 ) = zero
              b( ihi, ihi-2 ) = zero
              call stdlib_${ri}$rot( ihi-istartm+1, a( istartm, ihi ), 1, a( istartm,ihi-1 ), 1, c1, &
                        s1 )
              call stdlib_${ri}$rot( ihi-istartm+1, a( istartm, ihi-1 ), 1, a( istartm,ihi-2 ), 1, c2, &
                        s2 )
              if ( ilz ) then
                 call stdlib_${ri}$rot( nz, z( 1, ihi-zstart+1 ), 1, z( 1, ihi-1-zstart+1 ), 1, c1, s1 &
                           )
                 call stdlib_${ri}$rot( nz, z( 1, ihi-1-zstart+1 ), 1, z( 1,ihi-2-zstart+1 ), 1, c2, &
                           s2 )
              end if
              call stdlib_${ri}$lartg( a( ihi-1, ihi-2 ), a( ihi, ihi-2 ), c1, s1,temp )
              a( ihi-1, ihi-2 ) = temp
              a( ihi, ihi-2 ) = zero
              call stdlib_${ri}$rot( istopm-ihi+2, a( ihi-1, ihi-1 ), lda, a( ihi,ihi-1 ), lda, c1, s1 &
                        )
              call stdlib_${ri}$rot( istopm-ihi+2, b( ihi-1, ihi-1 ), ldb, b( ihi,ihi-1 ), ldb, c1, s1 &
                        )
              if ( ilq ) then
                 call stdlib_${ri}$rot( nq, q( 1, ihi-1-qstart+1 ), 1, q( 1, ihi-qstart+1 ), 1, c1, s1 &
                           )
              end if
              call stdlib_${ri}$lartg( b( ihi, ihi ), b( ihi, ihi-1 ), c1, s1, temp )
              b( ihi, ihi ) = temp
              b( ihi, ihi-1 ) = zero
              call stdlib_${ri}$rot( ihi-istartm, b( istartm, ihi ), 1, b( istartm,ihi-1 ), 1, c1, s1 )
                        
              call stdlib_${ri}$rot( ihi-istartm+1, a( istartm, ihi ), 1, a( istartm,ihi-1 ), 1, c1, &
                        s1 )
              if ( ilz ) then
                 call stdlib_${ri}$rot( nz, z( 1, ihi-zstart+1 ), 1, z( 1, ihi-1-zstart+1 ), 1, c1, s1 &
                           )
              end if
           else
              ! normal operation, move bulge down
              h = b( k+1:k+2, k:k+2 )
              ! make h upper triangular
              call stdlib_${ri}$lartg( h( 1, 1 ), h( 2, 1 ), c1, s1, temp )
              h( 2, 1 ) = zero
              h( 1, 1 ) = temp
              call stdlib_${ri}$rot( 2, h( 1, 2 ), 2, h( 2, 2 ), 2, c1, s1 )
              ! calculate z1 and z2
              call stdlib_${ri}$lartg( h( 2, 3 ), h( 2, 2 ), c1, s1, temp )
              call stdlib_${ri}$rot( 1, h( 1, 3 ), 1, h( 1, 2 ), 1, c1, s1 )
              call stdlib_${ri}$lartg( h( 1, 2 ), h( 1, 1 ), c2, s2, temp )
              ! apply transformations from the right
              call stdlib_${ri}$rot( k+3-istartm+1, a( istartm, k+2 ), 1, a( istartm,k+1 ), 1, c1, s1 )
                        
              call stdlib_${ri}$rot( k+3-istartm+1, a( istartm, k+1 ), 1, a( istartm,k ), 1, c2, s2 )
                        
              call stdlib_${ri}$rot( k+2-istartm+1, b( istartm, k+2 ), 1, b( istartm,k+1 ), 1, c1, s1 )
                        
              call stdlib_${ri}$rot( k+2-istartm+1, b( istartm, k+1 ), 1, b( istartm,k ), 1, c2, s2 )
                        
              if ( ilz ) then
                 call stdlib_${ri}$rot( nz, z( 1, k+2-zstart+1 ), 1, z( 1, k+1-zstart+1 ), 1, c1, s1 )
                           
                 call stdlib_${ri}$rot( nz, z( 1, k+1-zstart+1 ), 1, z( 1, k-zstart+1 ),1, c2, s2 )
                           
              end if
              b( k+1, k ) = zero
              b( k+2, k ) = zero
              ! calculate q1 and q2
              call stdlib_${ri}$lartg( a( k+2, k ), a( k+3, k ), c1, s1, temp )
              a( k+2, k ) = temp
              a( k+3, k ) = zero
              call stdlib_${ri}$lartg( a( k+1, k ), a( k+2, k ), c2, s2, temp )
              a( k+1, k ) = temp
              a( k+2, k ) = zero
              ! apply transformations from the left
              call stdlib_${ri}$rot( istopm-k, a( k+2, k+1 ), lda, a( k+3, k+1 ), lda,c1, s1 )
              call stdlib_${ri}$rot( istopm-k, a( k+1, k+1 ), lda, a( k+2, k+1 ), lda,c2, s2 )
              call stdlib_${ri}$rot( istopm-k, b( k+2, k+1 ), ldb, b( k+3, k+1 ), ldb,c1, s1 )
              call stdlib_${ri}$rot( istopm-k, b( k+1, k+1 ), ldb, b( k+2, k+1 ), ldb,c2, s2 )
              if ( ilq ) then
                 call stdlib_${ri}$rot( nq, q( 1, k+2-qstart+1 ), 1, q( 1, k+3-qstart+1 ), 1, c1, s1 )
                           
                 call stdlib_${ri}$rot( nq, q( 1, k+1-qstart+1 ), 1, q( 1, k+2-qstart+1 ), 1, c2, s2 )
                           
              end if
           end if
     end subroutine stdlib_${ri}$laqz2

#:endif
#:endfor

     module recursive subroutine stdlib_claqz2( ilschur, ilq, ilz, n, ilo, ihi, nw,a, lda, b, ldb, q, &
     !! CLAQZ2 performs AED
               ldq, z, ldz, ns,nd, alpha, beta, qc, ldqc, zc, ldzc,work, lwork, rwork, rec, info )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(ilp), intent( in ) :: n, ilo, ihi, nw, lda, ldb, ldq, ldz,ldqc, ldzc, lwork, &
                     rec
           complex(sp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq, * ),z( ldz, * ), &
                     alpha( * ), beta( * )
           integer(ilp), intent( out ) :: ns, nd, info
           complex(sp), intent(inout) :: qc(ldqc,*), zc(ldzc,*)
           complex(sp), intent(out) :: work(*)
           real(sp), intent(out) :: rwork(*)
           
           ! ================================================================
           ! local scalars
           integer(ilp) :: jw, kwtop, kwbot, istopm, istartm, k, k2, ctgexc_info, ifst, ilst, &
                     lworkreq, qz_small_info
           real(sp) :: smlnum, ulp, safmin, safmax, c1, tempr
           complex(sp) :: s, s1, temp
           info = 0
           ! set up deflation window
           jw = min( nw, ihi-ilo+1 )
           kwtop = ihi-jw+1
           if ( kwtop == ilo ) then
              s = czero
           else
              s = a( kwtop, kwtop-1 )
           end if
           ! determine required workspace
           ifst = 1
           ilst = jw
           call stdlib_claqz0( 'S', 'V', 'V', jw, 1, jw, a( kwtop, kwtop ), lda,b( kwtop, kwtop ),&
                      ldb, alpha, beta, qc, ldqc, zc,ldzc, work, -1, rwork, rec+1, qz_small_info )
           lworkreq = int( work( 1 ),KIND=ilp)+2*jw**2
           lworkreq = max( lworkreq, n*nw, 2*nw**2+n )
           if ( lwork ==-1 ) then
              ! workspace query, quick return
              work( 1 ) = lworkreq
              return
           else if ( lwork < lworkreq ) then
              info = -26
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLAQZ2', -info )
              return
           end if
           ! get machine constants
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=sp)/ulp )
           if ( ihi == kwtop ) then
              ! 1 by 1 deflation window, just try a regular deflation
              alpha( kwtop ) = a( kwtop, kwtop )
              beta( kwtop ) = b( kwtop, kwtop )
              ns = 1
              nd = 0
              if ( abs( s ) <= max( smlnum, ulp*abs( a( kwtop,kwtop ) ) ) ) then
                 ns = 0
                 nd = 1
                 if ( kwtop > ilo ) then
                    a( kwtop, kwtop-1 ) = czero
                 end if
              end if
           end if
           ! store window in case of convergence failure
           call stdlib_clacpy( 'ALL', jw, jw, a( kwtop, kwtop ), lda, work, jw )
           call stdlib_clacpy( 'ALL', jw, jw, b( kwtop, kwtop ), ldb, work( jw**2+1 ), jw )
                     
           ! transform window to real schur form
           call stdlib_claset( 'FULL', jw, jw, czero, cone, qc, ldqc )
           call stdlib_claset( 'FULL', jw, jw, czero, cone, zc, ldzc )
           call stdlib_claqz0( 'S', 'V', 'V', jw, 1, jw, a( kwtop, kwtop ), lda,b( kwtop, kwtop ),&
            ldb, alpha, beta, qc, ldqc, zc,ldzc, work( 2*jw**2+1 ), lwork-2*jw**2, rwork,rec+1, &
                      qz_small_info )
           if( qz_small_info /= 0 ) then
              ! convergence failure, restore the window and exit
              nd = 0
              ns = jw-qz_small_info
              call stdlib_clacpy( 'ALL', jw, jw, work, jw, a( kwtop, kwtop ), lda )
              call stdlib_clacpy( 'ALL', jw, jw, work( jw**2+1 ), jw, b( kwtop,kwtop ), ldb )
                        
              return
           end if
           ! deflation detection loop
           if ( kwtop == ilo .or. s == czero ) then
              kwbot = kwtop-1
           else
              kwbot = ihi
              k = 1
              k2 = 1
              do while ( k <= jw )
                    ! try to deflate eigenvalue
                    tempr = abs( a( kwbot, kwbot ) )
                    if( tempr == zero ) then
                       tempr = abs( s )
                    end if
                    if ( ( abs( s*qc( 1, kwbot-kwtop+1 ) ) ) <= max( ulp*tempr, smlnum ) ) &
                              then
                       ! deflatable
                       kwbot = kwbot-1
                    else
                       ! not deflatable, move out of the way
                       ifst = kwbot-kwtop+1
                       ilst = k2
                       call stdlib_ctgexc( .true., .true., jw, a( kwtop, kwtop ),lda, b( kwtop, &
                                 kwtop ), ldb, qc, ldqc,zc, ldzc, ifst, ilst, ctgexc_info )
                       k2 = k2+1
                    end if
                    k = k+1
              end do
           end if
           ! store eigenvalues
           nd = ihi-kwbot
           ns = jw-nd
           k = kwtop
           do while ( k <= ihi )
              alpha( k ) = a( k, k )
              beta( k ) = b( k, k )
              k = k+1
           end do
           if ( kwtop /= ilo .and. s /= czero ) then
              ! reflect spike back, this will create optimally packed bulges
              a( kwtop:kwbot, kwtop-1 ) = a( kwtop, kwtop-1 ) *conjg( qc( 1,1:jw-nd ) )
              do k = kwbot-1, kwtop, -1
                 call stdlib_clartg( a( k, kwtop-1 ), a( k+1, kwtop-1 ), c1, s1,temp )
                 a( k, kwtop-1 ) = temp
                 a( k+1, kwtop-1 ) = czero
                 k2 = max( kwtop, k-1 )
                 call stdlib_crot( ihi-k2+1, a( k, k2 ), lda, a( k+1, k2 ), lda, c1,s1 )
                 call stdlib_crot( ihi-( k-1 )+1, b( k, k-1 ), ldb, b( k+1, k-1 ),ldb, c1, s1 )
                           
                 call stdlib_crot( jw, qc( 1, k-kwtop+1 ), 1, qc( 1, k+1-kwtop+1 ),1, c1, conjg( &
                           s1 ) )
              end do
              ! chase bulges down
              istartm = kwtop
              istopm = ihi
              k = kwbot-1
              do while ( k >= kwtop )
                 ! move bulge down and remove it
                 do k2 = k, kwbot-1
                    call stdlib_claqz1( .true., .true., k2, kwtop, kwtop+jw-1,kwbot, a, lda, b, &
                              ldb, jw, kwtop, qc, ldqc,jw, kwtop, zc, ldzc )
                 end do
                 k = k-1
              end do
           end if
           ! apply qc and zc to rest of the matrix
           if ( ilschur ) then
              istartm = 1
              istopm = n
           else
              istartm = ilo
              istopm = ihi
           end if
           if ( istopm-ihi > 0 ) then
              call stdlib_cgemm( 'C', 'N', jw, istopm-ihi, jw, cone, qc, ldqc,a( kwtop, ihi+1 ), &
                        lda, czero, work, jw )
              call stdlib_clacpy( 'ALL', jw, istopm-ihi, work, jw, a( kwtop,ihi+1 ), lda )
              call stdlib_cgemm( 'C', 'N', jw, istopm-ihi, jw, cone, qc, ldqc,b( kwtop, ihi+1 ), &
                        ldb, czero, work, jw )
              call stdlib_clacpy( 'ALL', jw, istopm-ihi, work, jw, b( kwtop,ihi+1 ), ldb )
           end if
           if ( ilq ) then
              call stdlib_cgemm( 'N', 'N', n, jw, jw, cone, q( 1, kwtop ), ldq, qc,ldqc, czero, &
                        work, n )
              call stdlib_clacpy( 'ALL', n, jw, work, n, q( 1, kwtop ), ldq )
           end if
           if ( kwtop-1-istartm+1 > 0 ) then
              call stdlib_cgemm( 'N', 'N', kwtop-istartm, jw, jw, cone, a( istartm,kwtop ), lda, &
                        zc, ldzc, czero, work,kwtop-istartm )
             call stdlib_clacpy( 'ALL', kwtop-istartm, jw, work, kwtop-istartm,a( istartm, kwtop )&
                       , lda )
              call stdlib_cgemm( 'N', 'N', kwtop-istartm, jw, jw, cone, b( istartm,kwtop ), ldb, &
                        zc, ldzc, czero, work,kwtop-istartm )
             call stdlib_clacpy( 'ALL', kwtop-istartm, jw, work, kwtop-istartm,b( istartm, kwtop )&
                       , ldb )
           end if
           if ( ilz ) then
              call stdlib_cgemm( 'N', 'N', n, jw, jw, cone, z( 1, kwtop ), ldz, zc,ldzc, czero, &
                        work, n )
              call stdlib_clacpy( 'ALL', n, jw, work, n, z( 1, kwtop ), ldz )
           end if
     end subroutine stdlib_claqz2

     module recursive subroutine stdlib_zlaqz2( ilschur, ilq, ilz, n, ilo, ihi, nw,a, lda, b, ldb, q, &
     !! ZLAQZ2 performs AED
               ldq, z, ldz, ns,nd, alpha, beta, qc, ldqc, zc, ldzc,work, lwork, rwork, rec, info )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(ilp), intent( in ) :: n, ilo, ihi, nw, lda, ldb, ldq, ldz,ldqc, ldzc, lwork, &
                     rec
           complex(dp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq,* ), z( ldz, * ), &
                     alpha( * ), beta( * )
           integer(ilp), intent( out ) :: ns, nd, info
           complex(dp), intent(inout) :: qc(ldqc,*), zc(ldzc,*)
           complex(dp), intent(out) :: work(*)
           real(dp), intent(out) :: rwork(*)
           
           ! ================================================================
           ! local scalars
           integer(ilp) :: jw, kwtop, kwbot, istopm, istartm, k, k2, ztgexc_info, ifst, ilst, &
                     lworkreq, qz_small_info
           real(dp) ::smlnum, ulp, safmin, safmax, c1, tempr
           complex(dp) :: s, s1, temp
           info = 0
           ! set up deflation window
           jw = min( nw, ihi-ilo+1 )
           kwtop = ihi-jw+1
           if ( kwtop == ilo ) then
              s = czero
           else
              s = a( kwtop, kwtop-1 )
           end if
           ! determine required workspace
           ifst = 1
           ilst = jw
           call stdlib_zlaqz0( 'S', 'V', 'V', jw, 1, jw, a( kwtop, kwtop ), lda,b( kwtop, kwtop ),&
                      ldb, alpha, beta, qc, ldqc, zc,ldzc, work, -1, rwork, rec+1, qz_small_info )
           lworkreq = int( work( 1 ),KIND=ilp)+2*jw**2
           lworkreq = max( lworkreq, n*nw, 2*nw**2+n )
           if ( lwork ==-1 ) then
              ! workspace query, quick return
              work( 1 ) = lworkreq
              return
           else if ( lwork < lworkreq ) then
              info = -26
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZLAQZ2', -info )
              return
           end if
           ! get machine constants
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_dlabad( safmin, safmax )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=dp)/ulp )
           if ( ihi == kwtop ) then
              ! 1 by 1 deflation window, just try a regular deflation
              alpha( kwtop ) = a( kwtop, kwtop )
              beta( kwtop ) = b( kwtop, kwtop )
              ns = 1
              nd = 0
              if ( abs( s ) <= max( smlnum, ulp*abs( a( kwtop,kwtop ) ) ) ) then
                 ns = 0
                 nd = 1
                 if ( kwtop > ilo ) then
                    a( kwtop, kwtop-1 ) = czero
                 end if
              end if
           end if
           ! store window in case of convergence failure
           call stdlib_zlacpy( 'ALL', jw, jw, a( kwtop, kwtop ), lda, work, jw )
           call stdlib_zlacpy( 'ALL', jw, jw, b( kwtop, kwtop ), ldb, work( jw**2+1 ), jw )
                     
           ! transform window to real schur form
           call stdlib_zlaset( 'FULL', jw, jw, czero, cone, qc, ldqc )
           call stdlib_zlaset( 'FULL', jw, jw, czero, cone, zc, ldzc )
           call stdlib_zlaqz0( 'S', 'V', 'V', jw, 1, jw, a( kwtop, kwtop ), lda,b( kwtop, kwtop ),&
            ldb, alpha, beta, qc, ldqc, zc,ldzc, work( 2*jw**2+1 ), lwork-2*jw**2, rwork,rec+1, &
                      qz_small_info )
           if( qz_small_info /= 0 ) then
              ! convergence failure, restore the window and exit
              nd = 0
              ns = jw-qz_small_info
              call stdlib_zlacpy( 'ALL', jw, jw, work, jw, a( kwtop, kwtop ), lda )
              call stdlib_zlacpy( 'ALL', jw, jw, work( jw**2+1 ), jw, b( kwtop,kwtop ), ldb )
                        
              return
           end if
           ! deflation detection loop
           if ( kwtop == ilo .or. s == czero ) then
              kwbot = kwtop-1
           else
              kwbot = ihi
              k = 1
              k2 = 1
              do while ( k <= jw )
                    ! try to deflate eigenvalue
                    tempr = abs( a( kwbot, kwbot ) )
                    if( tempr == zero ) then
                       tempr = abs( s )
                    end if
                    if ( ( abs( s*qc( 1, kwbot-kwtop+1 ) ) ) <= max( ulp*tempr, smlnum ) ) &
                              then
                       ! deflatable
                       kwbot = kwbot-1
                    else
                       ! not deflatable, move out of the way
                       ifst = kwbot-kwtop+1
                       ilst = k2
                       call stdlib_ztgexc( .true., .true., jw, a( kwtop, kwtop ),lda, b( kwtop, &
                                 kwtop ), ldb, qc, ldqc,zc, ldzc, ifst, ilst, ztgexc_info )
                       k2 = k2+1
                    end if
                    k = k+1
              end do
           end if
           ! store eigenvalues
           nd = ihi-kwbot
           ns = jw-nd
           k = kwtop
           do while ( k <= ihi )
              alpha( k ) = a( k, k )
              beta( k ) = b( k, k )
              k = k+1
           end do
           if ( kwtop /= ilo .and. s /= czero ) then
              ! reflect spike back, this will create optimally packed bulges
              a( kwtop:kwbot, kwtop-1 ) = a( kwtop, kwtop-1 ) *conjg( qc( 1,1:jw-nd ) )
              do k = kwbot-1, kwtop, -1
                 call stdlib_zlartg( a( k, kwtop-1 ), a( k+1, kwtop-1 ), c1, s1,temp )
                 a( k, kwtop-1 ) = temp
                 a( k+1, kwtop-1 ) = czero
                 k2 = max( kwtop, k-1 )
                 call stdlib_zrot( ihi-k2+1, a( k, k2 ), lda, a( k+1, k2 ), lda, c1,s1 )
                 call stdlib_zrot( ihi-( k-1 )+1, b( k, k-1 ), ldb, b( k+1, k-1 ),ldb, c1, s1 )
                           
                 call stdlib_zrot( jw, qc( 1, k-kwtop+1 ), 1, qc( 1, k+1-kwtop+1 ),1, c1, conjg( &
                           s1 ) )
              end do
              ! chase bulges down
              istartm = kwtop
              istopm = ihi
              k = kwbot-1
              do while ( k >= kwtop )
                 ! move bulge down and remove it
                 do k2 = k, kwbot-1
                    call stdlib_zlaqz1( .true., .true., k2, kwtop, kwtop+jw-1,kwbot, a, lda, b, &
                              ldb, jw, kwtop, qc, ldqc,jw, kwtop, zc, ldzc )
                 end do
                 k = k-1
              end do
           end if
           ! apply qc and zc to rest of the matrix
           if ( ilschur ) then
              istartm = 1
              istopm = n
           else
              istartm = ilo
              istopm = ihi
           end if
           if ( istopm-ihi > 0 ) then
              call stdlib_zgemm( 'C', 'N', jw, istopm-ihi, jw, cone, qc, ldqc,a( kwtop, ihi+1 ), &
                        lda, czero, work, jw )
              call stdlib_zlacpy( 'ALL', jw, istopm-ihi, work, jw, a( kwtop,ihi+1 ), lda )
              call stdlib_zgemm( 'C', 'N', jw, istopm-ihi, jw, cone, qc, ldqc,b( kwtop, ihi+1 ), &
                        ldb, czero, work, jw )
              call stdlib_zlacpy( 'ALL', jw, istopm-ihi, work, jw, b( kwtop,ihi+1 ), ldb )
           end if
           if ( ilq ) then
              call stdlib_zgemm( 'N', 'N', n, jw, jw, cone, q( 1, kwtop ), ldq, qc,ldqc, czero, &
                        work, n )
              call stdlib_zlacpy( 'ALL', n, jw, work, n, q( 1, kwtop ), ldq )
           end if
           if ( kwtop-1-istartm+1 > 0 ) then
              call stdlib_zgemm( 'N', 'N', kwtop-istartm, jw, jw, cone, a( istartm,kwtop ), lda, &
                        zc, ldzc, czero, work,kwtop-istartm )
             call stdlib_zlacpy( 'ALL', kwtop-istartm, jw, work, kwtop-istartm,a( istartm, kwtop )&
                       , lda )
              call stdlib_zgemm( 'N', 'N', kwtop-istartm, jw, jw, cone, b( istartm,kwtop ), ldb, &
                        zc, ldzc, czero, work,kwtop-istartm )
             call stdlib_zlacpy( 'ALL', kwtop-istartm, jw, work, kwtop-istartm,b( istartm, kwtop )&
                       , ldb )
           end if
           if ( ilz ) then
              call stdlib_zgemm( 'N', 'N', n, jw, jw, cone, z( 1, kwtop ), ldz, zc,ldzc, czero, &
                        work, n )
              call stdlib_zlacpy( 'ALL', n, jw, work, n, z( 1, kwtop ), ldz )
           end if
     end subroutine stdlib_zlaqz2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module recursive subroutine stdlib_${ci}$laqz2( ilschur, ilq, ilz, n, ilo, ihi, nw,a, lda, b, ldb, q, &
     !! ZLAQZ2: performs AED
               ldq, z, ldz, ns,nd, alpha, beta, qc, ldqc, zc, ldzc,work, lwork, rwork, rec, info )
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(ilp), intent( in ) :: n, ilo, ihi, nw, lda, ldb, ldq, ldz,ldqc, ldzc, lwork, &
                     rec
           complex(${ck}$), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq,* ), z( ldz, * ), &
                     alpha( * ), beta( * )
           integer(ilp), intent( out ) :: ns, nd, info
           complex(${ck}$), intent(inout) :: qc(ldqc,*), zc(ldzc,*)
           complex(${ck}$), intent(out) :: work(*)
           real(${ck}$), intent(out) :: rwork(*)
           
           ! ================================================================
           ! local scalars
           integer(ilp) :: jw, kwtop, kwbot, istopm, istartm, k, k2, ztgexc_info, ifst, ilst, &
                     lworkreq, qz_small_info
           real(${ck}$) ::smlnum, ulp, safmin, safmax, c1, tempr
           complex(${ck}$) :: s, s1, temp
           info = 0
           ! set up deflation window
           jw = min( nw, ihi-ilo+1 )
           kwtop = ihi-jw+1
           if ( kwtop == ilo ) then
              s = czero
           else
              s = a( kwtop, kwtop-1 )
           end if
           ! determine required workspace
           ifst = 1
           ilst = jw
           call stdlib_${ci}$laqz0( 'S', 'V', 'V', jw, 1, jw, a( kwtop, kwtop ), lda,b( kwtop, kwtop ),&
                      ldb, alpha, beta, qc, ldqc, zc,ldzc, work, -1, rwork, rec+1, qz_small_info )
           lworkreq = int( work( 1 ),KIND=ilp)+2*jw**2
           lworkreq = max( lworkreq, n*nw, 2*nw**2+n )
           if ( lwork ==-1 ) then
              ! workspace query, quick return
              work( 1 ) = lworkreq
              return
           else if ( lwork < lworkreq ) then
              info = -26
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZLAQZ2', -info )
              return
           end if
           ! get machine constants
           safmin = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_${c2ri(ci)}$labad( safmin, safmax )
           ulp = stdlib_${c2ri(ci)}$lamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=${ck}$)/ulp )
           if ( ihi == kwtop ) then
              ! 1 by 1 deflation window, just try a regular deflation
              alpha( kwtop ) = a( kwtop, kwtop )
              beta( kwtop ) = b( kwtop, kwtop )
              ns = 1
              nd = 0
              if ( abs( s ) <= max( smlnum, ulp*abs( a( kwtop,kwtop ) ) ) ) then
                 ns = 0
                 nd = 1
                 if ( kwtop > ilo ) then
                    a( kwtop, kwtop-1 ) = czero
                 end if
              end if
           end if
           ! store window in case of convergence failure
           call stdlib_${ci}$lacpy( 'ALL', jw, jw, a( kwtop, kwtop ), lda, work, jw )
           call stdlib_${ci}$lacpy( 'ALL', jw, jw, b( kwtop, kwtop ), ldb, work( jw**2+1 ), jw )
                     
           ! transform window to real schur form
           call stdlib_${ci}$laset( 'FULL', jw, jw, czero, cone, qc, ldqc )
           call stdlib_${ci}$laset( 'FULL', jw, jw, czero, cone, zc, ldzc )
           call stdlib_${ci}$laqz0( 'S', 'V', 'V', jw, 1, jw, a( kwtop, kwtop ), lda,b( kwtop, kwtop ),&
            ldb, alpha, beta, qc, ldqc, zc,ldzc, work( 2*jw**2+1 ), lwork-2*jw**2, rwork,rec+1, &
                      qz_small_info )
           if( qz_small_info /= 0 ) then
              ! convergence failure, restore the window and exit
              nd = 0
              ns = jw-qz_small_info
              call stdlib_${ci}$lacpy( 'ALL', jw, jw, work, jw, a( kwtop, kwtop ), lda )
              call stdlib_${ci}$lacpy( 'ALL', jw, jw, work( jw**2+1 ), jw, b( kwtop,kwtop ), ldb )
                        
              return
           end if
           ! deflation detection loop
           if ( kwtop == ilo .or. s == czero ) then
              kwbot = kwtop-1
           else
              kwbot = ihi
              k = 1
              k2 = 1
              do while ( k <= jw )
                    ! try to deflate eigenvalue
                    tempr = abs( a( kwbot, kwbot ) )
                    if( tempr == zero ) then
                       tempr = abs( s )
                    end if
                    if ( ( abs( s*qc( 1, kwbot-kwtop+1 ) ) ) <= max( ulp*tempr, smlnum ) ) &
                              then
                       ! deflatable
                       kwbot = kwbot-1
                    else
                       ! not deflatable, move out of the way
                       ifst = kwbot-kwtop+1
                       ilst = k2
                       call stdlib_${ci}$tgexc( .true., .true., jw, a( kwtop, kwtop ),lda, b( kwtop, &
                                 kwtop ), ldb, qc, ldqc,zc, ldzc, ifst, ilst, ztgexc_info )
                       k2 = k2+1
                    end if
                    k = k+1
              end do
           end if
           ! store eigenvalues
           nd = ihi-kwbot
           ns = jw-nd
           k = kwtop
           do while ( k <= ihi )
              alpha( k ) = a( k, k )
              beta( k ) = b( k, k )
              k = k+1
           end do
           if ( kwtop /= ilo .and. s /= czero ) then
              ! reflect spike back, this will create optimally packed bulges
              a( kwtop:kwbot, kwtop-1 ) = a( kwtop, kwtop-1 ) *conjg( qc( 1,1:jw-nd ) )
              do k = kwbot-1, kwtop, -1
                 call stdlib_${ci}$lartg( a( k, kwtop-1 ), a( k+1, kwtop-1 ), c1, s1,temp )
                 a( k, kwtop-1 ) = temp
                 a( k+1, kwtop-1 ) = czero
                 k2 = max( kwtop, k-1 )
                 call stdlib_${ci}$rot( ihi-k2+1, a( k, k2 ), lda, a( k+1, k2 ), lda, c1,s1 )
                 call stdlib_${ci}$rot( ihi-( k-1 )+1, b( k, k-1 ), ldb, b( k+1, k-1 ),ldb, c1, s1 )
                           
                 call stdlib_${ci}$rot( jw, qc( 1, k-kwtop+1 ), 1, qc( 1, k+1-kwtop+1 ),1, c1, conjg( &
                           s1 ) )
              end do
              ! chase bulges down
              istartm = kwtop
              istopm = ihi
              k = kwbot-1
              do while ( k >= kwtop )
                 ! move bulge down and remove it
                 do k2 = k, kwbot-1
                    call stdlib_${ci}$laqz1( .true., .true., k2, kwtop, kwtop+jw-1,kwbot, a, lda, b, &
                              ldb, jw, kwtop, qc, ldqc,jw, kwtop, zc, ldzc )
                 end do
                 k = k-1
              end do
           end if
           ! apply qc and zc to rest of the matrix
           if ( ilschur ) then
              istartm = 1
              istopm = n
           else
              istartm = ilo
              istopm = ihi
           end if
           if ( istopm-ihi > 0 ) then
              call stdlib_${ci}$gemm( 'C', 'N', jw, istopm-ihi, jw, cone, qc, ldqc,a( kwtop, ihi+1 ), &
                        lda, czero, work, jw )
              call stdlib_${ci}$lacpy( 'ALL', jw, istopm-ihi, work, jw, a( kwtop,ihi+1 ), lda )
              call stdlib_${ci}$gemm( 'C', 'N', jw, istopm-ihi, jw, cone, qc, ldqc,b( kwtop, ihi+1 ), &
                        ldb, czero, work, jw )
              call stdlib_${ci}$lacpy( 'ALL', jw, istopm-ihi, work, jw, b( kwtop,ihi+1 ), ldb )
           end if
           if ( ilq ) then
              call stdlib_${ci}$gemm( 'N', 'N', n, jw, jw, cone, q( 1, kwtop ), ldq, qc,ldqc, czero, &
                        work, n )
              call stdlib_${ci}$lacpy( 'ALL', n, jw, work, n, q( 1, kwtop ), ldq )
           end if
           if ( kwtop-1-istartm+1 > 0 ) then
              call stdlib_${ci}$gemm( 'N', 'N', kwtop-istartm, jw, jw, cone, a( istartm,kwtop ), lda, &
                        zc, ldzc, czero, work,kwtop-istartm )
             call stdlib_${ci}$lacpy( 'ALL', kwtop-istartm, jw, work, kwtop-istartm,a( istartm, kwtop )&
                       , lda )
              call stdlib_${ci}$gemm( 'N', 'N', kwtop-istartm, jw, jw, cone, b( istartm,kwtop ), ldb, &
                        zc, ldzc, czero, work,kwtop-istartm )
             call stdlib_${ci}$lacpy( 'ALL', kwtop-istartm, jw, work, kwtop-istartm,b( istartm, kwtop )&
                       , ldb )
           end if
           if ( ilz ) then
              call stdlib_${ci}$gemm( 'N', 'N', n, jw, jw, cone, z( 1, kwtop ), ldz, zc,ldzc, czero, &
                        work, n )
              call stdlib_${ci}$lacpy( 'ALL', n, jw, work, n, z( 1, kwtop ), ldz )
           end if
     end subroutine stdlib_${ci}$laqz2

#:endif
#:endfor



     module subroutine stdlib_shgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alphar, alphai, &
     !! SHGEQZ computes the eigenvalues of a real matrix pair (H,T),
     !! where H is an upper Hessenberg matrix and T is upper triangular,
     !! using the double-shift QZ method.
     !! Matrix pairs of this type are produced by the reduction to
     !! generalized upper Hessenberg form of a real matrix pair (A,B):
     !! A = Q1*H*Z1**T,  B = Q1*T*Z1**T,
     !! as computed by SGGHRD.
     !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
     !! also reduced to generalized Schur form,
     !! H = Q*S*Z**T,  T = Q*P*Z**T,
     !! where Q and Z are orthogonal matrices, P is an upper triangular
     !! matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2
     !! diagonal blocks.
     !! The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
     !! (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of
     !! eigenvalues.
     !! Additionally, the 2-by-2 upper triangular diagonal blocks of P
     !! corresponding to 2-by-2 blocks of S are reduced to positive diagonal
     !! form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,
     !! P(j,j) > 0, and P(j+1,j+1) > 0.
     !! Optionally, the orthogonal matrix Q from the generalized Schur
     !! factorization may be postmultiplied into an input matrix Q1, and the
     !! orthogonal matrix Z may be postmultiplied into an input matrix Z1.
     !! If Q1 and Z1 are the orthogonal matrices from SGGHRD that reduced
     !! the matrix pair (A,B) to generalized upper Hessenberg form, then the
     !! output matrices Q1*Q and Z1*Z are the orthogonal factors from the
     !! generalized Schur factorization of (A,B):
     !! A = (Q1*Q)*S*(Z1*Z)**T,  B = (Q1*Q)*P*(Z1*Z)**T.
     !! To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
     !! of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
     !! complex and beta real.
     !! If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
     !! generalized nonsymmetric eigenvalue problem (GNEP)
     !! A*x = lambda*B*x
     !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     !! alternate form of the GNEP
     !! mu*A*y = B*y.
     !! Real eigenvalues can be read directly from the generalized Schur
     !! form:
     !! alpha = S(i,i), beta = P(i,i).
     !! Ref: C.B. Moler
     !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
     !! pp. 241--256.
               beta, q, ldq, z, ldz, work,lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz, job
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldq, ldt, ldz, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(out) :: alphai(*), alphar(*), beta(*), work(*)
           real(sp), intent(inout) :: h(ldh,*), q(ldq,*), t(ldt,*), z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: safety = 1.0e+2_sp
          ! $                     safety = one )
           
           ! Local Scalars 
           logical(lk) :: ilazr2, ilazro, ilpivt, ilq, ilschr, ilz, lquery
           integer(ilp) :: icompq, icompz, ifirst, ifrstm, iiter, ilast, ilastm, in, ischur, &
                     istart, j, jc, jch, jiter, jr, maxit
           real(sp) :: a11, a12, a1i, a1r, a21, a22, a2i, a2r, ad11, ad11l, ad12, ad12l, ad21, &
           ad21l, ad22, ad22l, ad32l, an, anorm, ascale, atol, b11, b1a, b1i, b1r, b22, b2a, b2i, &
           b2r, bn, bnorm, bscale, btol, c, c11i, c11r, c12, c21, c22i, c22r, cl, cq, cr, cz, &
           eshift, s, s1, s1inv, s2, safmax, safmin, scale, sl, sqi, sqr, sr, szi, szr, t1, tau, &
           temp, temp2, tempi, tempr, u1, u12, u12l, u2, ulp, vs, w11, w12, w21, w22, wabs, wi, &
                     wr, wr2
           ! Local Arrays 
           real(sp) :: v(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode job, compq, compz
           if( stdlib_lsame( job, 'E' ) ) then
              ilschr = .false.
              ischur = 1
           else if( stdlib_lsame( job, 'S' ) ) then
              ilschr = .true.
              ischur = 2
           else
              ischur = 0
           end if
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              icompq = 0
           end if
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              icompz = 0
           end if
           ! check argument values
           info = 0
           work( 1 ) = max( 1, n )
           lquery = ( lwork==-1 )
           if( ischur==0 ) then
              info = -1
           else if( icompq==0 ) then
              info = -2
           else if( icompz==0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 ) then
              info = -5
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -6
           else if( ldh<n ) then
              info = -8
           else if( ldt<n ) then
              info = -10
           else if( ldq<1 .or. ( ilq .and. ldq<n ) ) then
              info = -15
           else if( ldz<1 .or. ( ilz .and. ldz<n ) ) then
              info = -17
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -19
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SHGEQZ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n<=0 ) then
              work( 1 ) = real( 1,KIND=sp)
              return
           end if
           ! initialize q and z
           if( icompq==3 )call stdlib_slaset( 'FULL', n, n, zero, one, q, ldq )
           if( icompz==3 )call stdlib_slaset( 'FULL', n, n, zero, one, z, ldz )
           ! machine constants
           in = ihi + 1 - ilo
           safmin = stdlib_slamch( 'S' )
           safmax = one / safmin
           ulp = stdlib_slamch( 'E' )*stdlib_slamch( 'B' )
           anorm = stdlib_slanhs( 'F', in, h( ilo, ilo ), ldh, work )
           bnorm = stdlib_slanhs( 'F', in, t( ilo, ilo ), ldt, work )
           atol = max( safmin, ulp*anorm )
           btol = max( safmin, ulp*bnorm )
           ascale = one / max( safmin, anorm )
           bscale = one / max( safmin, bnorm )
           ! set eigenvalues ihi+1:n
           do j = ihi + 1, n
              if( t( j, j )<zero ) then
                 if( ilschr ) then
                    do jr = 1, j
                       h( jr, j ) = -h( jr, j )
                       t( jr, j ) = -t( jr, j )
                    end do
                 else
                    h( j, j ) = -h( j, j )
                    t( j, j ) = -t( j, j )
                 end if
                 if( ilz ) then
                    do jr = 1, n
                       z( jr, j ) = -z( jr, j )
                    end do
                 end if
              end if
              alphar( j ) = h( j, j )
              alphai( j ) = zero
              beta( j ) = t( j, j )
           end do
           ! if ihi < ilo, skip qz steps
           if( ihi<ilo )go to 380
           ! main qz iteration loop
           ! initialize dynamic indices
           ! eigenvalues ilast+1:n have been found.
              ! column operations modify rows ifrstm:whatever.
              ! row operations modify columns whatever:ilastm.
           ! if only eigenvalues are being computed, then
              ! ifrstm is the row of the last splitting row above row ilast;
              ! this is always at least ilo.
           ! iiter counts iterations since the last eigenvalue was found,
              ! to tell when to use an extraordinary shift.
           ! maxit is the maximum number of qz sweeps allowed.
           ilast = ihi
           if( ilschr ) then
              ifrstm = 1
              ilastm = n
           else
              ifrstm = ilo
              ilastm = ihi
           end if
           iiter = 0
           eshift = zero
           maxit = 30*( ihi-ilo+1 )
           loop_360: do jiter = 1, maxit
              ! split the matrix if possible.
              ! two tests:
                 ! 1: h(j,j-1)=0  or  j=ilo
                 ! 2: t(j,j)=0
              if( ilast==ilo ) then
                 ! special case: j=ilast
                 go to 80
              else
                 if( abs( h( ilast, ilast-1 ) )<=max( safmin, ulp*(abs( h( ilast, ilast ) ) + abs(&
                            h( ilast-1, ilast-1 ) )) ) ) then
                    h( ilast, ilast-1 ) = zero
                    go to 80
                 end if
              end if
              if( abs( t( ilast, ilast ) )<=max( safmin, ulp*(abs( t( ilast - 1, ilast ) ) + abs( &
                        t( ilast-1, ilast-1 )) ) ) ) then
                 t( ilast, ilast ) = zero
                 go to 70
              end if
              ! general case: j<ilast
              loop_60: do j = ilast - 1, ilo, -1
                 ! test 1: for h(j,j-1)=0 or j=ilo
                 if( j==ilo ) then
                    ilazro = .true.
                 else
                    if( abs( h( j, j-1 ) )<=max( safmin, ulp*(abs( h( j, j ) ) + abs( h( j-1, j-1 &
                              ) )) ) ) then
                       h( j, j-1 ) = zero
                       ilazro = .true.
                    else
                       ilazro = .false.
                    end if
                 end if
                 ! test 2: for t(j,j)=0
                 temp = abs ( t( j, j + 1 ) )
                 if ( j > ilo )temp = temp + abs ( t( j - 1, j ) )
                 if( abs( t( j, j ) )<max( safmin,ulp*temp ) ) then
                    t( j, j ) = zero
                    ! test 1a: check for 2 consecutive small subdiagonals in a
                    ilazr2 = .false.
                    if( .not.ilazro ) then
                       temp = abs( h( j, j-1 ) )
                       temp2 = abs( h( j, j ) )
                       tempr = max( temp, temp2 )
                       if( tempr<one .and. tempr/=zero ) then
                          temp = temp / tempr
                          temp2 = temp2 / tempr
                       end if
                       if( temp*( ascale*abs( h( j+1, j ) ) )<=temp2*( ascale*atol ) )ilazr2 = &
                                 .true.
                    end if
                    ! if both tests pass (1
                    ! element of b in the block is zero, split a 1x1 block off
                    ! at the top. (i.e., at the j-th row/column) the leading
                    ! diagonal element of the remainder can also be zero, so
                    ! this may have to be done repeatedly.
                    if( ilazro .or. ilazr2 ) then
                       do jch = j, ilast - 1
                          temp = h( jch, jch )
                          call stdlib_slartg( temp, h( jch+1, jch ), c, s,h( jch, jch ) )
                          h( jch+1, jch ) = zero
                          call stdlib_srot( ilastm-jch, h( jch, jch+1 ), ldh,h( jch+1, jch+1 ), &
                                    ldh, c, s )
                          call stdlib_srot( ilastm-jch, t( jch, jch+1 ), ldt,t( jch+1, jch+1 ), &
                                    ldt, c, s )
                          if( ilq )call stdlib_srot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, s )
                                    
                          if( ilazr2 )h( jch, jch-1 ) = h( jch, jch-1 )*c
                          ilazr2 = .false.
                          if( abs( t( jch+1, jch+1 ) )>=btol ) then
                             if( jch+1>=ilast ) then
                                go to 80
                             else
                                ifirst = jch + 1
                                go to 110
                             end if
                          end if
                          t( jch+1, jch+1 ) = zero
                       end do
                       go to 70
                    else
                       ! only test 2 passed -- chase the zero to t(ilast,ilast)
                       ! then process as in the case t(ilast,ilast)=0
                       do jch = j, ilast - 1
                          temp = t( jch, jch+1 )
                          call stdlib_slartg( temp, t( jch+1, jch+1 ), c, s,t( jch, jch+1 ) )
                                    
                          t( jch+1, jch+1 ) = zero
                          if( jch<ilastm-1 )call stdlib_srot( ilastm-jch-1, t( jch, jch+2 ), ldt,&
                                    t( jch+1, jch+2 ), ldt, c, s )
                          call stdlib_srot( ilastm-jch+2, h( jch, jch-1 ), ldh,h( jch+1, jch-1 ), &
                                    ldh, c, s )
                          if( ilq )call stdlib_srot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, s )
                                    
                          temp = h( jch+1, jch )
                          call stdlib_slartg( temp, h( jch+1, jch-1 ), c, s,h( jch+1, jch ) )
                                    
                          h( jch+1, jch-1 ) = zero
                          call stdlib_srot( jch+1-ifrstm, h( ifrstm, jch ), 1,h( ifrstm, jch-1 ), &
                                    1, c, s )
                          call stdlib_srot( jch-ifrstm, t( ifrstm, jch ), 1,t( ifrstm, jch-1 ), 1,&
                                     c, s )
                          if( ilz )call stdlib_srot( n, z( 1, jch ), 1, z( 1, jch-1 ), 1,c, s )
                                    
                       end do
                       go to 70
                    end if
                 else if( ilazro ) then
                    ! only test 1 passed -- work on j:ilast
                    ifirst = j
                    go to 110
                 end if
                 ! neither test passed -- try next j
              end do loop_60
              ! (drop-through is "impossible")
              info = n + 1
              go to 420
              ! t(ilast,ilast)=0 -- clear h(ilast,ilast-1) to split off a
              ! 1x1 block.
              70 continue
              temp = h( ilast, ilast )
              call stdlib_slartg( temp, h( ilast, ilast-1 ), c, s,h( ilast, ilast ) )
              h( ilast, ilast-1 ) = zero
              call stdlib_srot( ilast-ifrstm, h( ifrstm, ilast ), 1,h( ifrstm, ilast-1 ), 1, c, s &
                        )
              call stdlib_srot( ilast-ifrstm, t( ifrstm, ilast ), 1,t( ifrstm, ilast-1 ), 1, c, s &
                        )
              if( ilz )call stdlib_srot( n, z( 1, ilast ), 1, z( 1, ilast-1 ), 1, c, s )
              ! h(ilast,ilast-1)=0 -- standardize b, set alphar, alphai,
                                    ! and beta
                                    80 continue
              if( t( ilast, ilast )<zero ) then
                 if( ilschr ) then
                    do j = ifrstm, ilast
                       h( j, ilast ) = -h( j, ilast )
                       t( j, ilast ) = -t( j, ilast )
                    end do
                 else
                    h( ilast, ilast ) = -h( ilast, ilast )
                    t( ilast, ilast ) = -t( ilast, ilast )
                 end if
                 if( ilz ) then
                    do j = 1, n
                       z( j, ilast ) = -z( j, ilast )
                    end do
                 end if
              end if
              alphar( ilast ) = h( ilast, ilast )
              alphai( ilast ) = zero
              beta( ilast ) = t( ilast, ilast )
              ! go to next block -- exit if finished.
              ilast = ilast - 1
              if( ilast<ilo )go to 380
              ! reset counters
              iiter = 0
              eshift = zero
              if( .not.ilschr ) then
                 ilastm = ilast
                 if( ifrstm>ilast )ifrstm = ilo
              end if
              go to 350
              ! qz step
              ! this iteration only involves rows/columns ifirst:ilast. we
              ! assume ifirst < ilast, and that the diagonal of b is non-zero.
              110 continue
              iiter = iiter + 1
              if( .not.ilschr ) then
                 ifrstm = ifirst
              end if
              ! compute single shifts.
              ! at this point, ifirst < ilast, and the diagonal elements of
              ! t(ifirst:ilast,ifirst,ilast) are larger than btol (in
              ! magnitude)
              if( ( iiter / 10 )*10==iiter ) then
                 ! exceptional shift.  chosen for no particularly good reason.
                 ! (single shift only.)
                 if( ( real( maxit,KIND=sp)*safmin )*abs( h( ilast, ilast-1 ) )<abs( t( ilast-1, &
                           ilast-1 ) ) ) then
                    eshift = h( ilast, ilast-1 ) /t( ilast-1, ilast-1 )
                 else
                    eshift = eshift + one / ( safmin*real( maxit,KIND=sp) )
                 end if
                 s1 = one
                 wr = eshift
              else
                 ! shifts based on the generalized eigenvalues of the
                 ! bottom-right 2x2 block of a and b. the first eigenvalue
                 ! returned by stdlib_slag2 is the wilkinson shift (aep p.512_sp),
                 call stdlib_slag2( h( ilast-1, ilast-1 ), ldh,t( ilast-1, ilast-1 ), ldt, &
                           safmin*safety, s1,s2, wr, wr2, wi )
                 if ( abs( (wr/s1)*t( ilast, ilast ) - h( ilast, ilast ) )> abs( (wr2/s2)*t( &
                           ilast, ilast )- h( ilast, ilast ) ) ) then
                    temp = wr
                    wr = wr2
                    wr2 = temp
                    temp = s1
                    s1 = s2
                    s2 = temp
                 end if
                 temp = max( s1, safmin*max( one, abs( wr ), abs( wi ) ) )
                 if( wi/=zero )go to 200
              end if
              ! fiddle with shift to avoid overflow
              temp = min( ascale, one )*( half*safmax )
              if( s1>temp ) then
                 scale = temp / s1
              else
                 scale = one
              end if
              temp = min( bscale, one )*( half*safmax )
              if( abs( wr )>temp )scale = min( scale, temp / abs( wr ) )
              s1 = scale*s1
              wr = scale*wr
              ! now check for two consecutive small subdiagonals.
              do j = ilast - 1, ifirst + 1, -1
                 istart = j
                 temp = abs( s1*h( j, j-1 ) )
                 temp2 = abs( s1*h( j, j )-wr*t( j, j ) )
                 tempr = max( temp, temp2 )
                 if( tempr<one .and. tempr/=zero ) then
                    temp = temp / tempr
                    temp2 = temp2 / tempr
                 end if
                 if( abs( ( ascale*h( j+1, j ) )*temp )<=( ascale*atol )*temp2 )go to 130
              end do
              istart = ifirst
              130 continue
              ! do an implicit single-shift qz sweep.
              ! initial q
              temp = s1*h( istart, istart ) - wr*t( istart, istart )
              temp2 = s1*h( istart+1, istart )
              call stdlib_slartg( temp, temp2, c, s, tempr )
              ! sweep
              loop_190: do j = istart, ilast - 1
                 if( j>istart ) then
                    temp = h( j, j-1 )
                    call stdlib_slartg( temp, h( j+1, j-1 ), c, s, h( j, j-1 ) )
                    h( j+1, j-1 ) = zero
                 end if
                 do jc = j, ilastm
                    temp = c*h( j, jc ) + s*h( j+1, jc )
                    h( j+1, jc ) = -s*h( j, jc ) + c*h( j+1, jc )
                    h( j, jc ) = temp
                    temp2 = c*t( j, jc ) + s*t( j+1, jc )
                    t( j+1, jc ) = -s*t( j, jc ) + c*t( j+1, jc )
                    t( j, jc ) = temp2
                 end do
                 if( ilq ) then
                    do jr = 1, n
                       temp = c*q( jr, j ) + s*q( jr, j+1 )
                       q( jr, j+1 ) = -s*q( jr, j ) + c*q( jr, j+1 )
                       q( jr, j ) = temp
                    end do
                 end if
                 temp = t( j+1, j+1 )
                 call stdlib_slartg( temp, t( j+1, j ), c, s, t( j+1, j+1 ) )
                 t( j+1, j ) = zero
                 do jr = ifrstm, min( j+2, ilast )
                    temp = c*h( jr, j+1 ) + s*h( jr, j )
                    h( jr, j ) = -s*h( jr, j+1 ) + c*h( jr, j )
                    h( jr, j+1 ) = temp
                 end do
                 do jr = ifrstm, j
                    temp = c*t( jr, j+1 ) + s*t( jr, j )
                    t( jr, j ) = -s*t( jr, j+1 ) + c*t( jr, j )
                    t( jr, j+1 ) = temp
                 end do
                 if( ilz ) then
                    do jr = 1, n
                       temp = c*z( jr, j+1 ) + s*z( jr, j )
                       z( jr, j ) = -s*z( jr, j+1 ) + c*z( jr, j )
                       z( jr, j+1 ) = temp
                    end do
                 end if
              end do loop_190
              go to 350
              ! use francis double-shift
              ! note: the francis double-shift should work with real shifts,
                    ! but only if the block is at least 3x3.
                    ! this code may break if this point is reached with
                    ! a 2x2 block with real eigenvalues.
                    200 continue
              if( ifirst+1==ilast ) then
                 ! special case -- 2x2 block with complex eigenvectors
                 ! step 1: standardize, that is, rotate so that
                             ! ( b11  0  )
                         ! b = (         )  with b11 non-negative.
                             ! (  0  b22 )
                 call stdlib_slasv2( t( ilast-1, ilast-1 ), t( ilast-1, ilast ),t( ilast, ilast ),&
                            b22, b11, sr, cr, sl, cl )
                 if( b11<zero ) then
                    cr = -cr
                    sr = -sr
                    b11 = -b11
                    b22 = -b22
                 end if
                 call stdlib_srot( ilastm+1-ifirst, h( ilast-1, ilast-1 ), ldh,h( ilast, ilast-1 )&
                           , ldh, cl, sl )
                 call stdlib_srot( ilast+1-ifrstm, h( ifrstm, ilast-1 ), 1,h( ifrstm, ilast ), 1, &
                           cr, sr )
                 if( ilast<ilastm )call stdlib_srot( ilastm-ilast, t( ilast-1, ilast+1 ), ldt,t( &
                           ilast, ilast+1 ), ldt, cl, sl )
                 if( ifrstm<ilast-1 )call stdlib_srot( ifirst-ifrstm, t( ifrstm, ilast-1 ), 1,t( &
                           ifrstm, ilast ), 1, cr, sr )
                 if( ilq )call stdlib_srot( n, q( 1, ilast-1 ), 1, q( 1, ilast ), 1, cl,sl )
                           
                 if( ilz )call stdlib_srot( n, z( 1, ilast-1 ), 1, z( 1, ilast ), 1, cr,sr )
                           
                 t( ilast-1, ilast-1 ) = b11
                 t( ilast-1, ilast ) = zero
                 t( ilast, ilast-1 ) = zero
                 t( ilast, ilast ) = b22
                 ! if b22 is negative, negate column ilast
                 if( b22<zero ) then
                    do j = ifrstm, ilast
                       h( j, ilast ) = -h( j, ilast )
                       t( j, ilast ) = -t( j, ilast )
                    end do
                    if( ilz ) then
                       do j = 1, n
                          z( j, ilast ) = -z( j, ilast )
                       end do
                    end if
                    b22 = -b22
                 end if
                 ! step 2: compute alphar, alphai, and beta (see refs.)
                 ! recompute shift
                 call stdlib_slag2( h( ilast-1, ilast-1 ), ldh,t( ilast-1, ilast-1 ), ldt, &
                           safmin*safety, s1,temp, wr, temp2, wi )
                 ! if standardization has perturbed the shift onto real line,
                 ! do another (real single-shift) qr step.
                 if( wi==zero )go to 350
                 s1inv = one / s1
                 ! do eispack (qzval) computation of alpha and beta
                 a11 = h( ilast-1, ilast-1 )
                 a21 = h( ilast, ilast-1 )
                 a12 = h( ilast-1, ilast )
                 a22 = h( ilast, ilast )
                 ! compute complex givens rotation on right
                 ! (assume some element of c = (sa - wb) > unfl )
                                  ! __
                 ! (sa - wb) ( cz   -sz )
                           ! ( sz    cz )
                 c11r = s1*a11 - wr*b11
                 c11i = -wi*b11
                 c12 = s1*a12
                 c21 = s1*a21
                 c22r = s1*a22 - wr*b22
                 c22i = -wi*b22
                 if( abs( c11r )+abs( c11i )+abs( c12 )>abs( c21 )+abs( c22r )+abs( c22i ) ) &
                           then
                    t1 = stdlib_slapy3( c12, c11r, c11i )
                    cz = c12 / t1
                    szr = -c11r / t1
                    szi = -c11i / t1
                 else
                    cz = stdlib_slapy2( c22r, c22i )
                    if( cz<=safmin ) then
                       cz = zero
                       szr = one
                       szi = zero
                    else
                       tempr = c22r / cz
                       tempi = c22i / cz
                       t1 = stdlib_slapy2( cz, c21 )
                       cz = cz / t1
                       szr = -c21*tempr / t1
                       szi = c21*tempi / t1
                    end if
                 end if
                 ! compute givens rotation on left
                 ! (  cq   sq )
                 ! (  __      )  a or b
                 ! ( -sq   cq )
                 an = abs( a11 ) + abs( a12 ) + abs( a21 ) + abs( a22 )
                 bn = abs( b11 ) + abs( b22 )
                 wabs = abs( wr ) + abs( wi )
                 if( s1*an>wabs*bn ) then
                    cq = cz*b11
                    sqr = szr*b22
                    sqi = -szi*b22
                 else
                    a1r = cz*a11 + szr*a12
                    a1i = szi*a12
                    a2r = cz*a21 + szr*a22
                    a2i = szi*a22
                    cq = stdlib_slapy2( a1r, a1i )
                    if( cq<=safmin ) then
                       cq = zero
                       sqr = one
                       sqi = zero
                    else
                       tempr = a1r / cq
                       tempi = a1i / cq
                       sqr = tempr*a2r + tempi*a2i
                       sqi = tempi*a2r - tempr*a2i
                    end if
                 end if
                 t1 = stdlib_slapy3( cq, sqr, sqi )
                 cq = cq / t1
                 sqr = sqr / t1
                 sqi = sqi / t1
                 ! compute diagonal elements of qbz
                 tempr = sqr*szr - sqi*szi
                 tempi = sqr*szi + sqi*szr
                 b1r = cq*cz*b11 + tempr*b22
                 b1i = tempi*b22
                 b1a = stdlib_slapy2( b1r, b1i )
                 b2r = cq*cz*b22 + tempr*b11
                 b2i = -tempi*b11
                 b2a = stdlib_slapy2( b2r, b2i )
                 ! normalize so beta > 0, and im( alpha1 ) > 0
                 beta( ilast-1 ) = b1a
                 beta( ilast ) = b2a
                 alphar( ilast-1 ) = ( wr*b1a )*s1inv
                 alphai( ilast-1 ) = ( wi*b1a )*s1inv
                 alphar( ilast ) = ( wr*b2a )*s1inv
                 alphai( ilast ) = -( wi*b2a )*s1inv
                 ! step 3: go to next block -- exit if finished.
                 ilast = ifirst - 1
                 if( ilast<ilo )go to 380
                 ! reset counters
                 iiter = 0
                 eshift = zero
                 if( .not.ilschr ) then
                    ilastm = ilast
                    if( ifrstm>ilast )ifrstm = ilo
                 end if
                 go to 350
              else
                 ! usual case: 3x3 or larger block, using francis implicit
                             ! double-shift
                                          ! 2
                 ! eigenvalue equation is  w  - c w + d = 0,
                                               ! -1 2        -1
                 ! so compute 1st column of  (a b  )  - c a b   + d
                 ! using the formula in qzit (from eispack)
                 ! we assume that the block is at least 3x3
                 ad11 = ( ascale*h( ilast-1, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad21 = ( ascale*h( ilast, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad12 = ( ascale*h( ilast-1, ilast ) ) /( bscale*t( ilast, ilast ) )
                 ad22 = ( ascale*h( ilast, ilast ) ) /( bscale*t( ilast, ilast ) )
                 u12 = t( ilast-1, ilast ) / t( ilast, ilast )
                 ad11l = ( ascale*h( ifirst, ifirst ) ) /( bscale*t( ifirst, ifirst ) )
                 ad21l = ( ascale*h( ifirst+1, ifirst ) ) /( bscale*t( ifirst, ifirst ) )
                 ad12l = ( ascale*h( ifirst, ifirst+1 ) ) /( bscale*t( ifirst+1, ifirst+1 ) )
                           
                 ad22l = ( ascale*h( ifirst+1, ifirst+1 ) ) /( bscale*t( ifirst+1, ifirst+1 ) )
                           
                 ad32l = ( ascale*h( ifirst+2, ifirst+1 ) ) /( bscale*t( ifirst+1, ifirst+1 ) )
                           
                 u12l = t( ifirst, ifirst+1 ) / t( ifirst+1, ifirst+1 )
                 v( 1 ) = ( ad11-ad11l )*( ad22-ad11l ) - ad12*ad21 +ad21*u12*ad11l + ( ad12l-&
                           ad11l*u12l )*ad21l
                 v( 2 ) = ( ( ad22l-ad11l )-ad21l*u12l-( ad11-ad11l )-( ad22-ad11l )+ad21*u12 )&
                           *ad21l
                 v( 3 ) = ad32l*ad21l
                 istart = ifirst
                 call stdlib_slarfg( 3, v( 1 ), v( 2 ), 1, tau )
                 v( 1 ) = one
                 ! sweep
                 loop_290: do j = istart, ilast - 2
                    ! all but last elements: use 3x3 householder transforms.
                    ! zero (j-1)st column of a
                    if( j>istart ) then
                       v( 1 ) = h( j, j-1 )
                       v( 2 ) = h( j+1, j-1 )
                       v( 3 ) = h( j+2, j-1 )
                       call stdlib_slarfg( 3, h( j, j-1 ), v( 2 ), 1, tau )
                       v( 1 ) = one
                       h( j+1, j-1 ) = zero
                       h( j+2, j-1 ) = zero
                    end if
                    do jc = j, ilastm
                       temp = tau*( h( j, jc )+v( 2 )*h( j+1, jc )+v( 3 )*h( j+2, jc ) )
                       h( j, jc ) = h( j, jc ) - temp
                       h( j+1, jc ) = h( j+1, jc ) - temp*v( 2 )
                       h( j+2, jc ) = h( j+2, jc ) - temp*v( 3 )
                       temp2 = tau*( t( j, jc )+v( 2 )*t( j+1, jc )+v( 3 )*t( j+2, jc ) )
                       t( j, jc ) = t( j, jc ) - temp2
                       t( j+1, jc ) = t( j+1, jc ) - temp2*v( 2 )
                       t( j+2, jc ) = t( j+2, jc ) - temp2*v( 3 )
                    end do
                    if( ilq ) then
                       do jr = 1, n
                          temp = tau*( q( jr, j )+v( 2 )*q( jr, j+1 )+v( 3 )*q( jr, j+2 ) )
                                    
                          q( jr, j ) = q( jr, j ) - temp
                          q( jr, j+1 ) = q( jr, j+1 ) - temp*v( 2 )
                          q( jr, j+2 ) = q( jr, j+2 ) - temp*v( 3 )
                       end do
                    end if
                    ! zero j-th column of b (see slagbc for details)
                    ! swap rows to pivot
                    ilpivt = .false.
                    temp = max( abs( t( j+1, j+1 ) ), abs( t( j+1, j+2 ) ) )
                    temp2 = max( abs( t( j+2, j+1 ) ), abs( t( j+2, j+2 ) ) )
                    if( max( temp, temp2 )<safmin ) then
                       scale = zero
                       u1 = one
                       u2 = zero
                       go to 250
                    else if( temp>=temp2 ) then
                       w11 = t( j+1, j+1 )
                       w21 = t( j+2, j+1 )
                       w12 = t( j+1, j+2 )
                       w22 = t( j+2, j+2 )
                       u1 = t( j+1, j )
                       u2 = t( j+2, j )
                    else
                       w21 = t( j+1, j+1 )
                       w11 = t( j+2, j+1 )
                       w22 = t( j+1, j+2 )
                       w12 = t( j+2, j+2 )
                       u2 = t( j+1, j )
                       u1 = t( j+2, j )
                    end if
                    ! swap columns if nec.
                    if( abs( w12 )>abs( w11 ) ) then
                       ilpivt = .true.
                       temp = w12
                       temp2 = w22
                       w12 = w11
                       w22 = w21
                       w11 = temp
                       w21 = temp2
                    end if
                    ! lu-factor
                    temp = w21 / w11
                    u2 = u2 - temp*u1
                    w22 = w22 - temp*w12
                    w21 = zero
                    ! compute scale
                    scale = one
                    if( abs( w22 )<safmin ) then
                       scale = zero
                       u2 = one
                       u1 = -w12 / w11
                       go to 250
                    end if
                    if( abs( w22 )<abs( u2 ) )scale = abs( w22 / u2 )
                    if( abs( w11 )<abs( u1 ) )scale = min( scale, abs( w11 / u1 ) )
                    ! solve
                    u2 = ( scale*u2 ) / w22
                    u1 = ( scale*u1-w12*u2 ) / w11
                    250 continue
                    if( ilpivt ) then
                       temp = u2
                       u2 = u1
                       u1 = temp
                    end if
                    ! compute householder vector
                    t1 = sqrt( scale**2+u1**2+u2**2 )
                    tau = one + scale / t1
                    vs = -one / ( scale+t1 )
                    v( 1 ) = one
                    v( 2 ) = vs*u1
                    v( 3 ) = vs*u2
                    ! apply transformations from the right.
                    do jr = ifrstm, min( j+3, ilast )
                       temp = tau*( h( jr, j )+v( 2 )*h( jr, j+1 )+v( 3 )*h( jr, j+2 ) )
                       h( jr, j ) = h( jr, j ) - temp
                       h( jr, j+1 ) = h( jr, j+1 ) - temp*v( 2 )
                       h( jr, j+2 ) = h( jr, j+2 ) - temp*v( 3 )
                    end do
                    do jr = ifrstm, j + 2
                       temp = tau*( t( jr, j )+v( 2 )*t( jr, j+1 )+v( 3 )*t( jr, j+2 ) )
                       t( jr, j ) = t( jr, j ) - temp
                       t( jr, j+1 ) = t( jr, j+1 ) - temp*v( 2 )
                       t( jr, j+2 ) = t( jr, j+2 ) - temp*v( 3 )
                    end do
                    if( ilz ) then
                       do jr = 1, n
                          temp = tau*( z( jr, j )+v( 2 )*z( jr, j+1 )+v( 3 )*z( jr, j+2 ) )
                                    
                          z( jr, j ) = z( jr, j ) - temp
                          z( jr, j+1 ) = z( jr, j+1 ) - temp*v( 2 )
                          z( jr, j+2 ) = z( jr, j+2 ) - temp*v( 3 )
                       end do
                    end if
                    t( j+1, j ) = zero
                    t( j+2, j ) = zero
                 end do loop_290
                 ! last elements: use givens rotations
                 ! rotations from the left
                 j = ilast - 1
                 temp = h( j, j-1 )
                 call stdlib_slartg( temp, h( j+1, j-1 ), c, s, h( j, j-1 ) )
                 h( j+1, j-1 ) = zero
                 do jc = j, ilastm
                    temp = c*h( j, jc ) + s*h( j+1, jc )
                    h( j+1, jc ) = -s*h( j, jc ) + c*h( j+1, jc )
                    h( j, jc ) = temp
                    temp2 = c*t( j, jc ) + s*t( j+1, jc )
                    t( j+1, jc ) = -s*t( j, jc ) + c*t( j+1, jc )
                    t( j, jc ) = temp2
                 end do
                 if( ilq ) then
                    do jr = 1, n
                       temp = c*q( jr, j ) + s*q( jr, j+1 )
                       q( jr, j+1 ) = -s*q( jr, j ) + c*q( jr, j+1 )
                       q( jr, j ) = temp
                    end do
                 end if
                 ! rotations from the right.
                 temp = t( j+1, j+1 )
                 call stdlib_slartg( temp, t( j+1, j ), c, s, t( j+1, j+1 ) )
                 t( j+1, j ) = zero
                 do jr = ifrstm, ilast
                    temp = c*h( jr, j+1 ) + s*h( jr, j )
                    h( jr, j ) = -s*h( jr, j+1 ) + c*h( jr, j )
                    h( jr, j+1 ) = temp
                 end do
                 do jr = ifrstm, ilast - 1
                    temp = c*t( jr, j+1 ) + s*t( jr, j )
                    t( jr, j ) = -s*t( jr, j+1 ) + c*t( jr, j )
                    t( jr, j+1 ) = temp
                 end do
                 if( ilz ) then
                    do jr = 1, n
                       temp = c*z( jr, j+1 ) + s*z( jr, j )
                       z( jr, j ) = -s*z( jr, j+1 ) + c*z( jr, j )
                       z( jr, j+1 ) = temp
                    end do
                 end if
                 ! end of double-shift code
              end if
              go to 350
              ! end of iteration loop
              350 continue
           end do loop_360
           ! drop-through = non-convergence
           info = ilast
           go to 420
           ! successful completion of all qz steps
           380 continue
           ! set eigenvalues 1:ilo-1
           do j = 1, ilo - 1
              if( t( j, j )<zero ) then
                 if( ilschr ) then
                    do jr = 1, j
                       h( jr, j ) = -h( jr, j )
                       t( jr, j ) = -t( jr, j )
                    end do
                 else
                    h( j, j ) = -h( j, j )
                    t( j, j ) = -t( j, j )
                 end if
                 if( ilz ) then
                    do jr = 1, n
                       z( jr, j ) = -z( jr, j )
                    end do
                 end if
              end if
              alphar( j ) = h( j, j )
              alphai( j ) = zero
              beta( j ) = t( j, j )
           end do
           ! normal termination
           info = 0
           ! exit (other than argument error) -- return optimal workspace size
           420 continue
           work( 1 ) = real( n,KIND=sp)
           return
     end subroutine stdlib_shgeqz

     module subroutine stdlib_dhgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alphar, alphai, &
     !! DHGEQZ computes the eigenvalues of a real matrix pair (H,T),
     !! where H is an upper Hessenberg matrix and T is upper triangular,
     !! using the double-shift QZ method.
     !! Matrix pairs of this type are produced by the reduction to
     !! generalized upper Hessenberg form of a real matrix pair (A,B):
     !! A = Q1*H*Z1**T,  B = Q1*T*Z1**T,
     !! as computed by DGGHRD.
     !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
     !! also reduced to generalized Schur form,
     !! H = Q*S*Z**T,  T = Q*P*Z**T,
     !! where Q and Z are orthogonal matrices, P is an upper triangular
     !! matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2
     !! diagonal blocks.
     !! The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
     !! (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of
     !! eigenvalues.
     !! Additionally, the 2-by-2 upper triangular diagonal blocks of P
     !! corresponding to 2-by-2 blocks of S are reduced to positive diagonal
     !! form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,
     !! P(j,j) > 0, and P(j+1,j+1) > 0.
     !! Optionally, the orthogonal matrix Q from the generalized Schur
     !! factorization may be postmultiplied into an input matrix Q1, and the
     !! orthogonal matrix Z may be postmultiplied into an input matrix Z1.
     !! If Q1 and Z1 are the orthogonal matrices from DGGHRD that reduced
     !! the matrix pair (A,B) to generalized upper Hessenberg form, then the
     !! output matrices Q1*Q and Z1*Z are the orthogonal factors from the
     !! generalized Schur factorization of (A,B):
     !! A = (Q1*Q)*S*(Z1*Z)**T,  B = (Q1*Q)*P*(Z1*Z)**T.
     !! To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
     !! of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
     !! complex and beta real.
     !! If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
     !! generalized nonsymmetric eigenvalue problem (GNEP)
     !! A*x = lambda*B*x
     !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     !! alternate form of the GNEP
     !! mu*A*y = B*y.
     !! Real eigenvalues can be read directly from the generalized Schur
     !! form:
     !! alpha = S(i,i), beta = P(i,i).
     !! Ref: C.B. Moler
     !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
     !! pp. 241--256.
               beta, q, ldq, z, ldz, work,lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz, job
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldq, ldt, ldz, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(out) :: alphai(*), alphar(*), beta(*), work(*)
           real(dp), intent(inout) :: h(ldh,*), q(ldq,*), t(ldt,*), z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: safety = 1.0e+2_dp
          ! $                     safety = one )
           
           ! Local Scalars 
           logical(lk) :: ilazr2, ilazro, ilpivt, ilq, ilschr, ilz, lquery
           integer(ilp) :: icompq, icompz, ifirst, ifrstm, iiter, ilast, ilastm, in, ischur, &
                     istart, j, jc, jch, jiter, jr, maxit
           real(dp) :: a11, a12, a1i, a1r, a21, a22, a2i, a2r, ad11, ad11l, ad12, ad12l, ad21, &
           ad21l, ad22, ad22l, ad32l, an, anorm, ascale, atol, b11, b1a, b1i, b1r, b22, b2a, b2i, &
           b2r, bn, bnorm, bscale, btol, c, c11i, c11r, c12, c21, c22i, c22r, cl, cq, cr, cz, &
           eshift, s, s1, s1inv, s2, safmax, safmin, scale, sl, sqi, sqr, sr, szi, szr, t1, tau, &
           temp, temp2, tempi, tempr, u1, u12, u12l, u2, ulp, vs, w11, w12, w21, w22, wabs, wi, &
                     wr, wr2
           ! Local Arrays 
           real(dp) :: v(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode job, compq, compz
           if( stdlib_lsame( job, 'E' ) ) then
              ilschr = .false.
              ischur = 1
           else if( stdlib_lsame( job, 'S' ) ) then
              ilschr = .true.
              ischur = 2
           else
              ischur = 0
           end if
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              icompq = 0
           end if
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              icompz = 0
           end if
           ! check argument values
           info = 0
           work( 1 ) = max( 1, n )
           lquery = ( lwork==-1 )
           if( ischur==0 ) then
              info = -1
           else if( icompq==0 ) then
              info = -2
           else if( icompz==0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 ) then
              info = -5
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -6
           else if( ldh<n ) then
              info = -8
           else if( ldt<n ) then
              info = -10
           else if( ldq<1 .or. ( ilq .and. ldq<n ) ) then
              info = -15
           else if( ldz<1 .or. ( ilz .and. ldz<n ) ) then
              info = -17
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -19
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DHGEQZ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n<=0 ) then
              work( 1 ) = real( 1,KIND=dp)
              return
           end if
           ! initialize q and z
           if( icompq==3 )call stdlib_dlaset( 'FULL', n, n, zero, one, q, ldq )
           if( icompz==3 )call stdlib_dlaset( 'FULL', n, n, zero, one, z, ldz )
           ! machine constants
           in = ihi + 1 - ilo
           safmin = stdlib_dlamch( 'S' )
           safmax = one / safmin
           ulp = stdlib_dlamch( 'E' )*stdlib_dlamch( 'B' )
           anorm = stdlib_dlanhs( 'F', in, h( ilo, ilo ), ldh, work )
           bnorm = stdlib_dlanhs( 'F', in, t( ilo, ilo ), ldt, work )
           atol = max( safmin, ulp*anorm )
           btol = max( safmin, ulp*bnorm )
           ascale = one / max( safmin, anorm )
           bscale = one / max( safmin, bnorm )
           ! set eigenvalues ihi+1:n
           do j = ihi + 1, n
              if( t( j, j )<zero ) then
                 if( ilschr ) then
                    do jr = 1, j
                       h( jr, j ) = -h( jr, j )
                       t( jr, j ) = -t( jr, j )
                    end do
                 else
                    h( j, j ) = -h( j, j )
                    t( j, j ) = -t( j, j )
                 end if
                 if( ilz ) then
                    do jr = 1, n
                       z( jr, j ) = -z( jr, j )
                    end do
                 end if
              end if
              alphar( j ) = h( j, j )
              alphai( j ) = zero
              beta( j ) = t( j, j )
           end do
           ! if ihi < ilo, skip qz steps
           if( ihi<ilo )go to 380
           ! main qz iteration loop
           ! initialize dynamic indices
           ! eigenvalues ilast+1:n have been found.
              ! column operations modify rows ifrstm:whatever.
              ! row operations modify columns whatever:ilastm.
           ! if only eigenvalues are being computed, then
              ! ifrstm is the row of the last splitting row above row ilast;
              ! this is always at least ilo.
           ! iiter counts iterations since the last eigenvalue was found,
              ! to tell when to use an extraordinary shift.
           ! maxit is the maximum number of qz sweeps allowed.
           ilast = ihi
           if( ilschr ) then
              ifrstm = 1
              ilastm = n
           else
              ifrstm = ilo
              ilastm = ihi
           end if
           iiter = 0
           eshift = zero
           maxit = 30*( ihi-ilo+1 )
           loop_360: do jiter = 1, maxit
              ! split the matrix if possible.
              ! two tests:
                 ! 1: h(j,j-1)=0  or  j=ilo
                 ! 2: t(j,j)=0
              if( ilast==ilo ) then
                 ! special case: j=ilast
                 go to 80
              else
                 if( abs( h( ilast, ilast-1 ) )<=max( safmin, ulp*(abs( h( ilast, ilast ) ) + abs(&
                            h( ilast-1, ilast-1 ) )) ) ) then
                    h( ilast, ilast-1 ) = zero
                    go to 80
                 end if
              end if
              if( abs( t( ilast, ilast ) )<=max( safmin, ulp*(abs( t( ilast - 1, ilast ) ) + abs( &
                        t( ilast-1, ilast-1 )) ) ) ) then
                 t( ilast, ilast ) = zero
                 go to 70
              end if
              ! general case: j<ilast
              loop_60: do j = ilast - 1, ilo, -1
                 ! test 1: for h(j,j-1)=0 or j=ilo
                 if( j==ilo ) then
                    ilazro = .true.
                 else
                    if( abs( h( j, j-1 ) )<=max( safmin, ulp*(abs( h( j, j ) ) + abs( h( j-1, j-1 &
                              ) )) ) ) then
                       h( j, j-1 ) = zero
                       ilazro = .true.
                    else
                       ilazro = .false.
                    end if
                 end if
                 ! test 2: for t(j,j)=0
                 temp = abs ( t( j, j + 1 ) )
                 if ( j > ilo )temp = temp + abs ( t( j - 1, j ) )
                 if( abs( t( j, j ) )<max( safmin,ulp*temp ) ) then
                    t( j, j ) = zero
                    ! test 1a: check for 2 consecutive small subdiagonals in a
                    ilazr2 = .false.
                    if( .not.ilazro ) then
                       temp = abs( h( j, j-1 ) )
                       temp2 = abs( h( j, j ) )
                       tempr = max( temp, temp2 )
                       if( tempr<one .and. tempr/=zero ) then
                          temp = temp / tempr
                          temp2 = temp2 / tempr
                       end if
                       if( temp*( ascale*abs( h( j+1, j ) ) )<=temp2*( ascale*atol ) )ilazr2 = &
                                 .true.
                    end if
                    ! if both tests pass (1
                    ! element of b in the block is zero, split a 1x1 block off
                    ! at the top. (i.e., at the j-th row/column) the leading
                    ! diagonal element of the remainder can also be zero, so
                    ! this may have to be done repeatedly.
                    if( ilazro .or. ilazr2 ) then
                       do jch = j, ilast - 1
                          temp = h( jch, jch )
                          call stdlib_dlartg( temp, h( jch+1, jch ), c, s,h( jch, jch ) )
                          h( jch+1, jch ) = zero
                          call stdlib_drot( ilastm-jch, h( jch, jch+1 ), ldh,h( jch+1, jch+1 ), &
                                    ldh, c, s )
                          call stdlib_drot( ilastm-jch, t( jch, jch+1 ), ldt,t( jch+1, jch+1 ), &
                                    ldt, c, s )
                          if( ilq )call stdlib_drot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, s )
                                    
                          if( ilazr2 )h( jch, jch-1 ) = h( jch, jch-1 )*c
                          ilazr2 = .false.
                          if( abs( t( jch+1, jch+1 ) )>=btol ) then
                             if( jch+1>=ilast ) then
                                go to 80
                             else
                                ifirst = jch + 1
                                go to 110
                             end if
                          end if
                          t( jch+1, jch+1 ) = zero
                       end do
                       go to 70
                    else
                       ! only test 2 passed -- chase the zero to t(ilast,ilast)
                       ! then process as in the case t(ilast,ilast)=0
                       do jch = j, ilast - 1
                          temp = t( jch, jch+1 )
                          call stdlib_dlartg( temp, t( jch+1, jch+1 ), c, s,t( jch, jch+1 ) )
                                    
                          t( jch+1, jch+1 ) = zero
                          if( jch<ilastm-1 )call stdlib_drot( ilastm-jch-1, t( jch, jch+2 ), ldt,&
                                    t( jch+1, jch+2 ), ldt, c, s )
                          call stdlib_drot( ilastm-jch+2, h( jch, jch-1 ), ldh,h( jch+1, jch-1 ), &
                                    ldh, c, s )
                          if( ilq )call stdlib_drot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, s )
                                    
                          temp = h( jch+1, jch )
                          call stdlib_dlartg( temp, h( jch+1, jch-1 ), c, s,h( jch+1, jch ) )
                                    
                          h( jch+1, jch-1 ) = zero
                          call stdlib_drot( jch+1-ifrstm, h( ifrstm, jch ), 1,h( ifrstm, jch-1 ), &
                                    1, c, s )
                          call stdlib_drot( jch-ifrstm, t( ifrstm, jch ), 1,t( ifrstm, jch-1 ), 1,&
                                     c, s )
                          if( ilz )call stdlib_drot( n, z( 1, jch ), 1, z( 1, jch-1 ), 1,c, s )
                                    
                       end do
                       go to 70
                    end if
                 else if( ilazro ) then
                    ! only test 1 passed -- work on j:ilast
                    ifirst = j
                    go to 110
                 end if
                 ! neither test passed -- try next j
              end do loop_60
              ! (drop-through is "impossible")
              info = n + 1
              go to 420
              ! t(ilast,ilast)=0 -- clear h(ilast,ilast-1) to split off a
              ! 1x1 block.
              70 continue
              temp = h( ilast, ilast )
              call stdlib_dlartg( temp, h( ilast, ilast-1 ), c, s,h( ilast, ilast ) )
              h( ilast, ilast-1 ) = zero
              call stdlib_drot( ilast-ifrstm, h( ifrstm, ilast ), 1,h( ifrstm, ilast-1 ), 1, c, s &
                        )
              call stdlib_drot( ilast-ifrstm, t( ifrstm, ilast ), 1,t( ifrstm, ilast-1 ), 1, c, s &
                        )
              if( ilz )call stdlib_drot( n, z( 1, ilast ), 1, z( 1, ilast-1 ), 1, c, s )
              ! h(ilast,ilast-1)=0 -- standardize b, set alphar, alphai,
                                    ! and beta
                                    80 continue
              if( t( ilast, ilast )<zero ) then
                 if( ilschr ) then
                    do j = ifrstm, ilast
                       h( j, ilast ) = -h( j, ilast )
                       t( j, ilast ) = -t( j, ilast )
                    end do
                 else
                    h( ilast, ilast ) = -h( ilast, ilast )
                    t( ilast, ilast ) = -t( ilast, ilast )
                 end if
                 if( ilz ) then
                    do j = 1, n
                       z( j, ilast ) = -z( j, ilast )
                    end do
                 end if
              end if
              alphar( ilast ) = h( ilast, ilast )
              alphai( ilast ) = zero
              beta( ilast ) = t( ilast, ilast )
              ! go to next block -- exit if finished.
              ilast = ilast - 1
              if( ilast<ilo )go to 380
              ! reset counters
              iiter = 0
              eshift = zero
              if( .not.ilschr ) then
                 ilastm = ilast
                 if( ifrstm>ilast )ifrstm = ilo
              end if
              go to 350
              ! qz step
              ! this iteration only involves rows/columns ifirst:ilast. we
              ! assume ifirst < ilast, and that the diagonal of b is non-zero.
              110 continue
              iiter = iiter + 1
              if( .not.ilschr ) then
                 ifrstm = ifirst
              end if
              ! compute single shifts.
              ! at this point, ifirst < ilast, and the diagonal elements of
              ! t(ifirst:ilast,ifirst,ilast) are larger than btol (in
              ! magnitude)
              if( ( iiter / 10 )*10==iiter ) then
                 ! exceptional shift.  chosen for no particularly good reason.
                 ! (single shift only.)
                 if( ( real( maxit,KIND=dp)*safmin )*abs( h( ilast, ilast-1 ) )<abs( t( ilast-1, &
                           ilast-1 ) ) ) then
                    eshift = h( ilast, ilast-1 ) /t( ilast-1, ilast-1 )
                 else
                    eshift = eshift + one / ( safmin*real( maxit,KIND=dp) )
                 end if
                 s1 = one
                 wr = eshift
              else
                 ! shifts based on the generalized eigenvalues of the
                 ! bottom-right 2x2 block of a and b. the first eigenvalue
                 ! returned by stdlib_dlag2 is the wilkinson shift (aep p.512_dp),
                 call stdlib_dlag2( h( ilast-1, ilast-1 ), ldh,t( ilast-1, ilast-1 ), ldt, &
                           safmin*safety, s1,s2, wr, wr2, wi )
                 if ( abs( (wr/s1)*t( ilast, ilast ) - h( ilast, ilast ) )> abs( (wr2/s2)*t( &
                           ilast, ilast )- h( ilast, ilast ) ) ) then
                    temp = wr
                    wr = wr2
                    wr2 = temp
                    temp = s1
                    s1 = s2
                    s2 = temp
                 end if
                 temp = max( s1, safmin*max( one, abs( wr ), abs( wi ) ) )
                 if( wi/=zero )go to 200
              end if
              ! fiddle with shift to avoid overflow
              temp = min( ascale, one )*( half*safmax )
              if( s1>temp ) then
                 scale = temp / s1
              else
                 scale = one
              end if
              temp = min( bscale, one )*( half*safmax )
              if( abs( wr )>temp )scale = min( scale, temp / abs( wr ) )
              s1 = scale*s1
              wr = scale*wr
              ! now check for two consecutive small subdiagonals.
              do j = ilast - 1, ifirst + 1, -1
                 istart = j
                 temp = abs( s1*h( j, j-1 ) )
                 temp2 = abs( s1*h( j, j )-wr*t( j, j ) )
                 tempr = max( temp, temp2 )
                 if( tempr<one .and. tempr/=zero ) then
                    temp = temp / tempr
                    temp2 = temp2 / tempr
                 end if
                 if( abs( ( ascale*h( j+1, j ) )*temp )<=( ascale*atol )*temp2 )go to 130
              end do
              istart = ifirst
              130 continue
              ! do an implicit single-shift qz sweep.
              ! initial q
              temp = s1*h( istart, istart ) - wr*t( istart, istart )
              temp2 = s1*h( istart+1, istart )
              call stdlib_dlartg( temp, temp2, c, s, tempr )
              ! sweep
              loop_190: do j = istart, ilast - 1
                 if( j>istart ) then
                    temp = h( j, j-1 )
                    call stdlib_dlartg( temp, h( j+1, j-1 ), c, s, h( j, j-1 ) )
                    h( j+1, j-1 ) = zero
                 end if
                 do jc = j, ilastm
                    temp = c*h( j, jc ) + s*h( j+1, jc )
                    h( j+1, jc ) = -s*h( j, jc ) + c*h( j+1, jc )
                    h( j, jc ) = temp
                    temp2 = c*t( j, jc ) + s*t( j+1, jc )
                    t( j+1, jc ) = -s*t( j, jc ) + c*t( j+1, jc )
                    t( j, jc ) = temp2
                 end do
                 if( ilq ) then
                    do jr = 1, n
                       temp = c*q( jr, j ) + s*q( jr, j+1 )
                       q( jr, j+1 ) = -s*q( jr, j ) + c*q( jr, j+1 )
                       q( jr, j ) = temp
                    end do
                 end if
                 temp = t( j+1, j+1 )
                 call stdlib_dlartg( temp, t( j+1, j ), c, s, t( j+1, j+1 ) )
                 t( j+1, j ) = zero
                 do jr = ifrstm, min( j+2, ilast )
                    temp = c*h( jr, j+1 ) + s*h( jr, j )
                    h( jr, j ) = -s*h( jr, j+1 ) + c*h( jr, j )
                    h( jr, j+1 ) = temp
                 end do
                 do jr = ifrstm, j
                    temp = c*t( jr, j+1 ) + s*t( jr, j )
                    t( jr, j ) = -s*t( jr, j+1 ) + c*t( jr, j )
                    t( jr, j+1 ) = temp
                 end do
                 if( ilz ) then
                    do jr = 1, n
                       temp = c*z( jr, j+1 ) + s*z( jr, j )
                       z( jr, j ) = -s*z( jr, j+1 ) + c*z( jr, j )
                       z( jr, j+1 ) = temp
                    end do
                 end if
              end do loop_190
              go to 350
              ! use francis double-shift
              ! note: the francis double-shift should work with real shifts,
                    ! but only if the block is at least 3x3.
                    ! this code may break if this point is reached with
                    ! a 2x2 block with real eigenvalues.
                    200 continue
              if( ifirst+1==ilast ) then
                 ! special case -- 2x2 block with complex eigenvectors
                 ! step 1: standardize, that is, rotate so that
                             ! ( b11  0  )
                         ! b = (         )  with b11 non-negative.
                             ! (  0  b22 )
                 call stdlib_dlasv2( t( ilast-1, ilast-1 ), t( ilast-1, ilast ),t( ilast, ilast ),&
                            b22, b11, sr, cr, sl, cl )
                 if( b11<zero ) then
                    cr = -cr
                    sr = -sr
                    b11 = -b11
                    b22 = -b22
                 end if
                 call stdlib_drot( ilastm+1-ifirst, h( ilast-1, ilast-1 ), ldh,h( ilast, ilast-1 )&
                           , ldh, cl, sl )
                 call stdlib_drot( ilast+1-ifrstm, h( ifrstm, ilast-1 ), 1,h( ifrstm, ilast ), 1, &
                           cr, sr )
                 if( ilast<ilastm )call stdlib_drot( ilastm-ilast, t( ilast-1, ilast+1 ), ldt,t( &
                           ilast, ilast+1 ), ldt, cl, sl )
                 if( ifrstm<ilast-1 )call stdlib_drot( ifirst-ifrstm, t( ifrstm, ilast-1 ), 1,t( &
                           ifrstm, ilast ), 1, cr, sr )
                 if( ilq )call stdlib_drot( n, q( 1, ilast-1 ), 1, q( 1, ilast ), 1, cl,sl )
                           
                 if( ilz )call stdlib_drot( n, z( 1, ilast-1 ), 1, z( 1, ilast ), 1, cr,sr )
                           
                 t( ilast-1, ilast-1 ) = b11
                 t( ilast-1, ilast ) = zero
                 t( ilast, ilast-1 ) = zero
                 t( ilast, ilast ) = b22
                 ! if b22 is negative, negate column ilast
                 if( b22<zero ) then
                    do j = ifrstm, ilast
                       h( j, ilast ) = -h( j, ilast )
                       t( j, ilast ) = -t( j, ilast )
                    end do
                    if( ilz ) then
                       do j = 1, n
                          z( j, ilast ) = -z( j, ilast )
                       end do
                    end if
                    b22 = -b22
                 end if
                 ! step 2: compute alphar, alphai, and beta (see refs.)
                 ! recompute shift
                 call stdlib_dlag2( h( ilast-1, ilast-1 ), ldh,t( ilast-1, ilast-1 ), ldt, &
                           safmin*safety, s1,temp, wr, temp2, wi )
                 ! if standardization has perturbed the shift onto real line,
                 ! do another (real single-shift) qr step.
                 if( wi==zero )go to 350
                 s1inv = one / s1
                 ! do eispack (qzval) computation of alpha and beta
                 a11 = h( ilast-1, ilast-1 )
                 a21 = h( ilast, ilast-1 )
                 a12 = h( ilast-1, ilast )
                 a22 = h( ilast, ilast )
                 ! compute complex givens rotation on right
                 ! (assume some element of c = (sa - wb) > unfl )
                                  ! __
                 ! (sa - wb) ( cz   -sz )
                           ! ( sz    cz )
                 c11r = s1*a11 - wr*b11
                 c11i = -wi*b11
                 c12 = s1*a12
                 c21 = s1*a21
                 c22r = s1*a22 - wr*b22
                 c22i = -wi*b22
                 if( abs( c11r )+abs( c11i )+abs( c12 )>abs( c21 )+abs( c22r )+abs( c22i ) ) &
                           then
                    t1 = stdlib_dlapy3( c12, c11r, c11i )
                    cz = c12 / t1
                    szr = -c11r / t1
                    szi = -c11i / t1
                 else
                    cz = stdlib_dlapy2( c22r, c22i )
                    if( cz<=safmin ) then
                       cz = zero
                       szr = one
                       szi = zero
                    else
                       tempr = c22r / cz
                       tempi = c22i / cz
                       t1 = stdlib_dlapy2( cz, c21 )
                       cz = cz / t1
                       szr = -c21*tempr / t1
                       szi = c21*tempi / t1
                    end if
                 end if
                 ! compute givens rotation on left
                 ! (  cq   sq )
                 ! (  __      )  a or b
                 ! ( -sq   cq )
                 an = abs( a11 ) + abs( a12 ) + abs( a21 ) + abs( a22 )
                 bn = abs( b11 ) + abs( b22 )
                 wabs = abs( wr ) + abs( wi )
                 if( s1*an>wabs*bn ) then
                    cq = cz*b11
                    sqr = szr*b22
                    sqi = -szi*b22
                 else
                    a1r = cz*a11 + szr*a12
                    a1i = szi*a12
                    a2r = cz*a21 + szr*a22
                    a2i = szi*a22
                    cq = stdlib_dlapy2( a1r, a1i )
                    if( cq<=safmin ) then
                       cq = zero
                       sqr = one
                       sqi = zero
                    else
                       tempr = a1r / cq
                       tempi = a1i / cq
                       sqr = tempr*a2r + tempi*a2i
                       sqi = tempi*a2r - tempr*a2i
                    end if
                 end if
                 t1 = stdlib_dlapy3( cq, sqr, sqi )
                 cq = cq / t1
                 sqr = sqr / t1
                 sqi = sqi / t1
                 ! compute diagonal elements of qbz
                 tempr = sqr*szr - sqi*szi
                 tempi = sqr*szi + sqi*szr
                 b1r = cq*cz*b11 + tempr*b22
                 b1i = tempi*b22
                 b1a = stdlib_dlapy2( b1r, b1i )
                 b2r = cq*cz*b22 + tempr*b11
                 b2i = -tempi*b11
                 b2a = stdlib_dlapy2( b2r, b2i )
                 ! normalize so beta > 0, and im( alpha1 ) > 0
                 beta( ilast-1 ) = b1a
                 beta( ilast ) = b2a
                 alphar( ilast-1 ) = ( wr*b1a )*s1inv
                 alphai( ilast-1 ) = ( wi*b1a )*s1inv
                 alphar( ilast ) = ( wr*b2a )*s1inv
                 alphai( ilast ) = -( wi*b2a )*s1inv
                 ! step 3: go to next block -- exit if finished.
                 ilast = ifirst - 1
                 if( ilast<ilo )go to 380
                 ! reset counters
                 iiter = 0
                 eshift = zero
                 if( .not.ilschr ) then
                    ilastm = ilast
                    if( ifrstm>ilast )ifrstm = ilo
                 end if
                 go to 350
              else
                 ! usual case: 3x3 or larger block, using francis implicit
                             ! double-shift
                                          ! 2
                 ! eigenvalue equation is  w  - c w + d = 0,
                                               ! -1 2        -1
                 ! so compute 1st column of  (a b  )  - c a b   + d
                 ! using the formula in qzit (from eispack)
                 ! we assume that the block is at least 3x3
                 ad11 = ( ascale*h( ilast-1, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad21 = ( ascale*h( ilast, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad12 = ( ascale*h( ilast-1, ilast ) ) /( bscale*t( ilast, ilast ) )
                 ad22 = ( ascale*h( ilast, ilast ) ) /( bscale*t( ilast, ilast ) )
                 u12 = t( ilast-1, ilast ) / t( ilast, ilast )
                 ad11l = ( ascale*h( ifirst, ifirst ) ) /( bscale*t( ifirst, ifirst ) )
                 ad21l = ( ascale*h( ifirst+1, ifirst ) ) /( bscale*t( ifirst, ifirst ) )
                 ad12l = ( ascale*h( ifirst, ifirst+1 ) ) /( bscale*t( ifirst+1, ifirst+1 ) )
                           
                 ad22l = ( ascale*h( ifirst+1, ifirst+1 ) ) /( bscale*t( ifirst+1, ifirst+1 ) )
                           
                 ad32l = ( ascale*h( ifirst+2, ifirst+1 ) ) /( bscale*t( ifirst+1, ifirst+1 ) )
                           
                 u12l = t( ifirst, ifirst+1 ) / t( ifirst+1, ifirst+1 )
                 v( 1 ) = ( ad11-ad11l )*( ad22-ad11l ) - ad12*ad21 +ad21*u12*ad11l + ( ad12l-&
                           ad11l*u12l )*ad21l
                 v( 2 ) = ( ( ad22l-ad11l )-ad21l*u12l-( ad11-ad11l )-( ad22-ad11l )+ad21*u12 )&
                           *ad21l
                 v( 3 ) = ad32l*ad21l
                 istart = ifirst
                 call stdlib_dlarfg( 3, v( 1 ), v( 2 ), 1, tau )
                 v( 1 ) = one
                 ! sweep
                 loop_290: do j = istart, ilast - 2
                    ! all but last elements: use 3x3 householder transforms.
                    ! zero (j-1)st column of a
                    if( j>istart ) then
                       v( 1 ) = h( j, j-1 )
                       v( 2 ) = h( j+1, j-1 )
                       v( 3 ) = h( j+2, j-1 )
                       call stdlib_dlarfg( 3, h( j, j-1 ), v( 2 ), 1, tau )
                       v( 1 ) = one
                       h( j+1, j-1 ) = zero
                       h( j+2, j-1 ) = zero
                    end if
                    do jc = j, ilastm
                       temp = tau*( h( j, jc )+v( 2 )*h( j+1, jc )+v( 3 )*h( j+2, jc ) )
                       h( j, jc ) = h( j, jc ) - temp
                       h( j+1, jc ) = h( j+1, jc ) - temp*v( 2 )
                       h( j+2, jc ) = h( j+2, jc ) - temp*v( 3 )
                       temp2 = tau*( t( j, jc )+v( 2 )*t( j+1, jc )+v( 3 )*t( j+2, jc ) )
                       t( j, jc ) = t( j, jc ) - temp2
                       t( j+1, jc ) = t( j+1, jc ) - temp2*v( 2 )
                       t( j+2, jc ) = t( j+2, jc ) - temp2*v( 3 )
                    end do
                    if( ilq ) then
                       do jr = 1, n
                          temp = tau*( q( jr, j )+v( 2 )*q( jr, j+1 )+v( 3 )*q( jr, j+2 ) )
                                    
                          q( jr, j ) = q( jr, j ) - temp
                          q( jr, j+1 ) = q( jr, j+1 ) - temp*v( 2 )
                          q( jr, j+2 ) = q( jr, j+2 ) - temp*v( 3 )
                       end do
                    end if
                    ! zero j-th column of b (see dlagbc for details)
                    ! swap rows to pivot
                    ilpivt = .false.
                    temp = max( abs( t( j+1, j+1 ) ), abs( t( j+1, j+2 ) ) )
                    temp2 = max( abs( t( j+2, j+1 ) ), abs( t( j+2, j+2 ) ) )
                    if( max( temp, temp2 )<safmin ) then
                       scale = zero
                       u1 = one
                       u2 = zero
                       go to 250
                    else if( temp>=temp2 ) then
                       w11 = t( j+1, j+1 )
                       w21 = t( j+2, j+1 )
                       w12 = t( j+1, j+2 )
                       w22 = t( j+2, j+2 )
                       u1 = t( j+1, j )
                       u2 = t( j+2, j )
                    else
                       w21 = t( j+1, j+1 )
                       w11 = t( j+2, j+1 )
                       w22 = t( j+1, j+2 )
                       w12 = t( j+2, j+2 )
                       u2 = t( j+1, j )
                       u1 = t( j+2, j )
                    end if
                    ! swap columns if nec.
                    if( abs( w12 )>abs( w11 ) ) then
                       ilpivt = .true.
                       temp = w12
                       temp2 = w22
                       w12 = w11
                       w22 = w21
                       w11 = temp
                       w21 = temp2
                    end if
                    ! lu-factor
                    temp = w21 / w11
                    u2 = u2 - temp*u1
                    w22 = w22 - temp*w12
                    w21 = zero
                    ! compute scale
                    scale = one
                    if( abs( w22 )<safmin ) then
                       scale = zero
                       u2 = one
                       u1 = -w12 / w11
                       go to 250
                    end if
                    if( abs( w22 )<abs( u2 ) )scale = abs( w22 / u2 )
                    if( abs( w11 )<abs( u1 ) )scale = min( scale, abs( w11 / u1 ) )
                    ! solve
                    u2 = ( scale*u2 ) / w22
                    u1 = ( scale*u1-w12*u2 ) / w11
                    250 continue
                    if( ilpivt ) then
                       temp = u2
                       u2 = u1
                       u1 = temp
                    end if
                    ! compute householder vector
                    t1 = sqrt( scale**2+u1**2+u2**2 )
                    tau = one + scale / t1
                    vs = -one / ( scale+t1 )
                    v( 1 ) = one
                    v( 2 ) = vs*u1
                    v( 3 ) = vs*u2
                    ! apply transformations from the right.
                    do jr = ifrstm, min( j+3, ilast )
                       temp = tau*( h( jr, j )+v( 2 )*h( jr, j+1 )+v( 3 )*h( jr, j+2 ) )
                       h( jr, j ) = h( jr, j ) - temp
                       h( jr, j+1 ) = h( jr, j+1 ) - temp*v( 2 )
                       h( jr, j+2 ) = h( jr, j+2 ) - temp*v( 3 )
                    end do
                    do jr = ifrstm, j + 2
                       temp = tau*( t( jr, j )+v( 2 )*t( jr, j+1 )+v( 3 )*t( jr, j+2 ) )
                       t( jr, j ) = t( jr, j ) - temp
                       t( jr, j+1 ) = t( jr, j+1 ) - temp*v( 2 )
                       t( jr, j+2 ) = t( jr, j+2 ) - temp*v( 3 )
                    end do
                    if( ilz ) then
                       do jr = 1, n
                          temp = tau*( z( jr, j )+v( 2 )*z( jr, j+1 )+v( 3 )*z( jr, j+2 ) )
                                    
                          z( jr, j ) = z( jr, j ) - temp
                          z( jr, j+1 ) = z( jr, j+1 ) - temp*v( 2 )
                          z( jr, j+2 ) = z( jr, j+2 ) - temp*v( 3 )
                       end do
                    end if
                    t( j+1, j ) = zero
                    t( j+2, j ) = zero
                 end do loop_290
                 ! last elements: use givens rotations
                 ! rotations from the left
                 j = ilast - 1
                 temp = h( j, j-1 )
                 call stdlib_dlartg( temp, h( j+1, j-1 ), c, s, h( j, j-1 ) )
                 h( j+1, j-1 ) = zero
                 do jc = j, ilastm
                    temp = c*h( j, jc ) + s*h( j+1, jc )
                    h( j+1, jc ) = -s*h( j, jc ) + c*h( j+1, jc )
                    h( j, jc ) = temp
                    temp2 = c*t( j, jc ) + s*t( j+1, jc )
                    t( j+1, jc ) = -s*t( j, jc ) + c*t( j+1, jc )
                    t( j, jc ) = temp2
                 end do
                 if( ilq ) then
                    do jr = 1, n
                       temp = c*q( jr, j ) + s*q( jr, j+1 )
                       q( jr, j+1 ) = -s*q( jr, j ) + c*q( jr, j+1 )
                       q( jr, j ) = temp
                    end do
                 end if
                 ! rotations from the right.
                 temp = t( j+1, j+1 )
                 call stdlib_dlartg( temp, t( j+1, j ), c, s, t( j+1, j+1 ) )
                 t( j+1, j ) = zero
                 do jr = ifrstm, ilast
                    temp = c*h( jr, j+1 ) + s*h( jr, j )
                    h( jr, j ) = -s*h( jr, j+1 ) + c*h( jr, j )
                    h( jr, j+1 ) = temp
                 end do
                 do jr = ifrstm, ilast - 1
                    temp = c*t( jr, j+1 ) + s*t( jr, j )
                    t( jr, j ) = -s*t( jr, j+1 ) + c*t( jr, j )
                    t( jr, j+1 ) = temp
                 end do
                 if( ilz ) then
                    do jr = 1, n
                       temp = c*z( jr, j+1 ) + s*z( jr, j )
                       z( jr, j ) = -s*z( jr, j+1 ) + c*z( jr, j )
                       z( jr, j+1 ) = temp
                    end do
                 end if
                 ! end of double-shift code
              end if
              go to 350
              ! end of iteration loop
              350 continue
           end do loop_360
           ! drop-through = non-convergence
           info = ilast
           go to 420
           ! successful completion of all qz steps
           380 continue
           ! set eigenvalues 1:ilo-1
           do j = 1, ilo - 1
              if( t( j, j )<zero ) then
                 if( ilschr ) then
                    do jr = 1, j
                       h( jr, j ) = -h( jr, j )
                       t( jr, j ) = -t( jr, j )
                    end do
                 else
                    h( j, j ) = -h( j, j )
                    t( j, j ) = -t( j, j )
                 end if
                 if( ilz ) then
                    do jr = 1, n
                       z( jr, j ) = -z( jr, j )
                    end do
                 end if
              end if
              alphar( j ) = h( j, j )
              alphai( j ) = zero
              beta( j ) = t( j, j )
           end do
           ! normal termination
           info = 0
           ! exit (other than argument error) -- return optimal workspace size
           420 continue
           work( 1 ) = real( n,KIND=dp)
           return
     end subroutine stdlib_dhgeqz

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$hgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alphar, alphai, &
     !! DHGEQZ: computes the eigenvalues of a real matrix pair (H,T),
     !! where H is an upper Hessenberg matrix and T is upper triangular,
     !! using the double-shift QZ method.
     !! Matrix pairs of this type are produced by the reduction to
     !! generalized upper Hessenberg form of a real matrix pair (A,B):
     !! A = Q1*H*Z1**T,  B = Q1*T*Z1**T,
     !! as computed by DGGHRD.
     !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
     !! also reduced to generalized Schur form,
     !! H = Q*S*Z**T,  T = Q*P*Z**T,
     !! where Q and Z are orthogonal matrices, P is an upper triangular
     !! matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2
     !! diagonal blocks.
     !! The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
     !! (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of
     !! eigenvalues.
     !! Additionally, the 2-by-2 upper triangular diagonal blocks of P
     !! corresponding to 2-by-2 blocks of S are reduced to positive diagonal
     !! form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,
     !! P(j,j) > 0, and P(j+1,j+1) > 0.
     !! Optionally, the orthogonal matrix Q from the generalized Schur
     !! factorization may be postmultiplied into an input matrix Q1, and the
     !! orthogonal matrix Z may be postmultiplied into an input matrix Z1.
     !! If Q1 and Z1 are the orthogonal matrices from DGGHRD that reduced
     !! the matrix pair (A,B) to generalized upper Hessenberg form, then the
     !! output matrices Q1*Q and Z1*Z are the orthogonal factors from the
     !! generalized Schur factorization of (A,B):
     !! A = (Q1*Q)*S*(Z1*Z)**T,  B = (Q1*Q)*P*(Z1*Z)**T.
     !! To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
     !! of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
     !! complex and beta real.
     !! If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
     !! generalized nonsymmetric eigenvalue problem (GNEP)
     !! A*x = lambda*B*x
     !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     !! alternate form of the GNEP
     !! mu*A*y = B*y.
     !! Real eigenvalues can be read directly from the generalized Schur
     !! form:
     !! alpha = S(i,i), beta = P(i,i).
     !! Ref: C.B. Moler
     !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
     !! pp. 241--256.
               beta, q, ldq, z, ldz, work,lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz, job
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldq, ldt, ldz, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), work(*)
           real(${rk}$), intent(inout) :: h(ldh,*), q(ldq,*), t(ldt,*), z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: safety = 1.0e+2_${rk}$
          ! $                     safety = one )
           
           ! Local Scalars 
           logical(lk) :: ilazr2, ilazro, ilpivt, ilq, ilschr, ilz, lquery
           integer(ilp) :: icompq, icompz, ifirst, ifrstm, iiter, ilast, ilastm, in, ischur, &
                     istart, j, jc, jch, jiter, jr, maxit
           real(${rk}$) :: a11, a12, a1i, a1r, a21, a22, a2i, a2r, ad11, ad11l, ad12, ad12l, ad21, &
           ad21l, ad22, ad22l, ad32l, an, anorm, ascale, atol, b11, b1a, b1i, b1r, b22, b2a, b2i, &
           b2r, bn, bnorm, bscale, btol, c, c11i, c11r, c12, c21, c22i, c22r, cl, cq, cr, cz, &
           eshift, s, s1, s1inv, s2, safmax, safmin, scale, sl, sqi, sqr, sr, szi, szr, t1, tau, &
           temp, temp2, tempi, tempr, u1, u12, u12l, u2, ulp, vs, w11, w12, w21, w22, wabs, wi, &
                     wr, wr2
           ! Local Arrays 
           real(${rk}$) :: v(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode job, compq, compz
           if( stdlib_lsame( job, 'E' ) ) then
              ilschr = .false.
              ischur = 1
           else if( stdlib_lsame( job, 'S' ) ) then
              ilschr = .true.
              ischur = 2
           else
              ischur = 0
           end if
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              icompq = 0
           end if
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              icompz = 0
           end if
           ! check argument values
           info = 0
           work( 1 ) = max( 1, n )
           lquery = ( lwork==-1 )
           if( ischur==0 ) then
              info = -1
           else if( icompq==0 ) then
              info = -2
           else if( icompz==0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 ) then
              info = -5
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -6
           else if( ldh<n ) then
              info = -8
           else if( ldt<n ) then
              info = -10
           else if( ldq<1 .or. ( ilq .and. ldq<n ) ) then
              info = -15
           else if( ldz<1 .or. ( ilz .and. ldz<n ) ) then
              info = -17
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -19
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DHGEQZ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n<=0 ) then
              work( 1 ) = real( 1,KIND=${rk}$)
              return
           end if
           ! initialize q and z
           if( icompq==3 )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, q, ldq )
           if( icompz==3 )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, z, ldz )
           ! machine constants
           in = ihi + 1 - ilo
           safmin = stdlib_${ri}$lamch( 'S' )
           safmax = one / safmin
           ulp = stdlib_${ri}$lamch( 'E' )*stdlib_${ri}$lamch( 'B' )
           anorm = stdlib_${ri}$lanhs( 'F', in, h( ilo, ilo ), ldh, work )
           bnorm = stdlib_${ri}$lanhs( 'F', in, t( ilo, ilo ), ldt, work )
           atol = max( safmin, ulp*anorm )
           btol = max( safmin, ulp*bnorm )
           ascale = one / max( safmin, anorm )
           bscale = one / max( safmin, bnorm )
           ! set eigenvalues ihi+1:n
           do j = ihi + 1, n
              if( t( j, j )<zero ) then
                 if( ilschr ) then
                    do jr = 1, j
                       h( jr, j ) = -h( jr, j )
                       t( jr, j ) = -t( jr, j )
                    end do
                 else
                    h( j, j ) = -h( j, j )
                    t( j, j ) = -t( j, j )
                 end if
                 if( ilz ) then
                    do jr = 1, n
                       z( jr, j ) = -z( jr, j )
                    end do
                 end if
              end if
              alphar( j ) = h( j, j )
              alphai( j ) = zero
              beta( j ) = t( j, j )
           end do
           ! if ihi < ilo, skip qz steps
           if( ihi<ilo )go to 380
           ! main qz iteration loop
           ! initialize dynamic indices
           ! eigenvalues ilast+1:n have been found.
              ! column operations modify rows ifrstm:whatever.
              ! row operations modify columns whatever:ilastm.
           ! if only eigenvalues are being computed, then
              ! ifrstm is the row of the last splitting row above row ilast;
              ! this is always at least ilo.
           ! iiter counts iterations since the last eigenvalue was found,
              ! to tell when to use an extraordinary shift.
           ! maxit is the maximum number of qz sweeps allowed.
           ilast = ihi
           if( ilschr ) then
              ifrstm = 1
              ilastm = n
           else
              ifrstm = ilo
              ilastm = ihi
           end if
           iiter = 0
           eshift = zero
           maxit = 30*( ihi-ilo+1 )
           loop_360: do jiter = 1, maxit
              ! split the matrix if possible.
              ! two tests:
                 ! 1: h(j,j-1)=0  or  j=ilo
                 ! 2: t(j,j)=0
              if( ilast==ilo ) then
                 ! special case: j=ilast
                 go to 80
              else
                 if( abs( h( ilast, ilast-1 ) )<=max( safmin, ulp*(abs( h( ilast, ilast ) ) + abs(&
                            h( ilast-1, ilast-1 ) )) ) ) then
                    h( ilast, ilast-1 ) = zero
                    go to 80
                 end if
              end if
              if( abs( t( ilast, ilast ) )<=max( safmin, ulp*(abs( t( ilast - 1, ilast ) ) + abs( &
                        t( ilast-1, ilast-1 )) ) ) ) then
                 t( ilast, ilast ) = zero
                 go to 70
              end if
              ! general case: j<ilast
              loop_60: do j = ilast - 1, ilo, -1
                 ! test 1: for h(j,j-1)=0 or j=ilo
                 if( j==ilo ) then
                    ilazro = .true.
                 else
                    if( abs( h( j, j-1 ) )<=max( safmin, ulp*(abs( h( j, j ) ) + abs( h( j-1, j-1 &
                              ) )) ) ) then
                       h( j, j-1 ) = zero
                       ilazro = .true.
                    else
                       ilazro = .false.
                    end if
                 end if
                 ! test 2: for t(j,j)=0
                 temp = abs ( t( j, j + 1 ) )
                 if ( j > ilo )temp = temp + abs ( t( j - 1, j ) )
                 if( abs( t( j, j ) )<max( safmin,ulp*temp ) ) then
                    t( j, j ) = zero
                    ! test 1a: check for 2 consecutive small subdiagonals in a
                    ilazr2 = .false.
                    if( .not.ilazro ) then
                       temp = abs( h( j, j-1 ) )
                       temp2 = abs( h( j, j ) )
                       tempr = max( temp, temp2 )
                       if( tempr<one .and. tempr/=zero ) then
                          temp = temp / tempr
                          temp2 = temp2 / tempr
                       end if
                       if( temp*( ascale*abs( h( j+1, j ) ) )<=temp2*( ascale*atol ) )ilazr2 = &
                                 .true.
                    end if
                    ! if both tests pass (1
                    ! element of b in the block is zero, split a 1x1 block off
                    ! at the top. (i.e., at the j-th row/column) the leading
                    ! diagonal element of the remainder can also be zero, so
                    ! this may have to be done repeatedly.
                    if( ilazro .or. ilazr2 ) then
                       do jch = j, ilast - 1
                          temp = h( jch, jch )
                          call stdlib_${ri}$lartg( temp, h( jch+1, jch ), c, s,h( jch, jch ) )
                          h( jch+1, jch ) = zero
                          call stdlib_${ri}$rot( ilastm-jch, h( jch, jch+1 ), ldh,h( jch+1, jch+1 ), &
                                    ldh, c, s )
                          call stdlib_${ri}$rot( ilastm-jch, t( jch, jch+1 ), ldt,t( jch+1, jch+1 ), &
                                    ldt, c, s )
                          if( ilq )call stdlib_${ri}$rot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, s )
                                    
                          if( ilazr2 )h( jch, jch-1 ) = h( jch, jch-1 )*c
                          ilazr2 = .false.
                          if( abs( t( jch+1, jch+1 ) )>=btol ) then
                             if( jch+1>=ilast ) then
                                go to 80
                             else
                                ifirst = jch + 1
                                go to 110
                             end if
                          end if
                          t( jch+1, jch+1 ) = zero
                       end do
                       go to 70
                    else
                       ! only test 2 passed -- chase the zero to t(ilast,ilast)
                       ! then process as in the case t(ilast,ilast)=0
                       do jch = j, ilast - 1
                          temp = t( jch, jch+1 )
                          call stdlib_${ri}$lartg( temp, t( jch+1, jch+1 ), c, s,t( jch, jch+1 ) )
                                    
                          t( jch+1, jch+1 ) = zero
                          if( jch<ilastm-1 )call stdlib_${ri}$rot( ilastm-jch-1, t( jch, jch+2 ), ldt,&
                                    t( jch+1, jch+2 ), ldt, c, s )
                          call stdlib_${ri}$rot( ilastm-jch+2, h( jch, jch-1 ), ldh,h( jch+1, jch-1 ), &
                                    ldh, c, s )
                          if( ilq )call stdlib_${ri}$rot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, s )
                                    
                          temp = h( jch+1, jch )
                          call stdlib_${ri}$lartg( temp, h( jch+1, jch-1 ), c, s,h( jch+1, jch ) )
                                    
                          h( jch+1, jch-1 ) = zero
                          call stdlib_${ri}$rot( jch+1-ifrstm, h( ifrstm, jch ), 1,h( ifrstm, jch-1 ), &
                                    1, c, s )
                          call stdlib_${ri}$rot( jch-ifrstm, t( ifrstm, jch ), 1,t( ifrstm, jch-1 ), 1,&
                                     c, s )
                          if( ilz )call stdlib_${ri}$rot( n, z( 1, jch ), 1, z( 1, jch-1 ), 1,c, s )
                                    
                       end do
                       go to 70
                    end if
                 else if( ilazro ) then
                    ! only test 1 passed -- work on j:ilast
                    ifirst = j
                    go to 110
                 end if
                 ! neither test passed -- try next j
              end do loop_60
              ! (drop-through is "impossible")
              info = n + 1
              go to 420
              ! t(ilast,ilast)=0 -- clear h(ilast,ilast-1) to split off a
              ! 1x1 block.
              70 continue
              temp = h( ilast, ilast )
              call stdlib_${ri}$lartg( temp, h( ilast, ilast-1 ), c, s,h( ilast, ilast ) )
              h( ilast, ilast-1 ) = zero
              call stdlib_${ri}$rot( ilast-ifrstm, h( ifrstm, ilast ), 1,h( ifrstm, ilast-1 ), 1, c, s &
                        )
              call stdlib_${ri}$rot( ilast-ifrstm, t( ifrstm, ilast ), 1,t( ifrstm, ilast-1 ), 1, c, s &
                        )
              if( ilz )call stdlib_${ri}$rot( n, z( 1, ilast ), 1, z( 1, ilast-1 ), 1, c, s )
              ! h(ilast,ilast-1)=0 -- standardize b, set alphar, alphai,
                                    ! and beta
                                    80 continue
              if( t( ilast, ilast )<zero ) then
                 if( ilschr ) then
                    do j = ifrstm, ilast
                       h( j, ilast ) = -h( j, ilast )
                       t( j, ilast ) = -t( j, ilast )
                    end do
                 else
                    h( ilast, ilast ) = -h( ilast, ilast )
                    t( ilast, ilast ) = -t( ilast, ilast )
                 end if
                 if( ilz ) then
                    do j = 1, n
                       z( j, ilast ) = -z( j, ilast )
                    end do
                 end if
              end if
              alphar( ilast ) = h( ilast, ilast )
              alphai( ilast ) = zero
              beta( ilast ) = t( ilast, ilast )
              ! go to next block -- exit if finished.
              ilast = ilast - 1
              if( ilast<ilo )go to 380
              ! reset counters
              iiter = 0
              eshift = zero
              if( .not.ilschr ) then
                 ilastm = ilast
                 if( ifrstm>ilast )ifrstm = ilo
              end if
              go to 350
              ! qz step
              ! this iteration only involves rows/columns ifirst:ilast. we
              ! assume ifirst < ilast, and that the diagonal of b is non-zero.
              110 continue
              iiter = iiter + 1
              if( .not.ilschr ) then
                 ifrstm = ifirst
              end if
              ! compute single shifts.
              ! at this point, ifirst < ilast, and the diagonal elements of
              ! t(ifirst:ilast,ifirst,ilast) are larger than btol (in
              ! magnitude)
              if( ( iiter / 10 )*10==iiter ) then
                 ! exceptional shift.  chosen for no particularly good reason.
                 ! (single shift only.)
                 if( ( real( maxit,KIND=${rk}$)*safmin )*abs( h( ilast, ilast-1 ) )<abs( t( ilast-1, &
                           ilast-1 ) ) ) then
                    eshift = h( ilast, ilast-1 ) /t( ilast-1, ilast-1 )
                 else
                    eshift = eshift + one / ( safmin*real( maxit,KIND=${rk}$) )
                 end if
                 s1 = one
                 wr = eshift
              else
                 ! shifts based on the generalized eigenvalues of the
                 ! bottom-right 2x2 block of a and b. the first eigenvalue
                 ! returned by stdlib_${ri}$lag2 is the wilkinson shift (aep p.512_${rk}$),
                 call stdlib_${ri}$lag2( h( ilast-1, ilast-1 ), ldh,t( ilast-1, ilast-1 ), ldt, &
                           safmin*safety, s1,s2, wr, wr2, wi )
                 if ( abs( (wr/s1)*t( ilast, ilast ) - h( ilast, ilast ) )> abs( (wr2/s2)*t( &
                           ilast, ilast )- h( ilast, ilast ) ) ) then
                    temp = wr
                    wr = wr2
                    wr2 = temp
                    temp = s1
                    s1 = s2
                    s2 = temp
                 end if
                 temp = max( s1, safmin*max( one, abs( wr ), abs( wi ) ) )
                 if( wi/=zero )go to 200
              end if
              ! fiddle with shift to avoid overflow
              temp = min( ascale, one )*( half*safmax )
              if( s1>temp ) then
                 scale = temp / s1
              else
                 scale = one
              end if
              temp = min( bscale, one )*( half*safmax )
              if( abs( wr )>temp )scale = min( scale, temp / abs( wr ) )
              s1 = scale*s1
              wr = scale*wr
              ! now check for two consecutive small subdiagonals.
              do j = ilast - 1, ifirst + 1, -1
                 istart = j
                 temp = abs( s1*h( j, j-1 ) )
                 temp2 = abs( s1*h( j, j )-wr*t( j, j ) )
                 tempr = max( temp, temp2 )
                 if( tempr<one .and. tempr/=zero ) then
                    temp = temp / tempr
                    temp2 = temp2 / tempr
                 end if
                 if( abs( ( ascale*h( j+1, j ) )*temp )<=( ascale*atol )*temp2 )go to 130
              end do
              istart = ifirst
              130 continue
              ! do an implicit single-shift qz sweep.
              ! initial q
              temp = s1*h( istart, istart ) - wr*t( istart, istart )
              temp2 = s1*h( istart+1, istart )
              call stdlib_${ri}$lartg( temp, temp2, c, s, tempr )
              ! sweep
              loop_190: do j = istart, ilast - 1
                 if( j>istart ) then
                    temp = h( j, j-1 )
                    call stdlib_${ri}$lartg( temp, h( j+1, j-1 ), c, s, h( j, j-1 ) )
                    h( j+1, j-1 ) = zero
                 end if
                 do jc = j, ilastm
                    temp = c*h( j, jc ) + s*h( j+1, jc )
                    h( j+1, jc ) = -s*h( j, jc ) + c*h( j+1, jc )
                    h( j, jc ) = temp
                    temp2 = c*t( j, jc ) + s*t( j+1, jc )
                    t( j+1, jc ) = -s*t( j, jc ) + c*t( j+1, jc )
                    t( j, jc ) = temp2
                 end do
                 if( ilq ) then
                    do jr = 1, n
                       temp = c*q( jr, j ) + s*q( jr, j+1 )
                       q( jr, j+1 ) = -s*q( jr, j ) + c*q( jr, j+1 )
                       q( jr, j ) = temp
                    end do
                 end if
                 temp = t( j+1, j+1 )
                 call stdlib_${ri}$lartg( temp, t( j+1, j ), c, s, t( j+1, j+1 ) )
                 t( j+1, j ) = zero
                 do jr = ifrstm, min( j+2, ilast )
                    temp = c*h( jr, j+1 ) + s*h( jr, j )
                    h( jr, j ) = -s*h( jr, j+1 ) + c*h( jr, j )
                    h( jr, j+1 ) = temp
                 end do
                 do jr = ifrstm, j
                    temp = c*t( jr, j+1 ) + s*t( jr, j )
                    t( jr, j ) = -s*t( jr, j+1 ) + c*t( jr, j )
                    t( jr, j+1 ) = temp
                 end do
                 if( ilz ) then
                    do jr = 1, n
                       temp = c*z( jr, j+1 ) + s*z( jr, j )
                       z( jr, j ) = -s*z( jr, j+1 ) + c*z( jr, j )
                       z( jr, j+1 ) = temp
                    end do
                 end if
              end do loop_190
              go to 350
              ! use francis double-shift
              ! note: the francis double-shift should work with real shifts,
                    ! but only if the block is at least 3x3.
                    ! this code may break if this point is reached with
                    ! a 2x2 block with real eigenvalues.
                    200 continue
              if( ifirst+1==ilast ) then
                 ! special case -- 2x2 block with complex eigenvectors
                 ! step 1: standardize, that is, rotate so that
                             ! ( b11  0  )
                         ! b = (         )  with b11 non-negative.
                             ! (  0  b22 )
                 call stdlib_${ri}$lasv2( t( ilast-1, ilast-1 ), t( ilast-1, ilast ),t( ilast, ilast ),&
                            b22, b11, sr, cr, sl, cl )
                 if( b11<zero ) then
                    cr = -cr
                    sr = -sr
                    b11 = -b11
                    b22 = -b22
                 end if
                 call stdlib_${ri}$rot( ilastm+1-ifirst, h( ilast-1, ilast-1 ), ldh,h( ilast, ilast-1 )&
                           , ldh, cl, sl )
                 call stdlib_${ri}$rot( ilast+1-ifrstm, h( ifrstm, ilast-1 ), 1,h( ifrstm, ilast ), 1, &
                           cr, sr )
                 if( ilast<ilastm )call stdlib_${ri}$rot( ilastm-ilast, t( ilast-1, ilast+1 ), ldt,t( &
                           ilast, ilast+1 ), ldt, cl, sl )
                 if( ifrstm<ilast-1 )call stdlib_${ri}$rot( ifirst-ifrstm, t( ifrstm, ilast-1 ), 1,t( &
                           ifrstm, ilast ), 1, cr, sr )
                 if( ilq )call stdlib_${ri}$rot( n, q( 1, ilast-1 ), 1, q( 1, ilast ), 1, cl,sl )
                           
                 if( ilz )call stdlib_${ri}$rot( n, z( 1, ilast-1 ), 1, z( 1, ilast ), 1, cr,sr )
                           
                 t( ilast-1, ilast-1 ) = b11
                 t( ilast-1, ilast ) = zero
                 t( ilast, ilast-1 ) = zero
                 t( ilast, ilast ) = b22
                 ! if b22 is negative, negate column ilast
                 if( b22<zero ) then
                    do j = ifrstm, ilast
                       h( j, ilast ) = -h( j, ilast )
                       t( j, ilast ) = -t( j, ilast )
                    end do
                    if( ilz ) then
                       do j = 1, n
                          z( j, ilast ) = -z( j, ilast )
                       end do
                    end if
                    b22 = -b22
                 end if
                 ! step 2: compute alphar, alphai, and beta (see refs.)
                 ! recompute shift
                 call stdlib_${ri}$lag2( h( ilast-1, ilast-1 ), ldh,t( ilast-1, ilast-1 ), ldt, &
                           safmin*safety, s1,temp, wr, temp2, wi )
                 ! if standardization has perturbed the shift onto real line,
                 ! do another (real single-shift) qr step.
                 if( wi==zero )go to 350
                 s1inv = one / s1
                 ! do eispack (qzval) computation of alpha and beta
                 a11 = h( ilast-1, ilast-1 )
                 a21 = h( ilast, ilast-1 )
                 a12 = h( ilast-1, ilast )
                 a22 = h( ilast, ilast )
                 ! compute complex givens rotation on right
                 ! (assume some element of c = (sa - wb) > unfl )
                                  ! __
                 ! (sa - wb) ( cz   -sz )
                           ! ( sz    cz )
                 c11r = s1*a11 - wr*b11
                 c11i = -wi*b11
                 c12 = s1*a12
                 c21 = s1*a21
                 c22r = s1*a22 - wr*b22
                 c22i = -wi*b22
                 if( abs( c11r )+abs( c11i )+abs( c12 )>abs( c21 )+abs( c22r )+abs( c22i ) ) &
                           then
                    t1 = stdlib_${ri}$lapy3( c12, c11r, c11i )
                    cz = c12 / t1
                    szr = -c11r / t1
                    szi = -c11i / t1
                 else
                    cz = stdlib_${ri}$lapy2( c22r, c22i )
                    if( cz<=safmin ) then
                       cz = zero
                       szr = one
                       szi = zero
                    else
                       tempr = c22r / cz
                       tempi = c22i / cz
                       t1 = stdlib_${ri}$lapy2( cz, c21 )
                       cz = cz / t1
                       szr = -c21*tempr / t1
                       szi = c21*tempi / t1
                    end if
                 end if
                 ! compute givens rotation on left
                 ! (  cq   sq )
                 ! (  __      )  a or b
                 ! ( -sq   cq )
                 an = abs( a11 ) + abs( a12 ) + abs( a21 ) + abs( a22 )
                 bn = abs( b11 ) + abs( b22 )
                 wabs = abs( wr ) + abs( wi )
                 if( s1*an>wabs*bn ) then
                    cq = cz*b11
                    sqr = szr*b22
                    sqi = -szi*b22
                 else
                    a1r = cz*a11 + szr*a12
                    a1i = szi*a12
                    a2r = cz*a21 + szr*a22
                    a2i = szi*a22
                    cq = stdlib_${ri}$lapy2( a1r, a1i )
                    if( cq<=safmin ) then
                       cq = zero
                       sqr = one
                       sqi = zero
                    else
                       tempr = a1r / cq
                       tempi = a1i / cq
                       sqr = tempr*a2r + tempi*a2i
                       sqi = tempi*a2r - tempr*a2i
                    end if
                 end if
                 t1 = stdlib_${ri}$lapy3( cq, sqr, sqi )
                 cq = cq / t1
                 sqr = sqr / t1
                 sqi = sqi / t1
                 ! compute diagonal elements of qbz
                 tempr = sqr*szr - sqi*szi
                 tempi = sqr*szi + sqi*szr
                 b1r = cq*cz*b11 + tempr*b22
                 b1i = tempi*b22
                 b1a = stdlib_${ri}$lapy2( b1r, b1i )
                 b2r = cq*cz*b22 + tempr*b11
                 b2i = -tempi*b11
                 b2a = stdlib_${ri}$lapy2( b2r, b2i )
                 ! normalize so beta > 0, and im( alpha1 ) > 0
                 beta( ilast-1 ) = b1a
                 beta( ilast ) = b2a
                 alphar( ilast-1 ) = ( wr*b1a )*s1inv
                 alphai( ilast-1 ) = ( wi*b1a )*s1inv
                 alphar( ilast ) = ( wr*b2a )*s1inv
                 alphai( ilast ) = -( wi*b2a )*s1inv
                 ! step 3: go to next block -- exit if finished.
                 ilast = ifirst - 1
                 if( ilast<ilo )go to 380
                 ! reset counters
                 iiter = 0
                 eshift = zero
                 if( .not.ilschr ) then
                    ilastm = ilast
                    if( ifrstm>ilast )ifrstm = ilo
                 end if
                 go to 350
              else
                 ! usual case: 3x3 or larger block, using francis implicit
                             ! double-shift
                                          ! 2
                 ! eigenvalue equation is  w  - c w + d = 0,
                                               ! -1 2        -1
                 ! so compute 1st column of  (a b  )  - c a b   + d
                 ! using the formula in qzit (from eispack)
                 ! we assume that the block is at least 3x3
                 ad11 = ( ascale*h( ilast-1, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad21 = ( ascale*h( ilast, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad12 = ( ascale*h( ilast-1, ilast ) ) /( bscale*t( ilast, ilast ) )
                 ad22 = ( ascale*h( ilast, ilast ) ) /( bscale*t( ilast, ilast ) )
                 u12 = t( ilast-1, ilast ) / t( ilast, ilast )
                 ad11l = ( ascale*h( ifirst, ifirst ) ) /( bscale*t( ifirst, ifirst ) )
                 ad21l = ( ascale*h( ifirst+1, ifirst ) ) /( bscale*t( ifirst, ifirst ) )
                 ad12l = ( ascale*h( ifirst, ifirst+1 ) ) /( bscale*t( ifirst+1, ifirst+1 ) )
                           
                 ad22l = ( ascale*h( ifirst+1, ifirst+1 ) ) /( bscale*t( ifirst+1, ifirst+1 ) )
                           
                 ad32l = ( ascale*h( ifirst+2, ifirst+1 ) ) /( bscale*t( ifirst+1, ifirst+1 ) )
                           
                 u12l = t( ifirst, ifirst+1 ) / t( ifirst+1, ifirst+1 )
                 v( 1 ) = ( ad11-ad11l )*( ad22-ad11l ) - ad12*ad21 +ad21*u12*ad11l + ( ad12l-&
                           ad11l*u12l )*ad21l
                 v( 2 ) = ( ( ad22l-ad11l )-ad21l*u12l-( ad11-ad11l )-( ad22-ad11l )+ad21*u12 )&
                           *ad21l
                 v( 3 ) = ad32l*ad21l
                 istart = ifirst
                 call stdlib_${ri}$larfg( 3, v( 1 ), v( 2 ), 1, tau )
                 v( 1 ) = one
                 ! sweep
                 loop_290: do j = istart, ilast - 2
                    ! all but last elements: use 3x3 householder transforms.
                    ! zero (j-1)st column of a
                    if( j>istart ) then
                       v( 1 ) = h( j, j-1 )
                       v( 2 ) = h( j+1, j-1 )
                       v( 3 ) = h( j+2, j-1 )
                       call stdlib_${ri}$larfg( 3, h( j, j-1 ), v( 2 ), 1, tau )
                       v( 1 ) = one
                       h( j+1, j-1 ) = zero
                       h( j+2, j-1 ) = zero
                    end if
                    do jc = j, ilastm
                       temp = tau*( h( j, jc )+v( 2 )*h( j+1, jc )+v( 3 )*h( j+2, jc ) )
                       h( j, jc ) = h( j, jc ) - temp
                       h( j+1, jc ) = h( j+1, jc ) - temp*v( 2 )
                       h( j+2, jc ) = h( j+2, jc ) - temp*v( 3 )
                       temp2 = tau*( t( j, jc )+v( 2 )*t( j+1, jc )+v( 3 )*t( j+2, jc ) )
                       t( j, jc ) = t( j, jc ) - temp2
                       t( j+1, jc ) = t( j+1, jc ) - temp2*v( 2 )
                       t( j+2, jc ) = t( j+2, jc ) - temp2*v( 3 )
                    end do
                    if( ilq ) then
                       do jr = 1, n
                          temp = tau*( q( jr, j )+v( 2 )*q( jr, j+1 )+v( 3 )*q( jr, j+2 ) )
                                    
                          q( jr, j ) = q( jr, j ) - temp
                          q( jr, j+1 ) = q( jr, j+1 ) - temp*v( 2 )
                          q( jr, j+2 ) = q( jr, j+2 ) - temp*v( 3 )
                       end do
                    end if
                    ! zero j-th column of b (see dlagbc for details)
                    ! swap rows to pivot
                    ilpivt = .false.
                    temp = max( abs( t( j+1, j+1 ) ), abs( t( j+1, j+2 ) ) )
                    temp2 = max( abs( t( j+2, j+1 ) ), abs( t( j+2, j+2 ) ) )
                    if( max( temp, temp2 )<safmin ) then
                       scale = zero
                       u1 = one
                       u2 = zero
                       go to 250
                    else if( temp>=temp2 ) then
                       w11 = t( j+1, j+1 )
                       w21 = t( j+2, j+1 )
                       w12 = t( j+1, j+2 )
                       w22 = t( j+2, j+2 )
                       u1 = t( j+1, j )
                       u2 = t( j+2, j )
                    else
                       w21 = t( j+1, j+1 )
                       w11 = t( j+2, j+1 )
                       w22 = t( j+1, j+2 )
                       w12 = t( j+2, j+2 )
                       u2 = t( j+1, j )
                       u1 = t( j+2, j )
                    end if
                    ! swap columns if nec.
                    if( abs( w12 )>abs( w11 ) ) then
                       ilpivt = .true.
                       temp = w12
                       temp2 = w22
                       w12 = w11
                       w22 = w21
                       w11 = temp
                       w21 = temp2
                    end if
                    ! lu-factor
                    temp = w21 / w11
                    u2 = u2 - temp*u1
                    w22 = w22 - temp*w12
                    w21 = zero
                    ! compute scale
                    scale = one
                    if( abs( w22 )<safmin ) then
                       scale = zero
                       u2 = one
                       u1 = -w12 / w11
                       go to 250
                    end if
                    if( abs( w22 )<abs( u2 ) )scale = abs( w22 / u2 )
                    if( abs( w11 )<abs( u1 ) )scale = min( scale, abs( w11 / u1 ) )
                    ! solve
                    u2 = ( scale*u2 ) / w22
                    u1 = ( scale*u1-w12*u2 ) / w11
                    250 continue
                    if( ilpivt ) then
                       temp = u2
                       u2 = u1
                       u1 = temp
                    end if
                    ! compute householder vector
                    t1 = sqrt( scale**2+u1**2+u2**2 )
                    tau = one + scale / t1
                    vs = -one / ( scale+t1 )
                    v( 1 ) = one
                    v( 2 ) = vs*u1
                    v( 3 ) = vs*u2
                    ! apply transformations from the right.
                    do jr = ifrstm, min( j+3, ilast )
                       temp = tau*( h( jr, j )+v( 2 )*h( jr, j+1 )+v( 3 )*h( jr, j+2 ) )
                       h( jr, j ) = h( jr, j ) - temp
                       h( jr, j+1 ) = h( jr, j+1 ) - temp*v( 2 )
                       h( jr, j+2 ) = h( jr, j+2 ) - temp*v( 3 )
                    end do
                    do jr = ifrstm, j + 2
                       temp = tau*( t( jr, j )+v( 2 )*t( jr, j+1 )+v( 3 )*t( jr, j+2 ) )
                       t( jr, j ) = t( jr, j ) - temp
                       t( jr, j+1 ) = t( jr, j+1 ) - temp*v( 2 )
                       t( jr, j+2 ) = t( jr, j+2 ) - temp*v( 3 )
                    end do
                    if( ilz ) then
                       do jr = 1, n
                          temp = tau*( z( jr, j )+v( 2 )*z( jr, j+1 )+v( 3 )*z( jr, j+2 ) )
                                    
                          z( jr, j ) = z( jr, j ) - temp
                          z( jr, j+1 ) = z( jr, j+1 ) - temp*v( 2 )
                          z( jr, j+2 ) = z( jr, j+2 ) - temp*v( 3 )
                       end do
                    end if
                    t( j+1, j ) = zero
                    t( j+2, j ) = zero
                 end do loop_290
                 ! last elements: use givens rotations
                 ! rotations from the left
                 j = ilast - 1
                 temp = h( j, j-1 )
                 call stdlib_${ri}$lartg( temp, h( j+1, j-1 ), c, s, h( j, j-1 ) )
                 h( j+1, j-1 ) = zero
                 do jc = j, ilastm
                    temp = c*h( j, jc ) + s*h( j+1, jc )
                    h( j+1, jc ) = -s*h( j, jc ) + c*h( j+1, jc )
                    h( j, jc ) = temp
                    temp2 = c*t( j, jc ) + s*t( j+1, jc )
                    t( j+1, jc ) = -s*t( j, jc ) + c*t( j+1, jc )
                    t( j, jc ) = temp2
                 end do
                 if( ilq ) then
                    do jr = 1, n
                       temp = c*q( jr, j ) + s*q( jr, j+1 )
                       q( jr, j+1 ) = -s*q( jr, j ) + c*q( jr, j+1 )
                       q( jr, j ) = temp
                    end do
                 end if
                 ! rotations from the right.
                 temp = t( j+1, j+1 )
                 call stdlib_${ri}$lartg( temp, t( j+1, j ), c, s, t( j+1, j+1 ) )
                 t( j+1, j ) = zero
                 do jr = ifrstm, ilast
                    temp = c*h( jr, j+1 ) + s*h( jr, j )
                    h( jr, j ) = -s*h( jr, j+1 ) + c*h( jr, j )
                    h( jr, j+1 ) = temp
                 end do
                 do jr = ifrstm, ilast - 1
                    temp = c*t( jr, j+1 ) + s*t( jr, j )
                    t( jr, j ) = -s*t( jr, j+1 ) + c*t( jr, j )
                    t( jr, j+1 ) = temp
                 end do
                 if( ilz ) then
                    do jr = 1, n
                       temp = c*z( jr, j+1 ) + s*z( jr, j )
                       z( jr, j ) = -s*z( jr, j+1 ) + c*z( jr, j )
                       z( jr, j+1 ) = temp
                    end do
                 end if
                 ! end of double-shift code
              end if
              go to 350
              ! end of iteration loop
              350 continue
           end do loop_360
           ! drop-through = non-convergence
           info = ilast
           go to 420
           ! successful completion of all qz steps
           380 continue
           ! set eigenvalues 1:ilo-1
           do j = 1, ilo - 1
              if( t( j, j )<zero ) then
                 if( ilschr ) then
                    do jr = 1, j
                       h( jr, j ) = -h( jr, j )
                       t( jr, j ) = -t( jr, j )
                    end do
                 else
                    h( j, j ) = -h( j, j )
                    t( j, j ) = -t( j, j )
                 end if
                 if( ilz ) then
                    do jr = 1, n
                       z( jr, j ) = -z( jr, j )
                    end do
                 end if
              end if
              alphar( j ) = h( j, j )
              alphai( j ) = zero
              beta( j ) = t( j, j )
           end do
           ! normal termination
           info = 0
           ! exit (other than argument error) -- return optimal workspace size
           420 continue
           work( 1 ) = real( n,KIND=${rk}$)
           return
     end subroutine stdlib_${ri}$hgeqz

#:endif
#:endfor

     module subroutine stdlib_chgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alpha, beta, q, ldq,&
     !! CHGEQZ computes the eigenvalues of a complex matrix pair (H,T),
     !! where H is an upper Hessenberg matrix and T is upper triangular,
     !! using the single-shift QZ method.
     !! Matrix pairs of this type are produced by the reduction to
     !! generalized upper Hessenberg form of a complex matrix pair (A,B):
     !! A = Q1*H*Z1**H,  B = Q1*T*Z1**H,
     !! as computed by CGGHRD.
     !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
     !! also reduced to generalized Schur form,
     !! H = Q*S*Z**H,  T = Q*P*Z**H,
     !! where Q and Z are unitary matrices and S and P are upper triangular.
     !! Optionally, the unitary matrix Q from the generalized Schur
     !! factorization may be postmultiplied into an input matrix Q1, and the
     !! unitary matrix Z may be postmultiplied into an input matrix Z1.
     !! If Q1 and Z1 are the unitary matrices from CGGHRD that reduced
     !! the matrix pair (A,B) to generalized Hessenberg form, then the output
     !! matrices Q1*Q and Z1*Z are the unitary factors from the generalized
     !! Schur factorization of (A,B):
     !! A = (Q1*Q)*S*(Z1*Z)**H,  B = (Q1*Q)*P*(Z1*Z)**H.
     !! To avoid overflow, eigenvalues of the matrix pair (H,T)
     !! (equivalently, of (A,B)) are computed as a pair of complex values
     !! (alpha,beta).  If beta is nonzero, lambda = alpha / beta is an
     !! eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP)
     !! A*x = lambda*B*x
     !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     !! alternate form of the GNEP
     !! mu*A*y = B*y.
     !! The values of alpha and beta for the i-th eigenvalue can be read
     !! directly from the generalized Schur form:  alpha = S(i,i),
     !! beta = P(i,i).
     !! Ref: C.B. Moler
     !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
     !! pp. 241--256.
                z, ldz, work, lwork,rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz, job
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldq, ldt, ldz, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(out) :: alpha(*), beta(*), work(*)
           complex(sp), intent(inout) :: h(ldh,*), q(ldq,*), t(ldt,*), z(ldz,*)
        ! =====================================================================
           
           
           
           ! Local Scalars 
           logical(lk) :: ilazr2, ilazro, ilq, ilschr, ilz, lquery
           integer(ilp) :: icompq, icompz, ifirst, ifrstm, iiter, ilast, ilastm, in, ischur, &
                     istart, j, jc, jch, jiter, jr, maxit
           real(sp) :: absb, anorm, ascale, atol, bnorm, bscale, btol, c, safmin, temp, temp2, &
                     tempr, ulp
           complex(sp) :: abi22, ad11, ad12, ad21, ad22, ctemp, ctemp2, ctemp3, eshift, s, shift, &
                     signbc, u12, x, abi12, y
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=sp) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode job, compq, compz
           if( stdlib_lsame( job, 'E' ) ) then
              ilschr = .false.
              ischur = 1
           else if( stdlib_lsame( job, 'S' ) ) then
              ilschr = .true.
              ischur = 2
           else
              ilschr = .true.
              ischur = 0
           end if
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              ilq = .true.
              icompq = 0
           end if
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              ilz = .true.
              icompz = 0
           end if
           ! check argument values
           info = 0
           work( 1 ) = max( 1, n )
           lquery = ( lwork==-1 )
           if( ischur==0 ) then
              info = -1
           else if( icompq==0 ) then
              info = -2
           else if( icompz==0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 ) then
              info = -5
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -6
           else if( ldh<n ) then
              info = -8
           else if( ldt<n ) then
              info = -10
           else if( ldq<1 .or. ( ilq .and. ldq<n ) ) then
              info = -14
           else if( ldz<1 .or. ( ilz .and. ldz<n ) ) then
              info = -16
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -18
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHGEQZ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           ! work( 1 ) = cmplx( 1,KIND=sp)
           if( n<=0 ) then
              work( 1 ) = cmplx( 1,KIND=sp)
              return
           end if
           ! initialize q and z
           if( icompq==3 )call stdlib_claset( 'FULL', n, n, czero, cone, q, ldq )
           if( icompz==3 )call stdlib_claset( 'FULL', n, n, czero, cone, z, ldz )
           ! machine constants
           in = ihi + 1 - ilo
           safmin = stdlib_slamch( 'S' )
           ulp = stdlib_slamch( 'E' )*stdlib_slamch( 'B' )
           anorm = stdlib_clanhs( 'F', in, h( ilo, ilo ), ldh, rwork )
           bnorm = stdlib_clanhs( 'F', in, t( ilo, ilo ), ldt, rwork )
           atol = max( safmin, ulp*anorm )
           btol = max( safmin, ulp*bnorm )
           ascale = one / max( safmin, anorm )
           bscale = one / max( safmin, bnorm )
           ! set eigenvalues ihi+1:n
           do j = ihi + 1, n
              absb = abs( t( j, j ) )
              if( absb>safmin ) then
                 signbc = conjg( t( j, j ) / absb )
                 t( j, j ) = absb
                 if( ilschr ) then
                    call stdlib_cscal( j-1, signbc, t( 1, j ), 1 )
                    call stdlib_cscal( j, signbc, h( 1, j ), 1 )
                 else
                    call stdlib_cscal( 1, signbc, h( j, j ), 1 )
                 end if
                 if( ilz )call stdlib_cscal( n, signbc, z( 1, j ), 1 )
              else
                 t( j, j ) = czero
              end if
              alpha( j ) = h( j, j )
              beta( j ) = t( j, j )
           end do
           ! if ihi < ilo, skip qz steps
           if( ihi<ilo )go to 190
           ! main qz iteration loop
           ! initialize dynamic indices
           ! eigenvalues ilast+1:n have been found.
              ! column operations modify rows ifrstm:whatever
              ! row operations modify columns whatever:ilastm
           ! if only eigenvalues are being computed, then
              ! ifrstm is the row of the last splitting row above row ilast;
              ! this is always at least ilo.
           ! iiter counts iterations since the last eigenvalue was found,
              ! to tell when to use an extraordinary shift.
           ! maxit is the maximum number of qz sweeps allowed.
           ilast = ihi
           if( ilschr ) then
              ifrstm = 1
              ilastm = n
           else
              ifrstm = ilo
              ilastm = ihi
           end if
           iiter = 0
           eshift = czero
           maxit = 30*( ihi-ilo+1 )
           loop_170: do jiter = 1, maxit
              ! check for too many iterations.
              if( jiter>maxit )go to 180
              ! split the matrix if possible.
              ! two tests:
                 ! 1: h(j,j-1)=0  or  j=ilo
                 ! 2: t(j,j)=0
              ! special case: j=ilast
              if( ilast==ilo ) then
                 go to 60
              else
                 if( abs1( h( ilast, ilast-1 ) )<=max( safmin, ulp*(abs1( h( ilast, ilast ) ) + &
                           abs1( h( ilast-1, ilast-1 )) ) ) ) then
                    h( ilast, ilast-1 ) = czero
                    go to 60
                 end if
              end if
              if( abs( t( ilast, ilast ) )<=max( safmin, ulp*(abs( t( ilast - 1, ilast ) ) + abs( &
                        t( ilast-1, ilast-1 )) ) ) ) then
                 t( ilast, ilast ) = czero
                 go to 50
              end if
              ! general case: j<ilast
              loop_40: do j = ilast - 1, ilo, -1
                 ! test 1: for h(j,j-1)=0 or j=ilo
                 if( j==ilo ) then
                    ilazro = .true.
                 else
                    if( abs1( h( j, j-1 ) )<=max( safmin, ulp*(abs1( h( j, j ) ) + abs1( h( j-1, &
                              j-1 ) )) ) ) then
                       h( j, j-1 ) = czero
                       ilazro = .true.
                    else
                       ilazro = .false.
                    end if
                 end if
                 ! test 2: for t(j,j)=0
                 temp = abs ( t( j, j + 1 ) )
                 if ( j > ilo )temp = temp + abs ( t( j - 1, j ) )
                 if( abs( t( j, j ) )<max( safmin,ulp*temp ) ) then
                    t( j, j ) = czero
                    ! test 1a: check for 2 consecutive small subdiagonals in a
                    ilazr2 = .false.
                    if( .not.ilazro ) then
                       if( abs1( h( j, j-1 ) )*( ascale*abs1( h( j+1,j ) ) )<=abs1( h( j, j ) )*( &
                                 ascale*atol ) )ilazr2 = .true.
                    end if
                    ! if both tests pass (1
                    ! element of b in the block is zero, split a 1x1 block off
                    ! at the top. (i.e., at the j-th row/column) the leading
                    ! diagonal element of the remainder can also be zero, so
                    ! this may have to be done repeatedly.
                    if( ilazro .or. ilazr2 ) then
                       do jch = j, ilast - 1
                          ctemp = h( jch, jch )
                          call stdlib_clartg( ctemp, h( jch+1, jch ), c, s,h( jch, jch ) )
                          h( jch+1, jch ) = czero
                          call stdlib_crot( ilastm-jch, h( jch, jch+1 ), ldh,h( jch+1, jch+1 ), &
                                    ldh, c, s )
                          call stdlib_crot( ilastm-jch, t( jch, jch+1 ), ldt,t( jch+1, jch+1 ), &
                                    ldt, c, s )
                          if( ilq )call stdlib_crot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, conjg(&
                                     s ) )
                          if( ilazr2 )h( jch, jch-1 ) = h( jch, jch-1 )*c
                          ilazr2 = .false.
                          if( abs1( t( jch+1, jch+1 ) )>=btol ) then
                             if( jch+1>=ilast ) then
                                go to 60
                             else
                                ifirst = jch + 1
                                go to 70
                             end if
                          end if
                          t( jch+1, jch+1 ) = czero
                       end do
                       go to 50
                    else
                       ! only test 2 passed -- chase the zero to t(ilast,ilast)
                       ! then process as in the case t(ilast,ilast)=0
                       do jch = j, ilast - 1
                          ctemp = t( jch, jch+1 )
                          call stdlib_clartg( ctemp, t( jch+1, jch+1 ), c, s,t( jch, jch+1 ) )
                                    
                          t( jch+1, jch+1 ) = czero
                          if( jch<ilastm-1 )call stdlib_crot( ilastm-jch-1, t( jch, jch+2 ), ldt,&
                                    t( jch+1, jch+2 ), ldt, c, s )
                          call stdlib_crot( ilastm-jch+2, h( jch, jch-1 ), ldh,h( jch+1, jch-1 ), &
                                    ldh, c, s )
                          if( ilq )call stdlib_crot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, conjg(&
                                     s ) )
                          ctemp = h( jch+1, jch )
                          call stdlib_clartg( ctemp, h( jch+1, jch-1 ), c, s,h( jch+1, jch ) )
                                    
                          h( jch+1, jch-1 ) = czero
                          call stdlib_crot( jch+1-ifrstm, h( ifrstm, jch ), 1,h( ifrstm, jch-1 ), &
                                    1, c, s )
                          call stdlib_crot( jch-ifrstm, t( ifrstm, jch ), 1,t( ifrstm, jch-1 ), 1,&
                                     c, s )
                          if( ilz )call stdlib_crot( n, z( 1, jch ), 1, z( 1, jch-1 ), 1,c, s )
                                    
                       end do
                       go to 50
                    end if
                 else if( ilazro ) then
                    ! only test 1 passed -- work on j:ilast
                    ifirst = j
                    go to 70
                 end if
                 ! neither test passed -- try next j
              end do loop_40
              ! (drop-through is "impossible")
              info = 2*n + 1
              go to 210
              ! t(ilast,ilast)=0 -- clear h(ilast,ilast-1) to split off a
              ! 1x1 block.
              50 continue
              ctemp = h( ilast, ilast )
              call stdlib_clartg( ctemp, h( ilast, ilast-1 ), c, s,h( ilast, ilast ) )
              h( ilast, ilast-1 ) = czero
              call stdlib_crot( ilast-ifrstm, h( ifrstm, ilast ), 1,h( ifrstm, ilast-1 ), 1, c, s &
                        )
              call stdlib_crot( ilast-ifrstm, t( ifrstm, ilast ), 1,t( ifrstm, ilast-1 ), 1, c, s &
                        )
              if( ilz )call stdlib_crot( n, z( 1, ilast ), 1, z( 1, ilast-1 ), 1, c, s )
              ! h(ilast,ilast-1)=0 -- standardize b, set alpha and beta
              60 continue
              absb = abs( t( ilast, ilast ) )
              if( absb>safmin ) then
                 signbc = conjg( t( ilast, ilast ) / absb )
                 t( ilast, ilast ) = absb
                 if( ilschr ) then
                    call stdlib_cscal( ilast-ifrstm, signbc, t( ifrstm, ilast ), 1 )
                    call stdlib_cscal( ilast+1-ifrstm, signbc, h( ifrstm, ilast ),1 )
                 else
                    call stdlib_cscal( 1, signbc, h( ilast, ilast ), 1 )
                 end if
                 if( ilz )call stdlib_cscal( n, signbc, z( 1, ilast ), 1 )
              else
                 t( ilast, ilast ) = czero
              end if
              alpha( ilast ) = h( ilast, ilast )
              beta( ilast ) = t( ilast, ilast )
              ! go to next block -- exit if finished.
              ilast = ilast - 1
              if( ilast<ilo )go to 190
              ! reset counters
              iiter = 0
              eshift = czero
              if( .not.ilschr ) then
                 ilastm = ilast
                 if( ifrstm>ilast )ifrstm = ilo
              end if
              go to 160
              ! qz step
              ! this iteration only involves rows/columns ifirst:ilast.  we
              ! assume ifirst < ilast, and that the diagonal of b is non-zero.
              70 continue
              iiter = iiter + 1
              if( .not.ilschr ) then
                 ifrstm = ifirst
              end if
              ! compute the shift.
              ! at this point, ifirst < ilast, and the diagonal elements of
              ! t(ifirst:ilast,ifirst,ilast) are larger than btol (in
              ! magnitude)
              if( ( iiter / 10 )*10/=iiter ) then
                 ! the wilkinson shift (aep p.512_sp), i.e., the eigenvalue of
                 ! the bottom-right 2x2 block of a inv(b) which is nearest to
                 ! the bottom-right element.
                 ! we factor b as u*d, where u has unit diagonals, and
                 ! compute (a*inv(d))*inv(u).
                 u12 = ( bscale*t( ilast-1, ilast ) ) /( bscale*t( ilast, ilast ) )
                 ad11 = ( ascale*h( ilast-1, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad21 = ( ascale*h( ilast, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad12 = ( ascale*h( ilast-1, ilast ) ) /( bscale*t( ilast, ilast ) )
                 ad22 = ( ascale*h( ilast, ilast ) ) /( bscale*t( ilast, ilast ) )
                 abi22 = ad22 - u12*ad21
                 abi12 = ad12 - u12*ad11
                 shift = abi22
                 ctemp = sqrt( abi12 )*sqrt( ad21 )
                 temp = abs1( ctemp )
                 if( ctemp/=zero ) then
                    x = half*( ad11-shift )
                    temp2 = abs1( x )
                    temp = max( temp, abs1( x ) )
                    y = temp*sqrt( ( x / temp )**2+( ctemp / temp )**2 )
                    if( temp2>zero ) then
                       if( real( x / temp2,KIND=sp)*real( y,KIND=sp)+aimag( x / temp2 )*aimag( y )&
                                 <zero )y = -y
                    end if
                    shift = shift - ctemp*stdlib_cladiv( ctemp, ( x+y ) )
                 end if
              else
                 ! exceptional shift.  chosen for no particularly good reason.
                 if( ( iiter / 20 )*20==iiter .and.bscale*abs1(t( ilast, ilast ))>safmin ) &
                           then
                    eshift = eshift + ( ascale*h( ilast,ilast ) )/( bscale*t( ilast, ilast ) )
                              
                 else
                    eshift = eshift + ( ascale*h( ilast,ilast-1 ) )/( bscale*t( ilast-1, ilast-1 )&
                               )
                 end if
                 shift = eshift
              end if
              ! now check for two consecutive small subdiagonals.
              do j = ilast - 1, ifirst + 1, -1
                 istart = j
                 ctemp = ascale*h( j, j ) - shift*( bscale*t( j, j ) )
                 temp = abs1( ctemp )
                 temp2 = ascale*abs1( h( j+1, j ) )
                 tempr = max( temp, temp2 )
                 if( tempr<one .and. tempr/=zero ) then
                    temp = temp / tempr
                    temp2 = temp2 / tempr
                 end if
                 if( abs1( h( j, j-1 ) )*temp2<=temp*atol )go to 90
              end do
              istart = ifirst
              ctemp = ascale*h( ifirst, ifirst ) -shift*( bscale*t( ifirst, ifirst ) )
              90 continue
              ! do an implicit-shift qz sweep.
              ! initial q
              ctemp2 = ascale*h( istart+1, istart )
              call stdlib_clartg( ctemp, ctemp2, c, s, ctemp3 )
              ! sweep
              loop_150: do j = istart, ilast - 1
                 if( j>istart ) then
                    ctemp = h( j, j-1 )
                    call stdlib_clartg( ctemp, h( j+1, j-1 ), c, s, h( j, j-1 ) )
                    h( j+1, j-1 ) = czero
                 end if
                 do jc = j, ilastm
                    ctemp = c*h( j, jc ) + s*h( j+1, jc )
                    h( j+1, jc ) = -conjg( s )*h( j, jc ) + c*h( j+1, jc )
                    h( j, jc ) = ctemp
                    ctemp2 = c*t( j, jc ) + s*t( j+1, jc )
                    t( j+1, jc ) = -conjg( s )*t( j, jc ) + c*t( j+1, jc )
                    t( j, jc ) = ctemp2
                 end do
                 if( ilq ) then
                    do jr = 1, n
                       ctemp = c*q( jr, j ) + conjg( s )*q( jr, j+1 )
                       q( jr, j+1 ) = -s*q( jr, j ) + c*q( jr, j+1 )
                       q( jr, j ) = ctemp
                    end do
                 end if
                 ctemp = t( j+1, j+1 )
                 call stdlib_clartg( ctemp, t( j+1, j ), c, s, t( j+1, j+1 ) )
                 t( j+1, j ) = czero
                 do jr = ifrstm, min( j+2, ilast )
                    ctemp = c*h( jr, j+1 ) + s*h( jr, j )
                    h( jr, j ) = -conjg( s )*h( jr, j+1 ) + c*h( jr, j )
                    h( jr, j+1 ) = ctemp
                 end do
                 do jr = ifrstm, j
                    ctemp = c*t( jr, j+1 ) + s*t( jr, j )
                    t( jr, j ) = -conjg( s )*t( jr, j+1 ) + c*t( jr, j )
                    t( jr, j+1 ) = ctemp
                 end do
                 if( ilz ) then
                    do jr = 1, n
                       ctemp = c*z( jr, j+1 ) + s*z( jr, j )
                       z( jr, j ) = -conjg( s )*z( jr, j+1 ) + c*z( jr, j )
                       z( jr, j+1 ) = ctemp
                    end do
                 end if
              end do loop_150
              160 continue
           end do loop_170
           ! drop-through = non-convergence
           180 continue
           info = ilast
           go to 210
           ! successful completion of all qz steps
           190 continue
           ! set eigenvalues 1:ilo-1
           do j = 1, ilo - 1
              absb = abs( t( j, j ) )
              if( absb>safmin ) then
                 signbc = conjg( t( j, j ) / absb )
                 t( j, j ) = absb
                 if( ilschr ) then
                    call stdlib_cscal( j-1, signbc, t( 1, j ), 1 )
                    call stdlib_cscal( j, signbc, h( 1, j ), 1 )
                 else
                    call stdlib_cscal( 1, signbc, h( j, j ), 1 )
                 end if
                 if( ilz )call stdlib_cscal( n, signbc, z( 1, j ), 1 )
              else
                 t( j, j ) = czero
              end if
              alpha( j ) = h( j, j )
              beta( j ) = t( j, j )
           end do
           ! normal termination
           info = 0
           ! exit (other than argument error) -- return optimal workspace size
           210 continue
           work( 1 ) = cmplx( n,KIND=sp)
           return
     end subroutine stdlib_chgeqz

     module subroutine stdlib_zhgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alpha, beta, q, ldq,&
     !! ZHGEQZ computes the eigenvalues of a complex matrix pair (H,T),
     !! where H is an upper Hessenberg matrix and T is upper triangular,
     !! using the single-shift QZ method.
     !! Matrix pairs of this type are produced by the reduction to
     !! generalized upper Hessenberg form of a complex matrix pair (A,B):
     !! A = Q1*H*Z1**H,  B = Q1*T*Z1**H,
     !! as computed by ZGGHRD.
     !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
     !! also reduced to generalized Schur form,
     !! H = Q*S*Z**H,  T = Q*P*Z**H,
     !! where Q and Z are unitary matrices and S and P are upper triangular.
     !! Optionally, the unitary matrix Q from the generalized Schur
     !! factorization may be postmultiplied into an input matrix Q1, and the
     !! unitary matrix Z may be postmultiplied into an input matrix Z1.
     !! If Q1 and Z1 are the unitary matrices from ZGGHRD that reduced
     !! the matrix pair (A,B) to generalized Hessenberg form, then the output
     !! matrices Q1*Q and Z1*Z are the unitary factors from the generalized
     !! Schur factorization of (A,B):
     !! A = (Q1*Q)*S*(Z1*Z)**H,  B = (Q1*Q)*P*(Z1*Z)**H.
     !! To avoid overflow, eigenvalues of the matrix pair (H,T)
     !! (equivalently, of (A,B)) are computed as a pair of complex values
     !! (alpha,beta).  If beta is nonzero, lambda = alpha / beta is an
     !! eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP)
     !! A*x = lambda*B*x
     !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     !! alternate form of the GNEP
     !! mu*A*y = B*y.
     !! The values of alpha and beta for the i-th eigenvalue can be read
     !! directly from the generalized Schur form:  alpha = S(i,i),
     !! beta = P(i,i).
     !! Ref: C.B. Moler
     !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
     !! pp. 241--256.
                z, ldz, work, lwork,rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz, job
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldq, ldt, ldz, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(out) :: alpha(*), beta(*), work(*)
           complex(dp), intent(inout) :: h(ldh,*), q(ldq,*), t(ldt,*), z(ldz,*)
        ! =====================================================================
           
           
           
           ! Local Scalars 
           logical(lk) :: ilazr2, ilazro, ilq, ilschr, ilz, lquery
           integer(ilp) :: icompq, icompz, ifirst, ifrstm, iiter, ilast, ilastm, in, ischur, &
                     istart, j, jc, jch, jiter, jr, maxit
           real(dp) :: absb, anorm, ascale, atol, bnorm, bscale, btol, c, safmin, temp, temp2, &
                     tempr, ulp
           complex(dp) :: abi22, ad11, ad12, ad21, ad22, ctemp, ctemp2, ctemp3, eshift, s, shift, &
                     signbc, u12, x, abi12, y
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=dp) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode job, compq, compz
           if( stdlib_lsame( job, 'E' ) ) then
              ilschr = .false.
              ischur = 1
           else if( stdlib_lsame( job, 'S' ) ) then
              ilschr = .true.
              ischur = 2
           else
              ilschr = .true.
              ischur = 0
           end if
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              ilq = .true.
              icompq = 0
           end if
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              ilz = .true.
              icompz = 0
           end if
           ! check argument values
           info = 0
           work( 1 ) = max( 1, n )
           lquery = ( lwork==-1 )
           if( ischur==0 ) then
              info = -1
           else if( icompq==0 ) then
              info = -2
           else if( icompz==0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 ) then
              info = -5
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -6
           else if( ldh<n ) then
              info = -8
           else if( ldt<n ) then
              info = -10
           else if( ldq<1 .or. ( ilq .and. ldq<n ) ) then
              info = -14
           else if( ldz<1 .or. ( ilz .and. ldz<n ) ) then
              info = -16
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -18
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHGEQZ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           ! work( 1 ) = cmplx( 1,KIND=dp)
           if( n<=0 ) then
              work( 1 ) = cmplx( 1,KIND=dp)
              return
           end if
           ! initialize q and z
           if( icompq==3 )call stdlib_zlaset( 'FULL', n, n, czero, cone, q, ldq )
           if( icompz==3 )call stdlib_zlaset( 'FULL', n, n, czero, cone, z, ldz )
           ! machine constants
           in = ihi + 1 - ilo
           safmin = stdlib_dlamch( 'S' )
           ulp = stdlib_dlamch( 'E' )*stdlib_dlamch( 'B' )
           anorm = stdlib_zlanhs( 'F', in, h( ilo, ilo ), ldh, rwork )
           bnorm = stdlib_zlanhs( 'F', in, t( ilo, ilo ), ldt, rwork )
           atol = max( safmin, ulp*anorm )
           btol = max( safmin, ulp*bnorm )
           ascale = one / max( safmin, anorm )
           bscale = one / max( safmin, bnorm )
           ! set eigenvalues ihi+1:n
           do j = ihi + 1, n
              absb = abs( t( j, j ) )
              if( absb>safmin ) then
                 signbc = conjg( t( j, j ) / absb )
                 t( j, j ) = absb
                 if( ilschr ) then
                    call stdlib_zscal( j-1, signbc, t( 1, j ), 1 )
                    call stdlib_zscal( j, signbc, h( 1, j ), 1 )
                 else
                    call stdlib_zscal( 1, signbc, h( j, j ), 1 )
                 end if
                 if( ilz )call stdlib_zscal( n, signbc, z( 1, j ), 1 )
              else
                 t( j, j ) = czero
              end if
              alpha( j ) = h( j, j )
              beta( j ) = t( j, j )
           end do
           ! if ihi < ilo, skip qz steps
           if( ihi<ilo )go to 190
           ! main qz iteration loop
           ! initialize dynamic indices
           ! eigenvalues ilast+1:n have been found.
              ! column operations modify rows ifrstm:whatever
              ! row operations modify columns whatever:ilastm
           ! if only eigenvalues are being computed, then
              ! ifrstm is the row of the last splitting row above row ilast;
              ! this is always at least ilo.
           ! iiter counts iterations since the last eigenvalue was found,
              ! to tell when to use an extraordinary shift.
           ! maxit is the maximum number of qz sweeps allowed.
           ilast = ihi
           if( ilschr ) then
              ifrstm = 1
              ilastm = n
           else
              ifrstm = ilo
              ilastm = ihi
           end if
           iiter = 0
           eshift = czero
           maxit = 30*( ihi-ilo+1 )
           loop_170: do jiter = 1, maxit
              ! check for too many iterations.
              if( jiter>maxit )go to 180
              ! split the matrix if possible.
              ! two tests:
                 ! 1: h(j,j-1)=0  or  j=ilo
                 ! 2: t(j,j)=0
              ! special case: j=ilast
              if( ilast==ilo ) then
                 go to 60
              else
                 if( abs1( h( ilast, ilast-1 ) )<=max( safmin, ulp*(abs1( h( ilast, ilast ) ) + &
                           abs1( h( ilast-1, ilast-1 )) ) ) ) then
                    h( ilast, ilast-1 ) = czero
                    go to 60
                 end if
              end if
              if( abs( t( ilast, ilast ) )<=max( safmin, ulp*(abs( t( ilast - 1, ilast ) ) + abs( &
                        t( ilast-1, ilast-1 )) ) ) ) then
                 t( ilast, ilast ) = czero
                 go to 50
              end if
              ! general case: j<ilast
              loop_40: do j = ilast - 1, ilo, -1
                 ! test 1: for h(j,j-1)=0 or j=ilo
                 if( j==ilo ) then
                    ilazro = .true.
                 else
                    if( abs1( h( j, j-1 ) )<=max( safmin, ulp*(abs1( h( j, j ) ) + abs1( h( j-1, &
                              j-1 ) )) ) ) then
                       h( j, j-1 ) = czero
                       ilazro = .true.
                    else
                       ilazro = .false.
                    end if
                 end if
                 ! test 2: for t(j,j)=0
                 temp = abs ( t( j, j + 1 ) )
                 if ( j > ilo )temp = temp + abs ( t( j - 1, j ) )
                 if( abs( t( j, j ) )<max( safmin,ulp*temp ) ) then
                    t( j, j ) = czero
                    ! test 1a: check for 2 consecutive small subdiagonals in a
                    ilazr2 = .false.
                    if( .not.ilazro ) then
                       if( abs1( h( j, j-1 ) )*( ascale*abs1( h( j+1,j ) ) )<=abs1( h( j, j ) )*( &
                                 ascale*atol ) )ilazr2 = .true.
                    end if
                    ! if both tests pass (1
                    ! element of b in the block is zero, split a 1x1 block off
                    ! at the top. (i.e., at the j-th row/column) the leading
                    ! diagonal element of the remainder can also be zero, so
                    ! this may have to be done repeatedly.
                    if( ilazro .or. ilazr2 ) then
                       do jch = j, ilast - 1
                          ctemp = h( jch, jch )
                          call stdlib_zlartg( ctemp, h( jch+1, jch ), c, s,h( jch, jch ) )
                          h( jch+1, jch ) = czero
                          call stdlib_zrot( ilastm-jch, h( jch, jch+1 ), ldh,h( jch+1, jch+1 ), &
                                    ldh, c, s )
                          call stdlib_zrot( ilastm-jch, t( jch, jch+1 ), ldt,t( jch+1, jch+1 ), &
                                    ldt, c, s )
                          if( ilq )call stdlib_zrot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, conjg(&
                                     s ) )
                          if( ilazr2 )h( jch, jch-1 ) = h( jch, jch-1 )*c
                          ilazr2 = .false.
                          if( abs1( t( jch+1, jch+1 ) )>=btol ) then
                             if( jch+1>=ilast ) then
                                go to 60
                             else
                                ifirst = jch + 1
                                go to 70
                             end if
                          end if
                          t( jch+1, jch+1 ) = czero
                       end do
                       go to 50
                    else
                       ! only test 2 passed -- chase the zero to t(ilast,ilast)
                       ! then process as in the case t(ilast,ilast)=0
                       do jch = j, ilast - 1
                          ctemp = t( jch, jch+1 )
                          call stdlib_zlartg( ctemp, t( jch+1, jch+1 ), c, s,t( jch, jch+1 ) )
                                    
                          t( jch+1, jch+1 ) = czero
                          if( jch<ilastm-1 )call stdlib_zrot( ilastm-jch-1, t( jch, jch+2 ), ldt,&
                                    t( jch+1, jch+2 ), ldt, c, s )
                          call stdlib_zrot( ilastm-jch+2, h( jch, jch-1 ), ldh,h( jch+1, jch-1 ), &
                                    ldh, c, s )
                          if( ilq )call stdlib_zrot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, conjg(&
                                     s ) )
                          ctemp = h( jch+1, jch )
                          call stdlib_zlartg( ctemp, h( jch+1, jch-1 ), c, s,h( jch+1, jch ) )
                                    
                          h( jch+1, jch-1 ) = czero
                          call stdlib_zrot( jch+1-ifrstm, h( ifrstm, jch ), 1,h( ifrstm, jch-1 ), &
                                    1, c, s )
                          call stdlib_zrot( jch-ifrstm, t( ifrstm, jch ), 1,t( ifrstm, jch-1 ), 1,&
                                     c, s )
                          if( ilz )call stdlib_zrot( n, z( 1, jch ), 1, z( 1, jch-1 ), 1,c, s )
                                    
                       end do
                       go to 50
                    end if
                 else if( ilazro ) then
                    ! only test 1 passed -- work on j:ilast
                    ifirst = j
                    go to 70
                 end if
                 ! neither test passed -- try next j
              end do loop_40
              ! (drop-through is "impossible")
              info = 2*n + 1
              go to 210
              ! t(ilast,ilast)=0 -- clear h(ilast,ilast-1) to split off a
              ! 1x1 block.
              50 continue
              ctemp = h( ilast, ilast )
              call stdlib_zlartg( ctemp, h( ilast, ilast-1 ), c, s,h( ilast, ilast ) )
              h( ilast, ilast-1 ) = czero
              call stdlib_zrot( ilast-ifrstm, h( ifrstm, ilast ), 1,h( ifrstm, ilast-1 ), 1, c, s &
                        )
              call stdlib_zrot( ilast-ifrstm, t( ifrstm, ilast ), 1,t( ifrstm, ilast-1 ), 1, c, s &
                        )
              if( ilz )call stdlib_zrot( n, z( 1, ilast ), 1, z( 1, ilast-1 ), 1, c, s )
              ! h(ilast,ilast-1)=0 -- standardize b, set alpha and beta
              60 continue
              absb = abs( t( ilast, ilast ) )
              if( absb>safmin ) then
                 signbc = conjg( t( ilast, ilast ) / absb )
                 t( ilast, ilast ) = absb
                 if( ilschr ) then
                    call stdlib_zscal( ilast-ifrstm, signbc, t( ifrstm, ilast ), 1 )
                    call stdlib_zscal( ilast+1-ifrstm, signbc, h( ifrstm, ilast ),1 )
                 else
                    call stdlib_zscal( 1, signbc, h( ilast, ilast ), 1 )
                 end if
                 if( ilz )call stdlib_zscal( n, signbc, z( 1, ilast ), 1 )
              else
                 t( ilast, ilast ) = czero
              end if
              alpha( ilast ) = h( ilast, ilast )
              beta( ilast ) = t( ilast, ilast )
              ! go to next block -- exit if finished.
              ilast = ilast - 1
              if( ilast<ilo )go to 190
              ! reset counters
              iiter = 0
              eshift = czero
              if( .not.ilschr ) then
                 ilastm = ilast
                 if( ifrstm>ilast )ifrstm = ilo
              end if
              go to 160
              ! qz step
              ! this iteration only involves rows/columns ifirst:ilast.  we
              ! assume ifirst < ilast, and that the diagonal of b is non-zero.
              70 continue
              iiter = iiter + 1
              if( .not.ilschr ) then
                 ifrstm = ifirst
              end if
              ! compute the shift.
              ! at this point, ifirst < ilast, and the diagonal elements of
              ! t(ifirst:ilast,ifirst,ilast) are larger than btol (in
              ! magnitude)
              if( ( iiter / 10 )*10/=iiter ) then
                 ! the wilkinson shift (aep p.512_dp), i.e., the eigenvalue of
                 ! the bottom-right 2x2 block of a inv(b) which is nearest to
                 ! the bottom-right element.
                 ! we factor b as u*d, where u has unit diagonals, and
                 ! compute (a*inv(d))*inv(u).
                 u12 = ( bscale*t( ilast-1, ilast ) ) /( bscale*t( ilast, ilast ) )
                 ad11 = ( ascale*h( ilast-1, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad21 = ( ascale*h( ilast, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad12 = ( ascale*h( ilast-1, ilast ) ) /( bscale*t( ilast, ilast ) )
                 ad22 = ( ascale*h( ilast, ilast ) ) /( bscale*t( ilast, ilast ) )
                 abi22 = ad22 - u12*ad21
                 abi12 = ad12 - u12*ad11
                 shift = abi22
                 ctemp = sqrt( abi12 )*sqrt( ad21 )
                 temp = abs1( ctemp )
                 if( ctemp/=zero ) then
                    x = half*( ad11-shift )
                    temp2 = abs1( x )
                    temp = max( temp, abs1( x ) )
                    y = temp*sqrt( ( x / temp )**2+( ctemp / temp )**2 )
                    if( temp2>zero ) then
                       if( real( x / temp2,KIND=dp)*real( y,KIND=dp)+aimag( x / temp2 )*aimag( y )&
                                 <zero )y = -y
                    end if
                    shift = shift - ctemp*stdlib_zladiv( ctemp, ( x+y ) )
                 end if
              else
                 ! exceptional shift.  chosen for no particularly good reason.
                 if( ( iiter / 20 )*20==iiter .and.bscale*abs1(t( ilast, ilast ))>safmin ) &
                           then
                    eshift = eshift + ( ascale*h( ilast,ilast ) )/( bscale*t( ilast, ilast ) )
                              
                 else
                    eshift = eshift + ( ascale*h( ilast,ilast-1 ) )/( bscale*t( ilast-1, ilast-1 )&
                               )
                 end if
                 shift = eshift
              end if
              ! now check for two consecutive small subdiagonals.
              do j = ilast - 1, ifirst + 1, -1
                 istart = j
                 ctemp = ascale*h( j, j ) - shift*( bscale*t( j, j ) )
                 temp = abs1( ctemp )
                 temp2 = ascale*abs1( h( j+1, j ) )
                 tempr = max( temp, temp2 )
                 if( tempr<one .and. tempr/=zero ) then
                    temp = temp / tempr
                    temp2 = temp2 / tempr
                 end if
                 if( abs1( h( j, j-1 ) )*temp2<=temp*atol )go to 90
              end do
              istart = ifirst
              ctemp = ascale*h( ifirst, ifirst ) -shift*( bscale*t( ifirst, ifirst ) )
              90 continue
              ! do an implicit-shift qz sweep.
              ! initial q
              ctemp2 = ascale*h( istart+1, istart )
              call stdlib_zlartg( ctemp, ctemp2, c, s, ctemp3 )
              ! sweep
              loop_150: do j = istart, ilast - 1
                 if( j>istart ) then
                    ctemp = h( j, j-1 )
                    call stdlib_zlartg( ctemp, h( j+1, j-1 ), c, s, h( j, j-1 ) )
                    h( j+1, j-1 ) = czero
                 end if
                 do jc = j, ilastm
                    ctemp = c*h( j, jc ) + s*h( j+1, jc )
                    h( j+1, jc ) = -conjg( s )*h( j, jc ) + c*h( j+1, jc )
                    h( j, jc ) = ctemp
                    ctemp2 = c*t( j, jc ) + s*t( j+1, jc )
                    t( j+1, jc ) = -conjg( s )*t( j, jc ) + c*t( j+1, jc )
                    t( j, jc ) = ctemp2
                 end do
                 if( ilq ) then
                    do jr = 1, n
                       ctemp = c*q( jr, j ) + conjg( s )*q( jr, j+1 )
                       q( jr, j+1 ) = -s*q( jr, j ) + c*q( jr, j+1 )
                       q( jr, j ) = ctemp
                    end do
                 end if
                 ctemp = t( j+1, j+1 )
                 call stdlib_zlartg( ctemp, t( j+1, j ), c, s, t( j+1, j+1 ) )
                 t( j+1, j ) = czero
                 do jr = ifrstm, min( j+2, ilast )
                    ctemp = c*h( jr, j+1 ) + s*h( jr, j )
                    h( jr, j ) = -conjg( s )*h( jr, j+1 ) + c*h( jr, j )
                    h( jr, j+1 ) = ctemp
                 end do
                 do jr = ifrstm, j
                    ctemp = c*t( jr, j+1 ) + s*t( jr, j )
                    t( jr, j ) = -conjg( s )*t( jr, j+1 ) + c*t( jr, j )
                    t( jr, j+1 ) = ctemp
                 end do
                 if( ilz ) then
                    do jr = 1, n
                       ctemp = c*z( jr, j+1 ) + s*z( jr, j )
                       z( jr, j ) = -conjg( s )*z( jr, j+1 ) + c*z( jr, j )
                       z( jr, j+1 ) = ctemp
                    end do
                 end if
              end do loop_150
              160 continue
           end do loop_170
           ! drop-through = non-convergence
           180 continue
           info = ilast
           go to 210
           ! successful completion of all qz steps
           190 continue
           ! set eigenvalues 1:ilo-1
           do j = 1, ilo - 1
              absb = abs( t( j, j ) )
              if( absb>safmin ) then
                 signbc = conjg( t( j, j ) / absb )
                 t( j, j ) = absb
                 if( ilschr ) then
                    call stdlib_zscal( j-1, signbc, t( 1, j ), 1 )
                    call stdlib_zscal( j, signbc, h( 1, j ), 1 )
                 else
                    call stdlib_zscal( 1, signbc, h( j, j ), 1 )
                 end if
                 if( ilz )call stdlib_zscal( n, signbc, z( 1, j ), 1 )
              else
                 t( j, j ) = czero
              end if
              alpha( j ) = h( j, j )
              beta( j ) = t( j, j )
           end do
           ! normal termination
           info = 0
           ! exit (other than argument error) -- return optimal workspace size
           210 continue
           work( 1 ) = cmplx( n,KIND=dp)
           return
     end subroutine stdlib_zhgeqz

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$hgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alpha, beta, q, ldq,&
     !! ZHGEQZ: computes the eigenvalues of a complex matrix pair (H,T),
     !! where H is an upper Hessenberg matrix and T is upper triangular,
     !! using the single-shift QZ method.
     !! Matrix pairs of this type are produced by the reduction to
     !! generalized upper Hessenberg form of a complex matrix pair (A,B):
     !! A = Q1*H*Z1**H,  B = Q1*T*Z1**H,
     !! as computed by ZGGHRD.
     !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
     !! also reduced to generalized Schur form,
     !! H = Q*S*Z**H,  T = Q*P*Z**H,
     !! where Q and Z are unitary matrices and S and P are upper triangular.
     !! Optionally, the unitary matrix Q from the generalized Schur
     !! factorization may be postmultiplied into an input matrix Q1, and the
     !! unitary matrix Z may be postmultiplied into an input matrix Z1.
     !! If Q1 and Z1 are the unitary matrices from ZGGHRD that reduced
     !! the matrix pair (A,B) to generalized Hessenberg form, then the output
     !! matrices Q1*Q and Z1*Z are the unitary factors from the generalized
     !! Schur factorization of (A,B):
     !! A = (Q1*Q)*S*(Z1*Z)**H,  B = (Q1*Q)*P*(Z1*Z)**H.
     !! To avoid overflow, eigenvalues of the matrix pair (H,T)
     !! (equivalently, of (A,B)) are computed as a pair of complex values
     !! (alpha,beta).  If beta is nonzero, lambda = alpha / beta is an
     !! eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP)
     !! A*x = lambda*B*x
     !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     !! alternate form of the GNEP
     !! mu*A*y = B*y.
     !! The values of alpha and beta for the i-th eigenvalue can be read
     !! directly from the generalized Schur form:  alpha = S(i,i),
     !! beta = P(i,i).
     !! Ref: C.B. Moler
     !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
     !! pp. 241--256.
                z, ldz, work, lwork,rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz, job
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldq, ldt, ldz, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(out) :: alpha(*), beta(*), work(*)
           complex(${ck}$), intent(inout) :: h(ldh,*), q(ldq,*), t(ldt,*), z(ldz,*)
        ! =====================================================================
           
           
           
           ! Local Scalars 
           logical(lk) :: ilazr2, ilazro, ilq, ilschr, ilz, lquery
           integer(ilp) :: icompq, icompz, ifirst, ifrstm, iiter, ilast, ilastm, in, ischur, &
                     istart, j, jc, jch, jiter, jr, maxit
           real(${ck}$) :: absb, anorm, ascale, atol, bnorm, bscale, btol, c, safmin, temp, temp2, &
                     tempr, ulp
           complex(${ck}$) :: abi22, ad11, ad12, ad21, ad22, ctemp, ctemp2, ctemp3, eshift, s, shift, &
                     signbc, u12, x, abi12, y
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=${ck}$) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode job, compq, compz
           if( stdlib_lsame( job, 'E' ) ) then
              ilschr = .false.
              ischur = 1
           else if( stdlib_lsame( job, 'S' ) ) then
              ilschr = .true.
              ischur = 2
           else
              ilschr = .true.
              ischur = 0
           end if
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              ilq = .true.
              icompq = 0
           end if
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              ilz = .true.
              icompz = 0
           end if
           ! check argument values
           info = 0
           work( 1 ) = max( 1, n )
           lquery = ( lwork==-1 )
           if( ischur==0 ) then
              info = -1
           else if( icompq==0 ) then
              info = -2
           else if( icompz==0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 ) then
              info = -5
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -6
           else if( ldh<n ) then
              info = -8
           else if( ldt<n ) then
              info = -10
           else if( ldq<1 .or. ( ilq .and. ldq<n ) ) then
              info = -14
           else if( ldz<1 .or. ( ilz .and. ldz<n ) ) then
              info = -16
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -18
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHGEQZ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           ! work( 1 ) = cmplx( 1,KIND=${ck}$)
           if( n<=0 ) then
              work( 1 ) = cmplx( 1,KIND=${ck}$)
              return
           end if
           ! initialize q and z
           if( icompq==3 )call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, q, ldq )
           if( icompz==3 )call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, z, ldz )
           ! machine constants
           in = ihi + 1 - ilo
           safmin = stdlib_${c2ri(ci)}$lamch( 'S' )
           ulp = stdlib_${c2ri(ci)}$lamch( 'E' )*stdlib_${c2ri(ci)}$lamch( 'B' )
           anorm = stdlib_${ci}$lanhs( 'F', in, h( ilo, ilo ), ldh, rwork )
           bnorm = stdlib_${ci}$lanhs( 'F', in, t( ilo, ilo ), ldt, rwork )
           atol = max( safmin, ulp*anorm )
           btol = max( safmin, ulp*bnorm )
           ascale = one / max( safmin, anorm )
           bscale = one / max( safmin, bnorm )
           ! set eigenvalues ihi+1:n
           do j = ihi + 1, n
              absb = abs( t( j, j ) )
              if( absb>safmin ) then
                 signbc = conjg( t( j, j ) / absb )
                 t( j, j ) = absb
                 if( ilschr ) then
                    call stdlib_${ci}$scal( j-1, signbc, t( 1, j ), 1 )
                    call stdlib_${ci}$scal( j, signbc, h( 1, j ), 1 )
                 else
                    call stdlib_${ci}$scal( 1, signbc, h( j, j ), 1 )
                 end if
                 if( ilz )call stdlib_${ci}$scal( n, signbc, z( 1, j ), 1 )
              else
                 t( j, j ) = czero
              end if
              alpha( j ) = h( j, j )
              beta( j ) = t( j, j )
           end do
           ! if ihi < ilo, skip qz steps
           if( ihi<ilo )go to 190
           ! main qz iteration loop
           ! initialize dynamic indices
           ! eigenvalues ilast+1:n have been found.
              ! column operations modify rows ifrstm:whatever
              ! row operations modify columns whatever:ilastm
           ! if only eigenvalues are being computed, then
              ! ifrstm is the row of the last splitting row above row ilast;
              ! this is always at least ilo.
           ! iiter counts iterations since the last eigenvalue was found,
              ! to tell when to use an extraordinary shift.
           ! maxit is the maximum number of qz sweeps allowed.
           ilast = ihi
           if( ilschr ) then
              ifrstm = 1
              ilastm = n
           else
              ifrstm = ilo
              ilastm = ihi
           end if
           iiter = 0
           eshift = czero
           maxit = 30*( ihi-ilo+1 )
           loop_170: do jiter = 1, maxit
              ! check for too many iterations.
              if( jiter>maxit )go to 180
              ! split the matrix if possible.
              ! two tests:
                 ! 1: h(j,j-1)=0  or  j=ilo
                 ! 2: t(j,j)=0
              ! special case: j=ilast
              if( ilast==ilo ) then
                 go to 60
              else
                 if( abs1( h( ilast, ilast-1 ) )<=max( safmin, ulp*(abs1( h( ilast, ilast ) ) + &
                           abs1( h( ilast-1, ilast-1 )) ) ) ) then
                    h( ilast, ilast-1 ) = czero
                    go to 60
                 end if
              end if
              if( abs( t( ilast, ilast ) )<=max( safmin, ulp*(abs( t( ilast - 1, ilast ) ) + abs( &
                        t( ilast-1, ilast-1 )) ) ) ) then
                 t( ilast, ilast ) = czero
                 go to 50
              end if
              ! general case: j<ilast
              loop_40: do j = ilast - 1, ilo, -1
                 ! test 1: for h(j,j-1)=0 or j=ilo
                 if( j==ilo ) then
                    ilazro = .true.
                 else
                    if( abs1( h( j, j-1 ) )<=max( safmin, ulp*(abs1( h( j, j ) ) + abs1( h( j-1, &
                              j-1 ) )) ) ) then
                       h( j, j-1 ) = czero
                       ilazro = .true.
                    else
                       ilazro = .false.
                    end if
                 end if
                 ! test 2: for t(j,j)=0
                 temp = abs ( t( j, j + 1 ) )
                 if ( j > ilo )temp = temp + abs ( t( j - 1, j ) )
                 if( abs( t( j, j ) )<max( safmin,ulp*temp ) ) then
                    t( j, j ) = czero
                    ! test 1a: check for 2 consecutive small subdiagonals in a
                    ilazr2 = .false.
                    if( .not.ilazro ) then
                       if( abs1( h( j, j-1 ) )*( ascale*abs1( h( j+1,j ) ) )<=abs1( h( j, j ) )*( &
                                 ascale*atol ) )ilazr2 = .true.
                    end if
                    ! if both tests pass (1
                    ! element of b in the block is zero, split a 1x1 block off
                    ! at the top. (i.e., at the j-th row/column) the leading
                    ! diagonal element of the remainder can also be zero, so
                    ! this may have to be done repeatedly.
                    if( ilazro .or. ilazr2 ) then
                       do jch = j, ilast - 1
                          ctemp = h( jch, jch )
                          call stdlib_${ci}$lartg( ctemp, h( jch+1, jch ), c, s,h( jch, jch ) )
                          h( jch+1, jch ) = czero
                          call stdlib_${ci}$rot( ilastm-jch, h( jch, jch+1 ), ldh,h( jch+1, jch+1 ), &
                                    ldh, c, s )
                          call stdlib_${ci}$rot( ilastm-jch, t( jch, jch+1 ), ldt,t( jch+1, jch+1 ), &
                                    ldt, c, s )
                          if( ilq )call stdlib_${ci}$rot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, conjg(&
                                     s ) )
                          if( ilazr2 )h( jch, jch-1 ) = h( jch, jch-1 )*c
                          ilazr2 = .false.
                          if( abs1( t( jch+1, jch+1 ) )>=btol ) then
                             if( jch+1>=ilast ) then
                                go to 60
                             else
                                ifirst = jch + 1
                                go to 70
                             end if
                          end if
                          t( jch+1, jch+1 ) = czero
                       end do
                       go to 50
                    else
                       ! only test 2 passed -- chase the zero to t(ilast,ilast)
                       ! then process as in the case t(ilast,ilast)=0
                       do jch = j, ilast - 1
                          ctemp = t( jch, jch+1 )
                          call stdlib_${ci}$lartg( ctemp, t( jch+1, jch+1 ), c, s,t( jch, jch+1 ) )
                                    
                          t( jch+1, jch+1 ) = czero
                          if( jch<ilastm-1 )call stdlib_${ci}$rot( ilastm-jch-1, t( jch, jch+2 ), ldt,&
                                    t( jch+1, jch+2 ), ldt, c, s )
                          call stdlib_${ci}$rot( ilastm-jch+2, h( jch, jch-1 ), ldh,h( jch+1, jch-1 ), &
                                    ldh, c, s )
                          if( ilq )call stdlib_${ci}$rot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, conjg(&
                                     s ) )
                          ctemp = h( jch+1, jch )
                          call stdlib_${ci}$lartg( ctemp, h( jch+1, jch-1 ), c, s,h( jch+1, jch ) )
                                    
                          h( jch+1, jch-1 ) = czero
                          call stdlib_${ci}$rot( jch+1-ifrstm, h( ifrstm, jch ), 1,h( ifrstm, jch-1 ), &
                                    1, c, s )
                          call stdlib_${ci}$rot( jch-ifrstm, t( ifrstm, jch ), 1,t( ifrstm, jch-1 ), 1,&
                                     c, s )
                          if( ilz )call stdlib_${ci}$rot( n, z( 1, jch ), 1, z( 1, jch-1 ), 1,c, s )
                                    
                       end do
                       go to 50
                    end if
                 else if( ilazro ) then
                    ! only test 1 passed -- work on j:ilast
                    ifirst = j
                    go to 70
                 end if
                 ! neither test passed -- try next j
              end do loop_40
              ! (drop-through is "impossible")
              info = 2*n + 1
              go to 210
              ! t(ilast,ilast)=0 -- clear h(ilast,ilast-1) to split off a
              ! 1x1 block.
              50 continue
              ctemp = h( ilast, ilast )
              call stdlib_${ci}$lartg( ctemp, h( ilast, ilast-1 ), c, s,h( ilast, ilast ) )
              h( ilast, ilast-1 ) = czero
              call stdlib_${ci}$rot( ilast-ifrstm, h( ifrstm, ilast ), 1,h( ifrstm, ilast-1 ), 1, c, s &
                        )
              call stdlib_${ci}$rot( ilast-ifrstm, t( ifrstm, ilast ), 1,t( ifrstm, ilast-1 ), 1, c, s &
                        )
              if( ilz )call stdlib_${ci}$rot( n, z( 1, ilast ), 1, z( 1, ilast-1 ), 1, c, s )
              ! h(ilast,ilast-1)=0 -- standardize b, set alpha and beta
              60 continue
              absb = abs( t( ilast, ilast ) )
              if( absb>safmin ) then
                 signbc = conjg( t( ilast, ilast ) / absb )
                 t( ilast, ilast ) = absb
                 if( ilschr ) then
                    call stdlib_${ci}$scal( ilast-ifrstm, signbc, t( ifrstm, ilast ), 1 )
                    call stdlib_${ci}$scal( ilast+1-ifrstm, signbc, h( ifrstm, ilast ),1 )
                 else
                    call stdlib_${ci}$scal( 1, signbc, h( ilast, ilast ), 1 )
                 end if
                 if( ilz )call stdlib_${ci}$scal( n, signbc, z( 1, ilast ), 1 )
              else
                 t( ilast, ilast ) = czero
              end if
              alpha( ilast ) = h( ilast, ilast )
              beta( ilast ) = t( ilast, ilast )
              ! go to next block -- exit if finished.
              ilast = ilast - 1
              if( ilast<ilo )go to 190
              ! reset counters
              iiter = 0
              eshift = czero
              if( .not.ilschr ) then
                 ilastm = ilast
                 if( ifrstm>ilast )ifrstm = ilo
              end if
              go to 160
              ! qz step
              ! this iteration only involves rows/columns ifirst:ilast.  we
              ! assume ifirst < ilast, and that the diagonal of b is non-zero.
              70 continue
              iiter = iiter + 1
              if( .not.ilschr ) then
                 ifrstm = ifirst
              end if
              ! compute the shift.
              ! at this point, ifirst < ilast, and the diagonal elements of
              ! t(ifirst:ilast,ifirst,ilast) are larger than btol (in
              ! magnitude)
              if( ( iiter / 10 )*10/=iiter ) then
                 ! the wilkinson shift (aep p.512_${ck}$), i.e., the eigenvalue of
                 ! the bottom-right 2x2 block of a inv(b) which is nearest to
                 ! the bottom-right element.
                 ! we factor b as u*d, where u has unit diagonals, and
                 ! compute (a*inv(d))*inv(u).
                 u12 = ( bscale*t( ilast-1, ilast ) ) /( bscale*t( ilast, ilast ) )
                 ad11 = ( ascale*h( ilast-1, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad21 = ( ascale*h( ilast, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad12 = ( ascale*h( ilast-1, ilast ) ) /( bscale*t( ilast, ilast ) )
                 ad22 = ( ascale*h( ilast, ilast ) ) /( bscale*t( ilast, ilast ) )
                 abi22 = ad22 - u12*ad21
                 abi12 = ad12 - u12*ad11
                 shift = abi22
                 ctemp = sqrt( abi12 )*sqrt( ad21 )
                 temp = abs1( ctemp )
                 if( ctemp/=zero ) then
                    x = half*( ad11-shift )
                    temp2 = abs1( x )
                    temp = max( temp, abs1( x ) )
                    y = temp*sqrt( ( x / temp )**2+( ctemp / temp )**2 )
                    if( temp2>zero ) then
                       if( real( x / temp2,KIND=${ck}$)*real( y,KIND=${ck}$)+aimag( x / temp2 )*aimag( y )&
                                 <zero )y = -y
                    end if
                    shift = shift - ctemp*stdlib_${ci}$ladiv( ctemp, ( x+y ) )
                 end if
              else
                 ! exceptional shift.  chosen for no particularly good reason.
                 if( ( iiter / 20 )*20==iiter .and.bscale*abs1(t( ilast, ilast ))>safmin ) &
                           then
                    eshift = eshift + ( ascale*h( ilast,ilast ) )/( bscale*t( ilast, ilast ) )
                              
                 else
                    eshift = eshift + ( ascale*h( ilast,ilast-1 ) )/( bscale*t( ilast-1, ilast-1 )&
                               )
                 end if
                 shift = eshift
              end if
              ! now check for two consecutive small subdiagonals.
              do j = ilast - 1, ifirst + 1, -1
                 istart = j
                 ctemp = ascale*h( j, j ) - shift*( bscale*t( j, j ) )
                 temp = abs1( ctemp )
                 temp2 = ascale*abs1( h( j+1, j ) )
                 tempr = max( temp, temp2 )
                 if( tempr<one .and. tempr/=zero ) then
                    temp = temp / tempr
                    temp2 = temp2 / tempr
                 end if
                 if( abs1( h( j, j-1 ) )*temp2<=temp*atol )go to 90
              end do
              istart = ifirst
              ctemp = ascale*h( ifirst, ifirst ) -shift*( bscale*t( ifirst, ifirst ) )
              90 continue
              ! do an implicit-shift qz sweep.
              ! initial q
              ctemp2 = ascale*h( istart+1, istart )
              call stdlib_${ci}$lartg( ctemp, ctemp2, c, s, ctemp3 )
              ! sweep
              loop_150: do j = istart, ilast - 1
                 if( j>istart ) then
                    ctemp = h( j, j-1 )
                    call stdlib_${ci}$lartg( ctemp, h( j+1, j-1 ), c, s, h( j, j-1 ) )
                    h( j+1, j-1 ) = czero
                 end if
                 do jc = j, ilastm
                    ctemp = c*h( j, jc ) + s*h( j+1, jc )
                    h( j+1, jc ) = -conjg( s )*h( j, jc ) + c*h( j+1, jc )
                    h( j, jc ) = ctemp
                    ctemp2 = c*t( j, jc ) + s*t( j+1, jc )
                    t( j+1, jc ) = -conjg( s )*t( j, jc ) + c*t( j+1, jc )
                    t( j, jc ) = ctemp2
                 end do
                 if( ilq ) then
                    do jr = 1, n
                       ctemp = c*q( jr, j ) + conjg( s )*q( jr, j+1 )
                       q( jr, j+1 ) = -s*q( jr, j ) + c*q( jr, j+1 )
                       q( jr, j ) = ctemp
                    end do
                 end if
                 ctemp = t( j+1, j+1 )
                 call stdlib_${ci}$lartg( ctemp, t( j+1, j ), c, s, t( j+1, j+1 ) )
                 t( j+1, j ) = czero
                 do jr = ifrstm, min( j+2, ilast )
                    ctemp = c*h( jr, j+1 ) + s*h( jr, j )
                    h( jr, j ) = -conjg( s )*h( jr, j+1 ) + c*h( jr, j )
                    h( jr, j+1 ) = ctemp
                 end do
                 do jr = ifrstm, j
                    ctemp = c*t( jr, j+1 ) + s*t( jr, j )
                    t( jr, j ) = -conjg( s )*t( jr, j+1 ) + c*t( jr, j )
                    t( jr, j+1 ) = ctemp
                 end do
                 if( ilz ) then
                    do jr = 1, n
                       ctemp = c*z( jr, j+1 ) + s*z( jr, j )
                       z( jr, j ) = -conjg( s )*z( jr, j+1 ) + c*z( jr, j )
                       z( jr, j+1 ) = ctemp
                    end do
                 end if
              end do loop_150
              160 continue
           end do loop_170
           ! drop-through = non-convergence
           180 continue
           info = ilast
           go to 210
           ! successful completion of all qz steps
           190 continue
           ! set eigenvalues 1:ilo-1
           do j = 1, ilo - 1
              absb = abs( t( j, j ) )
              if( absb>safmin ) then
                 signbc = conjg( t( j, j ) / absb )
                 t( j, j ) = absb
                 if( ilschr ) then
                    call stdlib_${ci}$scal( j-1, signbc, t( 1, j ), 1 )
                    call stdlib_${ci}$scal( j, signbc, h( 1, j ), 1 )
                 else
                    call stdlib_${ci}$scal( 1, signbc, h( j, j ), 1 )
                 end if
                 if( ilz )call stdlib_${ci}$scal( n, signbc, z( 1, j ), 1 )
              else
                 t( j, j ) = czero
              end if
              alpha( j ) = h( j, j )
              beta( j ) = t( j, j )
           end do
           ! normal termination
           info = 0
           ! exit (other than argument error) -- return optimal workspace size
           210 continue
           work( 1 ) = cmplx( n,KIND=${ck}$)
           return
     end subroutine stdlib_${ci}$hgeqz

#:endif
#:endfor



     module subroutine stdlib_sggev3( jobvl, jobvr, n, a, lda, b, ldb, alphar,alphai, beta, vl, ldvl, vr,&
     !! SGGEV3 computes for a pair of N-by-N real nonsymmetric matrices (A,B)
     !! the generalized eigenvalues, and optionally, the left and/or right
     !! generalized eigenvectors.
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j).
     !! The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! u(j)**H * A  = lambda(j) * u(j)**H * B .
     !! where u(j)**H is the conjugate-transpose of u(j).
                ldvr, work, lwork,info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: alphai(*), alphar(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
                     
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery
           character :: chtemp
           integer(ilp) :: icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, in, iright, irows, itau, &
                     iwrk, jc, jr, lwkopt
           real(sp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -12
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -14
           else if( lwork<max( 1, 8*n ) .and. .not.lquery ) then
              info = -16
           end if
           ! compute workspace
           if( info==0 ) then
              call stdlib_sgeqrf( n, n, b, ldb, work, work, -1, ierr )
              lwkopt = max( 1, 8*n, 3*n+int( work( 1 ),KIND=ilp) )
              call stdlib_sormqr( 'L', 'T', n, n, n, b, ldb, work, a, lda, work,-1, ierr )
              lwkopt = max( lwkopt, 3*n+int( work( 1 ),KIND=ilp) )
              call stdlib_sgghd3( jobvl, jobvr, n, 1, n, a, lda, b, ldb, vl, ldvl,vr, ldvr, work, &
                        -1, ierr )
              lwkopt = max( lwkopt, 3*n+int( work( 1 ),KIND=ilp) )
              if( ilvl ) then
                 call stdlib_sorgqr( n, n, n, vl, ldvl, work, work, -1, ierr )
                 lwkopt = max( lwkopt, 3*n+int( work( 1 ),KIND=ilp) )
                 call stdlib_slaqz0( 'S', jobvl, jobvr, n, 1, n, a, lda, b, ldb,alphar, alphai, &
                           beta, vl, ldvl, vr, ldvr,work, -1, 0, ierr )
                 lwkopt = max( lwkopt, 2*n+int( work( 1 ),KIND=ilp) )
              else
                 call stdlib_slaqz0( 'E', jobvl, jobvr, n, 1, n, a, lda, b, ldb,alphar, alphai, &
                           beta, vl, ldvl, vr, ldvr,work, -1, 0, ierr )
                 lwkopt = max( lwkopt, 2*n+int( work( 1 ),KIND=ilp) )
              end if
              work( 1 ) = real( lwkopt,KIND=sp)
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGGEV3 ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_slange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_slascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_slange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_slascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrices a, b to isolate eigenvalues if possible
           ileft = 1
           iright = n + 1
           iwrk = iright + n
           call stdlib_sggbal( 'P', n, a, lda, b, ldb, ilo, ihi, work( ileft ),work( iright ), &
                     work( iwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           irows = ihi + 1 - ilo
           if( ilv ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = iwrk
           iwrk = itau + irows
           call stdlib_sgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           call stdlib_sormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl
           if( ilvl ) then
              call stdlib_slaset( 'FULL', n, n, zero, one, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_slacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_sorgqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vr
           if( ilvr )call stdlib_slaset( 'FULL', n, n, zero, one, vr, ldvr )
           ! reduce to generalized hessenberg form
           if( ilv ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_sgghd3( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        work( iwrk ), lwork+1-iwrk, ierr )
           else
              call stdlib_sgghd3( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr,work( iwrk ), lwork+1-iwrk, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur forms and schur vectors)
           iwrk = itau
           if( ilv ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_slaqz0( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vl, ldvl, vr, ldvr,work( iwrk ), lwork+1-iwrk, 0, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 110
           end if
           ! compute eigenvectors
           if( ilv ) then
              if( ilvl ) then
                 if( ilvr ) then
                    chtemp = 'B'
                 else
                    chtemp = 'L'
                 end if
              else
                 chtemp = 'R'
              end if
              call stdlib_stgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl, ldvl,vr, ldvr, n, &
                        in, work( iwrk ), ierr )
              if( ierr/=0 ) then
                 info = n + 2
                 go to 110
              end if
              ! undo balancing on vl and vr and normalization
              if( ilvl ) then
                 call stdlib_sggbak( 'P', 'L', n, ilo, ihi, work( ileft ),work( iright ), n, vl, &
                           ldvl, ierr )
                 loop_50: do jc = 1, n
                    if( alphai( jc )<zero )cycle loop_50
                    temp = zero
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          temp = max( temp, abs( vl( jr, jc ) ) )
                       end do
                    else
                       do jr = 1, n
                          temp = max( temp, abs( vl( jr, jc ) )+abs( vl( jr, jc+1 ) ) )
                       end do
                    end if
                    if( temp<smlnum )cycle loop_50
                    temp = one / temp
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          vl( jr, jc ) = vl( jr, jc )*temp
                       end do
                    else
                       do jr = 1, n
                          vl( jr, jc ) = vl( jr, jc )*temp
                          vl( jr, jc+1 ) = vl( jr, jc+1 )*temp
                       end do
                    end if
                 end do loop_50
              end if
              if( ilvr ) then
                 call stdlib_sggbak( 'P', 'R', n, ilo, ihi, work( ileft ),work( iright ), n, vr, &
                           ldvr, ierr )
                 loop_100: do jc = 1, n
                    if( alphai( jc )<zero )cycle loop_100
                    temp = zero
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          temp = max( temp, abs( vr( jr, jc ) ) )
                       end do
                    else
                       do jr = 1, n
                          temp = max( temp, abs( vr( jr, jc ) )+abs( vr( jr, jc+1 ) ) )
                       end do
                    end if
                    if( temp<smlnum )cycle loop_100
                    temp = one / temp
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          vr( jr, jc ) = vr( jr, jc )*temp
                       end do
                    else
                       do jr = 1, n
                          vr( jr, jc ) = vr( jr, jc )*temp
                          vr( jr, jc+1 ) = vr( jr, jc+1 )*temp
                       end do
                    end if
                 end do loop_100
              end if
              ! end of eigenvector calculation
           end if
           ! undo scaling if necessary
           110 continue
           if( ilascl ) then
              call stdlib_slascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_slascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_slascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           work( 1 ) = real( lwkopt,KIND=sp)
           return
     end subroutine stdlib_sggev3

     module subroutine stdlib_dggev3( jobvl, jobvr, n, a, lda, b, ldb, alphar,alphai, beta, vl, ldvl, vr,&
     !! DGGEV3 computes for a pair of N-by-N real nonsymmetric matrices (A,B)
     !! the generalized eigenvalues, and optionally, the left and/or right
     !! generalized eigenvectors.
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j).
     !! The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! u(j)**H * A  = lambda(j) * u(j)**H * B .
     !! where u(j)**H is the conjugate-transpose of u(j).
                ldvr, work, lwork,info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: alphai(*), alphar(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
                     
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery
           character :: chtemp
           integer(ilp) :: icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, in, iright, irows, itau, &
                     iwrk, jc, jr, lwkopt
           real(dp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -12
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -14
           else if( lwork<max( 1, 8*n ) .and. .not.lquery ) then
              info = -16
           end if
           ! compute workspace
           if( info==0 ) then
              call stdlib_dgeqrf( n, n, b, ldb, work, work, -1, ierr )
              lwkopt = max(1, 8*n, 3*n+int( work( 1 ),KIND=ilp) )
              call stdlib_dormqr( 'L', 'T', n, n, n, b, ldb, work, a, lda, work, -1,ierr )
              lwkopt = max( lwkopt, 3*n+int( work ( 1 ),KIND=ilp) )
              if( ilvl ) then
                 call stdlib_dorgqr( n, n, n, vl, ldvl, work, work, -1, ierr )
                 lwkopt = max( lwkopt, 3*n+int( work ( 1 ),KIND=ilp) )
              end if
              if( ilv ) then
                 call stdlib_dgghd3( jobvl, jobvr, n, 1, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                           work, -1, ierr )
                 lwkopt = max( lwkopt, 3*n+int( work ( 1 ),KIND=ilp) )
                 call stdlib_dlaqz0( 'S', jobvl, jobvr, n, 1, n, a, lda, b, ldb,alphar, alphai, &
                           beta, vl, ldvl, vr, ldvr,work, -1, 0, ierr )
                 lwkopt = max( lwkopt, 2*n+int( work ( 1 ),KIND=ilp) )
              else
                 call stdlib_dgghd3( 'N', 'N', n, 1, n, a, lda, b, ldb, vl, ldvl,vr, ldvr, work, -&
                           1, ierr )
                 lwkopt = max( lwkopt, 3*n+int( work ( 1 ),KIND=ilp) )
                 call stdlib_dlaqz0( 'E', jobvl, jobvr, n, 1, n, a, lda, b, ldb,alphar, alphai, &
                           beta, vl, ldvl, vr, ldvr,work, -1, 0, ierr )
                 lwkopt = max( lwkopt, 2*n+int( work ( 1 ),KIND=ilp) )
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGEV3 ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' )
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_dlange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_dlascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_dlange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_dlascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrices a, b to isolate eigenvalues if possible
           ileft = 1
           iright = n + 1
           iwrk = iright + n
           call stdlib_dggbal( 'P', n, a, lda, b, ldb, ilo, ihi, work( ileft ),work( iright ), &
                     work( iwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           irows = ihi + 1 - ilo
           if( ilv ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = iwrk
           iwrk = itau + irows
           call stdlib_dgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           call stdlib_dormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl
           if( ilvl ) then
              call stdlib_dlaset( 'FULL', n, n, zero, one, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_dlacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_dorgqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vr
           if( ilvr )call stdlib_dlaset( 'FULL', n, n, zero, one, vr, ldvr )
           ! reduce to generalized hessenberg form
           if( ilv ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_dgghd3( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        work( iwrk ), lwork+1-iwrk, ierr )
           else
              call stdlib_dgghd3( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr,work( iwrk ), lwork+1-iwrk, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur forms and schur vectors)
           iwrk = itau
           if( ilv ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_dlaqz0( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vl, ldvl, vr, ldvr,work( iwrk ), lwork+1-iwrk, 0, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 110
           end if
           ! compute eigenvectors
           if( ilv ) then
              if( ilvl ) then
                 if( ilvr ) then
                    chtemp = 'B'
                 else
                    chtemp = 'L'
                 end if
              else
                 chtemp = 'R'
              end if
              call stdlib_dtgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl, ldvl,vr, ldvr, n, &
                        in, work( iwrk ), ierr )
              if( ierr/=0 ) then
                 info = n + 2
                 go to 110
              end if
              ! undo balancing on vl and vr and normalization
              if( ilvl ) then
                 call stdlib_dggbak( 'P', 'L', n, ilo, ihi, work( ileft ),work( iright ), n, vl, &
                           ldvl, ierr )
                 loop_50: do jc = 1, n
                    if( alphai( jc )<zero )cycle loop_50
                    temp = zero
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          temp = max( temp, abs( vl( jr, jc ) ) )
                       end do
                    else
                       do jr = 1, n
                          temp = max( temp, abs( vl( jr, jc ) )+abs( vl( jr, jc+1 ) ) )
                       end do
                    end if
                    if( temp<smlnum )cycle loop_50
                    temp = one / temp
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          vl( jr, jc ) = vl( jr, jc )*temp
                       end do
                    else
                       do jr = 1, n
                          vl( jr, jc ) = vl( jr, jc )*temp
                          vl( jr, jc+1 ) = vl( jr, jc+1 )*temp
                       end do
                    end if
                 end do loop_50
              end if
              if( ilvr ) then
                 call stdlib_dggbak( 'P', 'R', n, ilo, ihi, work( ileft ),work( iright ), n, vr, &
                           ldvr, ierr )
                 loop_100: do jc = 1, n
                    if( alphai( jc )<zero )cycle loop_100
                    temp = zero
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          temp = max( temp, abs( vr( jr, jc ) ) )
                       end do
                    else
                       do jr = 1, n
                          temp = max( temp, abs( vr( jr, jc ) )+abs( vr( jr, jc+1 ) ) )
                       end do
                    end if
                    if( temp<smlnum )cycle loop_100
                    temp = one / temp
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          vr( jr, jc ) = vr( jr, jc )*temp
                       end do
                    else
                       do jr = 1, n
                          vr( jr, jc ) = vr( jr, jc )*temp
                          vr( jr, jc+1 ) = vr( jr, jc+1 )*temp
                       end do
                    end if
                 end do loop_100
              end if
              ! end of eigenvector calculation
           end if
           ! undo scaling if necessary
           110 continue
           if( ilascl ) then
              call stdlib_dlascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_dlascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_dlascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dggev3

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$ggev3( jobvl, jobvr, n, a, lda, b, ldb, alphar,alphai, beta, vl, ldvl, vr,&
     !! DGGEV3: computes for a pair of N-by-N real nonsymmetric matrices (A,B)
     !! the generalized eigenvalues, and optionally, the left and/or right
     !! generalized eigenvectors.
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j).
     !! The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
     !! of (A,B) satisfies
     !! u(j)**H * A  = lambda(j) * u(j)**H * B .
     !! where u(j)**H is the conjugate-transpose of u(j).
                ldvr, work, lwork,info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
                     
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery
           character :: chtemp
           integer(ilp) :: icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, in, iright, irows, itau, &
                     iwrk, jc, jr, lwkopt
           real(${rk}$) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -12
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -14
           else if( lwork<max( 1, 8*n ) .and. .not.lquery ) then
              info = -16
           end if
           ! compute workspace
           if( info==0 ) then
              call stdlib_${ri}$geqrf( n, n, b, ldb, work, work, -1, ierr )
              lwkopt = max(1, 8*n, 3*n+int( work( 1 ),KIND=ilp) )
              call stdlib_${ri}$ormqr( 'L', 'T', n, n, n, b, ldb, work, a, lda, work, -1,ierr )
              lwkopt = max( lwkopt, 3*n+int( work ( 1 ),KIND=ilp) )
              if( ilvl ) then
                 call stdlib_${ri}$orgqr( n, n, n, vl, ldvl, work, work, -1, ierr )
                 lwkopt = max( lwkopt, 3*n+int( work ( 1 ),KIND=ilp) )
              end if
              if( ilv ) then
                 call stdlib_${ri}$gghd3( jobvl, jobvr, n, 1, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                           work, -1, ierr )
                 lwkopt = max( lwkopt, 3*n+int( work ( 1 ),KIND=ilp) )
                 call stdlib_${ri}$laqz0( 'S', jobvl, jobvr, n, 1, n, a, lda, b, ldb,alphar, alphai, &
                           beta, vl, ldvl, vr, ldvr,work, -1, 0, ierr )
                 lwkopt = max( lwkopt, 2*n+int( work ( 1 ),KIND=ilp) )
              else
                 call stdlib_${ri}$gghd3( 'N', 'N', n, 1, n, a, lda, b, ldb, vl, ldvl,vr, ldvr, work, -&
                           1, ierr )
                 lwkopt = max( lwkopt, 3*n+int( work ( 1 ),KIND=ilp) )
                 call stdlib_${ri}$laqz0( 'E', jobvl, jobvr, n, 1, n, a, lda, b, ldb,alphar, alphai, &
                           beta, vl, ldvl, vr, ldvr,work, -1, 0, ierr )
                 lwkopt = max( lwkopt, 2*n+int( work ( 1 ),KIND=ilp) )
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGEV3 ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_${ri}$lascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_${ri}$lange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_${ri}$lascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrices a, b to isolate eigenvalues if possible
           ileft = 1
           iright = n + 1
           iwrk = iright + n
           call stdlib_${ri}$ggbal( 'P', n, a, lda, b, ldb, ilo, ihi, work( ileft ),work( iright ), &
                     work( iwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           irows = ihi + 1 - ilo
           if( ilv ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = iwrk
           iwrk = itau + irows
           call stdlib_${ri}$geqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           call stdlib_${ri}$ormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl
           if( ilvl ) then
              call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_${ri}$lacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_${ri}$orgqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vr
           if( ilvr )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vr, ldvr )
           ! reduce to generalized hessenberg form
           if( ilv ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_${ri}$gghd3( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        work( iwrk ), lwork+1-iwrk, ierr )
           else
              call stdlib_${ri}$gghd3( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr,work( iwrk ), lwork+1-iwrk, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur forms and schur vectors)
           iwrk = itau
           if( ilv ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_${ri}$laqz0( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vl, ldvl, vr, ldvr,work( iwrk ), lwork+1-iwrk, 0, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 110
           end if
           ! compute eigenvectors
           if( ilv ) then
              if( ilvl ) then
                 if( ilvr ) then
                    chtemp = 'B'
                 else
                    chtemp = 'L'
                 end if
              else
                 chtemp = 'R'
              end if
              call stdlib_${ri}$tgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl, ldvl,vr, ldvr, n, &
                        in, work( iwrk ), ierr )
              if( ierr/=0 ) then
                 info = n + 2
                 go to 110
              end if
              ! undo balancing on vl and vr and normalization
              if( ilvl ) then
                 call stdlib_${ri}$ggbak( 'P', 'L', n, ilo, ihi, work( ileft ),work( iright ), n, vl, &
                           ldvl, ierr )
                 loop_50: do jc = 1, n
                    if( alphai( jc )<zero )cycle loop_50
                    temp = zero
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          temp = max( temp, abs( vl( jr, jc ) ) )
                       end do
                    else
                       do jr = 1, n
                          temp = max( temp, abs( vl( jr, jc ) )+abs( vl( jr, jc+1 ) ) )
                       end do
                    end if
                    if( temp<smlnum )cycle loop_50
                    temp = one / temp
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          vl( jr, jc ) = vl( jr, jc )*temp
                       end do
                    else
                       do jr = 1, n
                          vl( jr, jc ) = vl( jr, jc )*temp
                          vl( jr, jc+1 ) = vl( jr, jc+1 )*temp
                       end do
                    end if
                 end do loop_50
              end if
              if( ilvr ) then
                 call stdlib_${ri}$ggbak( 'P', 'R', n, ilo, ihi, work( ileft ),work( iright ), n, vr, &
                           ldvr, ierr )
                 loop_100: do jc = 1, n
                    if( alphai( jc )<zero )cycle loop_100
                    temp = zero
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          temp = max( temp, abs( vr( jr, jc ) ) )
                       end do
                    else
                       do jr = 1, n
                          temp = max( temp, abs( vr( jr, jc ) )+abs( vr( jr, jc+1 ) ) )
                       end do
                    end if
                    if( temp<smlnum )cycle loop_100
                    temp = one / temp
                    if( alphai( jc )==zero ) then
                       do jr = 1, n
                          vr( jr, jc ) = vr( jr, jc )*temp
                       end do
                    else
                       do jr = 1, n
                          vr( jr, jc ) = vr( jr, jc )*temp
                          vr( jr, jc+1 ) = vr( jr, jc+1 )*temp
                       end do
                    end if
                 end do loop_100
              end if
              ! end of eigenvector calculation
           end if
           ! undo scaling if necessary
           110 continue
           if( ilascl ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$ggev3

#:endif
#:endfor

     module subroutine stdlib_cggev3( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,vl, ldvl, vr, ldvr, &
     !! CGGEV3 computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, and optionally, the left and/or
     !! right generalized eigenvectors.
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right generalized eigenvector v(j) corresponding to the
     !! generalized eigenvalue lambda(j) of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j).
     !! The left generalized eigenvector u(j) corresponding to the
     !! generalized eigenvalues lambda(j) of (A,B) satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H * B
     !! where u(j)**H is the conjugate-transpose of u(j).
               work, lwork, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: alpha(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery
           character :: chtemp
           integer(ilp) :: icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, in, iright, irows, irwrk,&
                      itau, iwrk, jc, jr, lwkopt
           real(sp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           complex(sp) :: x
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=sp) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -11
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -13
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -15
           end if
           ! compute workspace
           if( info==0 ) then
              call stdlib_cgeqrf( n, n, b, ldb, work, work, -1, ierr )
              lwkopt = max( n,  n+int( work( 1 ),KIND=ilp) )
              call stdlib_cunmqr( 'L', 'C', n, n, n, b, ldb, work, a, lda, work,-1, ierr )
              lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
              if( ilvl ) then
                 call stdlib_cungqr( n, n, n, vl, ldvl, work, work, -1, ierr )
                 lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
              end if
              if( ilv ) then
                 call stdlib_cgghd3( jobvl, jobvr, n, 1, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                           work, -1, ierr )
                 lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
                 call stdlib_claqz0( 'S', jobvl, jobvr, n, 1, n, a, lda, b, ldb,alpha, beta, vl, &
                           ldvl, vr, ldvr, work, -1,rwork, 0, ierr )
                 lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
              else
                 call stdlib_cgghd3( 'N', 'N', n, 1, n, a, lda, b, ldb, vl, ldvl,vr, ldvr, work, -&
                           1, ierr )
                 lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
                 call stdlib_claqz0( 'E', jobvl, jobvr, n, 1, n, a, lda, b, ldb,alpha, beta, vl, &
                           ldvl, vr, ldvr, work, -1,rwork, 0, ierr )
                 lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
              end if
              work( 1 ) = cmplx( lwkopt,KIND=sp)
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGEV3 ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_slamch( 'E' )*stdlib_slamch( 'B' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_clascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_clange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrices a, b to isolate eigenvalues if possible
           ileft = 1
           iright = n + 1
           irwrk = iright + n
           call stdlib_cggbal( 'P', n, a, lda, b, ldb, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     rwork( irwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           irows = ihi + 1 - ilo
           if( ilv ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = 1
           iwrk = itau + irows
           call stdlib_cgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           call stdlib_cunmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl
           if( ilvl ) then
              call stdlib_claset( 'FULL', n, n, czero, cone, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_clacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_cungqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vr
           if( ilvr )call stdlib_claset( 'FULL', n, n, czero, cone, vr, ldvr )
           ! reduce to generalized hessenberg form
           if( ilv ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_cgghd3( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        work( iwrk ), lwork+1-iwrk,ierr )
           else
              call stdlib_cgghd3( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr,work( iwrk ), lwork+1-iwrk, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur form and schur vectors)
           iwrk = itau
           if( ilv ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_claqz0( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vl, &
                     ldvl, vr, ldvr, work( iwrk ),lwork+1-iwrk, rwork( irwrk ), 0, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 70
           end if
           ! compute eigenvectors
           if( ilv ) then
              if( ilvl ) then
                 if( ilvr ) then
                    chtemp = 'B'
                 else
                    chtemp = 'L'
                 end if
              else
                 chtemp = 'R'
              end if
              call stdlib_ctgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl, ldvl,vr, ldvr, n, &
                        in, work( iwrk ), rwork( irwrk ),ierr )
              if( ierr/=0 ) then
                 info = n + 2
                 go to 70
              end if
              ! undo balancing on vl and vr and normalization
              if( ilvl ) then
                 call stdlib_cggbak( 'P', 'L', n, ilo, ihi, rwork( ileft ),rwork( iright ), n, vl,&
                            ldvl, ierr )
                 loop_30: do jc = 1, n
                    temp = zero
                    do jr = 1, n
                       temp = max( temp, abs1( vl( jr, jc ) ) )
                    end do
                    if( temp<smlnum )cycle loop_30
                    temp = one / temp
                    do jr = 1, n
                       vl( jr, jc ) = vl( jr, jc )*temp
                    end do
                 end do loop_30
              end if
              if( ilvr ) then
                 call stdlib_cggbak( 'P', 'R', n, ilo, ihi, rwork( ileft ),rwork( iright ), n, vr,&
                            ldvr, ierr )
                 loop_60: do jc = 1, n
                    temp = zero
                    do jr = 1, n
                       temp = max( temp, abs1( vr( jr, jc ) ) )
                    end do
                    if( temp<smlnum )cycle loop_60
                    temp = one / temp
                    do jr = 1, n
                       vr( jr, jc ) = vr( jr, jc )*temp
                    end do
                 end do loop_60
              end if
           end if
           ! undo scaling if necessary
           70 continue
           if( ilascl )call stdlib_clascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           work( 1 ) = cmplx( lwkopt,KIND=sp)
           return
     end subroutine stdlib_cggev3

     module subroutine stdlib_zggev3( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,vl, ldvl, vr, ldvr, &
     !! ZGGEV3 computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, and optionally, the left and/or
     !! right generalized eigenvectors.
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right generalized eigenvector v(j) corresponding to the
     !! generalized eigenvalue lambda(j) of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j).
     !! The left generalized eigenvector u(j) corresponding to the
     !! generalized eigenvalues lambda(j) of (A,B) satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H * B
     !! where u(j)**H is the conjugate-transpose of u(j).
               work, lwork, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: alpha(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery
           character :: chtemp
           integer(ilp) :: icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, in, iright, irows, irwrk,&
                      itau, iwrk, jc, jr, lwkopt
           real(dp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           complex(dp) :: x
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=dp) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -11
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -13
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -15
           end if
           ! compute workspace
           if( info==0 ) then
              call stdlib_zgeqrf( n, n, b, ldb, work, work, -1, ierr )
              lwkopt = max( 1,  n+int( work( 1 ),KIND=ilp) )
              call stdlib_zunmqr( 'L', 'C', n, n, n, b, ldb, work, a, lda, work,-1, ierr )
              lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
              if( ilvl ) then
                 call stdlib_zungqr( n, n, n, vl, ldvl, work, work, -1, ierr )
                 lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
              end if
              if( ilv ) then
                 call stdlib_zgghd3( jobvl, jobvr, n, 1, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                           work, -1, ierr )
                 lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
                 call stdlib_zlaqz0( 'S', jobvl, jobvr, n, 1, n, a, lda, b, ldb,alpha, beta, vl, &
                           ldvl, vr, ldvr, work, -1,rwork, 0, ierr )
                 lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
              else
                 call stdlib_zgghd3( jobvl, jobvr, n, 1, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                           work, -1, ierr )
                 lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
                 call stdlib_zlaqz0( 'E', jobvl, jobvr, n, 1, n, a, lda, b, ldb,alpha, beta, vl, &
                           ldvl, vr, ldvr, work, -1,rwork, 0, ierr )
                 lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
              end if
              work( 1 ) = cmplx( lwkopt,KIND=dp)
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGEV3 ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_dlamch( 'E' )*stdlib_dlamch( 'B' )
           smlnum = stdlib_dlamch( 'S' )
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_zlange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_zlascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_zlange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_zlascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrices a, b to isolate eigenvalues if possible
           ileft = 1
           iright = n + 1
           irwrk = iright + n
           call stdlib_zggbal( 'P', n, a, lda, b, ldb, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     rwork( irwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           irows = ihi + 1 - ilo
           if( ilv ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = 1
           iwrk = itau + irows
           call stdlib_zgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           call stdlib_zunmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl
           if( ilvl ) then
              call stdlib_zlaset( 'FULL', n, n, czero, cone, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_zlacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_zungqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vr
           if( ilvr )call stdlib_zlaset( 'FULL', n, n, czero, cone, vr, ldvr )
           ! reduce to generalized hessenberg form
           if( ilv ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_zgghd3( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        work( iwrk ), lwork+1-iwrk, ierr )
           else
              call stdlib_zgghd3( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr,work( iwrk ), lwork+1-iwrk, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur form and schur vectors)
           iwrk = itau
           if( ilv ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_zlaqz0( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vl, &
                     ldvl, vr, ldvr, work( iwrk ),lwork+1-iwrk, rwork( irwrk ), 0, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 70
           end if
           ! compute eigenvectors
           if( ilv ) then
              if( ilvl ) then
                 if( ilvr ) then
                    chtemp = 'B'
                 else
                    chtemp = 'L'
                 end if
              else
                 chtemp = 'R'
              end if
              call stdlib_ztgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl, ldvl,vr, ldvr, n, &
                        in, work( iwrk ), rwork( irwrk ),ierr )
              if( ierr/=0 ) then
                 info = n + 2
                 go to 70
              end if
              ! undo balancing on vl and vr and normalization
              if( ilvl ) then
                 call stdlib_zggbak( 'P', 'L', n, ilo, ihi, rwork( ileft ),rwork( iright ), n, vl,&
                            ldvl, ierr )
                 loop_30: do jc = 1, n
                    temp = zero
                    do jr = 1, n
                       temp = max( temp, abs1( vl( jr, jc ) ) )
                    end do
                    if( temp<smlnum )cycle loop_30
                    temp = one / temp
                    do jr = 1, n
                       vl( jr, jc ) = vl( jr, jc )*temp
                    end do
                 end do loop_30
              end if
              if( ilvr ) then
                 call stdlib_zggbak( 'P', 'R', n, ilo, ihi, rwork( ileft ),rwork( iright ), n, vr,&
                            ldvr, ierr )
                 loop_60: do jc = 1, n
                    temp = zero
                    do jr = 1, n
                       temp = max( temp, abs1( vr( jr, jc ) ) )
                    end do
                    if( temp<smlnum )cycle loop_60
                    temp = one / temp
                    do jr = 1, n
                       vr( jr, jc ) = vr( jr, jc )*temp
                    end do
                 end do loop_60
              end if
           end if
           ! undo scaling if necessary
           70 continue
           if( ilascl )call stdlib_zlascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           if( ilbscl )call stdlib_zlascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           work( 1 ) = cmplx( lwkopt,KIND=dp)
           return
     end subroutine stdlib_zggev3

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$ggev3( jobvl, jobvr, n, a, lda, b, ldb, alpha, beta,vl, ldvl, vr, ldvr, &
     !! ZGGEV3: computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, and optionally, the left and/or
     !! right generalized eigenvectors.
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar
     !! lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
     !! singular. It is usually represented as the pair (alpha,beta), as
     !! there is a reasonable interpretation for beta=0, and even for both
     !! being zero.
     !! The right generalized eigenvector v(j) corresponding to the
     !! generalized eigenvalue lambda(j) of (A,B) satisfies
     !! A * v(j) = lambda(j) * B * v(j).
     !! The left generalized eigenvector u(j) corresponding to the
     !! generalized eigenvalues lambda(j) of (A,B) satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H * B
     !! where u(j)**H is the conjugate-transpose of u(j).
               work, lwork, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvl, jobvr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, n
           ! Array Arguments 
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: alpha(*), beta(*), vl(ldvl,*), vr(ldvr,*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: ilascl, ilbscl, ilv, ilvl, ilvr, lquery
           character :: chtemp
           integer(ilp) :: icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, in, iright, irows, irwrk,&
                      itau, iwrk, jc, jr, lwkopt
           real(${ck}$) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, smlnum, temp
           complex(${ck}$) :: x
           ! Local Arrays 
           logical(lk) :: ldumma(1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=${ck}$) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvl, 'N' ) ) then
              ijobvl = 1
              ilvl = .false.
           else if( stdlib_lsame( jobvl, 'V' ) ) then
              ijobvl = 2
              ilvl = .true.
           else
              ijobvl = -1
              ilvl = .false.
           end if
           if( stdlib_lsame( jobvr, 'N' ) ) then
              ijobvr = 1
              ilvr = .false.
           else if( stdlib_lsame( jobvr, 'V' ) ) then
              ijobvr = 2
              ilvr = .true.
           else
              ijobvr = -1
              ilvr = .false.
           end if
           ilv = ilvl .or. ilvr
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( ilvl .and. ldvl<n ) ) then
              info = -11
           else if( ldvr<1 .or. ( ilvr .and. ldvr<n ) ) then
              info = -13
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -15
           end if
           ! compute workspace
           if( info==0 ) then
              call stdlib_${ci}$geqrf( n, n, b, ldb, work, work, -1, ierr )
              lwkopt = max( 1,  n+int( work( 1 ),KIND=ilp) )
              call stdlib_${ci}$unmqr( 'L', 'C', n, n, n, b, ldb, work, a, lda, work,-1, ierr )
              lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
              if( ilvl ) then
                 call stdlib_${ci}$ungqr( n, n, n, vl, ldvl, work, work, -1, ierr )
                 lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
              end if
              if( ilv ) then
                 call stdlib_${ci}$gghd3( jobvl, jobvr, n, 1, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                           work, -1, ierr )
                 lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
                 call stdlib_${ci}$laqz0( 'S', jobvl, jobvr, n, 1, n, a, lda, b, ldb,alpha, beta, vl, &
                           ldvl, vr, ldvr, work, -1,rwork, 0, ierr )
                 lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
              else
                 call stdlib_${ci}$gghd3( jobvl, jobvr, n, 1, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                           work, -1, ierr )
                 lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
                 call stdlib_${ci}$laqz0( 'E', jobvl, jobvr, n, 1, n, a, lda, b, ldb,alpha, beta, vl, &
                           ldvl, vr, ldvr, work, -1,rwork, 0, ierr )
                 lwkopt = max( lwkopt, n+int( work( 1 ),KIND=ilp) )
              end if
              work( 1 ) = cmplx( lwkopt,KIND=${ck}$)
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGEV3 ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_${c2ri(ci)}$lamch( 'E' )*stdlib_${c2ri(ci)}$lamch( 'B' )
           smlnum = stdlib_${c2ri(ci)}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${c2ri(ci)}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ci}$lange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_${ci}$lascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_${ci}$lange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_${ci}$lascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrices a, b to isolate eigenvalues if possible
           ileft = 1
           iright = n + 1
           irwrk = iright + n
           call stdlib_${ci}$ggbal( 'P', n, a, lda, b, ldb, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     rwork( irwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           irows = ihi + 1 - ilo
           if( ilv ) then
              icols = n + 1 - ilo
           else
              icols = irows
           end if
           itau = 1
           iwrk = itau + irows
           call stdlib_${ci}$geqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           call stdlib_${ci}$unmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vl
           if( ilvl ) then
              call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, vl, ldvl )
              if( irows>1 ) then
                 call stdlib_${ci}$lacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vl( ilo+1, ilo ),&
                            ldvl )
              end if
              call stdlib_${ci}$ungqr( irows, irows, irows, vl( ilo, ilo ), ldvl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vr
           if( ilvr )call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, vr, ldvr )
           ! reduce to generalized hessenberg form
           if( ilv ) then
              ! eigenvectors requested -- work on whole matrix.
              call stdlib_${ci}$gghd3( jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb, vl,ldvl, vr, ldvr, &
                        work( iwrk ), lwork+1-iwrk, ierr )
           else
              call stdlib_${ci}$gghd3( 'N', 'N', irows, 1, irows, a( ilo, ilo ), lda,b( ilo, ilo ), &
                        ldb, vl, ldvl, vr, ldvr,work( iwrk ), lwork+1-iwrk, ierr )
           end if
           ! perform qz algorithm (compute eigenvalues, and optionally, the
           ! schur form and schur vectors)
           iwrk = itau
           if( ilv ) then
              chtemp = 'S'
           else
              chtemp = 'E'
           end if
           call stdlib_${ci}$laqz0( chtemp, jobvl, jobvr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vl, &
                     ldvl, vr, ldvr, work( iwrk ),lwork+1-iwrk, rwork( irwrk ), 0, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 70
           end if
           ! compute eigenvectors
           if( ilv ) then
              if( ilvl ) then
                 if( ilvr ) then
                    chtemp = 'B'
                 else
                    chtemp = 'L'
                 end if
              else
                 chtemp = 'R'
              end if
              call stdlib_${ci}$tgevc( chtemp, 'B', ldumma, n, a, lda, b, ldb, vl, ldvl,vr, ldvr, n, &
                        in, work( iwrk ), rwork( irwrk ),ierr )
              if( ierr/=0 ) then
                 info = n + 2
                 go to 70
              end if
              ! undo balancing on vl and vr and normalization
              if( ilvl ) then
                 call stdlib_${ci}$ggbak( 'P', 'L', n, ilo, ihi, rwork( ileft ),rwork( iright ), n, vl,&
                            ldvl, ierr )
                 loop_30: do jc = 1, n
                    temp = zero
                    do jr = 1, n
                       temp = max( temp, abs1( vl( jr, jc ) ) )
                    end do
                    if( temp<smlnum )cycle loop_30
                    temp = one / temp
                    do jr = 1, n
                       vl( jr, jc ) = vl( jr, jc )*temp
                    end do
                 end do loop_30
              end if
              if( ilvr ) then
                 call stdlib_${ci}$ggbak( 'P', 'R', n, ilo, ihi, rwork( ileft ),rwork( iright ), n, vr,&
                            ldvr, ierr )
                 loop_60: do jc = 1, n
                    temp = zero
                    do jr = 1, n
                       temp = max( temp, abs1( vr( jr, jc ) ) )
                    end do
                    if( temp<smlnum )cycle loop_60
                    temp = one / temp
                    do jr = 1, n
                       vr( jr, jc ) = vr( jr, jc )*temp
                    end do
                 end do loop_60
              end if
           end if
           ! undo scaling if necessary
           70 continue
           if( ilascl )call stdlib_${ci}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           if( ilbscl )call stdlib_${ci}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           work( 1 ) = cmplx( lwkopt,KIND=${ck}$)
           return
     end subroutine stdlib_${ci}$ggev3

#:endif
#:endfor



     module pure subroutine stdlib_strevc3( side, howmny, select, n, t, ldt, vl, ldvl,vr, ldvr, mm, m, &
     !! STREVC3 computes some or all of the right and/or left eigenvectors of
     !! a real upper quasi-triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a real general matrix:  A = Q*T*Q**T, as computed by SHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**T)*T = w*(y**T)
     !! where y**T denotes the transpose of the vector y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal blocks of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix. If Q is the orthogonal factor that reduces a matrix
     !! A to Schur form T, then Q*X and Q*Y are the matrices of right and
     !! left eigenvectors of A.
     !! This uses a Level 3 BLAS version of the back transformation.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, lwork, mm, n
           ! Array Arguments 
           logical(lk), intent(inout) :: select(*)
           real(sp), intent(in) :: t(ldt,*)
           real(sp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmin = 8
           integer(ilp), parameter :: nbmax = 128
           
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, lquery, over, pair, rightv, somev
           integer(ilp) :: i, ierr, ii, ip, is, j, j1, j2, jnxt, k, ki, iv, maxwrk, nb, &
                     ki2
           real(sp) :: beta, bignum, emax, ovfl, rec, remax, scale, smin, smlnum, ulp, unfl, &
                     vcrit, vmax, wi, wr, xnorm
           ! Intrinsic Functions 
           ! Local Arrays 
           real(sp) :: x(2,2)
           integer(ilp) :: iscomplex(nbmax)
           ! Executable Statements 
           ! decode and test the input parameters
           bothv  = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv  = stdlib_lsame( side, 'L' ) .or. bothv
           allv  = stdlib_lsame( howmny, 'A' )
           over  = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           info = 0
           nb = stdlib_ilaenv( 1, 'STREVC', side // howmny, n, -1, -1, -1 )
           maxwrk = n + 2*n*nb
           work(1) = maxwrk
           lquery = ( lwork==-1 )
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else if( lwork<max( 1, 3*n ) .and. .not.lquery ) then
              info = -14
           else
              ! set m to the number of columns required to store the selected
              ! eigenvectors, standardize the array select if necessary, and
              ! test mm.
              if( somev ) then
                 m = 0
                 pair = .false.
                 do j = 1, n
                    if( pair ) then
                       pair = .false.
                       select( j ) = .false.
                    else
                       if( j<n ) then
                          if( t( j+1, j )==zero ) then
                             if( select( j ) )m = m + 1
                          else
                             pair = .true.
                             if( select( j ) .or. select( j+1 ) ) then
                                select( j ) = .true.
                                m = m + 2
                             end if
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( mm<m ) then
                 info = -11
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STREVC3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! use blocked version of back-transformation if sufficient workspace.
           ! zero-out the workspace to avoid potential nan propagation.
           if( over .and. lwork >= n + 2*n*nbmin ) then
              nb = (lwork - n) / (2*n)
              nb = min( nb, nbmax )
              call stdlib_slaset( 'F', n, 1+2*nb, zero, zero, work, n )
           else
              nb = 1
           end if
           ! set the constants to control overflow.
           unfl = stdlib_slamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_slabad( unfl, ovfl )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           bignum = ( one-ulp ) / smlnum
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           work( 1 ) = zero
           do j = 2, n
              work( j ) = zero
              do i = 1, j - 1
                 work( j ) = work( j ) + abs( t( i, j ) )
              end do
           end do
           ! index ip is used to specify the real or complex eigenvalue:
             ! ip = 0, real eigenvalue,
                  ! 1, first  of conjugate complex pair: (wr,wi)
                 ! -1, second of conjugate complex pair: (wr,wi)
             ! iscomplex array stores ip for each column in current block.
           if( rightv ) then
              ! ============================================================
              ! compute right eigenvectors.
              ! iv is index of column in current block.
              ! for complex right vector, uses iv-1 for real part and iv for complex part.
              ! non-blocked version always uses iv=2;
              ! blocked     version starts with iv=nb, goes down to 1 or 2.
              ! (note the "0-th" column is used for 1-norms computed above.)
              iv = 2
              if( nb>2 ) then
                 iv = nb
              end if
              ip = 0
              is = m
              loop_140: do ki = n, 1, -1
                 if( ip==-1 ) then
                    ! previous iteration (ki+1) was second of conjugate pair,
                    ! so this ki is first of conjugate pair; skip to end of loop
                    ip = 1
                    cycle loop_140
                 else if( ki==1 ) then
                    ! last column, so this ki must be real eigenvalue
                    ip = 0
                 else if( t( ki, ki-1 )==zero ) then
                    ! zero on sub-diagonal, so this ki is real eigenvalue
                    ip = 0
                 else
                    ! non-zero on sub-diagonal, so this ki is second of conjugate pair
                    ip = -1
                 end if
                 if( somev ) then
                    if( ip==0 ) then
                       if( .not.select( ki ) )cycle loop_140
                    else
                       if( .not.select( ki-1 ) )cycle loop_140
                    end if
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki-1 ) ) )*sqrt( abs( t( ki-1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! --------------------------------------------------------
                    ! real right eigenvector
                    work( ki + iv*n ) = one
                    ! form right-hand side.
                    do k = 1, ki - 1
                       work( k + iv*n ) = -t( k, ki )
                    end do
                    ! solve upper quasi-triangular system:
                    ! [ t(1:ki-1,1:ki-1) - wr ]*x = scale*work.
                    jnxt = ki - 1
                    loop_60: do j = ki - 1, 1, -1
                       if( j>jnxt )cycle loop_60
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1   = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_slaln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_sscal( ki, scale, work( 1+iv*n ), 1 )
                                    
                          work( j+iv*n ) = x( 1, 1 )
                          ! update right-hand side
                          call stdlib_saxpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+iv*n ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_slaln2( .false., 2, 1, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+iv*n ), n, wr, zero, x, 2,scale, xnorm, ierr )
                          ! scale x(1,1) and x(2,1) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 2, 1 ) = x( 2, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_sscal( ki, scale, work( 1+iv*n ), 1 )
                                    
                          work( j-1+iv*n ) = x( 1, 1 )
                          work( j  +iv*n ) = x( 2, 1 )
                          ! update right-hand side
                          call stdlib_saxpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+iv*n ), 1 )
                                    
                          call stdlib_saxpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+iv*n ), 1 )
                                    
                       end if
                    end do loop_60
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vr and normalize.
                       call stdlib_scopy( ki, work( 1 + iv*n ), 1, vr( 1, is ), 1 )
                       ii = stdlib_isamax( ki, vr( 1, is ), 1 )
                       remax = one / abs( vr( ii, is ) )
                       call stdlib_sscal( ki, remax, vr( 1, is ), 1 )
                       do k = ki + 1, n
                          vr( k, is ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki>1 )call stdlib_sgemv( 'N', n, ki-1, one, vr, ldvr,work( 1 + iv*n ), &
                                 1, work( ki + iv*n ),vr( 1, ki ), 1 )
                       ii = stdlib_isamax( n, vr( 1, ki ), 1 )
                       remax = one / abs( vr( ii, ki ) )
                       call stdlib_sscal( n, remax, vr( 1, ki ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out below vector
                       do k = ki + 1, n
                          work( k + iv*n ) = zero
                       end do
                       iscomplex( iv ) = ip
                       ! back-transform and normalization is done below
                    end if
                 else
                    ! --------------------------------------------------------
                    ! complex right eigenvector.
                    ! initial solve
                    ! [ ( t(ki-1,ki-1) t(ki-1,ki) ) - (wr + i*wi) ]*x = 0.
                    ! [ ( t(ki,  ki-1) t(ki,  ki) )               ]
                    if( abs( t( ki-1, ki ) )>=abs( t( ki, ki-1 ) ) ) then
                       work( ki-1 + (iv-1)*n ) = one
                       work( ki   + (iv  )*n ) = wi / t( ki-1, ki )
                    else
                       work( ki-1 + (iv-1)*n ) = -wi / t( ki, ki-1 )
                       work( ki   + (iv  )*n ) = one
                    end if
                    work( ki   + (iv-1)*n ) = zero
                    work( ki-1 + (iv  )*n ) = zero
                    ! form right-hand side.
                    do k = 1, ki - 2
                       work( k+(iv-1)*n ) = -work( ki-1+(iv-1)*n )*t(k,ki-1)
                       work( k+(iv  )*n ) = -work( ki  +(iv  )*n )*t(k,ki  )
                    end do
                    ! solve upper quasi-triangular system:
                    ! [ t(1:ki-2,1:ki-2) - (wr+i*wi) ]*x = scale*(work+i*work2)
                    jnxt = ki - 2
                    loop_90: do j = ki - 2, 1, -1
                       if( j>jnxt )cycle loop_90
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1   = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_slaln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+(iv-1)*n ), n,wr, wi, x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) and x(1,2) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 1, 2 ) = x( 1, 2 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_sscal( ki, scale, work( 1+(iv-1)*n ), 1 )
                             call stdlib_sscal( ki, scale, work( 1+(iv  )*n ), 1 )
                          end if
                          work( j+(iv-1)*n ) = x( 1, 1 )
                          work( j+(iv  )*n ) = x( 1, 2 )
                          ! update the right-hand side
                          call stdlib_saxpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+(iv-1)*n ), 1 )
                                    
                          call stdlib_saxpy( j-1, -x( 1, 2 ), t( 1, j ), 1,work( 1+(iv  )*n ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_slaln2( .false., 2, 2, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+(iv-1)*n ), n, wr, wi, x, 2,scale, xnorm, ierr )
                          ! scale x to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                rec = one / xnorm
                                x( 1, 1 ) = x( 1, 1 )*rec
                                x( 1, 2 ) = x( 1, 2 )*rec
                                x( 2, 1 ) = x( 2, 1 )*rec
                                x( 2, 2 ) = x( 2, 2 )*rec
                                scale = scale*rec
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_sscal( ki, scale, work( 1+(iv-1)*n ), 1 )
                             call stdlib_sscal( ki, scale, work( 1+(iv  )*n ), 1 )
                          end if
                          work( j-1+(iv-1)*n ) = x( 1, 1 )
                          work( j  +(iv-1)*n ) = x( 2, 1 )
                          work( j-1+(iv  )*n ) = x( 1, 2 )
                          work( j  +(iv  )*n ) = x( 2, 2 )
                          ! update the right-hand side
                          call stdlib_saxpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+(iv-1)*n   ),&
                                     1 )
                          call stdlib_saxpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+(iv-1)*n   ), &
                                    1 )
                          call stdlib_saxpy( j-2, -x( 1, 2 ), t( 1, j-1 ), 1,work( 1+(iv  )*n ), &
                                    1 )
                          call stdlib_saxpy( j-2, -x( 2, 2 ), t( 1, j ), 1,work( 1+(iv  )*n ), 1 )
                                    
                       end if
                    end do loop_90
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vr and normalize.
                       call stdlib_scopy( ki, work( 1+(iv-1)*n ), 1, vr(1,is-1), 1 )
                       call stdlib_scopy( ki, work( 1+(iv  )*n ), 1, vr(1,is  ), 1 )
                       emax = zero
                       do k = 1, ki
                          emax = max( emax, abs( vr( k, is-1 ) )+abs( vr( k, is   ) ) )
                       end do
                       remax = one / emax
                       call stdlib_sscal( ki, remax, vr( 1, is-1 ), 1 )
                       call stdlib_sscal( ki, remax, vr( 1, is   ), 1 )
                       do k = ki + 1, n
                          vr( k, is-1 ) = zero
                          vr( k, is   ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki>2 ) then
                          call stdlib_sgemv( 'N', n, ki-2, one, vr, ldvr,work( 1    + (iv-1)*n ), &
                                    1,work( ki-1 + (iv-1)*n ), vr(1,ki-1), 1)
                          call stdlib_sgemv( 'N', n, ki-2, one, vr, ldvr,work( 1  + (iv)*n ), 1,&
                                    work( ki + (iv)*n ), vr( 1, ki ), 1 )
                       else
                          call stdlib_sscal( n, work(ki-1+(iv-1)*n), vr(1,ki-1), 1)
                          call stdlib_sscal( n, work(ki  +(iv  )*n), vr(1,ki  ), 1)
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vr( k, ki-1 ) )+abs( vr( k, ki   ) ) )
                       end do
                       remax = one / emax
                       call stdlib_sscal( n, remax, vr( 1, ki-1 ), 1 )
                       call stdlib_sscal( n, remax, vr( 1, ki   ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out below vector
                       do k = ki + 1, n
                          work( k + (iv-1)*n ) = zero
                          work( k + (iv  )*n ) = zero
                       end do
                       iscomplex( iv-1 ) = -ip
                       iscomplex( iv   ) =  ip
                       iv = iv - 1
                       ! back-transform and normalization is done below
                    end if
                 end if
                 if( nb>1 ) then
                    ! --------------------------------------------------------
                    ! blocked version of back-transform
                    ! for complex case, ki2 includes both vectors (ki-1 and ki)
                    if( ip==0 ) then
                       ki2 = ki
                    else
                       ki2 = ki - 1
                    end if
                    ! columns iv:nb of work are valid vectors.
                    ! when the number of vectors stored reaches nb-1 or nb,
                    ! or if this was last vector, do the gemm
                    if( (iv<=2) .or. (ki2==1) ) then
                       call stdlib_sgemm( 'N', 'N', n, nb-iv+1, ki2+nb-iv, one,vr, ldvr,work( 1 + &
                                 (iv)*n    ), n,zero,work( 1 + (nb+iv)*n ), n )
                       ! normalize vectors
                       do k = iv, nb
                          if( iscomplex(k)==0 ) then
                             ! real eigenvector
                             ii = stdlib_isamax( n, work( 1 + (nb+k)*n ), 1 )
                             remax = one / abs( work( ii + (nb+k)*n ) )
                          else if( iscomplex(k)==1 ) then
                             ! first eigenvector of conjugate pair
                             emax = zero
                             do ii = 1, n
                                emax = max( emax,abs( work( ii + (nb+k  )*n ) )+abs( work( ii + (&
                                          nb+k+1)*n ) ) )
                             end do
                             remax = one / emax
                          ! else if iscomplex(k)==-1
                             ! second eigenvector of conjugate pair
                             ! reuse same remax as previous k
                          end if
                          call stdlib_sscal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_slacpy( 'F', n, nb-iv+1,work( 1 + (nb+iv)*n ), n,vr( 1, ki2 ), &
                                 ldvr )
                       iv = nb
                    else
                       iv = iv - 1
                    end if
                 end if ! blocked back-transform
                 is = is - 1
                 if( ip/=0 )is = is - 1
              end do loop_140
           end if
           if( leftv ) then
              ! ============================================================
              ! compute left eigenvectors.
              ! iv is index of column in current block.
              ! for complex left vector, uses iv for real part and iv+1 for complex part.
              ! non-blocked version always uses iv=1;
              ! blocked     version starts with iv=1, goes up to nb-1 or nb.
              ! (note the "0-th" column is used for 1-norms computed above.)
              iv = 1
              ip = 0
              is = 1
              loop_260: do ki = 1, n
                 if( ip==1 ) then
                    ! previous iteration (ki-1) was first of conjugate pair,
                    ! so this ki is second of conjugate pair; skip to end of loop
                    ip = -1
                    cycle loop_260
                 else if( ki==n ) then
                    ! last column, so this ki must be real eigenvalue
                    ip = 0
                 else if( t( ki+1, ki )==zero ) then
                    ! zero on sub-diagonal, so this ki is real eigenvalue
                    ip = 0
                 else
                    ! non-zero on sub-diagonal, so this ki is first of conjugate pair
                    ip = 1
                 end if
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_260
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki+1 ) ) )*sqrt( abs( t( ki+1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! --------------------------------------------------------
                    ! real left eigenvector
                    work( ki + iv*n ) = one
                    ! form right-hand side.
                    do k = ki + 1, n
                       work( k + iv*n ) = -t( ki, k )
                    end do
                    ! solve transposed quasi-triangular system:
                    ! [ t(ki+1:n,ki+1:n) - wr ]**t * x = scale*work
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 1
                    loop_170: do j = ki + 1, n
                       if( j<jnxt )cycle loop_170
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_sscal( n-ki+1, rec, work( ki+iv*n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+iv*n ) = work( j+iv*n ) -stdlib_sdot( j-ki-1, t( ki+1, j ), 1,&
                                    work( ki+1+iv*n ), 1 )
                          ! solve [ t(j,j) - wr ]**t * x = work
                          call stdlib_slaln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_sscal( n-ki+1, scale, work( ki+iv*n ), 1 )
                                    
                          work( j+iv*n ) = x( 1, 1 )
                          vmax = max( abs( work( j+iv*n ) ), vmax )
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_sscal( n-ki+1, rec, work( ki+iv*n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+iv*n ) = work( j+iv*n ) -stdlib_sdot( j-ki-1, t( ki+1, j ), 1,&
                                    work( ki+1+iv*n ), 1 )
                          work( j+1+iv*n ) = work( j+1+iv*n ) -stdlib_sdot( j-ki-1, t( ki+1, j+1 )&
                                    , 1,work( ki+1+iv*n ), 1 )
                          ! solve
                          ! [ t(j,j)-wr   t(j,j+1)      ]**t * x = scale*( work1 )
                          ! [ t(j+1,j)    t(j+1,j+1)-wr ]                ( work2 )
                          call stdlib_slaln2( .true., 2, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_sscal( n-ki+1, scale, work( ki+iv*n ), 1 )
                                    
                          work( j  +iv*n ) = x( 1, 1 )
                          work( j+1+iv*n ) = x( 2, 1 )
                          vmax = max( abs( work( j  +iv*n ) ),abs( work( j+1+iv*n ) ), vmax )
                                    
                          vcrit = bignum / vmax
                       end if
                    end do loop_170
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vl and normalize.
                       call stdlib_scopy( n-ki+1, work( ki + iv*n ), 1,vl( ki, is ), 1 )
                       ii = stdlib_isamax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                       remax = one / abs( vl( ii, is ) )
                       call stdlib_sscal( n-ki+1, remax, vl( ki, is ), 1 )
                       do k = 1, ki - 1
                          vl( k, is ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki<n )call stdlib_sgemv( 'N', n, n-ki, one,vl( 1, ki+1 ), ldvl,work( &
                                 ki+1 + iv*n ), 1,work( ki   + iv*n ), vl( 1, ki ), 1 )
                       ii = stdlib_isamax( n, vl( 1, ki ), 1 )
                       remax = one / abs( vl( ii, ki ) )
                       call stdlib_sscal( n, remax, vl( 1, ki ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out above vector
                       ! could go from ki-nv+1 to ki-1
                       do k = 1, ki - 1
                          work( k + iv*n ) = zero
                       end do
                       iscomplex( iv ) = ip
                       ! back-transform and normalization is done below
                    end if
                 else
                    ! --------------------------------------------------------
                    ! complex left eigenvector.
                    ! initial solve:
                    ! [ ( t(ki,ki)    t(ki,ki+1)  )**t - (wr - i* wi) ]*x = 0.
                    ! [ ( t(ki+1,ki) t(ki+1,ki+1) )                   ]
                    if( abs( t( ki, ki+1 ) )>=abs( t( ki+1, ki ) ) ) then
                       work( ki   + (iv  )*n ) = wi / t( ki, ki+1 )
                       work( ki+1 + (iv+1)*n ) = one
                    else
                       work( ki   + (iv  )*n ) = one
                       work( ki+1 + (iv+1)*n ) = -wi / t( ki+1, ki )
                    end if
                    work( ki+1 + (iv  )*n ) = zero
                    work( ki   + (iv+1)*n ) = zero
                    ! form right-hand side.
                    do k = ki + 2, n
                       work( k+(iv  )*n ) = -work( ki  +(iv  )*n )*t(ki,  k)
                       work( k+(iv+1)*n ) = -work( ki+1+(iv+1)*n )*t(ki+1,k)
                    end do
                    ! solve transposed quasi-triangular system:
                    ! [ t(ki+2:n,ki+2:n)**t - (wr-i*wi) ]*x = work1+i*work2
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 2
                    loop_200: do j = ki + 2, n
                       if( j<jnxt )cycle loop_200
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when
                          ! forming the right-hand side elements.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_sscal( n-ki+1, rec, work(ki+(iv  )*n), 1 )
                             call stdlib_sscal( n-ki+1, rec, work(ki+(iv+1)*n), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+(iv  )*n ) = work( j+(iv)*n ) -stdlib_sdot( j-ki-2, t( ki+2, j )&
                                    , 1,work( ki+2+(iv)*n ), 1 )
                          work( j+(iv+1)*n ) = work( j+(iv+1)*n ) -stdlib_sdot( j-ki-2, t( ki+2, &
                                    j ), 1,work( ki+2+(iv+1)*n ), 1 )
                          ! solve [ t(j,j)-(wr-i*wi) ]*(x11+i*x12)= wk+i*wk2
                          call stdlib_slaln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_sscal( n-ki+1, scale, work(ki+(iv  )*n), 1)
                             call stdlib_sscal( n-ki+1, scale, work(ki+(iv+1)*n), 1)
                          end if
                          work( j+(iv  )*n ) = x( 1, 1 )
                          work( j+(iv+1)*n ) = x( 1, 2 )
                          vmax = max( abs( work( j+(iv  )*n ) ),abs( work( j+(iv+1)*n ) ), vmax )
                                    
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side elements.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_sscal( n-ki+1, rec, work(ki+(iv  )*n), 1 )
                             call stdlib_sscal( n-ki+1, rec, work(ki+(iv+1)*n), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j  +(iv  )*n ) = work( j+(iv)*n ) -stdlib_sdot( j-ki-2, t( ki+2, &
                                    j ), 1,work( ki+2+(iv)*n ), 1 )
                          work( j  +(iv+1)*n ) = work( j+(iv+1)*n ) -stdlib_sdot( j-ki-2, t( ki+2,&
                                     j ), 1,work( ki+2+(iv+1)*n ), 1 )
                          work( j+1+(iv  )*n ) = work( j+1+(iv)*n ) -stdlib_sdot( j-ki-2, t( ki+2,&
                                     j+1 ), 1,work( ki+2+(iv)*n ), 1 )
                          work( j+1+(iv+1)*n ) = work( j+1+(iv+1)*n ) -stdlib_sdot( j-ki-2, t( ki+&
                                    2, j+1 ), 1,work( ki+2+(iv+1)*n ), 1 )
                          ! solve 2-by-2 complex linear equation
                          ! [ (t(j,j)   t(j,j+1)  )**t - (wr-i*wi)*i ]*x = scale*b
                          ! [ (t(j+1,j) t(j+1,j+1))                  ]
                          call stdlib_slaln2( .true., 2, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_sscal( n-ki+1, scale, work(ki+(iv  )*n), 1)
                             call stdlib_sscal( n-ki+1, scale, work(ki+(iv+1)*n), 1)
                          end if
                          work( j  +(iv  )*n ) = x( 1, 1 )
                          work( j  +(iv+1)*n ) = x( 1, 2 )
                          work( j+1+(iv  )*n ) = x( 2, 1 )
                          work( j+1+(iv+1)*n ) = x( 2, 2 )
                          vmax = max( abs( x( 1, 1 ) ), abs( x( 1, 2 ) ),abs( x( 2, 1 ) ), abs( x(&
                                     2, 2 ) ),vmax )
                          vcrit = bignum / vmax
                       end if
                    end do loop_200
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vl and normalize.
                       call stdlib_scopy( n-ki+1, work( ki + (iv  )*n ), 1,vl( ki, is   ), 1 )
                                 
                       call stdlib_scopy( n-ki+1, work( ki + (iv+1)*n ), 1,vl( ki, is+1 ), 1 )
                                 
                       emax = zero
                       do k = ki, n
                          emax = max( emax, abs( vl( k, is   ) )+abs( vl( k, is+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_sscal( n-ki+1, remax, vl( ki, is   ), 1 )
                       call stdlib_sscal( n-ki+1, remax, vl( ki, is+1 ), 1 )
                       do k = 1, ki - 1
                          vl( k, is   ) = zero
                          vl( k, is+1 ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki<n-1 ) then
                          call stdlib_sgemv( 'N', n, n-ki-1, one,vl( 1, ki+2 ), ldvl,work( ki+2 + &
                                    (iv)*n ), 1,work( ki   + (iv)*n ),vl( 1, ki ), 1 )
                          call stdlib_sgemv( 'N', n, n-ki-1, one,vl( 1, ki+2 ), ldvl,work( ki+2 + &
                                    (iv+1)*n ), 1,work( ki+1 + (iv+1)*n ),vl( 1, ki+1 ), 1 )
                       else
                          call stdlib_sscal( n, work(ki+  (iv  )*n), vl(1, ki  ), 1)
                          call stdlib_sscal( n, work(ki+1+(iv+1)*n), vl(1, ki+1), 1)
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vl( k, ki   ) )+abs( vl( k, ki+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_sscal( n, remax, vl( 1, ki   ), 1 )
                       call stdlib_sscal( n, remax, vl( 1, ki+1 ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out above vector
                       ! could go from ki-nv+1 to ki-1
                       do k = 1, ki - 1
                          work( k + (iv  )*n ) = zero
                          work( k + (iv+1)*n ) = zero
                       end do
                       iscomplex( iv   ) =  ip
                       iscomplex( iv+1 ) = -ip
                       iv = iv + 1
                       ! back-transform and normalization is done below
                    end if
                 end if
                 if( nb>1 ) then
                    ! --------------------------------------------------------
                    ! blocked version of back-transform
                    ! for complex case, ki2 includes both vectors (ki and ki+1)
                    if( ip==0 ) then
                       ki2 = ki
                    else
                       ki2 = ki + 1
                    end if
                    ! columns 1:iv of work are valid vectors.
                    ! when the number of vectors stored reaches nb-1 or nb,
                    ! or if this was last vector, do the gemm
                    if( (iv>=nb-1) .or. (ki2==n) ) then
                       call stdlib_sgemm( 'N', 'N', n, iv, n-ki2+iv, one,vl( 1, ki2-iv+1 ), ldvl,&
                                 work( ki2-iv+1 + (1)*n ), n,zero,work( 1 + (nb+1)*n ), n )
                       ! normalize vectors
                       do k = 1, iv
                          if( iscomplex(k)==0) then
                             ! real eigenvector
                             ii = stdlib_isamax( n, work( 1 + (nb+k)*n ), 1 )
                             remax = one / abs( work( ii + (nb+k)*n ) )
                          else if( iscomplex(k)==1) then
                             ! first eigenvector of conjugate pair
                             emax = zero
                             do ii = 1, n
                                emax = max( emax,abs( work( ii + (nb+k  )*n ) )+abs( work( ii + (&
                                          nb+k+1)*n ) ) )
                             end do
                             remax = one / emax
                          ! else if iscomplex(k)==-1
                             ! second eigenvector of conjugate pair
                             ! reuse same remax as previous k
                          end if
                          call stdlib_sscal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_slacpy( 'F', n, iv,work( 1 + (nb+1)*n ), n,vl( 1, ki2-iv+1 ), &
                                 ldvl )
                       iv = 1
                    else
                       iv = iv + 1
                    end if
                 end if ! blocked back-transform
                 is = is + 1
                 if( ip/=0 )is = is + 1
              end do loop_260
           end if
           return
     end subroutine stdlib_strevc3

     module pure subroutine stdlib_dtrevc3( side, howmny, select, n, t, ldt, vl, ldvl,vr, ldvr, mm, m, &
     !! DTREVC3 computes some or all of the right and/or left eigenvectors of
     !! a real upper quasi-triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a real general matrix:  A = Q*T*Q**T, as computed by DHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**T)*T = w*(y**T)
     !! where y**T denotes the transpose of the vector y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal blocks of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix. If Q is the orthogonal factor that reduces a matrix
     !! A to Schur form T, then Q*X and Q*Y are the matrices of right and
     !! left eigenvectors of A.
     !! This uses a Level 3 BLAS version of the back transformation.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, lwork, mm, n
           ! Array Arguments 
           logical(lk), intent(inout) :: select(*)
           real(dp), intent(in) :: t(ldt,*)
           real(dp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmin = 8
           integer(ilp), parameter :: nbmax = 128
           
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, lquery, over, pair, rightv, somev
           integer(ilp) :: i, ierr, ii, ip, is, j, j1, j2, jnxt, k, ki, iv, maxwrk, nb, &
                     ki2
           real(dp) :: beta, bignum, emax, ovfl, rec, remax, scale, smin, smlnum, ulp, unfl, &
                     vcrit, vmax, wi, wr, xnorm
           ! Intrinsic Functions 
           ! Local Arrays 
           real(dp) :: x(2,2)
           integer(ilp) :: iscomplex(nbmax)
           ! Executable Statements 
           ! decode and test the input parameters
           bothv  = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv  = stdlib_lsame( side, 'L' ) .or. bothv
           allv  = stdlib_lsame( howmny, 'A' )
           over  = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           info = 0
           nb = stdlib_ilaenv( 1, 'DTREVC', side // howmny, n, -1, -1, -1 )
           maxwrk = n + 2*n*nb
           work(1) = maxwrk
           lquery = ( lwork==-1 )
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else if( lwork<max( 1, 3*n ) .and. .not.lquery ) then
              info = -14
           else
              ! set m to the number of columns required to store the selected
              ! eigenvectors, standardize the array select if necessary, and
              ! test mm.
              if( somev ) then
                 m = 0
                 pair = .false.
                 do j = 1, n
                    if( pair ) then
                       pair = .false.
                       select( j ) = .false.
                    else
                       if( j<n ) then
                          if( t( j+1, j )==zero ) then
                             if( select( j ) )m = m + 1
                          else
                             pair = .true.
                             if( select( j ) .or. select( j+1 ) ) then
                                select( j ) = .true.
                                m = m + 2
                             end if
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( mm<m ) then
                 info = -11
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTREVC3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! use blocked version of back-transformation if sufficient workspace.
           ! zero-out the workspace to avoid potential nan propagation.
           if( over .and. lwork >= n + 2*n*nbmin ) then
              nb = (lwork - n) / (2*n)
              nb = min( nb, nbmax )
              call stdlib_dlaset( 'F', n, 1+2*nb, zero, zero, work, n )
           else
              nb = 1
           end if
           ! set the constants to control overflow.
           unfl = stdlib_dlamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_dlabad( unfl, ovfl )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           bignum = ( one-ulp ) / smlnum
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           work( 1 ) = zero
           do j = 2, n
              work( j ) = zero
              do i = 1, j - 1
                 work( j ) = work( j ) + abs( t( i, j ) )
              end do
           end do
           ! index ip is used to specify the real or complex eigenvalue:
             ! ip = 0, real eigenvalue,
                  ! 1, first  of conjugate complex pair: (wr,wi)
                 ! -1, second of conjugate complex pair: (wr,wi)
             ! iscomplex array stores ip for each column in current block.
           if( rightv ) then
              ! ============================================================
              ! compute right eigenvectors.
              ! iv is index of column in current block.
              ! for complex right vector, uses iv-1 for real part and iv for complex part.
              ! non-blocked version always uses iv=2;
              ! blocked     version starts with iv=nb, goes down to 1 or 2.
              ! (note the "0-th" column is used for 1-norms computed above.)
              iv = 2
              if( nb>2 ) then
                 iv = nb
              end if
              ip = 0
              is = m
              loop_140: do ki = n, 1, -1
                 if( ip==-1 ) then
                    ! previous iteration (ki+1) was second of conjugate pair,
                    ! so this ki is first of conjugate pair; skip to end of loop
                    ip = 1
                    cycle loop_140
                 else if( ki==1 ) then
                    ! last column, so this ki must be real eigenvalue
                    ip = 0
                 else if( t( ki, ki-1 )==zero ) then
                    ! zero on sub-diagonal, so this ki is real eigenvalue
                    ip = 0
                 else
                    ! non-zero on sub-diagonal, so this ki is second of conjugate pair
                    ip = -1
                 end if
                 if( somev ) then
                    if( ip==0 ) then
                       if( .not.select( ki ) )cycle loop_140
                    else
                       if( .not.select( ki-1 ) )cycle loop_140
                    end if
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki-1 ) ) )*sqrt( abs( t( ki-1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! --------------------------------------------------------
                    ! real right eigenvector
                    work( ki + iv*n ) = one
                    ! form right-hand side.
                    do k = 1, ki - 1
                       work( k + iv*n ) = -t( k, ki )
                    end do
                    ! solve upper quasi-triangular system:
                    ! [ t(1:ki-1,1:ki-1) - wr ]*x = scale*work.
                    jnxt = ki - 1
                    loop_60: do j = ki - 1, 1, -1
                       if( j>jnxt )cycle loop_60
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1   = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_dlaln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_dscal( ki, scale, work( 1+iv*n ), 1 )
                                    
                          work( j+iv*n ) = x( 1, 1 )
                          ! update right-hand side
                          call stdlib_daxpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+iv*n ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_dlaln2( .false., 2, 1, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+iv*n ), n, wr, zero, x, 2,scale, xnorm, ierr )
                          ! scale x(1,1) and x(2,1) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 2, 1 ) = x( 2, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_dscal( ki, scale, work( 1+iv*n ), 1 )
                                    
                          work( j-1+iv*n ) = x( 1, 1 )
                          work( j  +iv*n ) = x( 2, 1 )
                          ! update right-hand side
                          call stdlib_daxpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+iv*n ), 1 )
                                    
                          call stdlib_daxpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+iv*n ), 1 )
                                    
                       end if
                    end do loop_60
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vr and normalize.
                       call stdlib_dcopy( ki, work( 1 + iv*n ), 1, vr( 1, is ), 1 )
                       ii = stdlib_idamax( ki, vr( 1, is ), 1 )
                       remax = one / abs( vr( ii, is ) )
                       call stdlib_dscal( ki, remax, vr( 1, is ), 1 )
                       do k = ki + 1, n
                          vr( k, is ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki>1 )call stdlib_dgemv( 'N', n, ki-1, one, vr, ldvr,work( 1 + iv*n ), &
                                 1, work( ki + iv*n ),vr( 1, ki ), 1 )
                       ii = stdlib_idamax( n, vr( 1, ki ), 1 )
                       remax = one / abs( vr( ii, ki ) )
                       call stdlib_dscal( n, remax, vr( 1, ki ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out below vector
                       do k = ki + 1, n
                          work( k + iv*n ) = zero
                       end do
                       iscomplex( iv ) = ip
                       ! back-transform and normalization is done below
                    end if
                 else
                    ! --------------------------------------------------------
                    ! complex right eigenvector.
                    ! initial solve
                    ! [ ( t(ki-1,ki-1) t(ki-1,ki) ) - (wr + i*wi) ]*x = 0.
                    ! [ ( t(ki,  ki-1) t(ki,  ki) )               ]
                    if( abs( t( ki-1, ki ) )>=abs( t( ki, ki-1 ) ) ) then
                       work( ki-1 + (iv-1)*n ) = one
                       work( ki   + (iv  )*n ) = wi / t( ki-1, ki )
                    else
                       work( ki-1 + (iv-1)*n ) = -wi / t( ki, ki-1 )
                       work( ki   + (iv  )*n ) = one
                    end if
                    work( ki   + (iv-1)*n ) = zero
                    work( ki-1 + (iv  )*n ) = zero
                    ! form right-hand side.
                    do k = 1, ki - 2
                       work( k+(iv-1)*n ) = -work( ki-1+(iv-1)*n )*t(k,ki-1)
                       work( k+(iv  )*n ) = -work( ki  +(iv  )*n )*t(k,ki  )
                    end do
                    ! solve upper quasi-triangular system:
                    ! [ t(1:ki-2,1:ki-2) - (wr+i*wi) ]*x = scale*(work+i*work2)
                    jnxt = ki - 2
                    loop_90: do j = ki - 2, 1, -1
                       if( j>jnxt )cycle loop_90
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1   = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_dlaln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+(iv-1)*n ), n,wr, wi, x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) and x(1,2) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 1, 2 ) = x( 1, 2 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_dscal( ki, scale, work( 1+(iv-1)*n ), 1 )
                             call stdlib_dscal( ki, scale, work( 1+(iv  )*n ), 1 )
                          end if
                          work( j+(iv-1)*n ) = x( 1, 1 )
                          work( j+(iv  )*n ) = x( 1, 2 )
                          ! update the right-hand side
                          call stdlib_daxpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+(iv-1)*n ), 1 )
                                    
                          call stdlib_daxpy( j-1, -x( 1, 2 ), t( 1, j ), 1,work( 1+(iv  )*n ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_dlaln2( .false., 2, 2, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+(iv-1)*n ), n, wr, wi, x, 2,scale, xnorm, ierr )
                          ! scale x to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                rec = one / xnorm
                                x( 1, 1 ) = x( 1, 1 )*rec
                                x( 1, 2 ) = x( 1, 2 )*rec
                                x( 2, 1 ) = x( 2, 1 )*rec
                                x( 2, 2 ) = x( 2, 2 )*rec
                                scale = scale*rec
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_dscal( ki, scale, work( 1+(iv-1)*n ), 1 )
                             call stdlib_dscal( ki, scale, work( 1+(iv  )*n ), 1 )
                          end if
                          work( j-1+(iv-1)*n ) = x( 1, 1 )
                          work( j  +(iv-1)*n ) = x( 2, 1 )
                          work( j-1+(iv  )*n ) = x( 1, 2 )
                          work( j  +(iv  )*n ) = x( 2, 2 )
                          ! update the right-hand side
                          call stdlib_daxpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+(iv-1)*n   ),&
                                     1 )
                          call stdlib_daxpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+(iv-1)*n   ), &
                                    1 )
                          call stdlib_daxpy( j-2, -x( 1, 2 ), t( 1, j-1 ), 1,work( 1+(iv  )*n ), &
                                    1 )
                          call stdlib_daxpy( j-2, -x( 2, 2 ), t( 1, j ), 1,work( 1+(iv  )*n ), 1 )
                                    
                       end if
                    end do loop_90
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vr and normalize.
                       call stdlib_dcopy( ki, work( 1+(iv-1)*n ), 1, vr(1,is-1), 1 )
                       call stdlib_dcopy( ki, work( 1+(iv  )*n ), 1, vr(1,is  ), 1 )
                       emax = zero
                       do k = 1, ki
                          emax = max( emax, abs( vr( k, is-1 ) )+abs( vr( k, is   ) ) )
                       end do
                       remax = one / emax
                       call stdlib_dscal( ki, remax, vr( 1, is-1 ), 1 )
                       call stdlib_dscal( ki, remax, vr( 1, is   ), 1 )
                       do k = ki + 1, n
                          vr( k, is-1 ) = zero
                          vr( k, is   ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki>2 ) then
                          call stdlib_dgemv( 'N', n, ki-2, one, vr, ldvr,work( 1    + (iv-1)*n ), &
                                    1,work( ki-1 + (iv-1)*n ), vr(1,ki-1), 1)
                          call stdlib_dgemv( 'N', n, ki-2, one, vr, ldvr,work( 1  + (iv)*n ), 1,&
                                    work( ki + (iv)*n ), vr( 1, ki ), 1 )
                       else
                          call stdlib_dscal( n, work(ki-1+(iv-1)*n), vr(1,ki-1), 1)
                          call stdlib_dscal( n, work(ki  +(iv  )*n), vr(1,ki  ), 1)
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vr( k, ki-1 ) )+abs( vr( k, ki   ) ) )
                       end do
                       remax = one / emax
                       call stdlib_dscal( n, remax, vr( 1, ki-1 ), 1 )
                       call stdlib_dscal( n, remax, vr( 1, ki   ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out below vector
                       do k = ki + 1, n
                          work( k + (iv-1)*n ) = zero
                          work( k + (iv  )*n ) = zero
                       end do
                       iscomplex( iv-1 ) = -ip
                       iscomplex( iv   ) =  ip
                       iv = iv - 1
                       ! back-transform and normalization is done below
                    end if
                 end if
                 if( nb>1 ) then
                    ! --------------------------------------------------------
                    ! blocked version of back-transform
                    ! for complex case, ki2 includes both vectors (ki-1 and ki)
                    if( ip==0 ) then
                       ki2 = ki
                    else
                       ki2 = ki - 1
                    end if
                    ! columns iv:nb of work are valid vectors.
                    ! when the number of vectors stored reaches nb-1 or nb,
                    ! or if this was last vector, do the gemm
                    if( (iv<=2) .or. (ki2==1) ) then
                       call stdlib_dgemm( 'N', 'N', n, nb-iv+1, ki2+nb-iv, one,vr, ldvr,work( 1 + &
                                 (iv)*n    ), n,zero,work( 1 + (nb+iv)*n ), n )
                       ! normalize vectors
                       do k = iv, nb
                          if( iscomplex(k)==0 ) then
                             ! real eigenvector
                             ii = stdlib_idamax( n, work( 1 + (nb+k)*n ), 1 )
                             remax = one / abs( work( ii + (nb+k)*n ) )
                          else if( iscomplex(k)==1 ) then
                             ! first eigenvector of conjugate pair
                             emax = zero
                             do ii = 1, n
                                emax = max( emax,abs( work( ii + (nb+k  )*n ) )+abs( work( ii + (&
                                          nb+k+1)*n ) ) )
                             end do
                             remax = one / emax
                          ! else if iscomplex(k)==-1
                             ! second eigenvector of conjugate pair
                             ! reuse same remax as previous k
                          end if
                          call stdlib_dscal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_dlacpy( 'F', n, nb-iv+1,work( 1 + (nb+iv)*n ), n,vr( 1, ki2 ), &
                                 ldvr )
                       iv = nb
                    else
                       iv = iv - 1
                    end if
                 end if ! blocked back-transform
                 is = is - 1
                 if( ip/=0 )is = is - 1
              end do loop_140
           end if
           if( leftv ) then
              ! ============================================================
              ! compute left eigenvectors.
              ! iv is index of column in current block.
              ! for complex left vector, uses iv for real part and iv+1 for complex part.
              ! non-blocked version always uses iv=1;
              ! blocked     version starts with iv=1, goes up to nb-1 or nb.
              ! (note the "0-th" column is used for 1-norms computed above.)
              iv = 1
              ip = 0
              is = 1
              loop_260: do ki = 1, n
                 if( ip==1 ) then
                    ! previous iteration (ki-1) was first of conjugate pair,
                    ! so this ki is second of conjugate pair; skip to end of loop
                    ip = -1
                    cycle loop_260
                 else if( ki==n ) then
                    ! last column, so this ki must be real eigenvalue
                    ip = 0
                 else if( t( ki+1, ki )==zero ) then
                    ! zero on sub-diagonal, so this ki is real eigenvalue
                    ip = 0
                 else
                    ! non-zero on sub-diagonal, so this ki is first of conjugate pair
                    ip = 1
                 end if
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_260
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki+1 ) ) )*sqrt( abs( t( ki+1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! --------------------------------------------------------
                    ! real left eigenvector
                    work( ki + iv*n ) = one
                    ! form right-hand side.
                    do k = ki + 1, n
                       work( k + iv*n ) = -t( ki, k )
                    end do
                    ! solve transposed quasi-triangular system:
                    ! [ t(ki+1:n,ki+1:n) - wr ]**t * x = scale*work
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 1
                    loop_170: do j = ki + 1, n
                       if( j<jnxt )cycle loop_170
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_dscal( n-ki+1, rec, work( ki+iv*n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+iv*n ) = work( j+iv*n ) -stdlib_ddot( j-ki-1, t( ki+1, j ), 1,&
                                    work( ki+1+iv*n ), 1 )
                          ! solve [ t(j,j) - wr ]**t * x = work
                          call stdlib_dlaln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_dscal( n-ki+1, scale, work( ki+iv*n ), 1 )
                                    
                          work( j+iv*n ) = x( 1, 1 )
                          vmax = max( abs( work( j+iv*n ) ), vmax )
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_dscal( n-ki+1, rec, work( ki+iv*n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+iv*n ) = work( j+iv*n ) -stdlib_ddot( j-ki-1, t( ki+1, j ), 1,&
                                    work( ki+1+iv*n ), 1 )
                          work( j+1+iv*n ) = work( j+1+iv*n ) -stdlib_ddot( j-ki-1, t( ki+1, j+1 )&
                                    , 1,work( ki+1+iv*n ), 1 )
                          ! solve
                          ! [ t(j,j)-wr   t(j,j+1)      ]**t * x = scale*( work1 )
                          ! [ t(j+1,j)    t(j+1,j+1)-wr ]                ( work2 )
                          call stdlib_dlaln2( .true., 2, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_dscal( n-ki+1, scale, work( ki+iv*n ), 1 )
                                    
                          work( j  +iv*n ) = x( 1, 1 )
                          work( j+1+iv*n ) = x( 2, 1 )
                          vmax = max( abs( work( j  +iv*n ) ),abs( work( j+1+iv*n ) ), vmax )
                                    
                          vcrit = bignum / vmax
                       end if
                    end do loop_170
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vl and normalize.
                       call stdlib_dcopy( n-ki+1, work( ki + iv*n ), 1,vl( ki, is ), 1 )
                       ii = stdlib_idamax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                       remax = one / abs( vl( ii, is ) )
                       call stdlib_dscal( n-ki+1, remax, vl( ki, is ), 1 )
                       do k = 1, ki - 1
                          vl( k, is ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki<n )call stdlib_dgemv( 'N', n, n-ki, one,vl( 1, ki+1 ), ldvl,work( &
                                 ki+1 + iv*n ), 1,work( ki   + iv*n ), vl( 1, ki ), 1 )
                       ii = stdlib_idamax( n, vl( 1, ki ), 1 )
                       remax = one / abs( vl( ii, ki ) )
                       call stdlib_dscal( n, remax, vl( 1, ki ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out above vector
                       ! could go from ki-nv+1 to ki-1
                       do k = 1, ki - 1
                          work( k + iv*n ) = zero
                       end do
                       iscomplex( iv ) = ip
                       ! back-transform and normalization is done below
                    end if
                 else
                    ! --------------------------------------------------------
                    ! complex left eigenvector.
                    ! initial solve:
                    ! [ ( t(ki,ki)    t(ki,ki+1)  )**t - (wr - i* wi) ]*x = 0.
                    ! [ ( t(ki+1,ki) t(ki+1,ki+1) )                   ]
                    if( abs( t( ki, ki+1 ) )>=abs( t( ki+1, ki ) ) ) then
                       work( ki   + (iv  )*n ) = wi / t( ki, ki+1 )
                       work( ki+1 + (iv+1)*n ) = one
                    else
                       work( ki   + (iv  )*n ) = one
                       work( ki+1 + (iv+1)*n ) = -wi / t( ki+1, ki )
                    end if
                    work( ki+1 + (iv  )*n ) = zero
                    work( ki   + (iv+1)*n ) = zero
                    ! form right-hand side.
                    do k = ki + 2, n
                       work( k+(iv  )*n ) = -work( ki  +(iv  )*n )*t(ki,  k)
                       work( k+(iv+1)*n ) = -work( ki+1+(iv+1)*n )*t(ki+1,k)
                    end do
                    ! solve transposed quasi-triangular system:
                    ! [ t(ki+2:n,ki+2:n)**t - (wr-i*wi) ]*x = work1+i*work2
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 2
                    loop_200: do j = ki + 2, n
                       if( j<jnxt )cycle loop_200
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when
                          ! forming the right-hand side elements.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_dscal( n-ki+1, rec, work(ki+(iv  )*n), 1 )
                             call stdlib_dscal( n-ki+1, rec, work(ki+(iv+1)*n), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+(iv  )*n ) = work( j+(iv)*n ) -stdlib_ddot( j-ki-2, t( ki+2, j )&
                                    , 1,work( ki+2+(iv)*n ), 1 )
                          work( j+(iv+1)*n ) = work( j+(iv+1)*n ) -stdlib_ddot( j-ki-2, t( ki+2, &
                                    j ), 1,work( ki+2+(iv+1)*n ), 1 )
                          ! solve [ t(j,j)-(wr-i*wi) ]*(x11+i*x12)= wk+i*wk2
                          call stdlib_dlaln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_dscal( n-ki+1, scale, work(ki+(iv  )*n), 1)
                             call stdlib_dscal( n-ki+1, scale, work(ki+(iv+1)*n), 1)
                          end if
                          work( j+(iv  )*n ) = x( 1, 1 )
                          work( j+(iv+1)*n ) = x( 1, 2 )
                          vmax = max( abs( work( j+(iv  )*n ) ),abs( work( j+(iv+1)*n ) ), vmax )
                                    
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side elements.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_dscal( n-ki+1, rec, work(ki+(iv  )*n), 1 )
                             call stdlib_dscal( n-ki+1, rec, work(ki+(iv+1)*n), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j  +(iv  )*n ) = work( j+(iv)*n ) -stdlib_ddot( j-ki-2, t( ki+2, &
                                    j ), 1,work( ki+2+(iv)*n ), 1 )
                          work( j  +(iv+1)*n ) = work( j+(iv+1)*n ) -stdlib_ddot( j-ki-2, t( ki+2,&
                                     j ), 1,work( ki+2+(iv+1)*n ), 1 )
                          work( j+1+(iv  )*n ) = work( j+1+(iv)*n ) -stdlib_ddot( j-ki-2, t( ki+2,&
                                     j+1 ), 1,work( ki+2+(iv)*n ), 1 )
                          work( j+1+(iv+1)*n ) = work( j+1+(iv+1)*n ) -stdlib_ddot( j-ki-2, t( ki+&
                                    2, j+1 ), 1,work( ki+2+(iv+1)*n ), 1 )
                          ! solve 2-by-2 complex linear equation
                          ! [ (t(j,j)   t(j,j+1)  )**t - (wr-i*wi)*i ]*x = scale*b
                          ! [ (t(j+1,j) t(j+1,j+1))                  ]
                          call stdlib_dlaln2( .true., 2, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_dscal( n-ki+1, scale, work(ki+(iv  )*n), 1)
                             call stdlib_dscal( n-ki+1, scale, work(ki+(iv+1)*n), 1)
                          end if
                          work( j  +(iv  )*n ) = x( 1, 1 )
                          work( j  +(iv+1)*n ) = x( 1, 2 )
                          work( j+1+(iv  )*n ) = x( 2, 1 )
                          work( j+1+(iv+1)*n ) = x( 2, 2 )
                          vmax = max( abs( x( 1, 1 ) ), abs( x( 1, 2 ) ),abs( x( 2, 1 ) ), abs( x(&
                                     2, 2 ) ),vmax )
                          vcrit = bignum / vmax
                       end if
                    end do loop_200
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vl and normalize.
                       call stdlib_dcopy( n-ki+1, work( ki + (iv  )*n ), 1,vl( ki, is   ), 1 )
                                 
                       call stdlib_dcopy( n-ki+1, work( ki + (iv+1)*n ), 1,vl( ki, is+1 ), 1 )
                                 
                       emax = zero
                       do k = ki, n
                          emax = max( emax, abs( vl( k, is   ) )+abs( vl( k, is+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_dscal( n-ki+1, remax, vl( ki, is   ), 1 )
                       call stdlib_dscal( n-ki+1, remax, vl( ki, is+1 ), 1 )
                       do k = 1, ki - 1
                          vl( k, is   ) = zero
                          vl( k, is+1 ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki<n-1 ) then
                          call stdlib_dgemv( 'N', n, n-ki-1, one,vl( 1, ki+2 ), ldvl,work( ki+2 + &
                                    (iv)*n ), 1,work( ki   + (iv)*n ),vl( 1, ki ), 1 )
                          call stdlib_dgemv( 'N', n, n-ki-1, one,vl( 1, ki+2 ), ldvl,work( ki+2 + &
                                    (iv+1)*n ), 1,work( ki+1 + (iv+1)*n ),vl( 1, ki+1 ), 1 )
                       else
                          call stdlib_dscal( n, work(ki+  (iv  )*n), vl(1, ki  ), 1)
                          call stdlib_dscal( n, work(ki+1+(iv+1)*n), vl(1, ki+1), 1)
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vl( k, ki   ) )+abs( vl( k, ki+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_dscal( n, remax, vl( 1, ki   ), 1 )
                       call stdlib_dscal( n, remax, vl( 1, ki+1 ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out above vector
                       ! could go from ki-nv+1 to ki-1
                       do k = 1, ki - 1
                          work( k + (iv  )*n ) = zero
                          work( k + (iv+1)*n ) = zero
                       end do
                       iscomplex( iv   ) =  ip
                       iscomplex( iv+1 ) = -ip
                       iv = iv + 1
                       ! back-transform and normalization is done below
                    end if
                 end if
                 if( nb>1 ) then
                    ! --------------------------------------------------------
                    ! blocked version of back-transform
                    ! for complex case, ki2 includes both vectors (ki and ki+1)
                    if( ip==0 ) then
                       ki2 = ki
                    else
                       ki2 = ki + 1
                    end if
                    ! columns 1:iv of work are valid vectors.
                    ! when the number of vectors stored reaches nb-1 or nb,
                    ! or if this was last vector, do the gemm
                    if( (iv>=nb-1) .or. (ki2==n) ) then
                       call stdlib_dgemm( 'N', 'N', n, iv, n-ki2+iv, one,vl( 1, ki2-iv+1 ), ldvl,&
                                 work( ki2-iv+1 + (1)*n ), n,zero,work( 1 + (nb+1)*n ), n )
                       ! normalize vectors
                       do k = 1, iv
                          if( iscomplex(k)==0) then
                             ! real eigenvector
                             ii = stdlib_idamax( n, work( 1 + (nb+k)*n ), 1 )
                             remax = one / abs( work( ii + (nb+k)*n ) )
                          else if( iscomplex(k)==1) then
                             ! first eigenvector of conjugate pair
                             emax = zero
                             do ii = 1, n
                                emax = max( emax,abs( work( ii + (nb+k  )*n ) )+abs( work( ii + (&
                                          nb+k+1)*n ) ) )
                             end do
                             remax = one / emax
                          ! else if iscomplex(k)==-1
                             ! second eigenvector of conjugate pair
                             ! reuse same remax as previous k
                          end if
                          call stdlib_dscal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_dlacpy( 'F', n, iv,work( 1 + (nb+1)*n ), n,vl( 1, ki2-iv+1 ), &
                                 ldvl )
                       iv = 1
                    else
                       iv = iv + 1
                    end if
                 end if ! blocked back-transform
                 is = is + 1
                 if( ip/=0 )is = is + 1
              end do loop_260
           end if
           return
     end subroutine stdlib_dtrevc3

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$trevc3( side, howmny, select, n, t, ldt, vl, ldvl,vr, ldvr, mm, m, &
     !! DTREVC3: computes some or all of the right and/or left eigenvectors of
     !! a real upper quasi-triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a real general matrix:  A = Q*T*Q**T, as computed by DHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**T)*T = w*(y**T)
     !! where y**T denotes the transpose of the vector y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal blocks of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix. If Q is the orthogonal factor that reduces a matrix
     !! A to Schur form T, then Q*X and Q*Y are the matrices of right and
     !! left eigenvectors of A.
     !! This uses a Level 3 BLAS version of the back transformation.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, lwork, mm, n
           ! Array Arguments 
           logical(lk), intent(inout) :: select(*)
           real(${rk}$), intent(in) :: t(ldt,*)
           real(${rk}$), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmin = 8
           integer(ilp), parameter :: nbmax = 128
           
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, lquery, over, pair, rightv, somev
           integer(ilp) :: i, ierr, ii, ip, is, j, j1, j2, jnxt, k, ki, iv, maxwrk, nb, &
                     ki2
           real(${rk}$) :: beta, bignum, emax, ovfl, rec, remax, scale, smin, smlnum, ulp, unfl, &
                     vcrit, vmax, wi, wr, xnorm
           ! Intrinsic Functions 
           ! Local Arrays 
           real(${rk}$) :: x(2,2)
           integer(ilp) :: iscomplex(nbmax)
           ! Executable Statements 
           ! decode and test the input parameters
           bothv  = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv  = stdlib_lsame( side, 'L' ) .or. bothv
           allv  = stdlib_lsame( howmny, 'A' )
           over  = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           info = 0
           nb = stdlib_ilaenv( 1, 'DTREVC', side // howmny, n, -1, -1, -1 )
           maxwrk = n + 2*n*nb
           work(1) = maxwrk
           lquery = ( lwork==-1 )
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else if( lwork<max( 1, 3*n ) .and. .not.lquery ) then
              info = -14
           else
              ! set m to the number of columns required to store the selected
              ! eigenvectors, standardize the array select if necessary, and
              ! test mm.
              if( somev ) then
                 m = 0
                 pair = .false.
                 do j = 1, n
                    if( pair ) then
                       pair = .false.
                       select( j ) = .false.
                    else
                       if( j<n ) then
                          if( t( j+1, j )==zero ) then
                             if( select( j ) )m = m + 1
                          else
                             pair = .true.
                             if( select( j ) .or. select( j+1 ) ) then
                                select( j ) = .true.
                                m = m + 2
                             end if
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( mm<m ) then
                 info = -11
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTREVC3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! use blocked version of back-transformation if sufficient workspace.
           ! zero-out the workspace to avoid potential nan propagation.
           if( over .and. lwork >= n + 2*n*nbmin ) then
              nb = (lwork - n) / (2*n)
              nb = min( nb, nbmax )
              call stdlib_${ri}$laset( 'F', n, 1+2*nb, zero, zero, work, n )
           else
              nb = 1
           end if
           ! set the constants to control overflow.
           unfl = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_${ri}$labad( unfl, ovfl )
           ulp = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           bignum = ( one-ulp ) / smlnum
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           work( 1 ) = zero
           do j = 2, n
              work( j ) = zero
              do i = 1, j - 1
                 work( j ) = work( j ) + abs( t( i, j ) )
              end do
           end do
           ! index ip is used to specify the real or complex eigenvalue:
             ! ip = 0, real eigenvalue,
                  ! 1, first  of conjugate complex pair: (wr,wi)
                 ! -1, second of conjugate complex pair: (wr,wi)
             ! iscomplex array stores ip for each column in current block.
           if( rightv ) then
              ! ============================================================
              ! compute right eigenvectors.
              ! iv is index of column in current block.
              ! for complex right vector, uses iv-1 for real part and iv for complex part.
              ! non-blocked version always uses iv=2;
              ! blocked     version starts with iv=nb, goes down to 1 or 2.
              ! (note the "0-th" column is used for 1-norms computed above.)
              iv = 2
              if( nb>2 ) then
                 iv = nb
              end if
              ip = 0
              is = m
              loop_140: do ki = n, 1, -1
                 if( ip==-1 ) then
                    ! previous iteration (ki+1) was second of conjugate pair,
                    ! so this ki is first of conjugate pair; skip to end of loop
                    ip = 1
                    cycle loop_140
                 else if( ki==1 ) then
                    ! last column, so this ki must be real eigenvalue
                    ip = 0
                 else if( t( ki, ki-1 )==zero ) then
                    ! zero on sub-diagonal, so this ki is real eigenvalue
                    ip = 0
                 else
                    ! non-zero on sub-diagonal, so this ki is second of conjugate pair
                    ip = -1
                 end if
                 if( somev ) then
                    if( ip==0 ) then
                       if( .not.select( ki ) )cycle loop_140
                    else
                       if( .not.select( ki-1 ) )cycle loop_140
                    end if
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki-1 ) ) )*sqrt( abs( t( ki-1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! --------------------------------------------------------
                    ! real right eigenvector
                    work( ki + iv*n ) = one
                    ! form right-hand side.
                    do k = 1, ki - 1
                       work( k + iv*n ) = -t( k, ki )
                    end do
                    ! solve upper quasi-triangular system:
                    ! [ t(1:ki-1,1:ki-1) - wr ]*x = scale*work.
                    jnxt = ki - 1
                    loop_60: do j = ki - 1, 1, -1
                       if( j>jnxt )cycle loop_60
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1   = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_${ri}$laln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( ki, scale, work( 1+iv*n ), 1 )
                                    
                          work( j+iv*n ) = x( 1, 1 )
                          ! update right-hand side
                          call stdlib_${ri}$axpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+iv*n ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_${ri}$laln2( .false., 2, 1, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+iv*n ), n, wr, zero, x, 2,scale, xnorm, ierr )
                          ! scale x(1,1) and x(2,1) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 2, 1 ) = x( 2, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( ki, scale, work( 1+iv*n ), 1 )
                                    
                          work( j-1+iv*n ) = x( 1, 1 )
                          work( j  +iv*n ) = x( 2, 1 )
                          ! update right-hand side
                          call stdlib_${ri}$axpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+iv*n ), 1 )
                                    
                          call stdlib_${ri}$axpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+iv*n ), 1 )
                                    
                       end if
                    end do loop_60
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vr and normalize.
                       call stdlib_${ri}$copy( ki, work( 1 + iv*n ), 1, vr( 1, is ), 1 )
                       ii = stdlib_i${ri}$amax( ki, vr( 1, is ), 1 )
                       remax = one / abs( vr( ii, is ) )
                       call stdlib_${ri}$scal( ki, remax, vr( 1, is ), 1 )
                       do k = ki + 1, n
                          vr( k, is ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki>1 )call stdlib_${ri}$gemv( 'N', n, ki-1, one, vr, ldvr,work( 1 + iv*n ), &
                                 1, work( ki + iv*n ),vr( 1, ki ), 1 )
                       ii = stdlib_i${ri}$amax( n, vr( 1, ki ), 1 )
                       remax = one / abs( vr( ii, ki ) )
                       call stdlib_${ri}$scal( n, remax, vr( 1, ki ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out below vector
                       do k = ki + 1, n
                          work( k + iv*n ) = zero
                       end do
                       iscomplex( iv ) = ip
                       ! back-transform and normalization is done below
                    end if
                 else
                    ! --------------------------------------------------------
                    ! complex right eigenvector.
                    ! initial solve
                    ! [ ( t(ki-1,ki-1) t(ki-1,ki) ) - (wr + i*wi) ]*x = 0.
                    ! [ ( t(ki,  ki-1) t(ki,  ki) )               ]
                    if( abs( t( ki-1, ki ) )>=abs( t( ki, ki-1 ) ) ) then
                       work( ki-1 + (iv-1)*n ) = one
                       work( ki   + (iv  )*n ) = wi / t( ki-1, ki )
                    else
                       work( ki-1 + (iv-1)*n ) = -wi / t( ki, ki-1 )
                       work( ki   + (iv  )*n ) = one
                    end if
                    work( ki   + (iv-1)*n ) = zero
                    work( ki-1 + (iv  )*n ) = zero
                    ! form right-hand side.
                    do k = 1, ki - 2
                       work( k+(iv-1)*n ) = -work( ki-1+(iv-1)*n )*t(k,ki-1)
                       work( k+(iv  )*n ) = -work( ki  +(iv  )*n )*t(k,ki  )
                    end do
                    ! solve upper quasi-triangular system:
                    ! [ t(1:ki-2,1:ki-2) - (wr+i*wi) ]*x = scale*(work+i*work2)
                    jnxt = ki - 2
                    loop_90: do j = ki - 2, 1, -1
                       if( j>jnxt )cycle loop_90
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1   = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_${ri}$laln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+(iv-1)*n ), n,wr, wi, x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) and x(1,2) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 1, 2 ) = x( 1, 2 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( ki, scale, work( 1+(iv-1)*n ), 1 )
                             call stdlib_${ri}$scal( ki, scale, work( 1+(iv  )*n ), 1 )
                          end if
                          work( j+(iv-1)*n ) = x( 1, 1 )
                          work( j+(iv  )*n ) = x( 1, 2 )
                          ! update the right-hand side
                          call stdlib_${ri}$axpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+(iv-1)*n ), 1 )
                                    
                          call stdlib_${ri}$axpy( j-1, -x( 1, 2 ), t( 1, j ), 1,work( 1+(iv  )*n ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_${ri}$laln2( .false., 2, 2, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+(iv-1)*n ), n, wr, wi, x, 2,scale, xnorm, ierr )
                          ! scale x to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                rec = one / xnorm
                                x( 1, 1 ) = x( 1, 1 )*rec
                                x( 1, 2 ) = x( 1, 2 )*rec
                                x( 2, 1 ) = x( 2, 1 )*rec
                                x( 2, 2 ) = x( 2, 2 )*rec
                                scale = scale*rec
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( ki, scale, work( 1+(iv-1)*n ), 1 )
                             call stdlib_${ri}$scal( ki, scale, work( 1+(iv  )*n ), 1 )
                          end if
                          work( j-1+(iv-1)*n ) = x( 1, 1 )
                          work( j  +(iv-1)*n ) = x( 2, 1 )
                          work( j-1+(iv  )*n ) = x( 1, 2 )
                          work( j  +(iv  )*n ) = x( 2, 2 )
                          ! update the right-hand side
                          call stdlib_${ri}$axpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+(iv-1)*n   ),&
                                     1 )
                          call stdlib_${ri}$axpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+(iv-1)*n   ), &
                                    1 )
                          call stdlib_${ri}$axpy( j-2, -x( 1, 2 ), t( 1, j-1 ), 1,work( 1+(iv  )*n ), &
                                    1 )
                          call stdlib_${ri}$axpy( j-2, -x( 2, 2 ), t( 1, j ), 1,work( 1+(iv  )*n ), 1 )
                                    
                       end if
                    end do loop_90
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vr and normalize.
                       call stdlib_${ri}$copy( ki, work( 1+(iv-1)*n ), 1, vr(1,is-1), 1 )
                       call stdlib_${ri}$copy( ki, work( 1+(iv  )*n ), 1, vr(1,is  ), 1 )
                       emax = zero
                       do k = 1, ki
                          emax = max( emax, abs( vr( k, is-1 ) )+abs( vr( k, is   ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( ki, remax, vr( 1, is-1 ), 1 )
                       call stdlib_${ri}$scal( ki, remax, vr( 1, is   ), 1 )
                       do k = ki + 1, n
                          vr( k, is-1 ) = zero
                          vr( k, is   ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki>2 ) then
                          call stdlib_${ri}$gemv( 'N', n, ki-2, one, vr, ldvr,work( 1    + (iv-1)*n ), &
                                    1,work( ki-1 + (iv-1)*n ), vr(1,ki-1), 1)
                          call stdlib_${ri}$gemv( 'N', n, ki-2, one, vr, ldvr,work( 1  + (iv)*n ), 1,&
                                    work( ki + (iv)*n ), vr( 1, ki ), 1 )
                       else
                          call stdlib_${ri}$scal( n, work(ki-1+(iv-1)*n), vr(1,ki-1), 1)
                          call stdlib_${ri}$scal( n, work(ki  +(iv  )*n), vr(1,ki  ), 1)
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vr( k, ki-1 ) )+abs( vr( k, ki   ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( n, remax, vr( 1, ki-1 ), 1 )
                       call stdlib_${ri}$scal( n, remax, vr( 1, ki   ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out below vector
                       do k = ki + 1, n
                          work( k + (iv-1)*n ) = zero
                          work( k + (iv  )*n ) = zero
                       end do
                       iscomplex( iv-1 ) = -ip
                       iscomplex( iv   ) =  ip
                       iv = iv - 1
                       ! back-transform and normalization is done below
                    end if
                 end if
                 if( nb>1 ) then
                    ! --------------------------------------------------------
                    ! blocked version of back-transform
                    ! for complex case, ki2 includes both vectors (ki-1 and ki)
                    if( ip==0 ) then
                       ki2 = ki
                    else
                       ki2 = ki - 1
                    end if
                    ! columns iv:nb of work are valid vectors.
                    ! when the number of vectors stored reaches nb-1 or nb,
                    ! or if this was last vector, do the gemm
                    if( (iv<=2) .or. (ki2==1) ) then
                       call stdlib_${ri}$gemm( 'N', 'N', n, nb-iv+1, ki2+nb-iv, one,vr, ldvr,work( 1 + &
                                 (iv)*n    ), n,zero,work( 1 + (nb+iv)*n ), n )
                       ! normalize vectors
                       do k = iv, nb
                          if( iscomplex(k)==0 ) then
                             ! real eigenvector
                             ii = stdlib_i${ri}$amax( n, work( 1 + (nb+k)*n ), 1 )
                             remax = one / abs( work( ii + (nb+k)*n ) )
                          else if( iscomplex(k)==1 ) then
                             ! first eigenvector of conjugate pair
                             emax = zero
                             do ii = 1, n
                                emax = max( emax,abs( work( ii + (nb+k  )*n ) )+abs( work( ii + (&
                                          nb+k+1)*n ) ) )
                             end do
                             remax = one / emax
                          ! else if iscomplex(k)==-1
                             ! second eigenvector of conjugate pair
                             ! reuse same remax as previous k
                          end if
                          call stdlib_${ri}$scal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_${ri}$lacpy( 'F', n, nb-iv+1,work( 1 + (nb+iv)*n ), n,vr( 1, ki2 ), &
                                 ldvr )
                       iv = nb
                    else
                       iv = iv - 1
                    end if
                 end if ! blocked back-transform
                 is = is - 1
                 if( ip/=0 )is = is - 1
              end do loop_140
           end if
           if( leftv ) then
              ! ============================================================
              ! compute left eigenvectors.
              ! iv is index of column in current block.
              ! for complex left vector, uses iv for real part and iv+1 for complex part.
              ! non-blocked version always uses iv=1;
              ! blocked     version starts with iv=1, goes up to nb-1 or nb.
              ! (note the "0-th" column is used for 1-norms computed above.)
              iv = 1
              ip = 0
              is = 1
              loop_260: do ki = 1, n
                 if( ip==1 ) then
                    ! previous iteration (ki-1) was first of conjugate pair,
                    ! so this ki is second of conjugate pair; skip to end of loop
                    ip = -1
                    cycle loop_260
                 else if( ki==n ) then
                    ! last column, so this ki must be real eigenvalue
                    ip = 0
                 else if( t( ki+1, ki )==zero ) then
                    ! zero on sub-diagonal, so this ki is real eigenvalue
                    ip = 0
                 else
                    ! non-zero on sub-diagonal, so this ki is first of conjugate pair
                    ip = 1
                 end if
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_260
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki+1 ) ) )*sqrt( abs( t( ki+1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! --------------------------------------------------------
                    ! real left eigenvector
                    work( ki + iv*n ) = one
                    ! form right-hand side.
                    do k = ki + 1, n
                       work( k + iv*n ) = -t( ki, k )
                    end do
                    ! solve transposed quasi-triangular system:
                    ! [ t(ki+1:n,ki+1:n) - wr ]**t * x = scale*work
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 1
                    loop_170: do j = ki + 1, n
                       if( j<jnxt )cycle loop_170
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+iv*n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+iv*n ) = work( j+iv*n ) -stdlib_${ri}$dot( j-ki-1, t( ki+1, j ), 1,&
                                    work( ki+1+iv*n ), 1 )
                          ! solve [ t(j,j) - wr ]**t * x = work
                          call stdlib_${ri}$laln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( n-ki+1, scale, work( ki+iv*n ), 1 )
                                    
                          work( j+iv*n ) = x( 1, 1 )
                          vmax = max( abs( work( j+iv*n ) ), vmax )
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+iv*n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+iv*n ) = work( j+iv*n ) -stdlib_${ri}$dot( j-ki-1, t( ki+1, j ), 1,&
                                    work( ki+1+iv*n ), 1 )
                          work( j+1+iv*n ) = work( j+1+iv*n ) -stdlib_${ri}$dot( j-ki-1, t( ki+1, j+1 )&
                                    , 1,work( ki+1+iv*n ), 1 )
                          ! solve
                          ! [ t(j,j)-wr   t(j,j+1)      ]**t * x = scale*( work1 )
                          ! [ t(j+1,j)    t(j+1,j+1)-wr ]                ( work2 )
                          call stdlib_${ri}$laln2( .true., 2, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( n-ki+1, scale, work( ki+iv*n ), 1 )
                                    
                          work( j  +iv*n ) = x( 1, 1 )
                          work( j+1+iv*n ) = x( 2, 1 )
                          vmax = max( abs( work( j  +iv*n ) ),abs( work( j+1+iv*n ) ), vmax )
                                    
                          vcrit = bignum / vmax
                       end if
                    end do loop_170
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vl and normalize.
                       call stdlib_${ri}$copy( n-ki+1, work( ki + iv*n ), 1,vl( ki, is ), 1 )
                       ii = stdlib_i${ri}$amax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                       remax = one / abs( vl( ii, is ) )
                       call stdlib_${ri}$scal( n-ki+1, remax, vl( ki, is ), 1 )
                       do k = 1, ki - 1
                          vl( k, is ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki<n )call stdlib_${ri}$gemv( 'N', n, n-ki, one,vl( 1, ki+1 ), ldvl,work( &
                                 ki+1 + iv*n ), 1,work( ki   + iv*n ), vl( 1, ki ), 1 )
                       ii = stdlib_i${ri}$amax( n, vl( 1, ki ), 1 )
                       remax = one / abs( vl( ii, ki ) )
                       call stdlib_${ri}$scal( n, remax, vl( 1, ki ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out above vector
                       ! could go from ki-nv+1 to ki-1
                       do k = 1, ki - 1
                          work( k + iv*n ) = zero
                       end do
                       iscomplex( iv ) = ip
                       ! back-transform and normalization is done below
                    end if
                 else
                    ! --------------------------------------------------------
                    ! complex left eigenvector.
                    ! initial solve:
                    ! [ ( t(ki,ki)    t(ki,ki+1)  )**t - (wr - i* wi) ]*x = 0.
                    ! [ ( t(ki+1,ki) t(ki+1,ki+1) )                   ]
                    if( abs( t( ki, ki+1 ) )>=abs( t( ki+1, ki ) ) ) then
                       work( ki   + (iv  )*n ) = wi / t( ki, ki+1 )
                       work( ki+1 + (iv+1)*n ) = one
                    else
                       work( ki   + (iv  )*n ) = one
                       work( ki+1 + (iv+1)*n ) = -wi / t( ki+1, ki )
                    end if
                    work( ki+1 + (iv  )*n ) = zero
                    work( ki   + (iv+1)*n ) = zero
                    ! form right-hand side.
                    do k = ki + 2, n
                       work( k+(iv  )*n ) = -work( ki  +(iv  )*n )*t(ki,  k)
                       work( k+(iv+1)*n ) = -work( ki+1+(iv+1)*n )*t(ki+1,k)
                    end do
                    ! solve transposed quasi-triangular system:
                    ! [ t(ki+2:n,ki+2:n)**t - (wr-i*wi) ]*x = work1+i*work2
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 2
                    loop_200: do j = ki + 2, n
                       if( j<jnxt )cycle loop_200
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when
                          ! forming the right-hand side elements.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work(ki+(iv  )*n), 1 )
                             call stdlib_${ri}$scal( n-ki+1, rec, work(ki+(iv+1)*n), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+(iv  )*n ) = work( j+(iv)*n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, j )&
                                    , 1,work( ki+2+(iv)*n ), 1 )
                          work( j+(iv+1)*n ) = work( j+(iv+1)*n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, &
                                    j ), 1,work( ki+2+(iv+1)*n ), 1 )
                          ! solve [ t(j,j)-(wr-i*wi) ]*(x11+i*x12)= wk+i*wk2
                          call stdlib_${ri}$laln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( n-ki+1, scale, work(ki+(iv  )*n), 1)
                             call stdlib_${ri}$scal( n-ki+1, scale, work(ki+(iv+1)*n), 1)
                          end if
                          work( j+(iv  )*n ) = x( 1, 1 )
                          work( j+(iv+1)*n ) = x( 1, 2 )
                          vmax = max( abs( work( j+(iv  )*n ) ),abs( work( j+(iv+1)*n ) ), vmax )
                                    
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side elements.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work(ki+(iv  )*n), 1 )
                             call stdlib_${ri}$scal( n-ki+1, rec, work(ki+(iv+1)*n), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j  +(iv  )*n ) = work( j+(iv)*n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, &
                                    j ), 1,work( ki+2+(iv)*n ), 1 )
                          work( j  +(iv+1)*n ) = work( j+(iv+1)*n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2,&
                                     j ), 1,work( ki+2+(iv+1)*n ), 1 )
                          work( j+1+(iv  )*n ) = work( j+1+(iv)*n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2,&
                                     j+1 ), 1,work( ki+2+(iv)*n ), 1 )
                          work( j+1+(iv+1)*n ) = work( j+1+(iv+1)*n ) -stdlib_${ri}$dot( j-ki-2, t( ki+&
                                    2, j+1 ), 1,work( ki+2+(iv+1)*n ), 1 )
                          ! solve 2-by-2 complex linear equation
                          ! [ (t(j,j)   t(j,j+1)  )**t - (wr-i*wi)*i ]*x = scale*b
                          ! [ (t(j+1,j) t(j+1,j+1))                  ]
                          call stdlib_${ri}$laln2( .true., 2, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( n-ki+1, scale, work(ki+(iv  )*n), 1)
                             call stdlib_${ri}$scal( n-ki+1, scale, work(ki+(iv+1)*n), 1)
                          end if
                          work( j  +(iv  )*n ) = x( 1, 1 )
                          work( j  +(iv+1)*n ) = x( 1, 2 )
                          work( j+1+(iv  )*n ) = x( 2, 1 )
                          work( j+1+(iv+1)*n ) = x( 2, 2 )
                          vmax = max( abs( x( 1, 1 ) ), abs( x( 1, 2 ) ),abs( x( 2, 1 ) ), abs( x(&
                                     2, 2 ) ),vmax )
                          vcrit = bignum / vmax
                       end if
                    end do loop_200
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vl and normalize.
                       call stdlib_${ri}$copy( n-ki+1, work( ki + (iv  )*n ), 1,vl( ki, is   ), 1 )
                                 
                       call stdlib_${ri}$copy( n-ki+1, work( ki + (iv+1)*n ), 1,vl( ki, is+1 ), 1 )
                                 
                       emax = zero
                       do k = ki, n
                          emax = max( emax, abs( vl( k, is   ) )+abs( vl( k, is+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( n-ki+1, remax, vl( ki, is   ), 1 )
                       call stdlib_${ri}$scal( n-ki+1, remax, vl( ki, is+1 ), 1 )
                       do k = 1, ki - 1
                          vl( k, is   ) = zero
                          vl( k, is+1 ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki<n-1 ) then
                          call stdlib_${ri}$gemv( 'N', n, n-ki-1, one,vl( 1, ki+2 ), ldvl,work( ki+2 + &
                                    (iv)*n ), 1,work( ki   + (iv)*n ),vl( 1, ki ), 1 )
                          call stdlib_${ri}$gemv( 'N', n, n-ki-1, one,vl( 1, ki+2 ), ldvl,work( ki+2 + &
                                    (iv+1)*n ), 1,work( ki+1 + (iv+1)*n ),vl( 1, ki+1 ), 1 )
                       else
                          call stdlib_${ri}$scal( n, work(ki+  (iv  )*n), vl(1, ki  ), 1)
                          call stdlib_${ri}$scal( n, work(ki+1+(iv+1)*n), vl(1, ki+1), 1)
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vl( k, ki   ) )+abs( vl( k, ki+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( n, remax, vl( 1, ki   ), 1 )
                       call stdlib_${ri}$scal( n, remax, vl( 1, ki+1 ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out above vector
                       ! could go from ki-nv+1 to ki-1
                       do k = 1, ki - 1
                          work( k + (iv  )*n ) = zero
                          work( k + (iv+1)*n ) = zero
                       end do
                       iscomplex( iv   ) =  ip
                       iscomplex( iv+1 ) = -ip
                       iv = iv + 1
                       ! back-transform and normalization is done below
                    end if
                 end if
                 if( nb>1 ) then
                    ! --------------------------------------------------------
                    ! blocked version of back-transform
                    ! for complex case, ki2 includes both vectors (ki and ki+1)
                    if( ip==0 ) then
                       ki2 = ki
                    else
                       ki2 = ki + 1
                    end if
                    ! columns 1:iv of work are valid vectors.
                    ! when the number of vectors stored reaches nb-1 or nb,
                    ! or if this was last vector, do the gemm
                    if( (iv>=nb-1) .or. (ki2==n) ) then
                       call stdlib_${ri}$gemm( 'N', 'N', n, iv, n-ki2+iv, one,vl( 1, ki2-iv+1 ), ldvl,&
                                 work( ki2-iv+1 + (1)*n ), n,zero,work( 1 + (nb+1)*n ), n )
                       ! normalize vectors
                       do k = 1, iv
                          if( iscomplex(k)==0) then
                             ! real eigenvector
                             ii = stdlib_i${ri}$amax( n, work( 1 + (nb+k)*n ), 1 )
                             remax = one / abs( work( ii + (nb+k)*n ) )
                          else if( iscomplex(k)==1) then
                             ! first eigenvector of conjugate pair
                             emax = zero
                             do ii = 1, n
                                emax = max( emax,abs( work( ii + (nb+k  )*n ) )+abs( work( ii + (&
                                          nb+k+1)*n ) ) )
                             end do
                             remax = one / emax
                          ! else if iscomplex(k)==-1
                             ! second eigenvector of conjugate pair
                             ! reuse same remax as previous k
                          end if
                          call stdlib_${ri}$scal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_${ri}$lacpy( 'F', n, iv,work( 1 + (nb+1)*n ), n,vl( 1, ki2-iv+1 ), &
                                 ldvl )
                       iv = 1
                    else
                       iv = iv + 1
                    end if
                 end if ! blocked back-transform
                 is = is + 1
                 if( ip/=0 )is = is + 1
              end do loop_260
           end if
           return
     end subroutine stdlib_${ri}$trevc3

#:endif
#:endfor

     module pure subroutine stdlib_ctrevc3( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
     !! CTREVC3 computes some or all of the right and/or left eigenvectors of
     !! a complex upper triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a complex general matrix:  A = Q*T*Q**H, as computed by CHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**H)*T = w*(y**H)
     !! where y**H denotes the conjugate transpose of the vector y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix. If Q is the unitary factor that reduces a matrix A to
     !! Schur form T, then Q*X and Q*Y are the matrices of right and left
     !! eigenvectors of A.
     !! This uses a Level 3 BLAS version of the back transformation.
               work, lwork, rwork, lrwork, info)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, lwork, lrwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmin = 8
           integer(ilp), parameter :: nbmax = 128
           
           
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, lquery, over, rightv, somev
           integer(ilp) :: i, ii, is, j, k, ki, iv, maxwrk, nb
           real(sp) :: ovfl, remax, scale, smin, smlnum, ulp, unfl
           complex(sp) :: cdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters
           bothv  = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv  = stdlib_lsame( side, 'L' ) .or. bothv
           allv  = stdlib_lsame( howmny, 'A' )
           over  = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           ! set m to the number of columns required to store the selected
           ! eigenvectors.
           if( somev ) then
              m = 0
              do j = 1, n
                 if( select( j ) )m = m + 1
              end do
           else
              m = n
           end if
           info = 0
           nb = stdlib_ilaenv( 1, 'CTREVC', side // howmny, n, -1, -1, -1 )
           maxwrk = n + 2*n*nb
           work(1) = maxwrk
           rwork(1) = n
           lquery = ( lwork==-1 .or. lrwork==-1 )
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else if( mm<m ) then
              info = -11
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -14
           else if ( lrwork<max( 1, n ) .and. .not.lquery ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTREVC3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! use blocked version of back-transformation if sufficient workspace.
           ! zero-out the workspace to avoid potential nan propagation.
           if( over .and. lwork >= n + 2*n*nbmin ) then
              nb = (lwork - n) / (2*n)
              nb = min( nb, nbmax )
              call stdlib_claset( 'F', n, 1+2*nb, czero, czero, work, n )
           else
              nb = 1
           end if
           ! set the constants to control overflow.
           unfl = stdlib_slamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_slabad( unfl, ovfl )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           ! store the diagonal elements of t in working array work.
           do i = 1, n
              work( i ) = t( i, i )
           end do
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           rwork( 1 ) = zero
           do j = 2, n
              rwork( j ) = stdlib_scasum( j-1, t( 1, j ), 1 )
           end do
           if( rightv ) then
              ! ============================================================
              ! compute right eigenvectors.
              ! iv is index of column in current block.
              ! non-blocked version always uses iv=nb=1;
              ! blocked     version starts with iv=nb, goes down to 1.
              ! (note the "0-th" column is used to store the original diagonal.)
              iv = nb
              is = m
              loop_80: do ki = n, 1, -1
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_80
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 ! --------------------------------------------------------
                 ! complex right eigenvector
                 work( ki + iv*n ) = cone
                 ! form right-hand side.
                 do k = 1, ki - 1
                    work( k + iv*n ) = -t( k, ki )
                 end do
                 ! solve upper triangular system:
                 ! [ t(1:ki-1,1:ki-1) - t(ki,ki) ]*x = scale*work.
                 do k = 1, ki - 1
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki>1 ) then
                    call stdlib_clatrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', 'Y',ki-1, t, ldt, &
                              work( 1 + iv*n ), scale,rwork, info )
                    work( ki + iv*n ) = scale
                 end if
                 ! copy the vector x or q*x to vr and normalize.
                 if( .not.over ) then
                    ! ------------------------------
                    ! no back-transform: copy x to vr and normalize.
                    call stdlib_ccopy( ki, work( 1 + iv*n ), 1, vr( 1, is ), 1 )
                    ii = stdlib_icamax( ki, vr( 1, is ), 1 )
                    remax = one / cabs1( vr( ii, is ) )
                    call stdlib_csscal( ki, remax, vr( 1, is ), 1 )
                    do k = ki + 1, n
                       vr( k, is ) = czero
                    end do
                 else if( nb==1 ) then
                    ! ------------------------------
                    ! version 1: back-transform each vector with gemv, q*x.
                    if( ki>1 )call stdlib_cgemv( 'N', n, ki-1, cone, vr, ldvr,work( 1 + iv*n ), 1,&
                               cmplx( scale,KIND=sp),vr( 1, ki ), 1 )
                    ii = stdlib_icamax( n, vr( 1, ki ), 1 )
                    remax = one / cabs1( vr( ii, ki ) )
                    call stdlib_csscal( n, remax, vr( 1, ki ), 1 )
                 else
                    ! ------------------------------
                    ! version 2: back-transform block of vectors with gemm
                    ! zero out below vector
                    do k = ki + 1, n
                       work( k + iv*n ) = czero
                    end do
                    ! columns iv:nb of work are valid vectors.
                    ! when the number of vectors stored reaches nb,
                    ! or if this was last vector, do the gemm
                    if( (iv==1) .or. (ki==1) ) then
                       call stdlib_cgemm( 'N', 'N', n, nb-iv+1, ki+nb-iv, cone,vr, ldvr,work( 1 + &
                                 (iv)*n    ), n,czero,work( 1 + (nb+iv)*n ), n )
                       ! normalize vectors
                       do k = iv, nb
                          ii = stdlib_icamax( n, work( 1 + (nb+k)*n ), 1 )
                          remax = one / cabs1( work( ii + (nb+k)*n ) )
                          call stdlib_csscal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_clacpy( 'F', n, nb-iv+1,work( 1 + (nb+iv)*n ), n,vr( 1, ki ), &
                                 ldvr )
                       iv = nb
                    else
                       iv = iv - 1
                    end if
                 end if
                 ! restore the original diagonal elements of t.
                 do k = 1, ki - 1
                    t( k, k ) = work( k )
                 end do
                 is = is - 1
              end do loop_80
           end if
           if( leftv ) then
              ! ============================================================
              ! compute left eigenvectors.
              ! iv is index of column in current block.
              ! non-blocked version always uses iv=1;
              ! blocked     version starts with iv=1, goes up to nb.
              ! (note the "0-th" column is used to store the original diagonal.)
              iv = 1
              is = 1
              loop_130: do ki = 1, n
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_130
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 ! --------------------------------------------------------
                 ! complex left eigenvector
                 work( ki + iv*n ) = cone
                 ! form right-hand side.
                 do k = ki + 1, n
                    work( k + iv*n ) = -conjg( t( ki, k ) )
                 end do
                 ! solve conjugate-transposed triangular system:
                 ! [ t(ki+1:n,ki+1:n) - t(ki,ki) ]**h * x = scale*work.
                 do k = ki + 1, n
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki<n ) then
                    call stdlib_clatrs( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT','Y', n-ki, t( &
                              ki+1, ki+1 ), ldt,work( ki+1 + iv*n ), scale, rwork, info )
                    work( ki + iv*n ) = scale
                 end if
                 ! copy the vector x or q*x to vl and normalize.
                 if( .not.over ) then
                    ! ------------------------------
                    ! no back-transform: copy x to vl and normalize.
                    call stdlib_ccopy( n-ki+1, work( ki + iv*n ), 1, vl(ki,is), 1 )
                    ii = stdlib_icamax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                    remax = one / cabs1( vl( ii, is ) )
                    call stdlib_csscal( n-ki+1, remax, vl( ki, is ), 1 )
                    do k = 1, ki - 1
                       vl( k, is ) = czero
                    end do
                 else if( nb==1 ) then
                    ! ------------------------------
                    ! version 1: back-transform each vector with gemv, q*x.
                    if( ki<n )call stdlib_cgemv( 'N', n, n-ki, cone, vl( 1, ki+1 ), ldvl,work( ki+&
                              1 + iv*n ), 1, cmplx( scale,KIND=sp),vl( 1, ki ), 1 )
                    ii = stdlib_icamax( n, vl( 1, ki ), 1 )
                    remax = one / cabs1( vl( ii, ki ) )
                    call stdlib_csscal( n, remax, vl( 1, ki ), 1 )
                 else
                    ! ------------------------------
                    ! version 2: back-transform block of vectors with gemm
                    ! zero out above vector
                    ! could go from ki-nv+1 to ki-1
                    do k = 1, ki - 1
                       work( k + iv*n ) = czero
                    end do
                    ! columns 1:iv of work are valid vectors.
                    ! when the number of vectors stored reaches nb,
                    ! or if this was last vector, do the gemm
                    if( (iv==nb) .or. (ki==n) ) then
                       call stdlib_cgemm( 'N', 'N', n, iv, n-ki+iv, cone,vl( 1, ki-iv+1 ), ldvl,&
                                 work( ki-iv+1 + (1)*n ), n,czero,work( 1 + (nb+1)*n ), n )
                       ! normalize vectors
                       do k = 1, iv
                          ii = stdlib_icamax( n, work( 1 + (nb+k)*n ), 1 )
                          remax = one / cabs1( work( ii + (nb+k)*n ) )
                          call stdlib_csscal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_clacpy( 'F', n, iv,work( 1 + (nb+1)*n ), n,vl( 1, ki-iv+1 ), &
                                 ldvl )
                       iv = 1
                    else
                       iv = iv + 1
                    end if
                 end if
                 ! restore the original diagonal elements of t.
                 do k = ki + 1, n
                    t( k, k ) = work( k )
                 end do
                 is = is + 1
              end do loop_130
           end if
           return
     end subroutine stdlib_ctrevc3

     module pure subroutine stdlib_ztrevc3( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
     !! ZTREVC3 computes some or all of the right and/or left eigenvectors of
     !! a complex upper triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a complex general matrix:  A = Q*T*Q**H, as computed by ZHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**H)*T = w*(y**H)
     !! where y**H denotes the conjugate transpose of the vector y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix. If Q is the unitary factor that reduces a matrix A to
     !! Schur form T, then Q*X and Q*Y are the matrices of right and left
     !! eigenvectors of A.
     !! This uses a Level 3 BLAS version of the back transformation.
               work, lwork, rwork, lrwork, info)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, lwork, lrwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmin = 8
           integer(ilp), parameter :: nbmax = 128
           
           
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, lquery, over, rightv, somev
           integer(ilp) :: i, ii, is, j, k, ki, iv, maxwrk, nb
           real(dp) :: ovfl, remax, scale, smin, smlnum, ulp, unfl
           complex(dp) :: cdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters
           bothv  = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv  = stdlib_lsame( side, 'L' ) .or. bothv
           allv  = stdlib_lsame( howmny, 'A' )
           over  = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           ! set m to the number of columns required to store the selected
           ! eigenvectors.
           if( somev ) then
              m = 0
              do j = 1, n
                 if( select( j ) )m = m + 1
              end do
           else
              m = n
           end if
           info = 0
           nb = stdlib_ilaenv( 1, 'ZTREVC', side // howmny, n, -1, -1, -1 )
           maxwrk = n + 2*n*nb
           work(1) = maxwrk
           rwork(1) = n
           lquery = ( lwork==-1 .or. lrwork==-1 )
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else if( mm<m ) then
              info = -11
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -14
           else if ( lrwork<max( 1, n ) .and. .not.lquery ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTREVC3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! use blocked version of back-transformation if sufficient workspace.
           ! zero-out the workspace to avoid potential nan propagation.
           if( over .and. lwork >= n + 2*n*nbmin ) then
              nb = (lwork - n) / (2*n)
              nb = min( nb, nbmax )
              call stdlib_zlaset( 'F', n, 1+2*nb, czero, czero, work, n )
           else
              nb = 1
           end if
           ! set the constants to control overflow.
           unfl = stdlib_dlamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_dlabad( unfl, ovfl )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           ! store the diagonal elements of t in working array work.
           do i = 1, n
              work( i ) = t( i, i )
           end do
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           rwork( 1 ) = zero
           do j = 2, n
              rwork( j ) = stdlib_dzasum( j-1, t( 1, j ), 1 )
           end do
           if( rightv ) then
              ! ============================================================
              ! compute right eigenvectors.
              ! iv is index of column in current block.
              ! non-blocked version always uses iv=nb=1;
              ! blocked     version starts with iv=nb, goes down to 1.
              ! (note the "0-th" column is used to store the original diagonal.)
              iv = nb
              is = m
              loop_80: do ki = n, 1, -1
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_80
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 ! --------------------------------------------------------
                 ! complex right eigenvector
                 work( ki + iv*n ) = cone
                 ! form right-hand side.
                 do k = 1, ki - 1
                    work( k + iv*n ) = -t( k, ki )
                 end do
                 ! solve upper triangular system:
                 ! [ t(1:ki-1,1:ki-1) - t(ki,ki) ]*x = scale*work.
                 do k = 1, ki - 1
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki>1 ) then
                    call stdlib_zlatrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', 'Y',ki-1, t, ldt, &
                              work( 1 + iv*n ), scale,rwork, info )
                    work( ki + iv*n ) = scale
                 end if
                 ! copy the vector x or q*x to vr and normalize.
                 if( .not.over ) then
                    ! ------------------------------
                    ! no back-transform: copy x to vr and normalize.
                    call stdlib_zcopy( ki, work( 1 + iv*n ), 1, vr( 1, is ), 1 )
                    ii = stdlib_izamax( ki, vr( 1, is ), 1 )
                    remax = one / cabs1( vr( ii, is ) )
                    call stdlib_zdscal( ki, remax, vr( 1, is ), 1 )
                    do k = ki + 1, n
                       vr( k, is ) = czero
                    end do
                 else if( nb==1 ) then
                    ! ------------------------------
                    ! version 1: back-transform each vector with gemv, q*x.
                    if( ki>1 )call stdlib_zgemv( 'N', n, ki-1, cone, vr, ldvr,work( 1 + iv*n ), 1,&
                               cmplx( scale,KIND=dp),vr( 1, ki ), 1 )
                    ii = stdlib_izamax( n, vr( 1, ki ), 1 )
                    remax = one / cabs1( vr( ii, ki ) )
                    call stdlib_zdscal( n, remax, vr( 1, ki ), 1 )
                 else
                    ! ------------------------------
                    ! version 2: back-transform block of vectors with gemm
                    ! zero out below vector
                    do k = ki + 1, n
                       work( k + iv*n ) = czero
                    end do
                    ! columns iv:nb of work are valid vectors.
                    ! when the number of vectors stored reaches nb,
                    ! or if this was last vector, do the gemm
                    if( (iv==1) .or. (ki==1) ) then
                       call stdlib_zgemm( 'N', 'N', n, nb-iv+1, ki+nb-iv, cone,vr, ldvr,work( 1 + &
                                 (iv)*n    ), n,czero,work( 1 + (nb+iv)*n ), n )
                       ! normalize vectors
                       do k = iv, nb
                          ii = stdlib_izamax( n, work( 1 + (nb+k)*n ), 1 )
                          remax = one / cabs1( work( ii + (nb+k)*n ) )
                          call stdlib_zdscal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_zlacpy( 'F', n, nb-iv+1,work( 1 + (nb+iv)*n ), n,vr( 1, ki ), &
                                 ldvr )
                       iv = nb
                    else
                       iv = iv - 1
                    end if
                 end if
                 ! restore the original diagonal elements of t.
                 do k = 1, ki - 1
                    t( k, k ) = work( k )
                 end do
                 is = is - 1
              end do loop_80
           end if
           if( leftv ) then
              ! ============================================================
              ! compute left eigenvectors.
              ! iv is index of column in current block.
              ! non-blocked version always uses iv=1;
              ! blocked     version starts with iv=1, goes up to nb.
              ! (note the "0-th" column is used to store the original diagonal.)
              iv = 1
              is = 1
              loop_130: do ki = 1, n
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_130
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 ! --------------------------------------------------------
                 ! complex left eigenvector
                 work( ki + iv*n ) = cone
                 ! form right-hand side.
                 do k = ki + 1, n
                    work( k + iv*n ) = -conjg( t( ki, k ) )
                 end do
                 ! solve conjugate-transposed triangular system:
                 ! [ t(ki+1:n,ki+1:n) - t(ki,ki) ]**h * x = scale*work.
                 do k = ki + 1, n
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki<n ) then
                    call stdlib_zlatrs( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT','Y', n-ki, t( &
                              ki+1, ki+1 ), ldt,work( ki+1 + iv*n ), scale, rwork, info )
                    work( ki + iv*n ) = scale
                 end if
                 ! copy the vector x or q*x to vl and normalize.
                 if( .not.over ) then
                    ! ------------------------------
                    ! no back-transform: copy x to vl and normalize.
                    call stdlib_zcopy( n-ki+1, work( ki + iv*n ), 1, vl(ki,is), 1 )
                    ii = stdlib_izamax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                    remax = one / cabs1( vl( ii, is ) )
                    call stdlib_zdscal( n-ki+1, remax, vl( ki, is ), 1 )
                    do k = 1, ki - 1
                       vl( k, is ) = czero
                    end do
                 else if( nb==1 ) then
                    ! ------------------------------
                    ! version 1: back-transform each vector with gemv, q*x.
                    if( ki<n )call stdlib_zgemv( 'N', n, n-ki, cone, vl( 1, ki+1 ), ldvl,work( ki+&
                              1 + iv*n ), 1, cmplx( scale,KIND=dp),vl( 1, ki ), 1 )
                    ii = stdlib_izamax( n, vl( 1, ki ), 1 )
                    remax = one / cabs1( vl( ii, ki ) )
                    call stdlib_zdscal( n, remax, vl( 1, ki ), 1 )
                 else
                    ! ------------------------------
                    ! version 2: back-transform block of vectors with gemm
                    ! zero out above vector
                    ! could go from ki-nv+1 to ki-1
                    do k = 1, ki - 1
                       work( k + iv*n ) = czero
                    end do
                    ! columns 1:iv of work are valid vectors.
                    ! when the number of vectors stored reaches nb,
                    ! or if this was last vector, do the gemm
                    if( (iv==nb) .or. (ki==n) ) then
                       call stdlib_zgemm( 'N', 'N', n, iv, n-ki+iv, cone,vl( 1, ki-iv+1 ), ldvl,&
                                 work( ki-iv+1 + (1)*n ), n,czero,work( 1 + (nb+1)*n ), n )
                       ! normalize vectors
                       do k = 1, iv
                          ii = stdlib_izamax( n, work( 1 + (nb+k)*n ), 1 )
                          remax = one / cabs1( work( ii + (nb+k)*n ) )
                          call stdlib_zdscal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_zlacpy( 'F', n, iv,work( 1 + (nb+1)*n ), n,vl( 1, ki-iv+1 ), &
                                 ldvl )
                       iv = 1
                    else
                       iv = iv + 1
                    end if
                 end if
                 ! restore the original diagonal elements of t.
                 do k = ki + 1, n
                    t( k, k ) = work( k )
                 end do
                 is = is + 1
              end do loop_130
           end if
           return
     end subroutine stdlib_ztrevc3

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$trevc3( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
     !! ZTREVC3: computes some or all of the right and/or left eigenvectors of
     !! a complex upper triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a complex general matrix:  A = Q*T*Q**H, as computed by ZHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**H)*T = w*(y**H)
     !! where y**H denotes the conjugate transpose of the vector y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix. If Q is the unitary factor that reduces a matrix A to
     !! Schur form T, then Q*X and Q*Y are the matrices of right and left
     !! eigenvectors of A.
     !! This uses a Level 3 BLAS version of the back transformation.
               work, lwork, rwork, lrwork, info)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, lwork, lrwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmin = 8
           integer(ilp), parameter :: nbmax = 128
           
           
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, lquery, over, rightv, somev
           integer(ilp) :: i, ii, is, j, k, ki, iv, maxwrk, nb
           real(${ck}$) :: ovfl, remax, scale, smin, smlnum, ulp, unfl
           complex(${ck}$) :: cdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters
           bothv  = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv  = stdlib_lsame( side, 'L' ) .or. bothv
           allv  = stdlib_lsame( howmny, 'A' )
           over  = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           ! set m to the number of columns required to store the selected
           ! eigenvectors.
           if( somev ) then
              m = 0
              do j = 1, n
                 if( select( j ) )m = m + 1
              end do
           else
              m = n
           end if
           info = 0
           nb = stdlib_ilaenv( 1, 'ZTREVC', side // howmny, n, -1, -1, -1 )
           maxwrk = n + 2*n*nb
           work(1) = maxwrk
           rwork(1) = n
           lquery = ( lwork==-1 .or. lrwork==-1 )
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else if( mm<m ) then
              info = -11
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -14
           else if ( lrwork<max( 1, n ) .and. .not.lquery ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTREVC3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! use blocked version of back-transformation if sufficient workspace.
           ! zero-out the workspace to avoid potential nan propagation.
           if( over .and. lwork >= n + 2*n*nbmin ) then
              nb = (lwork - n) / (2*n)
              nb = min( nb, nbmax )
              call stdlib_${ci}$laset( 'F', n, 1+2*nb, czero, czero, work, n )
           else
              nb = 1
           end if
           ! set the constants to control overflow.
           unfl = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_${c2ri(ci)}$labad( unfl, ovfl )
           ulp = stdlib_${c2ri(ci)}$lamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           ! store the diagonal elements of t in working array work.
           do i = 1, n
              work( i ) = t( i, i )
           end do
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           rwork( 1 ) = zero
           do j = 2, n
              rwork( j ) = stdlib_${c2ri(ci)}$zasum( j-1, t( 1, j ), 1 )
           end do
           if( rightv ) then
              ! ============================================================
              ! compute right eigenvectors.
              ! iv is index of column in current block.
              ! non-blocked version always uses iv=nb=1;
              ! blocked     version starts with iv=nb, goes down to 1.
              ! (note the "0-th" column is used to store the original diagonal.)
              iv = nb
              is = m
              loop_80: do ki = n, 1, -1
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_80
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 ! --------------------------------------------------------
                 ! complex right eigenvector
                 work( ki + iv*n ) = cone
                 ! form right-hand side.
                 do k = 1, ki - 1
                    work( k + iv*n ) = -t( k, ki )
                 end do
                 ! solve upper triangular system:
                 ! [ t(1:ki-1,1:ki-1) - t(ki,ki) ]*x = scale*work.
                 do k = 1, ki - 1
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki>1 ) then
                    call stdlib_${ci}$latrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', 'Y',ki-1, t, ldt, &
                              work( 1 + iv*n ), scale,rwork, info )
                    work( ki + iv*n ) = scale
                 end if
                 ! copy the vector x or q*x to vr and normalize.
                 if( .not.over ) then
                    ! ------------------------------
                    ! no back-transform: copy x to vr and normalize.
                    call stdlib_${ci}$copy( ki, work( 1 + iv*n ), 1, vr( 1, is ), 1 )
                    ii = stdlib_i${ci}$amax( ki, vr( 1, is ), 1 )
                    remax = one / cabs1( vr( ii, is ) )
                    call stdlib_${ci}$dscal( ki, remax, vr( 1, is ), 1 )
                    do k = ki + 1, n
                       vr( k, is ) = czero
                    end do
                 else if( nb==1 ) then
                    ! ------------------------------
                    ! version 1: back-transform each vector with gemv, q*x.
                    if( ki>1 )call stdlib_${ci}$gemv( 'N', n, ki-1, cone, vr, ldvr,work( 1 + iv*n ), 1,&
                               cmplx( scale,KIND=${ck}$),vr( 1, ki ), 1 )
                    ii = stdlib_i${ci}$amax( n, vr( 1, ki ), 1 )
                    remax = one / cabs1( vr( ii, ki ) )
                    call stdlib_${ci}$dscal( n, remax, vr( 1, ki ), 1 )
                 else
                    ! ------------------------------
                    ! version 2: back-transform block of vectors with gemm
                    ! zero out below vector
                    do k = ki + 1, n
                       work( k + iv*n ) = czero
                    end do
                    ! columns iv:nb of work are valid vectors.
                    ! when the number of vectors stored reaches nb,
                    ! or if this was last vector, do the gemm
                    if( (iv==1) .or. (ki==1) ) then
                       call stdlib_${ci}$gemm( 'N', 'N', n, nb-iv+1, ki+nb-iv, cone,vr, ldvr,work( 1 + &
                                 (iv)*n    ), n,czero,work( 1 + (nb+iv)*n ), n )
                       ! normalize vectors
                       do k = iv, nb
                          ii = stdlib_i${ci}$amax( n, work( 1 + (nb+k)*n ), 1 )
                          remax = one / cabs1( work( ii + (nb+k)*n ) )
                          call stdlib_${ci}$dscal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_${ci}$lacpy( 'F', n, nb-iv+1,work( 1 + (nb+iv)*n ), n,vr( 1, ki ), &
                                 ldvr )
                       iv = nb
                    else
                       iv = iv - 1
                    end if
                 end if
                 ! restore the original diagonal elements of t.
                 do k = 1, ki - 1
                    t( k, k ) = work( k )
                 end do
                 is = is - 1
              end do loop_80
           end if
           if( leftv ) then
              ! ============================================================
              ! compute left eigenvectors.
              ! iv is index of column in current block.
              ! non-blocked version always uses iv=1;
              ! blocked     version starts with iv=1, goes up to nb.
              ! (note the "0-th" column is used to store the original diagonal.)
              iv = 1
              is = 1
              loop_130: do ki = 1, n
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_130
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 ! --------------------------------------------------------
                 ! complex left eigenvector
                 work( ki + iv*n ) = cone
                 ! form right-hand side.
                 do k = ki + 1, n
                    work( k + iv*n ) = -conjg( t( ki, k ) )
                 end do
                 ! solve conjugate-transposed triangular system:
                 ! [ t(ki+1:n,ki+1:n) - t(ki,ki) ]**h * x = scale*work.
                 do k = ki + 1, n
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki<n ) then
                    call stdlib_${ci}$latrs( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT','Y', n-ki, t( &
                              ki+1, ki+1 ), ldt,work( ki+1 + iv*n ), scale, rwork, info )
                    work( ki + iv*n ) = scale
                 end if
                 ! copy the vector x or q*x to vl and normalize.
                 if( .not.over ) then
                    ! ------------------------------
                    ! no back-transform: copy x to vl and normalize.
                    call stdlib_${ci}$copy( n-ki+1, work( ki + iv*n ), 1, vl(ki,is), 1 )
                    ii = stdlib_i${ci}$amax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                    remax = one / cabs1( vl( ii, is ) )
                    call stdlib_${ci}$dscal( n-ki+1, remax, vl( ki, is ), 1 )
                    do k = 1, ki - 1
                       vl( k, is ) = czero
                    end do
                 else if( nb==1 ) then
                    ! ------------------------------
                    ! version 1: back-transform each vector with gemv, q*x.
                    if( ki<n )call stdlib_${ci}$gemv( 'N', n, n-ki, cone, vl( 1, ki+1 ), ldvl,work( ki+&
                              1 + iv*n ), 1, cmplx( scale,KIND=${ck}$),vl( 1, ki ), 1 )
                    ii = stdlib_i${ci}$amax( n, vl( 1, ki ), 1 )
                    remax = one / cabs1( vl( ii, ki ) )
                    call stdlib_${ci}$dscal( n, remax, vl( 1, ki ), 1 )
                 else
                    ! ------------------------------
                    ! version 2: back-transform block of vectors with gemm
                    ! zero out above vector
                    ! could go from ki-nv+1 to ki-1
                    do k = 1, ki - 1
                       work( k + iv*n ) = czero
                    end do
                    ! columns 1:iv of work are valid vectors.
                    ! when the number of vectors stored reaches nb,
                    ! or if this was last vector, do the gemm
                    if( (iv==nb) .or. (ki==n) ) then
                       call stdlib_${ci}$gemm( 'N', 'N', n, iv, n-ki+iv, cone,vl( 1, ki-iv+1 ), ldvl,&
                                 work( ki-iv+1 + (1)*n ), n,czero,work( 1 + (nb+1)*n ), n )
                       ! normalize vectors
                       do k = 1, iv
                          ii = stdlib_i${ci}$amax( n, work( 1 + (nb+k)*n ), 1 )
                          remax = one / cabs1( work( ii + (nb+k)*n ) )
                          call stdlib_${ci}$dscal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_${ci}$lacpy( 'F', n, iv,work( 1 + (nb+1)*n ), n,vl( 1, ki-iv+1 ), &
                                 ldvl )
                       iv = 1
                    else
                       iv = iv + 1
                    end if
                 end if
                 ! restore the original diagonal elements of t.
                 do k = ki + 1, n
                    t( k, k ) = work( k )
                 end do
                 is = is + 1
              end do loop_130
           end if
           return
     end subroutine stdlib_${ci}$trevc3

#:endif
#:endfor



     module pure subroutine stdlib_stgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst, &
     !! STGEXC reorders the generalized real Schur decomposition of a real
     !! matrix pair (A,B) using an orthogonal equivalence transformation
     !! (A, B) = Q * (A, B) * Z**T,
     !! so that the diagonal block of (A, B) with row index IFST is moved
     !! to row ILST.
     !! (A, B) must be in generalized real Schur canonical form (as returned
     !! by SGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
     !! diagonal blocks. B is upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T
     !! Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(inout) :: ifst, ilst
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldq, ldz, lwork, n
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: here, lwmin, nbf, nbl, nbnext
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input arguments.
           info = 0
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldq<1 .or. wantq .and. ( ldq<max( 1, n ) ) ) then
              info = -9
           else if( ldz<1 .or. wantz .and. ( ldz<max( 1, n ) ) ) then
              info = -11
           else if( ifst<1 .or. ifst>n ) then
              info = -12
           else if( ilst<1 .or. ilst>n ) then
              info = -13
           end if
           if( info==0 ) then
              if( n<=1 ) then
                 lwmin = 1
              else
                 lwmin = 4*n + 16
              end if
              work(1) = lwmin
              if (lwork<lwmin .and. .not.lquery) then
                 info = -15
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STGEXC', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n<=1 )return
           ! determine the first row of the specified block and find out
           ! if it is 1-by-1 or 2-by-2.
           if( ifst>1 ) then
              if( a( ifst, ifst-1 )/=zero )ifst = ifst - 1
           end if
           nbf = 1
           if( ifst<n ) then
              if( a( ifst+1, ifst )/=zero )nbf = 2
           end if
           ! determine the first row of the final block
           ! and find out if it is 1-by-1 or 2-by-2.
           if( ilst>1 ) then
              if( a( ilst, ilst-1 )/=zero )ilst = ilst - 1
           end if
           nbl = 1
           if( ilst<n ) then
              if( a( ilst+1, ilst )/=zero )nbl = 2
           end if
           if( ifst==ilst )return
           if( ifst<ilst ) then
              ! update ilst.
              if( nbf==2 .and. nbl==1 )ilst = ilst - 1
              if( nbf==1 .and. nbl==2 )ilst = ilst + 1
              here = ifst
              10 continue
              ! swap with next one below.
              if( nbf==1 .or. nbf==2 ) then
                 ! current block either 1-by-1 or 2-by-2.
                 nbnext = 1
                 if( here+nbf+1<=n ) then
                    if( a( here+nbf+1, here+nbf )/=zero )nbnext = 2
                 end if
                 call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here, nbf, &
                           nbnext, work, lwork, info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 here = here + nbnext
                 ! test if 2-by-2 block breaks into two 1-by-1 blocks.
                 if( nbf==2 ) then
                    if( a( here+1, here )==zero )nbf = 3
                 end if
              else
                 ! current block consists of two 1-by-1 blocks, each of which
                 ! must be swapped individually.
                 nbnext = 1
                 if( here+3<=n ) then
                    if( a( here+3, here+2 )/=zero )nbnext = 2
                 end if
                 call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here+1, 1, &
                           nbnext, work, lwork, info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 if( nbnext==1 ) then
                    ! swap two 1-by-1 blocks.
                    call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here, 1, &
                              1, work, lwork, info )
                    if( info/=0 ) then
                       ilst = here
                       return
                    end if
                    here = here + 1
                 else
                    ! recompute nbnext in case of 2-by-2 split.
                    if( a( here+2, here+1 )==zero )nbnext = 1
                    if( nbnext==2 ) then
                       ! 2-by-2 block did not split.
                       call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, nbnext, work, lwork,info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 2
                    else
                       ! 2-by-2 block did split.
                       call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 1
                       call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 1
                    end if
                 end if
              end if
              if( here<ilst )go to 10
           else
              here = ifst
              20 continue
              ! swap with next one below.
              if( nbf==1 .or. nbf==2 ) then
                 ! current block either 1-by-1 or 2-by-2.
                 nbnext = 1
                 if( here>=3 ) then
                    if( a( here-1, here-2 )/=zero )nbnext = 2
                 end if
                 call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here-nbnext, &
                           nbnext, nbf, work, lwork,info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 here = here - nbnext
                 ! test if 2-by-2 block breaks into two 1-by-1 blocks.
                 if( nbf==2 ) then
                    if( a( here+1, here )==zero )nbf = 3
                 end if
              else
                 ! current block consists of two 1-by-1 blocks, each of which
                 ! must be swapped individually.
                 nbnext = 1
                 if( here>=3 ) then
                    if( a( here-1, here-2 )/=zero )nbnext = 2
                 end if
                 call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here-nbnext, &
                           nbnext, 1, work, lwork,info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 if( nbnext==1 ) then
                    ! swap two 1-by-1 blocks.
                    call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here, &
                              nbnext, 1, work, lwork, info )
                    if( info/=0 ) then
                       ilst = here
                       return
                    end if
                    here = here - 1
                 else
                   ! recompute nbnext in case of 2-by-2 split.
                    if( a( here, here-1 )==zero )nbnext = 1
                    if( nbnext==2 ) then
                       ! 2-by-2 block did not split.
                       call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here-1,&
                                  2, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 2
                    else
                       ! 2-by-2 block did split.
                       call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 1
                       call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 1
                    end if
                 end if
              end if
              if( here>ilst )go to 20
           end if
           ilst = here
           work( 1 ) = lwmin
           return
     end subroutine stdlib_stgexc

     module pure subroutine stdlib_dtgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst, &
     !! DTGEXC reorders the generalized real Schur decomposition of a real
     !! matrix pair (A,B) using an orthogonal equivalence transformation
     !! (A, B) = Q * (A, B) * Z**T,
     !! so that the diagonal block of (A, B) with row index IFST is moved
     !! to row ILST.
     !! (A, B) must be in generalized real Schur canonical form (as returned
     !! by DGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
     !! diagonal blocks. B is upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T
     !! Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(inout) :: ifst, ilst
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldq, ldz, lwork, n
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: here, lwmin, nbf, nbl, nbnext
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input arguments.
           info = 0
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldq<1 .or. wantq .and. ( ldq<max( 1, n ) ) ) then
              info = -9
           else if( ldz<1 .or. wantz .and. ( ldz<max( 1, n ) ) ) then
              info = -11
           else if( ifst<1 .or. ifst>n ) then
              info = -12
           else if( ilst<1 .or. ilst>n ) then
              info = -13
           end if
           if( info==0 ) then
              if( n<=1 ) then
                 lwmin = 1
              else
                 lwmin = 4*n + 16
              end if
              work(1) = lwmin
              if (lwork<lwmin .and. .not.lquery) then
                 info = -15
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGEXC', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n<=1 )return
           ! determine the first row of the specified block and find out
           ! if it is 1-by-1 or 2-by-2.
           if( ifst>1 ) then
              if( a( ifst, ifst-1 )/=zero )ifst = ifst - 1
           end if
           nbf = 1
           if( ifst<n ) then
              if( a( ifst+1, ifst )/=zero )nbf = 2
           end if
           ! determine the first row of the final block
           ! and find out if it is 1-by-1 or 2-by-2.
           if( ilst>1 ) then
              if( a( ilst, ilst-1 )/=zero )ilst = ilst - 1
           end if
           nbl = 1
           if( ilst<n ) then
              if( a( ilst+1, ilst )/=zero )nbl = 2
           end if
           if( ifst==ilst )return
           if( ifst<ilst ) then
              ! update ilst.
              if( nbf==2 .and. nbl==1 )ilst = ilst - 1
              if( nbf==1 .and. nbl==2 )ilst = ilst + 1
              here = ifst
              10 continue
              ! swap with next one below.
              if( nbf==1 .or. nbf==2 ) then
                 ! current block either 1-by-1 or 2-by-2.
                 nbnext = 1
                 if( here+nbf+1<=n ) then
                    if( a( here+nbf+1, here+nbf )/=zero )nbnext = 2
                 end if
                 call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here, nbf, &
                           nbnext, work, lwork, info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 here = here + nbnext
                 ! test if 2-by-2 block breaks into two 1-by-1 blocks.
                 if( nbf==2 ) then
                    if( a( here+1, here )==zero )nbf = 3
                 end if
              else
                 ! current block consists of two 1-by-1 blocks, each of which
                 ! must be swapped individually.
                 nbnext = 1
                 if( here+3<=n ) then
                    if( a( here+3, here+2 )/=zero )nbnext = 2
                 end if
                 call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here+1, 1, &
                           nbnext, work, lwork, info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 if( nbnext==1 ) then
                    ! swap two 1-by-1 blocks.
                    call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here, 1, &
                              1, work, lwork, info )
                    if( info/=0 ) then
                       ilst = here
                       return
                    end if
                    here = here + 1
                 else
                    ! recompute nbnext in case of 2-by-2 split.
                    if( a( here+2, here+1 )==zero )nbnext = 1
                    if( nbnext==2 ) then
                       ! 2-by-2 block did not split.
                       call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, nbnext, work, lwork,info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 2
                    else
                       ! 2-by-2 block did split.
                       call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 1
                       call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 1
                    end if
                 end if
              end if
              if( here<ilst )go to 10
           else
              here = ifst
              20 continue
              ! swap with next one below.
              if( nbf==1 .or. nbf==2 ) then
                 ! current block either 1-by-1 or 2-by-2.
                 nbnext = 1
                 if( here>=3 ) then
                    if( a( here-1, here-2 )/=zero )nbnext = 2
                 end if
                 call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here-nbnext, &
                           nbnext, nbf, work, lwork,info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 here = here - nbnext
                 ! test if 2-by-2 block breaks into two 1-by-1 blocks.
                 if( nbf==2 ) then
                    if( a( here+1, here )==zero )nbf = 3
                 end if
              else
                 ! current block consists of two 1-by-1 blocks, each of which
                 ! must be swapped individually.
                 nbnext = 1
                 if( here>=3 ) then
                    if( a( here-1, here-2 )/=zero )nbnext = 2
                 end if
                 call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here-nbnext, &
                           nbnext, 1, work, lwork,info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 if( nbnext==1 ) then
                    ! swap two 1-by-1 blocks.
                    call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here, &
                              nbnext, 1, work, lwork, info )
                    if( info/=0 ) then
                       ilst = here
                       return
                    end if
                    here = here - 1
                 else
                   ! recompute nbnext in case of 2-by-2 split.
                    if( a( here, here-1 )==zero )nbnext = 1
                    if( nbnext==2 ) then
                       ! 2-by-2 block did not split.
                       call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here-1,&
                                  2, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 2
                    else
                       ! 2-by-2 block did split.
                       call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 1
                       call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 1
                    end if
                 end if
              end if
              if( here>ilst )go to 20
           end if
           ilst = here
           work( 1 ) = lwmin
           return
     end subroutine stdlib_dtgexc

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$tgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst, &
     !! DTGEXC: reorders the generalized real Schur decomposition of a real
     !! matrix pair (A,B) using an orthogonal equivalence transformation
     !! (A, B) = Q * (A, B) * Z**T,
     !! so that the diagonal block of (A, B) with row index IFST is moved
     !! to row ILST.
     !! (A, B) must be in generalized real Schur canonical form (as returned
     !! by DGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
     !! diagonal blocks. B is upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T
     !! Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(inout) :: ifst, ilst
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldq, ldz, lwork, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: here, lwmin, nbf, nbl, nbnext
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input arguments.
           info = 0
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldq<1 .or. wantq .and. ( ldq<max( 1, n ) ) ) then
              info = -9
           else if( ldz<1 .or. wantz .and. ( ldz<max( 1, n ) ) ) then
              info = -11
           else if( ifst<1 .or. ifst>n ) then
              info = -12
           else if( ilst<1 .or. ilst>n ) then
              info = -13
           end if
           if( info==0 ) then
              if( n<=1 ) then
                 lwmin = 1
              else
                 lwmin = 4*n + 16
              end if
              work(1) = lwmin
              if (lwork<lwmin .and. .not.lquery) then
                 info = -15
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGEXC', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n<=1 )return
           ! determine the first row of the specified block and find out
           ! if it is 1-by-1 or 2-by-2.
           if( ifst>1 ) then
              if( a( ifst, ifst-1 )/=zero )ifst = ifst - 1
           end if
           nbf = 1
           if( ifst<n ) then
              if( a( ifst+1, ifst )/=zero )nbf = 2
           end if
           ! determine the first row of the final block
           ! and find out if it is 1-by-1 or 2-by-2.
           if( ilst>1 ) then
              if( a( ilst, ilst-1 )/=zero )ilst = ilst - 1
           end if
           nbl = 1
           if( ilst<n ) then
              if( a( ilst+1, ilst )/=zero )nbl = 2
           end if
           if( ifst==ilst )return
           if( ifst<ilst ) then
              ! update ilst.
              if( nbf==2 .and. nbl==1 )ilst = ilst - 1
              if( nbf==1 .and. nbl==2 )ilst = ilst + 1
              here = ifst
              10 continue
              ! swap with next one below.
              if( nbf==1 .or. nbf==2 ) then
                 ! current block either 1-by-1 or 2-by-2.
                 nbnext = 1
                 if( here+nbf+1<=n ) then
                    if( a( here+nbf+1, here+nbf )/=zero )nbnext = 2
                 end if
                 call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here, nbf, &
                           nbnext, work, lwork, info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 here = here + nbnext
                 ! test if 2-by-2 block breaks into two 1-by-1 blocks.
                 if( nbf==2 ) then
                    if( a( here+1, here )==zero )nbf = 3
                 end if
              else
                 ! current block consists of two 1-by-1 blocks, each of which
                 ! must be swapped individually.
                 nbnext = 1
                 if( here+3<=n ) then
                    if( a( here+3, here+2 )/=zero )nbnext = 2
                 end if
                 call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here+1, 1, &
                           nbnext, work, lwork, info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 if( nbnext==1 ) then
                    ! swap two 1-by-1 blocks.
                    call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here, 1, &
                              1, work, lwork, info )
                    if( info/=0 ) then
                       ilst = here
                       return
                    end if
                    here = here + 1
                 else
                    ! recompute nbnext in case of 2-by-2 split.
                    if( a( here+2, here+1 )==zero )nbnext = 1
                    if( nbnext==2 ) then
                       ! 2-by-2 block did not split.
                       call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, nbnext, work, lwork,info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 2
                    else
                       ! 2-by-2 block did split.
                       call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 1
                       call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 1
                    end if
                 end if
              end if
              if( here<ilst )go to 10
           else
              here = ifst
              20 continue
              ! swap with next one below.
              if( nbf==1 .or. nbf==2 ) then
                 ! current block either 1-by-1 or 2-by-2.
                 nbnext = 1
                 if( here>=3 ) then
                    if( a( here-1, here-2 )/=zero )nbnext = 2
                 end if
                 call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here-nbnext, &
                           nbnext, nbf, work, lwork,info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 here = here - nbnext
                 ! test if 2-by-2 block breaks into two 1-by-1 blocks.
                 if( nbf==2 ) then
                    if( a( here+1, here )==zero )nbf = 3
                 end if
              else
                 ! current block consists of two 1-by-1 blocks, each of which
                 ! must be swapped individually.
                 nbnext = 1
                 if( here>=3 ) then
                    if( a( here-1, here-2 )/=zero )nbnext = 2
                 end if
                 call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here-nbnext, &
                           nbnext, 1, work, lwork,info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 if( nbnext==1 ) then
                    ! swap two 1-by-1 blocks.
                    call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here, &
                              nbnext, 1, work, lwork, info )
                    if( info/=0 ) then
                       ilst = here
                       return
                    end if
                    here = here - 1
                 else
                   ! recompute nbnext in case of 2-by-2 split.
                    if( a( here, here-1 )==zero )nbnext = 1
                    if( nbnext==2 ) then
                       ! 2-by-2 block did not split.
                       call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here-1,&
                                  2, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 2
                    else
                       ! 2-by-2 block did split.
                       call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 1
                       call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 1
                    end if
                 end if
              end if
              if( here>ilst )go to 20
           end if
           ilst = here
           work( 1 ) = lwmin
           return
     end subroutine stdlib_${ri}$tgexc

#:endif
#:endfor

     module pure subroutine stdlib_ctgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst, &
     !! CTGEXC reorders the generalized Schur decomposition of a complex
     !! matrix pair (A,B), using an unitary equivalence transformation
     !! (A, B) := Q * (A, B) * Z**H, so that the diagonal block of (A, B) with
     !! row index IFST is moved to row ILST.
     !! (A, B) must be in generalized Schur canonical form, that is, A and
     !! B are both upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H
     !! Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(in) :: ifst, lda, ldb, ldq, ldz, n
           integer(ilp), intent(inout) :: ilst
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: here
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input arguments.
           info = 0
           if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldq<1 .or. wantq .and. ( ldq<max( 1, n ) ) ) then
              info = -9
           else if( ldz<1 .or. wantz .and. ( ldz<max( 1, n ) ) ) then
              info = -11
           else if( ifst<1 .or. ifst>n ) then
              info = -12
           else if( ilst<1 .or. ilst>n ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGEXC', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 )return
           if( ifst==ilst )return
           if( ifst<ilst ) then
              here = ifst
              10 continue
              ! swap with next one below
              call stdlib_ctgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz,here, info )
                        
              if( info/=0 ) then
                 ilst = here
                 return
              end if
              here = here + 1
              if( here<ilst )go to 10
              here = here - 1
           else
              here = ifst - 1
              20 continue
              ! swap with next one above
              call stdlib_ctgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz,here, info )
                        
              if( info/=0 ) then
                 ilst = here
                 return
              end if
              here = here - 1
              if( here>=ilst )go to 20
              here = here + 1
           end if
           ilst = here
           return
     end subroutine stdlib_ctgexc

     module pure subroutine stdlib_ztgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst, &
     !! ZTGEXC reorders the generalized Schur decomposition of a complex
     !! matrix pair (A,B), using an unitary equivalence transformation
     !! (A, B) := Q * (A, B) * Z**H, so that the diagonal block of (A, B) with
     !! row index IFST is moved to row ILST.
     !! (A, B) must be in generalized Schur canonical form, that is, A and
     !! B are both upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H
     !! Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(in) :: ifst, lda, ldb, ldq, ldz, n
           integer(ilp), intent(inout) :: ilst
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: here
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input arguments.
           info = 0
           if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldq<1 .or. wantq .and. ( ldq<max( 1, n ) ) ) then
              info = -9
           else if( ldz<1 .or. wantz .and. ( ldz<max( 1, n ) ) ) then
              info = -11
           else if( ifst<1 .or. ifst>n ) then
              info = -12
           else if( ilst<1 .or. ilst>n ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGEXC', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 )return
           if( ifst==ilst )return
           if( ifst<ilst ) then
              here = ifst
              10 continue
              ! swap with next one below
              call stdlib_ztgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz,here, info )
                        
              if( info/=0 ) then
                 ilst = here
                 return
              end if
              here = here + 1
              if( here<ilst )go to 10
              here = here - 1
           else
              here = ifst - 1
              20 continue
              ! swap with next one above
              call stdlib_ztgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz,here, info )
                        
              if( info/=0 ) then
                 ilst = here
                 return
              end if
              here = here - 1
              if( here>=ilst )go to 20
              here = here + 1
           end if
           ilst = here
           return
     end subroutine stdlib_ztgexc

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$tgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst, &
     !! ZTGEXC: reorders the generalized Schur decomposition of a complex
     !! matrix pair (A,B), using an unitary equivalence transformation
     !! (A, B) := Q * (A, B) * Z**H, so that the diagonal block of (A, B) with
     !! row index IFST is moved to row ILST.
     !! (A, B) must be in generalized Schur canonical form, that is, A and
     !! B are both upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H
     !! Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(in) :: ifst, lda, ldb, ldq, ldz, n
           integer(ilp), intent(inout) :: ilst
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: here
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input arguments.
           info = 0
           if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldq<1 .or. wantq .and. ( ldq<max( 1, n ) ) ) then
              info = -9
           else if( ldz<1 .or. wantz .and. ( ldz<max( 1, n ) ) ) then
              info = -11
           else if( ifst<1 .or. ifst>n ) then
              info = -12
           else if( ilst<1 .or. ilst>n ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGEXC', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 )return
           if( ifst==ilst )return
           if( ifst<ilst ) then
              here = ifst
              10 continue
              ! swap with next one below
              call stdlib_${ci}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz,here, info )
                        
              if( info/=0 ) then
                 ilst = here
                 return
              end if
              here = here + 1
              if( here<ilst )go to 10
              here = here - 1
           else
              here = ifst - 1
              20 continue
              ! swap with next one above
              call stdlib_${ci}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz,here, info )
                        
              if( info/=0 ) then
                 ilst = here
                 return
              end if
              here = here - 1
              if( here>=ilst )go to 20
              here = here + 1
           end if
           ilst = here
           return
     end subroutine stdlib_${ci}$tgexc

#:endif
#:endfor



     module subroutine stdlib_sgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alphar, &
     !! SGGES computes for a pair of N-by-N real nonsymmetric matrices (A,B),
     !! the generalized eigenvalues, the generalized real Schur form (S,T),
     !! optionally, the left and/or right matrices of Schur vectors (VSL and
     !! VSR). This gives the generalized Schur factorization
     !! (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! quasi-triangular matrix S and the upper triangular matrix T.The
     !! leading columns of VSL and VSR then form an orthonormal basis for the
     !! corresponding left and right eigenspaces (deflating subspaces).
     !! (If only the generalized eigenvalues are needed, use the driver
     !! SGGEV instead, which is faster.)
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0 or both being zero.
     !! A pair of matrices (S,T) is in generalized real Schur form if T is
     !! upper triangular with non-negative diagonal and S is block upper
     !! triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
     !! to real generalized eigenvalues, while 2-by-2 blocks of S will be
     !! "standardized" by making the corresponding elements of T have the
     !! form:
     !! [  a  0  ]
     !! [  0  b  ]
     !! and the pair of corresponding 2-by-2 blocks in S and T will have a
     !! complex conjugate pair of generalized eigenvalues.
               alphai, beta, vsl, ldvsl, vsr,ldvsr, work, lwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: alphai(*), alphar(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), &
                     work(*)
           ! Function Arguments 
           procedure(stdlib_selctg_s) :: selctg
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, lst2sl, &
                     wantst
           integer(ilp) :: i, icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, ip, iright, irows, &
                     itau, iwrk, maxwrk, minwrk
           real(sp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl, pvsr, safmax, safmin, &
                     smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(sp) :: dif(2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -15
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -17
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              if( n>0 )then
                 minwrk = max( 8*n, 6*n + 16 )
                 maxwrk = minwrk - n +n*stdlib_ilaenv( 1, 'SGEQRF', ' ', n, 1, n, 0 )
                 maxwrk = max( maxwrk, minwrk - n +n*stdlib_ilaenv( 1, 'SORMQR', ' ', n, 1, n, -1 &
                           ) )
                 if( ilvsl ) then
                    maxwrk = max( maxwrk, minwrk - n +n*stdlib_ilaenv( 1, 'SORGQR', ' ', n, 1, n, &
                              -1 ) )
                 end if
              else
                 minwrk = 1
                 maxwrk = 1
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery )info = -19
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGGES ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           safmin = stdlib_slamch( 'S' )
           safmax = one / safmin
           call stdlib_slabad( safmin, safmax )
           smlnum = sqrt( safmin ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_slange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_slascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_slange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_slascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (workspace: need 6*n + 2*n space for storing balancing factors)
           ileft = 1
           iright = n + 1
           iwrk = iright + n
           call stdlib_sggbal( 'P', n, a, lda, b, ldb, ilo, ihi, work( ileft ),work( iright ), &
                     work( iwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = iwrk
           iwrk = itau + irows
           call stdlib_sgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           ! (workspace: need n, prefer n*nb)
           call stdlib_sormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           ! (workspace: need n, prefer n*nb)
           if( ilvsl ) then
              call stdlib_slaset( 'FULL', n, n, zero, one, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_slacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_sorgqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_slaset( 'FULL', n, n, zero, one, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           call stdlib_sgghrd( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      ierr )
           ! perform qz algorithm, computing schur vectors if desired
           ! (workspace: need n)
           iwrk = itau
           call stdlib_shgeqz( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vsl, ldvsl, vsr, ldvsr,work( iwrk ), lwork+1-iwrk, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 40
           end if
           ! sort eigenvalues alpha/beta if desired
           ! (workspace: need 4*n+16 )
           sdim = 0
           if( wantst ) then
              ! undo scaling on eigenvalues before selctging
              if( ilascl ) then
                 call stdlib_slascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n,ierr )
                 call stdlib_slascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n,ierr )
              end if
              if( ilbscl )call stdlib_slascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alphar( i ), alphai( i ), beta( i ) )
              end do
              call stdlib_stgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb, alphar,alphai, beta, &
              vsl, ldvsl, vsr, ldvsr, sdim, pvsl,pvsr, dif, work( iwrk ), lwork-iwrk+1, idum, 1,&
                        ierr )
              if( ierr==1 )info = n + 3
           end if
           ! apply back-permutation to vsl and vsr
           ! (workspace: none needed)
           if( ilvsl )call stdlib_sggbak( 'P', 'L', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_sggbak( 'P', 'R', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsr, ldvsr, ierr )
           ! check if unscaling would cause over/underflow, if so, rescale
           ! (alphar(i),alphai(i),beta(i)) so beta(i) is on the order of
           ! b(i,i) and alphar(i) and alphai(i) are on the order of a(i,i)
           if( ilascl )then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                    if( ( alphar( i )/safmax )>( anrmto/anrm ) .or.( safmin/alphar( i ) )>( &
                              anrm/anrmto ) ) then
                       work( 1 ) = abs( a( i, i )/alphar( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    else if( ( alphai( i )/safmax )>( anrmto/anrm ) .or.( safmin/alphai( i ) )>( &
                              anrm/anrmto ) ) then
                       work( 1 ) = abs( a( i, i+1 )/alphai( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    end if
                 end if
              end do
           end if
           if( ilbscl )then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                     if( ( beta( i )/safmax )>( bnrmto/bnrm ) .or.( safmin/beta( i ) )>( &
                               bnrm/bnrmto ) ) then
                        work( 1 ) = abs(b( i, i )/beta( i ))
                        beta( i ) = beta( i )*work( 1 )
                        alphar( i ) = alphar( i )*work( 1 )
                        alphai( i ) = alphai( i )*work( 1 )
                     end if
                  end if
              end do
           end if
           ! undo scaling
           if( ilascl ) then
              call stdlib_slascl( 'H', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_slascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_slascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_slascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_slascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              lst2sl = .true.
              sdim = 0
              ip = 0
              do i = 1, n
                 cursl = selctg( alphar( i ), alphai( i ), beta( i ) )
                 if( alphai( i )==zero ) then
                    if( cursl )sdim = sdim + 1
                    ip = 0
                    if( cursl .and. .not.lastsl )info = n + 2
                 else
                    if( ip==1 ) then
                       ! last eigenvalue of conjugate pair
                       cursl = cursl .or. lastsl
                       lastsl = cursl
                       if( cursl )sdim = sdim + 2
                       ip = -1
                       if( cursl .and. .not.lst2sl )info = n + 2
                    else
                       ! first eigenvalue of conjugate pair
                       ip = 1
                    end if
                 end if
                 lst2sl = lastsl
                 lastsl = cursl
              end do
           end if
           40 continue
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_sgges

     module subroutine stdlib_dgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alphar, &
     !! DGGES computes for a pair of N-by-N real nonsymmetric matrices (A,B),
     !! the generalized eigenvalues, the generalized real Schur form (S,T),
     !! optionally, the left and/or right matrices of Schur vectors (VSL and
     !! VSR). This gives the generalized Schur factorization
     !! (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! quasi-triangular matrix S and the upper triangular matrix T.The
     !! leading columns of VSL and VSR then form an orthonormal basis for the
     !! corresponding left and right eigenspaces (deflating subspaces).
     !! (If only the generalized eigenvalues are needed, use the driver
     !! DGGEV instead, which is faster.)
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0 or both being zero.
     !! A pair of matrices (S,T) is in generalized real Schur form if T is
     !! upper triangular with non-negative diagonal and S is block upper
     !! triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
     !! to real generalized eigenvalues, while 2-by-2 blocks of S will be
     !! "standardized" by making the corresponding elements of T have the
     !! form:
     !! [  a  0  ]
     !! [  0  b  ]
     !! and the pair of corresponding 2-by-2 blocks in S and T will have a
     !! complex conjugate pair of generalized eigenvalues.
               alphai, beta, vsl, ldvsl, vsr,ldvsr, work, lwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: alphai(*), alphar(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), &
                     work(*)
           ! Function Arguments 
           procedure(stdlib_selctg_d) :: selctg
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, lst2sl, &
                     wantst
           integer(ilp) :: i, icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, ip, iright, irows, &
                     itau, iwrk, maxwrk, minwrk
           real(dp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl, pvsr, safmax, safmin, &
                     smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(dp) :: dif(2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -15
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -17
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              if( n>0 )then
                 minwrk = max( 8*n, 6*n + 16 )
                 maxwrk = minwrk - n +n*stdlib_ilaenv( 1, 'DGEQRF', ' ', n, 1, n, 0 )
                 maxwrk = max( maxwrk, minwrk - n +n*stdlib_ilaenv( 1, 'DORMQR', ' ', n, 1, n, -1 &
                           ) )
                 if( ilvsl ) then
                    maxwrk = max( maxwrk, minwrk - n +n*stdlib_ilaenv( 1, 'DORGQR', ' ', n, 1, n, &
                              -1 ) )
                 end if
              else
                 minwrk = 1
                 maxwrk = 1
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery )info = -19
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGES ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           safmin = stdlib_dlamch( 'S' )
           safmax = one / safmin
           call stdlib_dlabad( safmin, safmax )
           smlnum = sqrt( safmin ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_dlange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_dlascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_dlange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_dlascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (workspace: need 6*n + 2*n space for storing balancing factors)
           ileft = 1
           iright = n + 1
           iwrk = iright + n
           call stdlib_dggbal( 'P', n, a, lda, b, ldb, ilo, ihi, work( ileft ),work( iright ), &
                     work( iwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = iwrk
           iwrk = itau + irows
           call stdlib_dgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           ! (workspace: need n, prefer n*nb)
           call stdlib_dormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           ! (workspace: need n, prefer n*nb)
           if( ilvsl ) then
              call stdlib_dlaset( 'FULL', n, n, zero, one, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_dlacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_dorgqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_dlaset( 'FULL', n, n, zero, one, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           call stdlib_dgghrd( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      ierr )
           ! perform qz algorithm, computing schur vectors if desired
           ! (workspace: need n)
           iwrk = itau
           call stdlib_dhgeqz( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vsl, ldvsl, vsr, ldvsr,work( iwrk ), lwork+1-iwrk, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 50
           end if
           ! sort eigenvalues alpha/beta if desired
           ! (workspace: need 4*n+16 )
           sdim = 0
           if( wantst ) then
              ! undo scaling on eigenvalues before selctging
              if( ilascl ) then
                 call stdlib_dlascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n,ierr )
                 call stdlib_dlascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n,ierr )
              end if
              if( ilbscl )call stdlib_dlascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alphar( i ), alphai( i ), beta( i ) )
              end do
              call stdlib_dtgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb, alphar,alphai, beta, &
              vsl, ldvsl, vsr, ldvsr, sdim, pvsl,pvsr, dif, work( iwrk ), lwork-iwrk+1, idum, 1,&
                        ierr )
              if( ierr==1 )info = n + 3
           end if
           ! apply back-permutation to vsl and vsr
           ! (workspace: none needed)
           if( ilvsl )call stdlib_dggbak( 'P', 'L', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_dggbak( 'P', 'R', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsr, ldvsr, ierr )
           ! check if unscaling would cause over/underflow, if so, rescale
           ! (alphar(i),alphai(i),beta(i)) so beta(i) is on the order of
           ! b(i,i) and alphar(i) and alphai(i) are on the order of a(i,i)
           if( ilascl ) then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                    if( ( alphar( i ) / safmax )>( anrmto / anrm ) .or.( safmin / alphar( i ) )>( &
                              anrm / anrmto ) ) then
                       work( 1 ) = abs( a( i, i ) / alphar( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    else if( ( alphai( i ) / safmax )>( anrmto / anrm ) .or.( safmin / alphai( i )&
                               )>( anrm / anrmto ) )then
                       work( 1 ) = abs( a( i, i+1 ) / alphai( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    end if
                 end if
              end do
           end if
           if( ilbscl ) then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                    if( ( beta( i ) / safmax )>( bnrmto / bnrm ) .or.( safmin / beta( i ) )>( &
                              bnrm / bnrmto ) ) then
                       work( 1 ) = abs( b( i, i ) / beta( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    end if
                 end if
              end do
           end if
           ! undo scaling
           if( ilascl ) then
              call stdlib_dlascl( 'H', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_dlascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_dlascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_dlascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_dlascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              lst2sl = .true.
              sdim = 0
              ip = 0
              do i = 1, n
                 cursl = selctg( alphar( i ), alphai( i ), beta( i ) )
                 if( alphai( i )==zero ) then
                    if( cursl )sdim = sdim + 1
                    ip = 0
                    if( cursl .and. .not.lastsl )info = n + 2
                 else
                    if( ip==1 ) then
                       ! last eigenvalue of conjugate pair
                       cursl = cursl .or. lastsl
                       lastsl = cursl
                       if( cursl )sdim = sdim + 2
                       ip = -1
                       if( cursl .and. .not.lst2sl )info = n + 2
                    else
                       ! first eigenvalue of conjugate pair
                       ip = 1
                    end if
                 end if
                 lst2sl = lastsl
                 lastsl = cursl
              end do
           end if
           50 continue
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_dgges

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$gges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alphar, &
     !! DGGES: computes for a pair of N-by-N real nonsymmetric matrices (A,B),
     !! the generalized eigenvalues, the generalized real Schur form (S,T),
     !! optionally, the left and/or right matrices of Schur vectors (VSL and
     !! VSR). This gives the generalized Schur factorization
     !! (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! quasi-triangular matrix S and the upper triangular matrix T.The
     !! leading columns of VSL and VSR then form an orthonormal basis for the
     !! corresponding left and right eigenspaces (deflating subspaces).
     !! (If only the generalized eigenvalues are needed, use the driver
     !! DGGEV instead, which is faster.)
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0 or both being zero.
     !! A pair of matrices (S,T) is in generalized real Schur form if T is
     !! upper triangular with non-negative diagonal and S is block upper
     !! triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
     !! to real generalized eigenvalues, while 2-by-2 blocks of S will be
     !! "standardized" by making the corresponding elements of T have the
     !! form:
     !! [  a  0  ]
     !! [  0  b  ]
     !! and the pair of corresponding 2-by-2 blocks in S and T will have a
     !! complex conjugate pair of generalized eigenvalues.
               alphai, beta, vsl, ldvsl, vsr,ldvsr, work, lwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), &
                     work(*)
           ! Function Arguments 
           procedure(stdlib_selctg_${ri}$) :: selctg
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, lst2sl, &
                     wantst
           integer(ilp) :: i, icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, ip, iright, irows, &
                     itau, iwrk, maxwrk, minwrk
           real(${rk}$) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl, pvsr, safmax, safmin, &
                     smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(${rk}$) :: dif(2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -15
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -17
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              if( n>0 )then
                 minwrk = max( 8*n, 6*n + 16 )
                 maxwrk = minwrk - n +n*stdlib_ilaenv( 1, 'DGEQRF', ' ', n, 1, n, 0 )
                 maxwrk = max( maxwrk, minwrk - n +n*stdlib_ilaenv( 1, 'DORMQR', ' ', n, 1, n, -1 &
                           ) )
                 if( ilvsl ) then
                    maxwrk = max( maxwrk, minwrk - n +n*stdlib_ilaenv( 1, 'DORGQR', ' ', n, 1, n, &
                              -1 ) )
                 end if
              else
                 minwrk = 1
                 maxwrk = 1
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery )info = -19
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGES ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           safmin = stdlib_${ri}$lamch( 'S' )
           safmax = one / safmin
           call stdlib_${ri}$labad( safmin, safmax )
           smlnum = sqrt( safmin ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_${ri}$lascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_${ri}$lange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_${ri}$lascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (workspace: need 6*n + 2*n space for storing balancing factors)
           ileft = 1
           iright = n + 1
           iwrk = iright + n
           call stdlib_${ri}$ggbal( 'P', n, a, lda, b, ldb, ilo, ihi, work( ileft ),work( iright ), &
                     work( iwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = iwrk
           iwrk = itau + irows
           call stdlib_${ri}$geqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           ! (workspace: need n, prefer n*nb)
           call stdlib_${ri}$ormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           ! (workspace: need n, prefer n*nb)
           if( ilvsl ) then
              call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_${ri}$lacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_${ri}$orgqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           call stdlib_${ri}$gghrd( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      ierr )
           ! perform qz algorithm, computing schur vectors if desired
           ! (workspace: need n)
           iwrk = itau
           call stdlib_${ri}$hgeqz( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vsl, ldvsl, vsr, ldvsr,work( iwrk ), lwork+1-iwrk, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 50
           end if
           ! sort eigenvalues alpha/beta if desired
           ! (workspace: need 4*n+16 )
           sdim = 0
           if( wantst ) then
              ! undo scaling on eigenvalues before selctging
              if( ilascl ) then
                 call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n,ierr )
                 call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n,ierr )
              end if
              if( ilbscl )call stdlib_${ri}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alphar( i ), alphai( i ), beta( i ) )
              end do
              call stdlib_${ri}$tgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb, alphar,alphai, beta, &
              vsl, ldvsl, vsr, ldvsr, sdim, pvsl,pvsr, dif, work( iwrk ), lwork-iwrk+1, idum, 1,&
                        ierr )
              if( ierr==1 )info = n + 3
           end if
           ! apply back-permutation to vsl and vsr
           ! (workspace: none needed)
           if( ilvsl )call stdlib_${ri}$ggbak( 'P', 'L', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_${ri}$ggbak( 'P', 'R', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsr, ldvsr, ierr )
           ! check if unscaling would cause over/underflow, if so, rescale
           ! (alphar(i),alphai(i),beta(i)) so beta(i) is on the order of
           ! b(i,i) and alphar(i) and alphai(i) are on the order of a(i,i)
           if( ilascl ) then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                    if( ( alphar( i ) / safmax )>( anrmto / anrm ) .or.( safmin / alphar( i ) )>( &
                              anrm / anrmto ) ) then
                       work( 1 ) = abs( a( i, i ) / alphar( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    else if( ( alphai( i ) / safmax )>( anrmto / anrm ) .or.( safmin / alphai( i )&
                               )>( anrm / anrmto ) )then
                       work( 1 ) = abs( a( i, i+1 ) / alphai( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    end if
                 end if
              end do
           end if
           if( ilbscl ) then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                    if( ( beta( i ) / safmax )>( bnrmto / bnrm ) .or.( safmin / beta( i ) )>( &
                              bnrm / bnrmto ) ) then
                       work( 1 ) = abs( b( i, i ) / beta( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    end if
                 end if
              end do
           end if
           ! undo scaling
           if( ilascl ) then
              call stdlib_${ri}$lascl( 'H', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_${ri}$lascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              lst2sl = .true.
              sdim = 0
              ip = 0
              do i = 1, n
                 cursl = selctg( alphar( i ), alphai( i ), beta( i ) )
                 if( alphai( i )==zero ) then
                    if( cursl )sdim = sdim + 1
                    ip = 0
                    if( cursl .and. .not.lastsl )info = n + 2
                 else
                    if( ip==1 ) then
                       ! last eigenvalue of conjugate pair
                       cursl = cursl .or. lastsl
                       lastsl = cursl
                       if( cursl )sdim = sdim + 2
                       ip = -1
                       if( cursl .and. .not.lst2sl )info = n + 2
                    else
                       ! first eigenvalue of conjugate pair
                       ip = 1
                    end if
                 end if
                 lst2sl = lastsl
                 lastsl = cursl
              end do
           end if
           50 continue
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_${ri}$gges

#:endif
#:endfor

     module subroutine stdlib_cgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alpha, beta, &
     !! CGGES computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, the generalized complex Schur
     !! form (S, T), and optionally left and/or right Schur vectors (VSL
     !! and VSR). This gives the generalized Schur factorization
     !! (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )
     !! where (VSR)**H is the conjugate-transpose of VSR.
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! triangular matrix S and the upper triangular matrix T. The leading
     !! columns of VSL and VSR then form an unitary basis for the
     !! corresponding left and right eigenspaces (deflating subspaces).
     !! (If only the generalized eigenvalues are needed, use the driver
     !! CGGEV instead, which is faster.)
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0, and even for both being zero.
     !! A pair of matrices (S,T) is in generalized complex Schur form if S
     !! and T are upper triangular and, in addition, the diagonal elements
     !! of T are non-negative real numbers.
               vsl, ldvsl, vsr, ldvsr, work,lwork, rwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: alpha(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), work(*)
                     
           ! Function Arguments 
           procedure(stdlib_selctg_c) :: selctg
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, wantst
           integer(ilp) :: i, icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, iright, irows, irwrk, &
                     itau, iwrk, lwkmin, lwkopt
           real(sp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl, pvsr, smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(sp) :: dif(2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -14
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -16
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              lwkmin = max( 1, 2*n )
              lwkopt = max( 1, n + n*stdlib_ilaenv( 1, 'CGEQRF', ' ', n, 1, n, 0 ) )
              lwkopt = max( lwkopt, n +n*stdlib_ilaenv( 1, 'CUNMQR', ' ', n, 1, n, -1 ) )
              if( ilvsl ) then
                 lwkopt = max( lwkopt, n +n*stdlib_ilaenv( 1, 'CUNGQR', ' ', n, 1, n, -1 ) )
                           
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery )info = -18
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGES ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_clascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_clange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (real workspace: need 6*n)
           ileft = 1
           iright = n + 1
           irwrk = iright + n
           call stdlib_cggbal( 'P', n, a, lda, b, ldb, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     rwork( irwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (complex workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = 1
           iwrk = itau + irows
           call stdlib_cgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           ! (complex workspace: need n, prefer n*nb)
           call stdlib_cunmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           ! (complex workspace: need n, prefer n*nb)
           if( ilvsl ) then
              call stdlib_claset( 'FULL', n, n, czero, cone, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_clacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_cungqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_claset( 'FULL', n, n, czero, cone, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           call stdlib_cgghrd( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      ierr )
           sdim = 0
           ! perform qz algorithm, computing schur vectors if desired
           ! (complex workspace: need n)
           ! (real workspace: need n)
           iwrk = itau
           call stdlib_chgeqz( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vsl, &
                     ldvsl, vsr, ldvsr, work( iwrk ),lwork+1-iwrk, rwork( irwrk ), ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 30
           end if
           ! sort eigenvalues alpha/beta if desired
           ! (workspace: none needed)
           if( wantst ) then
              ! undo scaling on eigenvalues before selecting
              if( ilascl )call stdlib_clascl( 'G', 0, 0, anrm, anrmto, n, 1, alpha, n, ierr )
                        
              if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrm, bnrmto, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alpha( i ), beta( i ) )
              end do
              call stdlib_ctgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb, alpha,beta, vsl, &
              ldvsl, vsr, ldvsr, sdim, pvsl, pvsr,dif, work( iwrk ), lwork-iwrk+1, idum, 1, ierr )
                        
              if( ierr==1 )info = n + 3
           end if
           ! apply back-permutation to vsl and vsr
           ! (workspace: none needed)
           if( ilvsl )call stdlib_cggbak( 'P', 'L', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_cggbak( 'P', 'R', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsr, ldvsr, ierr )
           ! undo scaling
           if( ilascl ) then
              call stdlib_clascl( 'U', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_clascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_clascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_clascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              sdim = 0
              do i = 1, n
                 cursl = selctg( alpha( i ), beta( i ) )
                 if( cursl )sdim = sdim + 1
                 if( cursl .and. .not.lastsl )info = n + 2
                 lastsl = cursl
              end do
           end if
           30 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cgges

     module subroutine stdlib_zgges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alpha, beta, &
     !! ZGGES computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, the generalized complex Schur
     !! form (S, T), and optionally left and/or right Schur vectors (VSL
     !! and VSR). This gives the generalized Schur factorization
     !! (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )
     !! where (VSR)**H is the conjugate-transpose of VSR.
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! triangular matrix S and the upper triangular matrix T. The leading
     !! columns of VSL and VSR then form an unitary basis for the
     !! corresponding left and right eigenspaces (deflating subspaces).
     !! (If only the generalized eigenvalues are needed, use the driver
     !! ZGGEV instead, which is faster.)
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0, and even for both being zero.
     !! A pair of matrices (S,T) is in generalized complex Schur form if S
     !! and T are upper triangular and, in addition, the diagonal elements
     !! of T are non-negative real numbers.
               vsl, ldvsl, vsr, ldvsr, work,lwork, rwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: alpha(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), work(*)
                     
           ! Function Arguments 
           procedure(stdlib_selctg_z) :: selctg
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, wantst
           integer(ilp) :: i, icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, iright, irows, irwrk, &
                     itau, iwrk, lwkmin, lwkopt
           real(dp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl, pvsr, smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(dp) :: dif(2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -14
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -16
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              lwkmin = max( 1, 2*n )
              lwkopt = max( 1, n + n*stdlib_ilaenv( 1, 'ZGEQRF', ' ', n, 1, n, 0 ) )
              lwkopt = max( lwkopt, n +n*stdlib_ilaenv( 1, 'ZUNMQR', ' ', n, 1, n, -1 ) )
              if( ilvsl ) then
                 lwkopt = max( lwkopt, n +n*stdlib_ilaenv( 1, 'ZUNGQR', ' ', n, 1, n, -1 ) )
                           
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery )info = -18
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGES ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' )
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_zlange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_zlascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_zlange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_zlascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (real workspace: need 6*n)
           ileft = 1
           iright = n + 1
           irwrk = iright + n
           call stdlib_zggbal( 'P', n, a, lda, b, ldb, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     rwork( irwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (complex workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = 1
           iwrk = itau + irows
           call stdlib_zgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           ! (complex workspace: need n, prefer n*nb)
           call stdlib_zunmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           ! (complex workspace: need n, prefer n*nb)
           if( ilvsl ) then
              call stdlib_zlaset( 'FULL', n, n, czero, cone, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_zlacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_zungqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_zlaset( 'FULL', n, n, czero, cone, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           call stdlib_zgghrd( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      ierr )
           sdim = 0
           ! perform qz algorithm, computing schur vectors if desired
           ! (complex workspace: need n)
           ! (real workspace: need n)
           iwrk = itau
           call stdlib_zhgeqz( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vsl, &
                     ldvsl, vsr, ldvsr, work( iwrk ),lwork+1-iwrk, rwork( irwrk ), ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 30
           end if
           ! sort eigenvalues alpha/beta if desired
           ! (workspace: none needed)
           if( wantst ) then
              ! undo scaling on eigenvalues before selecting
              if( ilascl )call stdlib_zlascl( 'G', 0, 0, anrm, anrmto, n, 1, alpha, n, ierr )
                        
              if( ilbscl )call stdlib_zlascl( 'G', 0, 0, bnrm, bnrmto, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alpha( i ), beta( i ) )
              end do
              call stdlib_ztgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb, alpha,beta, vsl, &
              ldvsl, vsr, ldvsr, sdim, pvsl, pvsr,dif, work( iwrk ), lwork-iwrk+1, idum, 1, ierr )
                        
              if( ierr==1 )info = n + 3
           end if
           ! apply back-permutation to vsl and vsr
           ! (workspace: none needed)
           if( ilvsl )call stdlib_zggbak( 'P', 'L', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_zggbak( 'P', 'R', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsr, ldvsr, ierr )
           ! undo scaling
           if( ilascl ) then
              call stdlib_zlascl( 'U', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_zlascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_zlascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_zlascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              sdim = 0
              do i = 1, n
                 cursl = selctg( alpha( i ), beta( i ) )
                 if( cursl )sdim = sdim + 1
                 if( cursl .and. .not.lastsl )info = n + 2
                 lastsl = cursl
              end do
           end if
           30 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zgges

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$gges( jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb,sdim, alpha, beta, &
     !! ZGGES: computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, the generalized complex Schur
     !! form (S, T), and optionally left and/or right Schur vectors (VSL
     !! and VSR). This gives the generalized Schur factorization
     !! (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )
     !! where (VSR)**H is the conjugate-transpose of VSR.
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! triangular matrix S and the upper triangular matrix T. The leading
     !! columns of VSL and VSR then form an unitary basis for the
     !! corresponding left and right eigenspaces (deflating subspaces).
     !! (If only the generalized eigenvalues are needed, use the driver
     !! ZGGEV instead, which is faster.)
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0, and even for both being zero.
     !! A pair of matrices (S,T) is in generalized complex Schur form if S
     !! and T are upper triangular and, in addition, the diagonal elements
     !! of T are non-negative real numbers.
               vsl, ldvsl, vsr, ldvsr, work,lwork, rwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: alpha(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), work(*)
                     
           ! Function Arguments 
           procedure(stdlib_selctg_${ci}$) :: selctg
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, wantst
           integer(ilp) :: i, icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, iright, irows, irwrk, &
                     itau, iwrk, lwkmin, lwkopt
           real(${ck}$) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl, pvsr, smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(${ck}$) :: dif(2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -14
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -16
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              lwkmin = max( 1, 2*n )
              lwkopt = max( 1, n + n*stdlib_ilaenv( 1, 'ZGEQRF', ' ', n, 1, n, 0 ) )
              lwkopt = max( lwkopt, n +n*stdlib_ilaenv( 1, 'ZUNMQR', ' ', n, 1, n, -1 ) )
              if( ilvsl ) then
                 lwkopt = max( lwkopt, n +n*stdlib_ilaenv( 1, 'ZUNGQR', ' ', n, 1, n, -1 ) )
                           
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery )info = -18
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGES ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_${c2ri(ci)}$lamch( 'P' )
           smlnum = stdlib_${c2ri(ci)}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${c2ri(ci)}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ci}$lange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_${ci}$lascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_${ci}$lange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_${ci}$lascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ! (real workspace: need 6*n)
           ileft = 1
           iright = n + 1
           irwrk = iright + n
           call stdlib_${ci}$ggbal( 'P', n, a, lda, b, ldb, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     rwork( irwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           ! (complex workspace: need n, prefer n*nb)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = 1
           iwrk = itau + irows
           call stdlib_${ci}$geqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           ! (complex workspace: need n, prefer n*nb)
           call stdlib_${ci}$unmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           ! (complex workspace: need n, prefer n*nb)
           if( ilvsl ) then
              call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_${ci}$lacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_${ci}$ungqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           ! (workspace: none needed)
           call stdlib_${ci}$gghrd( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      ierr )
           sdim = 0
           ! perform qz algorithm, computing schur vectors if desired
           ! (complex workspace: need n)
           ! (real workspace: need n)
           iwrk = itau
           call stdlib_${ci}$hgeqz( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vsl, &
                     ldvsl, vsr, ldvsr, work( iwrk ),lwork+1-iwrk, rwork( irwrk ), ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 30
           end if
           ! sort eigenvalues alpha/beta if desired
           ! (workspace: none needed)
           if( wantst ) then
              ! undo scaling on eigenvalues before selecting
              if( ilascl )call stdlib_${ci}$lascl( 'G', 0, 0, anrm, anrmto, n, 1, alpha, n, ierr )
                        
              if( ilbscl )call stdlib_${ci}$lascl( 'G', 0, 0, bnrm, bnrmto, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alpha( i ), beta( i ) )
              end do
              call stdlib_${ci}$tgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb, alpha,beta, vsl, &
              ldvsl, vsr, ldvsr, sdim, pvsl, pvsr,dif, work( iwrk ), lwork-iwrk+1, idum, 1, ierr )
                        
              if( ierr==1 )info = n + 3
           end if
           ! apply back-permutation to vsl and vsr
           ! (workspace: none needed)
           if( ilvsl )call stdlib_${ci}$ggbak( 'P', 'L', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_${ci}$ggbak( 'P', 'R', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsr, ldvsr, ierr )
           ! undo scaling
           if( ilascl ) then
              call stdlib_${ci}$lascl( 'U', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_${ci}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_${ci}$lascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_${ci}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              sdim = 0
              do i = 1, n
                 cursl = selctg( alpha( i ), beta( i ) )
                 if( cursl )sdim = sdim + 1
                 if( cursl .and. .not.lastsl )info = n + 2
                 lastsl = cursl
              end do
           end if
           30 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$gges

#:endif
#:endfor



     module subroutine stdlib_sgeevx( balanc, jobvl, jobvr, sense, n, a, lda, wr, wi,vl, ldvl, vr, ldvr, &
     !! SGEEVX computes for an N-by-N real nonsymmetric matrix A, the
     !! eigenvalues and, optionally, the left and/or right eigenvectors.
     !! Optionally also, it computes a balancing transformation to improve
     !! the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
     !! SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
     !! (RCONDE), and reciprocal condition numbers for the right
     !! eigenvectors (RCONDV).
     !! The right eigenvector v(j) of A satisfies
     !! A * v(j) = lambda(j) * v(j)
     !! where lambda(j) is its eigenvalue.
     !! The left eigenvector u(j) of A satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H
     !! where u(j)**H denotes the conjugate-transpose of u(j).
     !! The computed eigenvectors are normalized to have Euclidean norm
     !! equal to 1 and largest component real.
     !! Balancing a matrix means permuting the rows and columns to make it
     !! more nearly upper triangular, and applying a diagonal similarity
     !! transformation D * A * D**(-1), where D is a diagonal matrix, to
     !! make its rows and columns closer in norm and the condition numbers
     !! of its eigenvalues and eigenvectors smaller.  The computed
     !! reciprocal condition numbers correspond to the balanced matrix.
     !! Permuting rows and columns will not change the condition numbers
     !! (in exact arithmetic) but diagonal scaling will.  For further
     !! explanation of balancing, see section 4.10.2_sp of the LAPACK
     !! Users' Guide.
               ilo, ihi, scale, abnrm,rconde, rcondv, work, lwork, iwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldvl, ldvr, lwork, n
           real(sp), intent(out) :: abnrm
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: rconde(*), rcondv(*), scale(*), vl(ldvl,*), vr(ldvr,*), wi(*),&
                      work(*), wr(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantvl, wantvr, wntsnb, wntsne, wntsnn, wntsnv
           character :: job, side
           integer(ilp) :: hswork, i, icond, ierr, itau, iwrk, k, lwork_trevc, maxwrk, minwrk, &
                     nout
           real(sp) :: anrm, bignum, cs, cscale, eps, r, scl, smlnum, sn
           ! Local Arrays 
           logical(lk) :: select(1)
           real(sp) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvl = stdlib_lsame( jobvl, 'V' )
           wantvr = stdlib_lsame( jobvr, 'V' )
           wntsnn = stdlib_lsame( sense, 'N' )
           wntsne = stdlib_lsame( sense, 'E' )
           wntsnv = stdlib_lsame( sense, 'V' )
           wntsnb = stdlib_lsame( sense, 'B' )
           if( .not.( stdlib_lsame( balanc, 'N' ) .or. stdlib_lsame( balanc, 'S' ).or. &
                     stdlib_lsame( balanc, 'P' ) .or. stdlib_lsame( balanc, 'B' ) ) )then
              info = -1
           else if( ( .not.wantvl ) .and. ( .not.stdlib_lsame( jobvl, 'N' ) ) ) then
              info = -2
           else if( ( .not.wantvr ) .and. ( .not.stdlib_lsame( jobvr, 'N' ) ) ) then
              info = -3
           else if( .not.( wntsnn .or. wntsne .or. wntsnb .or. wntsnv ) .or.( ( wntsne .or. &
                     wntsnb ) .and. .not.( wantvl .and.wantvr ) ) ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( wantvl .and. ldvl<n ) ) then
              info = -11
           else if( ldvr<1 .or. ( wantvr .and. ldvr<n ) ) then
              info = -13
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_shseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = n + n*stdlib_ilaenv( 1, 'SGEHRD', ' ', n, 1, n, 0 )
                 if( wantvl ) then
                    call stdlib_strevc3( 'L', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    call stdlib_shseqr( 'S', 'V', n, 1, n, a, lda, wr, wi, vl, ldvl,work, -1, &
                              info )
                 else if( wantvr ) then
                    call stdlib_strevc3( 'R', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    call stdlib_shseqr( 'S', 'V', n, 1, n, a, lda, wr, wi, vr, ldvr,work, -1, &
                              info )
                 else
                    if( wntsnn ) then
                       call stdlib_shseqr( 'E', 'N', n, 1, n, a, lda, wr, wi, vr,ldvr, work, -1, &
                                 info )
                    else
                       call stdlib_shseqr( 'S', 'N', n, 1, n, a, lda, wr, wi, vr,ldvr, work, -1, &
                                 info )
                    end if
                 end if
                 hswork = int( work(1),KIND=ilp)
                 if( ( .not.wantvl ) .and. ( .not.wantvr ) ) then
                    minwrk = 2*n
                    if( .not.wntsnn )minwrk = max( minwrk, n*n+6*n )
                    maxwrk = max( maxwrk, hswork )
                    if( .not.wntsnn )maxwrk = max( maxwrk, n*n + 6*n )
                 else
                    minwrk = 3*n
                    if( ( .not.wntsnn ) .and. ( .not.wntsne ) )minwrk = max( minwrk, n*n + 6*n )
                              
                    maxwrk = max( maxwrk, hswork )
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'SORGHR',' ', n, 1, n, -&
                              1 ) )
                    if( ( .not.wntsnn ) .and. ( .not.wntsne ) )maxwrk = max( maxwrk, n*n + 6*n )
                              
                    maxwrk = max( maxwrk, 3*n )
                 end if
                 maxwrk = max( maxwrk, minwrk )
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -21
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGEEVX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           icond = 0
           anrm = stdlib_slange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_slascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! balance the matrix and compute abnrm
           call stdlib_sgebal( balanc, n, a, lda, ilo, ihi, scale, ierr )
           abnrm = stdlib_slange( '1', n, n, a, lda, dum )
           if( scalea ) then
              dum( 1 ) = abnrm
              call stdlib_slascl( 'G', 0, 0, cscale, anrm, 1, 1, dum, 1, ierr )
              abnrm = dum( 1 )
           end if
           ! reduce to upper hessenberg form
           ! (workspace: need 2*n, prefer n+n*nb)
           itau = 1
           iwrk = itau + n
           call stdlib_sgehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvl ) then
              ! want left eigenvectors
              ! copy householder vectors to vl
              side = 'L'
              call stdlib_slacpy( 'L', n, n, a, lda, vl, ldvl )
              ! generate orthogonal matrix in vl
              ! (workspace: need 2*n-1, prefer n+(n-1)*nb)
              call stdlib_sorghr( n, ilo, ihi, vl, ldvl, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vl
              ! (workspace: need 1, prefer hswork (see comments) )
              iwrk = itau
              call stdlib_shseqr( 'S', 'V', n, ilo, ihi, a, lda, wr, wi, vl, ldvl,work( iwrk ), &
                        lwork-iwrk+1, info )
              if( wantvr ) then
                 ! want left and right eigenvectors
                 ! copy schur vectors to vr
                 side = 'B'
                 call stdlib_slacpy( 'F', n, n, vl, ldvl, vr, ldvr )
              end if
           else if( wantvr ) then
              ! want right eigenvectors
              ! copy householder vectors to vr
              side = 'R'
              call stdlib_slacpy( 'L', n, n, a, lda, vr, ldvr )
              ! generate orthogonal matrix in vr
              ! (workspace: need 2*n-1, prefer n+(n-1)*nb)
              call stdlib_sorghr( n, ilo, ihi, vr, ldvr, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vr
              ! (workspace: need 1, prefer hswork (see comments) )
              iwrk = itau
              call stdlib_shseqr( 'S', 'V', n, ilo, ihi, a, lda, wr, wi, vr, ldvr,work( iwrk ), &
                        lwork-iwrk+1, info )
           else
              ! compute eigenvalues only
              ! if condition numbers desired, compute schur form
              if( wntsnn ) then
                 job = 'E'
              else
                 job = 'S'
              end if
              ! (workspace: need 1, prefer hswork (see comments) )
              iwrk = itau
              call stdlib_shseqr( job, 'N', n, ilo, ihi, a, lda, wr, wi, vr, ldvr,work( iwrk ), &
                        lwork-iwrk+1, info )
           end if
           ! if info /= 0 from stdlib_shseqr, then quit
           if( info/=0 )go to 50
           if( wantvl .or. wantvr ) then
              ! compute left and/or right eigenvectors
              ! (workspace: need 3*n, prefer n + 2*n*nb)
              call stdlib_strevc3( side, 'B', select, n, a, lda, vl, ldvl, vr, ldvr,n, nout, work(&
                         iwrk ), lwork-iwrk+1, ierr )
           end if
           ! compute condition numbers if desired
           ! (workspace: need n*n+6*n unless sense = 'e')
           if( .not.wntsnn ) then
              call stdlib_strsna( sense, 'A', select, n, a, lda, vl, ldvl, vr, ldvr,rconde, &
                        rcondv, n, nout, work( iwrk ), n, iwork,icond )
           end if
           if( wantvl ) then
              ! undo balancing of left eigenvectors
              call stdlib_sgebak( balanc, 'L', n, ilo, ihi, scale, n, vl, ldvl,ierr )
              ! normalize left eigenvectors and make largest component real
              do i = 1, n
                 if( wi( i )==zero ) then
                    scl = one / stdlib_snrm2( n, vl( 1, i ), 1 )
                    call stdlib_sscal( n, scl, vl( 1, i ), 1 )
                 else if( wi( i )>zero ) then
                    scl = one / stdlib_slapy2( stdlib_snrm2( n, vl( 1, i ), 1 ),stdlib_snrm2( n, &
                              vl( 1, i+1 ), 1 ) )
                    call stdlib_sscal( n, scl, vl( 1, i ), 1 )
                    call stdlib_sscal( n, scl, vl( 1, i+1 ), 1 )
                    do k = 1, n
                       work( k ) = vl( k, i )**2 + vl( k, i+1 )**2
                    end do
                    k = stdlib_isamax( n, work, 1 )
                    call stdlib_slartg( vl( k, i ), vl( k, i+1 ), cs, sn, r )
                    call stdlib_srot( n, vl( 1, i ), 1, vl( 1, i+1 ), 1, cs, sn )
                    vl( k, i+1 ) = zero
                 end if
              end do
           end if
           if( wantvr ) then
              ! undo balancing of right eigenvectors
              call stdlib_sgebak( balanc, 'R', n, ilo, ihi, scale, n, vr, ldvr,ierr )
              ! normalize right eigenvectors and make largest component real
              do i = 1, n
                 if( wi( i )==zero ) then
                    scl = one / stdlib_snrm2( n, vr( 1, i ), 1 )
                    call stdlib_sscal( n, scl, vr( 1, i ), 1 )
                 else if( wi( i )>zero ) then
                    scl = one / stdlib_slapy2( stdlib_snrm2( n, vr( 1, i ), 1 ),stdlib_snrm2( n, &
                              vr( 1, i+1 ), 1 ) )
                    call stdlib_sscal( n, scl, vr( 1, i ), 1 )
                    call stdlib_sscal( n, scl, vr( 1, i+1 ), 1 )
                    do k = 1, n
                       work( k ) = vr( k, i )**2 + vr( k, i+1 )**2
                    end do
                    k = stdlib_isamax( n, work, 1 )
                    call stdlib_slartg( vr( k, i ), vr( k, i+1 ), cs, sn, r )
                    call stdlib_srot( n, vr( 1, i ), 1, vr( 1, i+1 ), 1, cs, sn )
                    vr( k, i+1 ) = zero
                 end if
              end do
           end if
           ! undo scaling if necessary
           50 continue
           if( scalea ) then
              call stdlib_slascl( 'G', 0, 0, cscale, anrm, n-info, 1, wr( info+1 ),max( n-info, 1 &
                        ), ierr )
              call stdlib_slascl( 'G', 0, 0, cscale, anrm, n-info, 1, wi( info+1 ),max( n-info, 1 &
                        ), ierr )
              if( info==0 ) then
                 if( ( wntsnv .or. wntsnb ) .and. icond==0 )call stdlib_slascl( 'G', 0, 0, cscale,&
                            anrm, n, 1, rcondv, n,ierr )
              else
                 call stdlib_slascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wr, n,ierr )
                 call stdlib_slascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wi, n,ierr )
              end if
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_sgeevx

     module subroutine stdlib_dgeevx( balanc, jobvl, jobvr, sense, n, a, lda, wr, wi,vl, ldvl, vr, ldvr, &
     !! DGEEVX computes for an N-by-N real nonsymmetric matrix A, the
     !! eigenvalues and, optionally, the left and/or right eigenvectors.
     !! Optionally also, it computes a balancing transformation to improve
     !! the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
     !! SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
     !! (RCONDE), and reciprocal condition numbers for the right
     !! eigenvectors (RCONDV).
     !! The right eigenvector v(j) of A satisfies
     !! A * v(j) = lambda(j) * v(j)
     !! where lambda(j) is its eigenvalue.
     !! The left eigenvector u(j) of A satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H
     !! where u(j)**H denotes the conjugate-transpose of u(j).
     !! The computed eigenvectors are normalized to have Euclidean norm
     !! equal to 1 and largest component real.
     !! Balancing a matrix means permuting the rows and columns to make it
     !! more nearly upper triangular, and applying a diagonal similarity
     !! transformation D * A * D**(-1), where D is a diagonal matrix, to
     !! make its rows and columns closer in norm and the condition numbers
     !! of its eigenvalues and eigenvectors smaller.  The computed
     !! reciprocal condition numbers correspond to the balanced matrix.
     !! Permuting rows and columns will not change the condition numbers
     !! (in exact arithmetic) but diagonal scaling will.  For further
     !! explanation of balancing, see section 4.10.2_dp of the LAPACK
     !! Users' Guide.
               ilo, ihi, scale, abnrm,rconde, rcondv, work, lwork, iwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldvl, ldvr, lwork, n
           real(dp), intent(out) :: abnrm
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: rconde(*), rcondv(*), scale(*), vl(ldvl,*), vr(ldvr,*), wi(*),&
                      work(*), wr(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantvl, wantvr, wntsnb, wntsne, wntsnn, wntsnv
           character :: job, side
           integer(ilp) :: hswork, i, icond, ierr, itau, iwrk, k, lwork_trevc, maxwrk, minwrk, &
                     nout
           real(dp) :: anrm, bignum, cs, cscale, eps, r, scl, smlnum, sn
           ! Local Arrays 
           logical(lk) :: select(1)
           real(dp) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvl = stdlib_lsame( jobvl, 'V' )
           wantvr = stdlib_lsame( jobvr, 'V' )
           wntsnn = stdlib_lsame( sense, 'N' )
           wntsne = stdlib_lsame( sense, 'E' )
           wntsnv = stdlib_lsame( sense, 'V' )
           wntsnb = stdlib_lsame( sense, 'B' )
           if( .not.( stdlib_lsame( balanc, 'N' ) .or. stdlib_lsame( balanc, 'S' ).or. &
                     stdlib_lsame( balanc, 'P' ) .or. stdlib_lsame( balanc, 'B' ) ) )then
              info = -1
           else if( ( .not.wantvl ) .and. ( .not.stdlib_lsame( jobvl, 'N' ) ) ) then
              info = -2
           else if( ( .not.wantvr ) .and. ( .not.stdlib_lsame( jobvr, 'N' ) ) ) then
              info = -3
           else if( .not.( wntsnn .or. wntsne .or. wntsnb .or. wntsnv ) .or.( ( wntsne .or. &
                     wntsnb ) .and. .not.( wantvl .and.wantvr ) ) ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( wantvl .and. ldvl<n ) ) then
              info = -11
           else if( ldvr<1 .or. ( wantvr .and. ldvr<n ) ) then
              info = -13
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_dhseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = n + n*stdlib_ilaenv( 1, 'DGEHRD', ' ', n, 1, n, 0 )
                 if( wantvl ) then
                    call stdlib_dtrevc3( 'L', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    call stdlib_dhseqr( 'S', 'V', n, 1, n, a, lda, wr, wi, vl, ldvl,work, -1, &
                              info )
                 else if( wantvr ) then
                    call stdlib_dtrevc3( 'R', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    call stdlib_dhseqr( 'S', 'V', n, 1, n, a, lda, wr, wi, vr, ldvr,work, -1, &
                              info )
                 else
                    if( wntsnn ) then
                       call stdlib_dhseqr( 'E', 'N', n, 1, n, a, lda, wr, wi, vr,ldvr, work, -1, &
                                 info )
                    else
                       call stdlib_dhseqr( 'S', 'N', n, 1, n, a, lda, wr, wi, vr,ldvr, work, -1, &
                                 info )
                    end if
                 end if
                 hswork = int( work(1),KIND=ilp)
                 if( ( .not.wantvl ) .and. ( .not.wantvr ) ) then
                    minwrk = 2*n
                    if( .not.wntsnn )minwrk = max( minwrk, n*n+6*n )
                    maxwrk = max( maxwrk, hswork )
                    if( .not.wntsnn )maxwrk = max( maxwrk, n*n + 6*n )
                 else
                    minwrk = 3*n
                    if( ( .not.wntsnn ) .and. ( .not.wntsne ) )minwrk = max( minwrk, n*n + 6*n )
                              
                    maxwrk = max( maxwrk, hswork )
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'DORGHR',' ', n, 1, n, -&
                              1 ) )
                    if( ( .not.wntsnn ) .and. ( .not.wntsne ) )maxwrk = max( maxwrk, n*n + 6*n )
                              
                    maxwrk = max( maxwrk, 3*n )
                 end if
                 maxwrk = max( maxwrk, minwrk )
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -21
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEEVX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' )
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           icond = 0
           anrm = stdlib_dlange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_dlascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! balance the matrix and compute abnrm
           call stdlib_dgebal( balanc, n, a, lda, ilo, ihi, scale, ierr )
           abnrm = stdlib_dlange( '1', n, n, a, lda, dum )
           if( scalea ) then
              dum( 1 ) = abnrm
              call stdlib_dlascl( 'G', 0, 0, cscale, anrm, 1, 1, dum, 1, ierr )
              abnrm = dum( 1 )
           end if
           ! reduce to upper hessenberg form
           ! (workspace: need 2*n, prefer n+n*nb)
           itau = 1
           iwrk = itau + n
           call stdlib_dgehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvl ) then
              ! want left eigenvectors
              ! copy householder vectors to vl
              side = 'L'
              call stdlib_dlacpy( 'L', n, n, a, lda, vl, ldvl )
              ! generate orthogonal matrix in vl
              ! (workspace: need 2*n-1, prefer n+(n-1)*nb)
              call stdlib_dorghr( n, ilo, ihi, vl, ldvl, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vl
              ! (workspace: need 1, prefer hswork (see comments) )
              iwrk = itau
              call stdlib_dhseqr( 'S', 'V', n, ilo, ihi, a, lda, wr, wi, vl, ldvl,work( iwrk ), &
                        lwork-iwrk+1, info )
              if( wantvr ) then
                 ! want left and right eigenvectors
                 ! copy schur vectors to vr
                 side = 'B'
                 call stdlib_dlacpy( 'F', n, n, vl, ldvl, vr, ldvr )
              end if
           else if( wantvr ) then
              ! want right eigenvectors
              ! copy householder vectors to vr
              side = 'R'
              call stdlib_dlacpy( 'L', n, n, a, lda, vr, ldvr )
              ! generate orthogonal matrix in vr
              ! (workspace: need 2*n-1, prefer n+(n-1)*nb)
              call stdlib_dorghr( n, ilo, ihi, vr, ldvr, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vr
              ! (workspace: need 1, prefer hswork (see comments) )
              iwrk = itau
              call stdlib_dhseqr( 'S', 'V', n, ilo, ihi, a, lda, wr, wi, vr, ldvr,work( iwrk ), &
                        lwork-iwrk+1, info )
           else
              ! compute eigenvalues only
              ! if condition numbers desired, compute schur form
              if( wntsnn ) then
                 job = 'E'
              else
                 job = 'S'
              end if
              ! (workspace: need 1, prefer hswork (see comments) )
              iwrk = itau
              call stdlib_dhseqr( job, 'N', n, ilo, ihi, a, lda, wr, wi, vr, ldvr,work( iwrk ), &
                        lwork-iwrk+1, info )
           end if
           ! if info /= 0 from stdlib_dhseqr, then quit
           if( info/=0 )go to 50
           if( wantvl .or. wantvr ) then
              ! compute left and/or right eigenvectors
              ! (workspace: need 3*n, prefer n + 2*n*nb)
              call stdlib_dtrevc3( side, 'B', select, n, a, lda, vl, ldvl, vr, ldvr,n, nout, work(&
                         iwrk ), lwork-iwrk+1, ierr )
           end if
           ! compute condition numbers if desired
           ! (workspace: need n*n+6*n unless sense = 'e')
           if( .not.wntsnn ) then
              call stdlib_dtrsna( sense, 'A', select, n, a, lda, vl, ldvl, vr, ldvr,rconde, &
                        rcondv, n, nout, work( iwrk ), n, iwork,icond )
           end if
           if( wantvl ) then
              ! undo balancing of left eigenvectors
              call stdlib_dgebak( balanc, 'L', n, ilo, ihi, scale, n, vl, ldvl,ierr )
              ! normalize left eigenvectors and make largest component real
              do i = 1, n
                 if( wi( i )==zero ) then
                    scl = one / stdlib_dnrm2( n, vl( 1, i ), 1 )
                    call stdlib_dscal( n, scl, vl( 1, i ), 1 )
                 else if( wi( i )>zero ) then
                    scl = one / stdlib_dlapy2( stdlib_dnrm2( n, vl( 1, i ), 1 ),stdlib_dnrm2( n, &
                              vl( 1, i+1 ), 1 ) )
                    call stdlib_dscal( n, scl, vl( 1, i ), 1 )
                    call stdlib_dscal( n, scl, vl( 1, i+1 ), 1 )
                    do k = 1, n
                       work( k ) = vl( k, i )**2 + vl( k, i+1 )**2
                    end do
                    k = stdlib_idamax( n, work, 1 )
                    call stdlib_dlartg( vl( k, i ), vl( k, i+1 ), cs, sn, r )
                    call stdlib_drot( n, vl( 1, i ), 1, vl( 1, i+1 ), 1, cs, sn )
                    vl( k, i+1 ) = zero
                 end if
              end do
           end if
           if( wantvr ) then
              ! undo balancing of right eigenvectors
              call stdlib_dgebak( balanc, 'R', n, ilo, ihi, scale, n, vr, ldvr,ierr )
              ! normalize right eigenvectors and make largest component real
              do i = 1, n
                 if( wi( i )==zero ) then
                    scl = one / stdlib_dnrm2( n, vr( 1, i ), 1 )
                    call stdlib_dscal( n, scl, vr( 1, i ), 1 )
                 else if( wi( i )>zero ) then
                    scl = one / stdlib_dlapy2( stdlib_dnrm2( n, vr( 1, i ), 1 ),stdlib_dnrm2( n, &
                              vr( 1, i+1 ), 1 ) )
                    call stdlib_dscal( n, scl, vr( 1, i ), 1 )
                    call stdlib_dscal( n, scl, vr( 1, i+1 ), 1 )
                    do k = 1, n
                       work( k ) = vr( k, i )**2 + vr( k, i+1 )**2
                    end do
                    k = stdlib_idamax( n, work, 1 )
                    call stdlib_dlartg( vr( k, i ), vr( k, i+1 ), cs, sn, r )
                    call stdlib_drot( n, vr( 1, i ), 1, vr( 1, i+1 ), 1, cs, sn )
                    vr( k, i+1 ) = zero
                 end if
              end do
           end if
           ! undo scaling if necessary
           50 continue
           if( scalea ) then
              call stdlib_dlascl( 'G', 0, 0, cscale, anrm, n-info, 1, wr( info+1 ),max( n-info, 1 &
                        ), ierr )
              call stdlib_dlascl( 'G', 0, 0, cscale, anrm, n-info, 1, wi( info+1 ),max( n-info, 1 &
                        ), ierr )
              if( info==0 ) then
                 if( ( wntsnv .or. wntsnb ) .and. icond==0 )call stdlib_dlascl( 'G', 0, 0, cscale,&
                            anrm, n, 1, rcondv, n,ierr )
              else
                 call stdlib_dlascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wr, n,ierr )
                 call stdlib_dlascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wi, n,ierr )
              end if
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_dgeevx

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$geevx( balanc, jobvl, jobvr, sense, n, a, lda, wr, wi,vl, ldvl, vr, ldvr, &
     !! DGEEVX: computes for an N-by-N real nonsymmetric matrix A, the
     !! eigenvalues and, optionally, the left and/or right eigenvectors.
     !! Optionally also, it computes a balancing transformation to improve
     !! the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
     !! SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
     !! (RCONDE), and reciprocal condition numbers for the right
     !! eigenvectors (RCONDV).
     !! The right eigenvector v(j) of A satisfies
     !! A * v(j) = lambda(j) * v(j)
     !! where lambda(j) is its eigenvalue.
     !! The left eigenvector u(j) of A satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H
     !! where u(j)**H denotes the conjugate-transpose of u(j).
     !! The computed eigenvectors are normalized to have Euclidean norm
     !! equal to 1 and largest component real.
     !! Balancing a matrix means permuting the rows and columns to make it
     !! more nearly upper triangular, and applying a diagonal similarity
     !! transformation D * A * D**(-1), where D is a diagonal matrix, to
     !! make its rows and columns closer in norm and the condition numbers
     !! of its eigenvalues and eigenvectors smaller.  The computed
     !! reciprocal condition numbers correspond to the balanced matrix.
     !! Permuting rows and columns will not change the condition numbers
     !! (in exact arithmetic) but diagonal scaling will.  For further
     !! explanation of balancing, see section 4.10.2_${rk}$ of the LAPACK
     !! Users' Guide.
               ilo, ihi, scale, abnrm,rconde, rcondv, work, lwork, iwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldvl, ldvr, lwork, n
           real(${rk}$), intent(out) :: abnrm
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: rconde(*), rcondv(*), scale(*), vl(ldvl,*), vr(ldvr,*), wi(*),&
                      work(*), wr(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantvl, wantvr, wntsnb, wntsne, wntsnn, wntsnv
           character :: job, side
           integer(ilp) :: hswork, i, icond, ierr, itau, iwrk, k, lwork_trevc, maxwrk, minwrk, &
                     nout
           real(${rk}$) :: anrm, bignum, cs, cscale, eps, r, scl, smlnum, sn
           ! Local Arrays 
           logical(lk) :: select(1)
           real(${rk}$) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvl = stdlib_lsame( jobvl, 'V' )
           wantvr = stdlib_lsame( jobvr, 'V' )
           wntsnn = stdlib_lsame( sense, 'N' )
           wntsne = stdlib_lsame( sense, 'E' )
           wntsnv = stdlib_lsame( sense, 'V' )
           wntsnb = stdlib_lsame( sense, 'B' )
           if( .not.( stdlib_lsame( balanc, 'N' ) .or. stdlib_lsame( balanc, 'S' ).or. &
                     stdlib_lsame( balanc, 'P' ) .or. stdlib_lsame( balanc, 'B' ) ) )then
              info = -1
           else if( ( .not.wantvl ) .and. ( .not.stdlib_lsame( jobvl, 'N' ) ) ) then
              info = -2
           else if( ( .not.wantvr ) .and. ( .not.stdlib_lsame( jobvr, 'N' ) ) ) then
              info = -3
           else if( .not.( wntsnn .or. wntsne .or. wntsnb .or. wntsnv ) .or.( ( wntsne .or. &
                     wntsnb ) .and. .not.( wantvl .and.wantvr ) ) ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( wantvl .and. ldvl<n ) ) then
              info = -11
           else if( ldvr<1 .or. ( wantvr .and. ldvr<n ) ) then
              info = -13
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_${ri}$hseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = n + n*stdlib_ilaenv( 1, 'DGEHRD', ' ', n, 1, n, 0 )
                 if( wantvl ) then
                    call stdlib_${ri}$trevc3( 'L', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    call stdlib_${ri}$hseqr( 'S', 'V', n, 1, n, a, lda, wr, wi, vl, ldvl,work, -1, &
                              info )
                 else if( wantvr ) then
                    call stdlib_${ri}$trevc3( 'R', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, n + lwork_trevc )
                    call stdlib_${ri}$hseqr( 'S', 'V', n, 1, n, a, lda, wr, wi, vr, ldvr,work, -1, &
                              info )
                 else
                    if( wntsnn ) then
                       call stdlib_${ri}$hseqr( 'E', 'N', n, 1, n, a, lda, wr, wi, vr,ldvr, work, -1, &
                                 info )
                    else
                       call stdlib_${ri}$hseqr( 'S', 'N', n, 1, n, a, lda, wr, wi, vr,ldvr, work, -1, &
                                 info )
                    end if
                 end if
                 hswork = int( work(1),KIND=ilp)
                 if( ( .not.wantvl ) .and. ( .not.wantvr ) ) then
                    minwrk = 2*n
                    if( .not.wntsnn )minwrk = max( minwrk, n*n+6*n )
                    maxwrk = max( maxwrk, hswork )
                    if( .not.wntsnn )maxwrk = max( maxwrk, n*n + 6*n )
                 else
                    minwrk = 3*n
                    if( ( .not.wntsnn ) .and. ( .not.wntsne ) )minwrk = max( minwrk, n*n + 6*n )
                              
                    maxwrk = max( maxwrk, hswork )
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'DORGHR',' ', n, 1, n, -&
                              1 ) )
                    if( ( .not.wntsnn ) .and. ( .not.wntsne ) )maxwrk = max( maxwrk, n*n + 6*n )
                              
                    maxwrk = max( maxwrk, 3*n )
                 end if
                 maxwrk = max( maxwrk, minwrk )
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -21
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEEVX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${ri}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           icond = 0
           anrm = stdlib_${ri}$lange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_${ri}$lascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! balance the matrix and compute abnrm
           call stdlib_${ri}$gebal( balanc, n, a, lda, ilo, ihi, scale, ierr )
           abnrm = stdlib_${ri}$lange( '1', n, n, a, lda, dum )
           if( scalea ) then
              dum( 1 ) = abnrm
              call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, 1, 1, dum, 1, ierr )
              abnrm = dum( 1 )
           end if
           ! reduce to upper hessenberg form
           ! (workspace: need 2*n, prefer n+n*nb)
           itau = 1
           iwrk = itau + n
           call stdlib_${ri}$gehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvl ) then
              ! want left eigenvectors
              ! copy householder vectors to vl
              side = 'L'
              call stdlib_${ri}$lacpy( 'L', n, n, a, lda, vl, ldvl )
              ! generate orthogonal matrix in vl
              ! (workspace: need 2*n-1, prefer n+(n-1)*nb)
              call stdlib_${ri}$orghr( n, ilo, ihi, vl, ldvl, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vl
              ! (workspace: need 1, prefer hswork (see comments) )
              iwrk = itau
              call stdlib_${ri}$hseqr( 'S', 'V', n, ilo, ihi, a, lda, wr, wi, vl, ldvl,work( iwrk ), &
                        lwork-iwrk+1, info )
              if( wantvr ) then
                 ! want left and right eigenvectors
                 ! copy schur vectors to vr
                 side = 'B'
                 call stdlib_${ri}$lacpy( 'F', n, n, vl, ldvl, vr, ldvr )
              end if
           else if( wantvr ) then
              ! want right eigenvectors
              ! copy householder vectors to vr
              side = 'R'
              call stdlib_${ri}$lacpy( 'L', n, n, a, lda, vr, ldvr )
              ! generate orthogonal matrix in vr
              ! (workspace: need 2*n-1, prefer n+(n-1)*nb)
              call stdlib_${ri}$orghr( n, ilo, ihi, vr, ldvr, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vr
              ! (workspace: need 1, prefer hswork (see comments) )
              iwrk = itau
              call stdlib_${ri}$hseqr( 'S', 'V', n, ilo, ihi, a, lda, wr, wi, vr, ldvr,work( iwrk ), &
                        lwork-iwrk+1, info )
           else
              ! compute eigenvalues only
              ! if condition numbers desired, compute schur form
              if( wntsnn ) then
                 job = 'E'
              else
                 job = 'S'
              end if
              ! (workspace: need 1, prefer hswork (see comments) )
              iwrk = itau
              call stdlib_${ri}$hseqr( job, 'N', n, ilo, ihi, a, lda, wr, wi, vr, ldvr,work( iwrk ), &
                        lwork-iwrk+1, info )
           end if
           ! if info /= 0 from stdlib_${ri}$hseqr, then quit
           if( info/=0 )go to 50
           if( wantvl .or. wantvr ) then
              ! compute left and/or right eigenvectors
              ! (workspace: need 3*n, prefer n + 2*n*nb)
              call stdlib_${ri}$trevc3( side, 'B', select, n, a, lda, vl, ldvl, vr, ldvr,n, nout, work(&
                         iwrk ), lwork-iwrk+1, ierr )
           end if
           ! compute condition numbers if desired
           ! (workspace: need n*n+6*n unless sense = 'e')
           if( .not.wntsnn ) then
              call stdlib_${ri}$trsna( sense, 'A', select, n, a, lda, vl, ldvl, vr, ldvr,rconde, &
                        rcondv, n, nout, work( iwrk ), n, iwork,icond )
           end if
           if( wantvl ) then
              ! undo balancing of left eigenvectors
              call stdlib_${ri}$gebak( balanc, 'L', n, ilo, ihi, scale, n, vl, ldvl,ierr )
              ! normalize left eigenvectors and make largest component real
              do i = 1, n
                 if( wi( i )==zero ) then
                    scl = one / stdlib_${ri}$nrm2( n, vl( 1, i ), 1 )
                    call stdlib_${ri}$scal( n, scl, vl( 1, i ), 1 )
                 else if( wi( i )>zero ) then
                    scl = one / stdlib_${ri}$lapy2( stdlib_${ri}$nrm2( n, vl( 1, i ), 1 ),stdlib_${ri}$nrm2( n, &
                              vl( 1, i+1 ), 1 ) )
                    call stdlib_${ri}$scal( n, scl, vl( 1, i ), 1 )
                    call stdlib_${ri}$scal( n, scl, vl( 1, i+1 ), 1 )
                    do k = 1, n
                       work( k ) = vl( k, i )**2 + vl( k, i+1 )**2
                    end do
                    k = stdlib_i${ri}$amax( n, work, 1 )
                    call stdlib_${ri}$lartg( vl( k, i ), vl( k, i+1 ), cs, sn, r )
                    call stdlib_${ri}$rot( n, vl( 1, i ), 1, vl( 1, i+1 ), 1, cs, sn )
                    vl( k, i+1 ) = zero
                 end if
              end do
           end if
           if( wantvr ) then
              ! undo balancing of right eigenvectors
              call stdlib_${ri}$gebak( balanc, 'R', n, ilo, ihi, scale, n, vr, ldvr,ierr )
              ! normalize right eigenvectors and make largest component real
              do i = 1, n
                 if( wi( i )==zero ) then
                    scl = one / stdlib_${ri}$nrm2( n, vr( 1, i ), 1 )
                    call stdlib_${ri}$scal( n, scl, vr( 1, i ), 1 )
                 else if( wi( i )>zero ) then
                    scl = one / stdlib_${ri}$lapy2( stdlib_${ri}$nrm2( n, vr( 1, i ), 1 ),stdlib_${ri}$nrm2( n, &
                              vr( 1, i+1 ), 1 ) )
                    call stdlib_${ri}$scal( n, scl, vr( 1, i ), 1 )
                    call stdlib_${ri}$scal( n, scl, vr( 1, i+1 ), 1 )
                    do k = 1, n
                       work( k ) = vr( k, i )**2 + vr( k, i+1 )**2
                    end do
                    k = stdlib_i${ri}$amax( n, work, 1 )
                    call stdlib_${ri}$lartg( vr( k, i ), vr( k, i+1 ), cs, sn, r )
                    call stdlib_${ri}$rot( n, vr( 1, i ), 1, vr( 1, i+1 ), 1, cs, sn )
                    vr( k, i+1 ) = zero
                 end if
              end do
           end if
           ! undo scaling if necessary
           50 continue
           if( scalea ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, n-info, 1, wr( info+1 ),max( n-info, 1 &
                        ), ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, n-info, 1, wi( info+1 ),max( n-info, 1 &
                        ), ierr )
              if( info==0 ) then
                 if( ( wntsnv .or. wntsnb ) .and. icond==0 )call stdlib_${ri}$lascl( 'G', 0, 0, cscale,&
                            anrm, n, 1, rcondv, n,ierr )
              else
                 call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wr, n,ierr )
                 call stdlib_${ri}$lascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, wi, n,ierr )
              end if
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_${ri}$geevx

#:endif
#:endfor

     module subroutine stdlib_cgeevx( balanc, jobvl, jobvr, sense, n, a, lda, w, vl,ldvl, vr, ldvr, ilo, &
     !! CGEEVX computes for an N-by-N complex nonsymmetric matrix A, the
     !! eigenvalues and, optionally, the left and/or right eigenvectors.
     !! Optionally also, it computes a balancing transformation to improve
     !! the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
     !! SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
     !! (RCONDE), and reciprocal condition numbers for the right
     !! eigenvectors (RCONDV).
     !! The right eigenvector v(j) of A satisfies
     !! A * v(j) = lambda(j) * v(j)
     !! where lambda(j) is its eigenvalue.
     !! The left eigenvector u(j) of A satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H
     !! where u(j)**H denotes the conjugate transpose of u(j).
     !! The computed eigenvectors are normalized to have Euclidean norm
     !! equal to 1 and largest component real.
     !! Balancing a matrix means permuting the rows and columns to make it
     !! more nearly upper triangular, and applying a diagonal similarity
     !! transformation D * A * D**(-1), where D is a diagonal matrix, to
     !! make its rows and columns closer in norm and the condition numbers
     !! of its eigenvalues and eigenvectors smaller.  The computed
     !! reciprocal condition numbers correspond to the balanced matrix.
     !! Permuting rows and columns will not change the condition numbers
     !! (in exact arithmetic) but diagonal scaling will.  For further
     !! explanation of balancing, see section 4.10.2_sp of the LAPACK
     !! Users' Guide.
               ihi, scale, abnrm, rconde,rcondv, work, lwork, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldvl, ldvr, lwork, n
           real(sp), intent(out) :: abnrm
           ! Array Arguments 
           real(sp), intent(out) :: rconde(*), rcondv(*), rwork(*), scale(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: vl(ldvl,*), vr(ldvr,*), w(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantvl, wantvr, wntsnb, wntsne, wntsnn, wntsnv
           character :: job, side
           integer(ilp) :: hswork, i, icond, ierr, itau, iwrk, k, lwork_trevc, maxwrk, minwrk, &
                     nout
           real(sp) :: anrm, bignum, cscale, eps, scl, smlnum
           complex(sp) :: tmp
           ! Local Arrays 
           logical(lk) :: select(1)
           real(sp) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvl = stdlib_lsame( jobvl, 'V' )
           wantvr = stdlib_lsame( jobvr, 'V' )
           wntsnn = stdlib_lsame( sense, 'N' )
           wntsne = stdlib_lsame( sense, 'E' )
           wntsnv = stdlib_lsame( sense, 'V' )
           wntsnb = stdlib_lsame( sense, 'B' )
           if( .not.( stdlib_lsame( balanc, 'N' ) .or. stdlib_lsame( balanc, 'S' ) &
                     .or.stdlib_lsame( balanc, 'P' ) .or. stdlib_lsame( balanc, 'B' ) ) ) then
              info = -1
           else if( ( .not.wantvl ) .and. ( .not.stdlib_lsame( jobvl, 'N' ) ) ) then
              info = -2
           else if( ( .not.wantvr ) .and. ( .not.stdlib_lsame( jobvr, 'N' ) ) ) then
              info = -3
           else if( .not.( wntsnn .or. wntsne .or. wntsnb .or. wntsnv ) .or.( ( wntsne .or. &
                     wntsnb ) .and. .not.( wantvl .and.wantvr ) ) ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( wantvl .and. ldvl<n ) ) then
              info = -10
           else if( ldvr<1 .or. ( wantvr .and. ldvr<n ) ) then
              info = -12
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to real
             ! workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_chseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = n + n*stdlib_ilaenv( 1, 'CGEHRD', ' ', n, 1, n, 0 )
                 if( wantvl ) then
                    call stdlib_ctrevc3( 'L', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, rwork, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, lwork_trevc )
                    call stdlib_chseqr( 'S', 'V', n, 1, n, a, lda, w, vl, ldvl,work, -1, info )
                              
                 else if( wantvr ) then
                    call stdlib_ctrevc3( 'R', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, rwork, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, lwork_trevc )
                    call stdlib_chseqr( 'S', 'V', n, 1, n, a, lda, w, vr, ldvr,work, -1, info )
                              
                 else
                    if( wntsnn ) then
                       call stdlib_chseqr( 'E', 'N', n, 1, n, a, lda, w, vr, ldvr,work, -1, info )
                                 
                    else
                       call stdlib_chseqr( 'S', 'N', n, 1, n, a, lda, w, vr, ldvr,work, -1, info )
                                 
                    end if
                 end if
                 hswork = int( work(1),KIND=ilp)
                 if( ( .not.wantvl ) .and. ( .not.wantvr ) ) then
                    minwrk = 2*n
                    if( .not.( wntsnn .or. wntsne ) )minwrk = max( minwrk, n*n + 2*n )
                    maxwrk = max( maxwrk, hswork )
                    if( .not.( wntsnn .or. wntsne ) )maxwrk = max( maxwrk, n*n + 2*n )
                 else
                    minwrk = 2*n
                    if( .not.( wntsnn .or. wntsne ) )minwrk = max( minwrk, n*n + 2*n )
                    maxwrk = max( maxwrk, hswork )
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'CUNGHR',' ', n, 1, n, -&
                              1 ) )
                    if( .not.( wntsnn .or. wntsne ) )maxwrk = max( maxwrk, n*n + 2*n )
                    maxwrk = max( maxwrk, 2*n )
                 end if
                 maxwrk = max( maxwrk, minwrk )
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -20
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEEVX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           icond = 0
           anrm = stdlib_clange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_clascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! balance the matrix and compute abnrm
           call stdlib_cgebal( balanc, n, a, lda, ilo, ihi, scale, ierr )
           abnrm = stdlib_clange( '1', n, n, a, lda, dum )
           if( scalea ) then
              dum( 1 ) = abnrm
              call stdlib_slascl( 'G', 0, 0, cscale, anrm, 1, 1, dum, 1, ierr )
              abnrm = dum( 1 )
           end if
           ! reduce to upper hessenberg form
           ! (cworkspace: need 2*n, prefer n+n*nb)
           ! (rworkspace: none)
           itau = 1
           iwrk = itau + n
           call stdlib_cgehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvl ) then
              ! want left eigenvectors
              ! copy householder vectors to vl
              side = 'L'
              call stdlib_clacpy( 'L', n, n, a, lda, vl, ldvl )
              ! generate unitary matrix in vl
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_cunghr( n, ilo, ihi, vl, ldvl, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vl
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_chseqr( 'S', 'V', n, ilo, ihi, a, lda, w, vl, ldvl,work( iwrk ), lwork-&
                        iwrk+1, info )
              if( wantvr ) then
                 ! want left and right eigenvectors
                 ! copy schur vectors to vr
                 side = 'B'
                 call stdlib_clacpy( 'F', n, n, vl, ldvl, vr, ldvr )
              end if
           else if( wantvr ) then
              ! want right eigenvectors
              ! copy householder vectors to vr
              side = 'R'
              call stdlib_clacpy( 'L', n, n, a, lda, vr, ldvr )
              ! generate unitary matrix in vr
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_cunghr( n, ilo, ihi, vr, ldvr, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vr
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_chseqr( 'S', 'V', n, ilo, ihi, a, lda, w, vr, ldvr,work( iwrk ), lwork-&
                        iwrk+1, info )
           else
              ! compute eigenvalues only
              ! if condition numbers desired, compute schur form
              if( wntsnn ) then
                 job = 'E'
              else
                 job = 'S'
              end if
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_chseqr( job, 'N', n, ilo, ihi, a, lda, w, vr, ldvr,work( iwrk ), lwork-&
                        iwrk+1, info )
           end if
           ! if info /= 0 from stdlib_chseqr, then quit
           if( info/=0 )go to 50
           if( wantvl .or. wantvr ) then
              ! compute left and/or right eigenvectors
              ! (cworkspace: need 2*n, prefer n + 2*n*nb)
              ! (rworkspace: need n)
              call stdlib_ctrevc3( side, 'B', select, n, a, lda, vl, ldvl, vr, ldvr,n, nout, work(&
                         iwrk ), lwork-iwrk+1,rwork, n, ierr )
           end if
           ! compute condition numbers if desired
           ! (cworkspace: need n*n+2*n unless sense = 'e')
           ! (rworkspace: need 2*n unless sense = 'e')
           if( .not.wntsnn ) then
              call stdlib_ctrsna( sense, 'A', select, n, a, lda, vl, ldvl, vr, ldvr,rconde, &
                        rcondv, n, nout, work( iwrk ), n, rwork,icond )
           end if
           if( wantvl ) then
              ! undo balancing of left eigenvectors
              call stdlib_cgebak( balanc, 'L', n, ilo, ihi, scale, n, vl, ldvl,ierr )
              ! normalize left eigenvectors and make largest component real
              do i = 1, n
                 scl = one / stdlib_scnrm2( n, vl( 1, i ), 1 )
                 call stdlib_csscal( n, scl, vl( 1, i ), 1 )
                 do k = 1, n
                    rwork( k ) = real( vl( k, i ),KIND=sp)**2 +aimag( vl( k, i ) )**2
                 end do
                 k = stdlib_isamax( n, rwork, 1 )
                 tmp = conjg( vl( k, i ) ) / sqrt( rwork( k ) )
                 call stdlib_cscal( n, tmp, vl( 1, i ), 1 )
                 vl( k, i ) = cmplx( real( vl( k, i ),KIND=sp), zero,KIND=sp)
              end do
           end if
           if( wantvr ) then
              ! undo balancing of right eigenvectors
              call stdlib_cgebak( balanc, 'R', n, ilo, ihi, scale, n, vr, ldvr,ierr )
              ! normalize right eigenvectors and make largest component real
              do i = 1, n
                 scl = one / stdlib_scnrm2( n, vr( 1, i ), 1 )
                 call stdlib_csscal( n, scl, vr( 1, i ), 1 )
                 do k = 1, n
                    rwork( k ) = real( vr( k, i ),KIND=sp)**2 +aimag( vr( k, i ) )**2
                 end do
                 k = stdlib_isamax( n, rwork, 1 )
                 tmp = conjg( vr( k, i ) ) / sqrt( rwork( k ) )
                 call stdlib_cscal( n, tmp, vr( 1, i ), 1 )
                 vr( k, i ) = cmplx( real( vr( k, i ),KIND=sp), zero,KIND=sp)
              end do
           end if
           ! undo scaling if necessary
           50 continue
           if( scalea ) then
              call stdlib_clascl( 'G', 0, 0, cscale, anrm, n-info, 1, w( info+1 ),max( n-info, 1 )&
                        , ierr )
              if( info==0 ) then
                 if( ( wntsnv .or. wntsnb ) .and. icond==0 )call stdlib_slascl( 'G', 0, 0, cscale,&
                            anrm, n, 1, rcondv, n,ierr )
              else
                 call stdlib_clascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, w, n, ierr )
              end if
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_cgeevx

     module subroutine stdlib_zgeevx( balanc, jobvl, jobvr, sense, n, a, lda, w, vl,ldvl, vr, ldvr, ilo, &
     !! ZGEEVX computes for an N-by-N complex nonsymmetric matrix A, the
     !! eigenvalues and, optionally, the left and/or right eigenvectors.
     !! Optionally also, it computes a balancing transformation to improve
     !! the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
     !! SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
     !! (RCONDE), and reciprocal condition numbers for the right
     !! eigenvectors (RCONDV).
     !! The right eigenvector v(j) of A satisfies
     !! A * v(j) = lambda(j) * v(j)
     !! where lambda(j) is its eigenvalue.
     !! The left eigenvector u(j) of A satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H
     !! where u(j)**H denotes the conjugate transpose of u(j).
     !! The computed eigenvectors are normalized to have Euclidean norm
     !! equal to 1 and largest component real.
     !! Balancing a matrix means permuting the rows and columns to make it
     !! more nearly upper triangular, and applying a diagonal similarity
     !! transformation D * A * D**(-1), where D is a diagonal matrix, to
     !! make its rows and columns closer in norm and the condition numbers
     !! of its eigenvalues and eigenvectors smaller.  The computed
     !! reciprocal condition numbers correspond to the balanced matrix.
     !! Permuting rows and columns will not change the condition numbers
     !! (in exact arithmetic) but diagonal scaling will.  For further
     !! explanation of balancing, see section 4.10.2_dp of the LAPACK
     !! Users' Guide.
               ihi, scale, abnrm, rconde,rcondv, work, lwork, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldvl, ldvr, lwork, n
           real(dp), intent(out) :: abnrm
           ! Array Arguments 
           real(dp), intent(out) :: rconde(*), rcondv(*), rwork(*), scale(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: vl(ldvl,*), vr(ldvr,*), w(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantvl, wantvr, wntsnb, wntsne, wntsnn, wntsnv
           character :: job, side
           integer(ilp) :: hswork, i, icond, ierr, itau, iwrk, k, lwork_trevc, maxwrk, minwrk, &
                     nout
           real(dp) :: anrm, bignum, cscale, eps, scl, smlnum
           complex(dp) :: tmp
           ! Local Arrays 
           logical(lk) :: select(1)
           real(dp) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvl = stdlib_lsame( jobvl, 'V' )
           wantvr = stdlib_lsame( jobvr, 'V' )
           wntsnn = stdlib_lsame( sense, 'N' )
           wntsne = stdlib_lsame( sense, 'E' )
           wntsnv = stdlib_lsame( sense, 'V' )
           wntsnb = stdlib_lsame( sense, 'B' )
           if( .not.( stdlib_lsame( balanc, 'N' ) .or. stdlib_lsame( balanc, 'S' ) &
                     .or.stdlib_lsame( balanc, 'P' ) .or. stdlib_lsame( balanc, 'B' ) ) ) then
              info = -1
           else if( ( .not.wantvl ) .and. ( .not.stdlib_lsame( jobvl, 'N' ) ) ) then
              info = -2
           else if( ( .not.wantvr ) .and. ( .not.stdlib_lsame( jobvr, 'N' ) ) ) then
              info = -3
           else if( .not.( wntsnn .or. wntsne .or. wntsnb .or. wntsnv ) .or.( ( wntsne .or. &
                     wntsnb ) .and. .not.( wantvl .and.wantvr ) ) ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( wantvl .and. ldvl<n ) ) then
              info = -10
           else if( ldvr<1 .or. ( wantvr .and. ldvr<n ) ) then
              info = -12
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to real
             ! workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_zhseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = n + n*stdlib_ilaenv( 1, 'ZGEHRD', ' ', n, 1, n, 0 )
                 if( wantvl ) then
                    call stdlib_ztrevc3( 'L', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, rwork, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, lwork_trevc )
                    call stdlib_zhseqr( 'S', 'V', n, 1, n, a, lda, w, vl, ldvl,work, -1, info )
                              
                 else if( wantvr ) then
                    call stdlib_ztrevc3( 'R', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, rwork, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, lwork_trevc )
                    call stdlib_zhseqr( 'S', 'V', n, 1, n, a, lda, w, vr, ldvr,work, -1, info )
                              
                 else
                    if( wntsnn ) then
                       call stdlib_zhseqr( 'E', 'N', n, 1, n, a, lda, w, vr, ldvr,work, -1, info )
                                 
                    else
                       call stdlib_zhseqr( 'S', 'N', n, 1, n, a, lda, w, vr, ldvr,work, -1, info )
                                 
                    end if
                 end if
                 hswork = int( work(1),KIND=ilp)
                 if( ( .not.wantvl ) .and. ( .not.wantvr ) ) then
                    minwrk = 2*n
                    if( .not.( wntsnn .or. wntsne ) )minwrk = max( minwrk, n*n + 2*n )
                    maxwrk = max( maxwrk, hswork )
                    if( .not.( wntsnn .or. wntsne ) )maxwrk = max( maxwrk, n*n + 2*n )
                 else
                    minwrk = 2*n
                    if( .not.( wntsnn .or. wntsne ) )minwrk = max( minwrk, n*n + 2*n )
                    maxwrk = max( maxwrk, hswork )
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'ZUNGHR',' ', n, 1, n, -&
                              1 ) )
                    if( .not.( wntsnn .or. wntsne ) )maxwrk = max( maxwrk, n*n + 2*n )
                    maxwrk = max( maxwrk, 2*n )
                 end if
                 maxwrk = max( maxwrk, minwrk )
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -20
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEEVX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' )
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           icond = 0
           anrm = stdlib_zlange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_zlascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! balance the matrix and compute abnrm
           call stdlib_zgebal( balanc, n, a, lda, ilo, ihi, scale, ierr )
           abnrm = stdlib_zlange( '1', n, n, a, lda, dum )
           if( scalea ) then
              dum( 1 ) = abnrm
              call stdlib_dlascl( 'G', 0, 0, cscale, anrm, 1, 1, dum, 1, ierr )
              abnrm = dum( 1 )
           end if
           ! reduce to upper hessenberg form
           ! (cworkspace: need 2*n, prefer n+n*nb)
           ! (rworkspace: none)
           itau = 1
           iwrk = itau + n
           call stdlib_zgehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvl ) then
              ! want left eigenvectors
              ! copy householder vectors to vl
              side = 'L'
              call stdlib_zlacpy( 'L', n, n, a, lda, vl, ldvl )
              ! generate unitary matrix in vl
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_zunghr( n, ilo, ihi, vl, ldvl, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vl
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_zhseqr( 'S', 'V', n, ilo, ihi, a, lda, w, vl, ldvl,work( iwrk ), lwork-&
                        iwrk+1, info )
              if( wantvr ) then
                 ! want left and right eigenvectors
                 ! copy schur vectors to vr
                 side = 'B'
                 call stdlib_zlacpy( 'F', n, n, vl, ldvl, vr, ldvr )
              end if
           else if( wantvr ) then
              ! want right eigenvectors
              ! copy householder vectors to vr
              side = 'R'
              call stdlib_zlacpy( 'L', n, n, a, lda, vr, ldvr )
              ! generate unitary matrix in vr
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_zunghr( n, ilo, ihi, vr, ldvr, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vr
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_zhseqr( 'S', 'V', n, ilo, ihi, a, lda, w, vr, ldvr,work( iwrk ), lwork-&
                        iwrk+1, info )
           else
              ! compute eigenvalues only
              ! if condition numbers desired, compute schur form
              if( wntsnn ) then
                 job = 'E'
              else
                 job = 'S'
              end if
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_zhseqr( job, 'N', n, ilo, ihi, a, lda, w, vr, ldvr,work( iwrk ), lwork-&
                        iwrk+1, info )
           end if
           ! if info /= 0 from stdlib_zhseqr, then quit
           if( info/=0 )go to 50
           if( wantvl .or. wantvr ) then
              ! compute left and/or right eigenvectors
              ! (cworkspace: need 2*n, prefer n + 2*n*nb)
              ! (rworkspace: need n)
              call stdlib_ztrevc3( side, 'B', select, n, a, lda, vl, ldvl, vr, ldvr,n, nout, work(&
                         iwrk ), lwork-iwrk+1,rwork, n, ierr )
           end if
           ! compute condition numbers if desired
           ! (cworkspace: need n*n+2*n unless sense = 'e')
           ! (rworkspace: need 2*n unless sense = 'e')
           if( .not.wntsnn ) then
              call stdlib_ztrsna( sense, 'A', select, n, a, lda, vl, ldvl, vr, ldvr,rconde, &
                        rcondv, n, nout, work( iwrk ), n, rwork,icond )
           end if
           if( wantvl ) then
              ! undo balancing of left eigenvectors
              call stdlib_zgebak( balanc, 'L', n, ilo, ihi, scale, n, vl, ldvl,ierr )
              ! normalize left eigenvectors and make largest component real
              do i = 1, n
                 scl = one / stdlib_dznrm2( n, vl( 1, i ), 1 )
                 call stdlib_zdscal( n, scl, vl( 1, i ), 1 )
                 do k = 1, n
                    rwork( k ) = real( vl( k, i ),KIND=dp)**2 +aimag( vl( k, i ) )**2
                 end do
                 k = stdlib_idamax( n, rwork, 1 )
                 tmp = conjg( vl( k, i ) ) / sqrt( rwork( k ) )
                 call stdlib_zscal( n, tmp, vl( 1, i ), 1 )
                 vl( k, i ) = cmplx( real( vl( k, i ),KIND=dp), zero,KIND=dp)
              end do
           end if
           if( wantvr ) then
              ! undo balancing of right eigenvectors
              call stdlib_zgebak( balanc, 'R', n, ilo, ihi, scale, n, vr, ldvr,ierr )
              ! normalize right eigenvectors and make largest component real
              do i = 1, n
                 scl = one / stdlib_dznrm2( n, vr( 1, i ), 1 )
                 call stdlib_zdscal( n, scl, vr( 1, i ), 1 )
                 do k = 1, n
                    rwork( k ) = real( vr( k, i ),KIND=dp)**2 +aimag( vr( k, i ) )**2
                 end do
                 k = stdlib_idamax( n, rwork, 1 )
                 tmp = conjg( vr( k, i ) ) / sqrt( rwork( k ) )
                 call stdlib_zscal( n, tmp, vr( 1, i ), 1 )
                 vr( k, i ) = cmplx( real( vr( k, i ),KIND=dp), zero,KIND=dp)
              end do
           end if
           ! undo scaling if necessary
           50 continue
           if( scalea ) then
              call stdlib_zlascl( 'G', 0, 0, cscale, anrm, n-info, 1, w( info+1 ),max( n-info, 1 )&
                        , ierr )
              if( info==0 ) then
                 if( ( wntsnv .or. wntsnb ) .and. icond==0 )call stdlib_dlascl( 'G', 0, 0, cscale,&
                            anrm, n, 1, rcondv, n,ierr )
              else
                 call stdlib_zlascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, w, n, ierr )
              end if
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_zgeevx

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$geevx( balanc, jobvl, jobvr, sense, n, a, lda, w, vl,ldvl, vr, ldvr, ilo, &
     !! ZGEEVX: computes for an N-by-N complex nonsymmetric matrix A, the
     !! eigenvalues and, optionally, the left and/or right eigenvectors.
     !! Optionally also, it computes a balancing transformation to improve
     !! the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
     !! SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
     !! (RCONDE), and reciprocal condition numbers for the right
     !! eigenvectors (RCONDV).
     !! The right eigenvector v(j) of A satisfies
     !! A * v(j) = lambda(j) * v(j)
     !! where lambda(j) is its eigenvalue.
     !! The left eigenvector u(j) of A satisfies
     !! u(j)**H * A = lambda(j) * u(j)**H
     !! where u(j)**H denotes the conjugate transpose of u(j).
     !! The computed eigenvectors are normalized to have Euclidean norm
     !! equal to 1 and largest component real.
     !! Balancing a matrix means permuting the rows and columns to make it
     !! more nearly upper triangular, and applying a diagonal similarity
     !! transformation D * A * D**(-1), where D is a diagonal matrix, to
     !! make its rows and columns closer in norm and the condition numbers
     !! of its eigenvalues and eigenvectors smaller.  The computed
     !! reciprocal condition numbers correspond to the balanced matrix.
     !! Permuting rows and columns will not change the condition numbers
     !! (in exact arithmetic) but diagonal scaling will.  For further
     !! explanation of balancing, see section 4.10.2_${ck}$ of the LAPACK
     !! Users' Guide.
               ihi, scale, abnrm, rconde,rcondv, work, lwork, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: balanc, jobvl, jobvr, sense
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldvl, ldvr, lwork, n
           real(${ck}$), intent(out) :: abnrm
           ! Array Arguments 
           real(${ck}$), intent(out) :: rconde(*), rcondv(*), rwork(*), scale(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: vl(ldvl,*), vr(ldvr,*), w(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, scalea, wantvl, wantvr, wntsnb, wntsne, wntsnn, wntsnv
           character :: job, side
           integer(ilp) :: hswork, i, icond, ierr, itau, iwrk, k, lwork_trevc, maxwrk, minwrk, &
                     nout
           real(${ck}$) :: anrm, bignum, cscale, eps, scl, smlnum
           complex(${ck}$) :: tmp
           ! Local Arrays 
           logical(lk) :: select(1)
           real(${ck}$) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           wantvl = stdlib_lsame( jobvl, 'V' )
           wantvr = stdlib_lsame( jobvr, 'V' )
           wntsnn = stdlib_lsame( sense, 'N' )
           wntsne = stdlib_lsame( sense, 'E' )
           wntsnv = stdlib_lsame( sense, 'V' )
           wntsnb = stdlib_lsame( sense, 'B' )
           if( .not.( stdlib_lsame( balanc, 'N' ) .or. stdlib_lsame( balanc, 'S' ) &
                     .or.stdlib_lsame( balanc, 'P' ) .or. stdlib_lsame( balanc, 'B' ) ) ) then
              info = -1
           else if( ( .not.wantvl ) .and. ( .not.stdlib_lsame( jobvl, 'N' ) ) ) then
              info = -2
           else if( ( .not.wantvr ) .and. ( .not.stdlib_lsame( jobvr, 'N' ) ) ) then
              info = -3
           else if( .not.( wntsnn .or. wntsne .or. wntsnb .or. wntsnv ) .or.( ( wntsne .or. &
                     wntsnb ) .and. .not.( wantvl .and.wantvr ) ) ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldvl<1 .or. ( wantvl .and. ldvl<n ) ) then
              info = -10
           else if( ldvr<1 .or. ( wantvr .and. ldvr<n ) ) then
              info = -12
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to real
             ! workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.
             ! hswork refers to the workspace preferred by stdlib_${ci}$hseqr, as
             ! calculated below. hswork is computed assuming ilo=1 and ihi=n,
             ! the worst case.)
           if( info==0 ) then
              if( n==0 ) then
                 minwrk = 1
                 maxwrk = 1
              else
                 maxwrk = n + n*stdlib_ilaenv( 1, 'ZGEHRD', ' ', n, 1, n, 0 )
                 if( wantvl ) then
                    call stdlib_${ci}$trevc3( 'L', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, rwork, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, lwork_trevc )
                    call stdlib_${ci}$hseqr( 'S', 'V', n, 1, n, a, lda, w, vl, ldvl,work, -1, info )
                              
                 else if( wantvr ) then
                    call stdlib_${ci}$trevc3( 'R', 'B', select, n, a, lda,vl, ldvl, vr, ldvr,n, nout, &
                              work, -1, rwork, -1, ierr )
                    lwork_trevc = int( work(1),KIND=ilp)
                    maxwrk = max( maxwrk, lwork_trevc )
                    call stdlib_${ci}$hseqr( 'S', 'V', n, 1, n, a, lda, w, vr, ldvr,work, -1, info )
                              
                 else
                    if( wntsnn ) then
                       call stdlib_${ci}$hseqr( 'E', 'N', n, 1, n, a, lda, w, vr, ldvr,work, -1, info )
                                 
                    else
                       call stdlib_${ci}$hseqr( 'S', 'N', n, 1, n, a, lda, w, vr, ldvr,work, -1, info )
                                 
                    end if
                 end if
                 hswork = int( work(1),KIND=ilp)
                 if( ( .not.wantvl ) .and. ( .not.wantvr ) ) then
                    minwrk = 2*n
                    if( .not.( wntsnn .or. wntsne ) )minwrk = max( minwrk, n*n + 2*n )
                    maxwrk = max( maxwrk, hswork )
                    if( .not.( wntsnn .or. wntsne ) )maxwrk = max( maxwrk, n*n + 2*n )
                 else
                    minwrk = 2*n
                    if( .not.( wntsnn .or. wntsne ) )minwrk = max( minwrk, n*n + 2*n )
                    maxwrk = max( maxwrk, hswork )
                    maxwrk = max( maxwrk, n + ( n - 1 )*stdlib_ilaenv( 1, 'ZUNGHR',' ', n, 1, n, -&
                              1 ) )
                    if( .not.( wntsnn .or. wntsne ) )maxwrk = max( maxwrk, n*n + 2*n )
                    maxwrk = max( maxwrk, 2*n )
                 end if
                 maxwrk = max( maxwrk, minwrk )
              end if
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -20
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEEVX', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_${c2ri(ci)}$lamch( 'P' )
           smlnum = stdlib_${c2ri(ci)}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${c2ri(ci)}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           icond = 0
           anrm = stdlib_${ci}$lange( 'M', n, n, a, lda, dum )
           scalea = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              scalea = .true.
              cscale = smlnum
           else if( anrm>bignum ) then
              scalea = .true.
              cscale = bignum
           end if
           if( scalea )call stdlib_${ci}$lascl( 'G', 0, 0, anrm, cscale, n, n, a, lda, ierr )
           ! balance the matrix and compute abnrm
           call stdlib_${ci}$gebal( balanc, n, a, lda, ilo, ihi, scale, ierr )
           abnrm = stdlib_${ci}$lange( '1', n, n, a, lda, dum )
           if( scalea ) then
              dum( 1 ) = abnrm
              call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, cscale, anrm, 1, 1, dum, 1, ierr )
              abnrm = dum( 1 )
           end if
           ! reduce to upper hessenberg form
           ! (cworkspace: need 2*n, prefer n+n*nb)
           ! (rworkspace: none)
           itau = 1
           iwrk = itau + n
           call stdlib_${ci}$gehrd( n, ilo, ihi, a, lda, work( itau ), work( iwrk ),lwork-iwrk+1, ierr &
                     )
           if( wantvl ) then
              ! want left eigenvectors
              ! copy householder vectors to vl
              side = 'L'
              call stdlib_${ci}$lacpy( 'L', n, n, a, lda, vl, ldvl )
              ! generate unitary matrix in vl
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_${ci}$unghr( n, ilo, ihi, vl, ldvl, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vl
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_${ci}$hseqr( 'S', 'V', n, ilo, ihi, a, lda, w, vl, ldvl,work( iwrk ), lwork-&
                        iwrk+1, info )
              if( wantvr ) then
                 ! want left and right eigenvectors
                 ! copy schur vectors to vr
                 side = 'B'
                 call stdlib_${ci}$lacpy( 'F', n, n, vl, ldvl, vr, ldvr )
              end if
           else if( wantvr ) then
              ! want right eigenvectors
              ! copy householder vectors to vr
              side = 'R'
              call stdlib_${ci}$lacpy( 'L', n, n, a, lda, vr, ldvr )
              ! generate unitary matrix in vr
              ! (cworkspace: need 2*n-1, prefer n+(n-1)*nb)
              ! (rworkspace: none)
              call stdlib_${ci}$unghr( n, ilo, ihi, vr, ldvr, work( itau ), work( iwrk ),lwork-iwrk+1, &
                        ierr )
              ! perform qr iteration, accumulating schur vectors in vr
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_${ci}$hseqr( 'S', 'V', n, ilo, ihi, a, lda, w, vr, ldvr,work( iwrk ), lwork-&
                        iwrk+1, info )
           else
              ! compute eigenvalues only
              ! if condition numbers desired, compute schur form
              if( wntsnn ) then
                 job = 'E'
              else
                 job = 'S'
              end if
              ! (cworkspace: need 1, prefer hswork (see comments) )
              ! (rworkspace: none)
              iwrk = itau
              call stdlib_${ci}$hseqr( job, 'N', n, ilo, ihi, a, lda, w, vr, ldvr,work( iwrk ), lwork-&
                        iwrk+1, info )
           end if
           ! if info /= 0 from stdlib_${ci}$hseqr, then quit
           if( info/=0 )go to 50
           if( wantvl .or. wantvr ) then
              ! compute left and/or right eigenvectors
              ! (cworkspace: need 2*n, prefer n + 2*n*nb)
              ! (rworkspace: need n)
              call stdlib_${ci}$trevc3( side, 'B', select, n, a, lda, vl, ldvl, vr, ldvr,n, nout, work(&
                         iwrk ), lwork-iwrk+1,rwork, n, ierr )
           end if
           ! compute condition numbers if desired
           ! (cworkspace: need n*n+2*n unless sense = 'e')
           ! (rworkspace: need 2*n unless sense = 'e')
           if( .not.wntsnn ) then
              call stdlib_${ci}$trsna( sense, 'A', select, n, a, lda, vl, ldvl, vr, ldvr,rconde, &
                        rcondv, n, nout, work( iwrk ), n, rwork,icond )
           end if
           if( wantvl ) then
              ! undo balancing of left eigenvectors
              call stdlib_${ci}$gebak( balanc, 'L', n, ilo, ihi, scale, n, vl, ldvl,ierr )
              ! normalize left eigenvectors and make largest component real
              do i = 1, n
                 scl = one / stdlib_${c2ri(ci)}$znrm2( n, vl( 1, i ), 1 )
                 call stdlib_${ci}$dscal( n, scl, vl( 1, i ), 1 )
                 do k = 1, n
                    rwork( k ) = real( vl( k, i ),KIND=${ck}$)**2 +aimag( vl( k, i ) )**2
                 end do
                 k = stdlib_i${c2ri(ci)}$amax( n, rwork, 1 )
                 tmp = conjg( vl( k, i ) ) / sqrt( rwork( k ) )
                 call stdlib_${ci}$scal( n, tmp, vl( 1, i ), 1 )
                 vl( k, i ) = cmplx( real( vl( k, i ),KIND=${ck}$), zero,KIND=${ck}$)
              end do
           end if
           if( wantvr ) then
              ! undo balancing of right eigenvectors
              call stdlib_${ci}$gebak( balanc, 'R', n, ilo, ihi, scale, n, vr, ldvr,ierr )
              ! normalize right eigenvectors and make largest component real
              do i = 1, n
                 scl = one / stdlib_${c2ri(ci)}$znrm2( n, vr( 1, i ), 1 )
                 call stdlib_${ci}$dscal( n, scl, vr( 1, i ), 1 )
                 do k = 1, n
                    rwork( k ) = real( vr( k, i ),KIND=${ck}$)**2 +aimag( vr( k, i ) )**2
                 end do
                 k = stdlib_i${c2ri(ci)}$amax( n, rwork, 1 )
                 tmp = conjg( vr( k, i ) ) / sqrt( rwork( k ) )
                 call stdlib_${ci}$scal( n, tmp, vr( 1, i ), 1 )
                 vr( k, i ) = cmplx( real( vr( k, i ),KIND=${ck}$), zero,KIND=${ck}$)
              end do
           end if
           ! undo scaling if necessary
           50 continue
           if( scalea ) then
              call stdlib_${ci}$lascl( 'G', 0, 0, cscale, anrm, n-info, 1, w( info+1 ),max( n-info, 1 )&
                        , ierr )
              if( info==0 ) then
                 if( ( wntsnv .or. wntsnb ) .and. icond==0 )call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, cscale,&
                            anrm, n, 1, rcondv, n,ierr )
              else
                 call stdlib_${ci}$lascl( 'G', 0, 0, cscale, anrm, ilo-1, 1, w, n, ierr )
              end if
           end if
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_${ci}$geevx

#:endif
#:endfor



     module pure subroutine stdlib_cunmhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, lwork, &
     !! CUNMHR overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! IHI-ILO elementary reflectors, as returned by CGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(in) :: ihi, ilo, lda, ldc, lwork, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, lquery
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, nh, ni, nq, nw
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           left = stdlib_lsame( side, 'L' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'C' ) )&
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 .or. ilo>max( 1, nq ) ) then
              info = -5
           else if( ihi<min( ilo, nq ) .or. ihi>nq ) then
              info = -6
           else if( lda<max( 1, nq ) ) then
              info = -8
           else if( ldc<max( 1, m ) ) then
              info = -11
           else if( lwork<nw .and. .not.lquery ) then
              info = -13
           end if
           if( info==0 ) then
              if( left ) then
                 nb = stdlib_ilaenv( 1, 'CUNMQR', side // trans, nh, n, nh, -1 )
              else
                 nb = stdlib_ilaenv( 1, 'CUNMQR', side // trans, m, nh, nh, -1 )
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNMHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. nh==0 ) then
              work( 1 ) = 1
              return
           end if
           if( left ) then
              mi = nh
              ni = n
              i1 = ilo + 1
              i2 = 1
           else
              mi = m
              ni = nh
              i1 = 1
              i2 = ilo + 1
           end if
           call stdlib_cunmqr( side, trans, mi, ni, nh, a( ilo+1, ilo ), lda,tau( ilo ), c( i1, &
                     i2 ), ldc, work, lwork, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cunmhr

     module pure subroutine stdlib_zunmhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, lwork, &
     !! ZUNMHR overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! IHI-ILO elementary reflectors, as returned by ZGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(in) :: ihi, ilo, lda, ldc, lwork, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(dp), intent(in) :: tau(*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, lquery
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, nh, ni, nq, nw
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           left = stdlib_lsame( side, 'L' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'C' ) )&
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 .or. ilo>max( 1, nq ) ) then
              info = -5
           else if( ihi<min( ilo, nq ) .or. ihi>nq ) then
              info = -6
           else if( lda<max( 1, nq ) ) then
              info = -8
           else if( ldc<max( 1, m ) ) then
              info = -11
           else if( lwork<nw .and. .not.lquery ) then
              info = -13
           end if
           if( info==0 ) then
              if( left ) then
                 nb = stdlib_ilaenv( 1, 'ZUNMQR', side // trans, nh, n, nh, -1 )
              else
                 nb = stdlib_ilaenv( 1, 'ZUNMQR', side // trans, m, nh, nh, -1 )
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZUNMHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. nh==0 ) then
              work( 1 ) = 1
              return
           end if
           if( left ) then
              mi = nh
              ni = n
              i1 = ilo + 1
              i2 = 1
           else
              mi = m
              ni = nh
              i1 = 1
              i2 = ilo + 1
           end if
           call stdlib_zunmqr( side, trans, mi, ni, nh, a( ilo+1, ilo ), lda,tau( ilo ), c( i1, &
                     i2 ), ldc, work, lwork, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zunmhr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$unmhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, lwork, &
     !! ZUNMHR: overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! IHI-ILO elementary reflectors, as returned by ZGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(in) :: ihi, ilo, lda, ldc, lwork, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*), c(ldc,*)
           complex(${ck}$), intent(in) :: tau(*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, lquery
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, nh, ni, nq, nw
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           left = stdlib_lsame( side, 'L' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'C' ) )&
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 .or. ilo>max( 1, nq ) ) then
              info = -5
           else if( ihi<min( ilo, nq ) .or. ihi>nq ) then
              info = -6
           else if( lda<max( 1, nq ) ) then
              info = -8
           else if( ldc<max( 1, m ) ) then
              info = -11
           else if( lwork<nw .and. .not.lquery ) then
              info = -13
           end if
           if( info==0 ) then
              if( left ) then
                 nb = stdlib_ilaenv( 1, 'ZUNMQR', side // trans, nh, n, nh, -1 )
              else
                 nb = stdlib_ilaenv( 1, 'ZUNMQR', side // trans, m, nh, nh, -1 )
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZUNMHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. nh==0 ) then
              work( 1 ) = 1
              return
           end if
           if( left ) then
              mi = nh
              ni = n
              i1 = ilo + 1
              i2 = 1
           else
              mi = m
              ni = nh
              i1 = 1
              i2 = ilo + 1
           end if
           call stdlib_${ci}$unmqr( side, trans, mi, ni, nh, a( ilo+1, ilo ), lda,tau( ilo ), c( i1, &
                     i2 ), ldc, work, lwork, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$unmhr

#:endif
#:endfor





     module subroutine stdlib_strsen( job, compq, select, n, t, ldt, q, ldq, wr, wi,m, s, sep, work, &
     !! STRSEN reorders the real Schur factorization of a real matrix
     !! A = Q*T*Q**T, so that a selected cluster of eigenvalues appears in
     !! the leading diagonal blocks of the upper quasi-triangular matrix T,
     !! and the leading columns of Q form an orthonormal basis of the
     !! corresponding right invariant subspace.
     !! Optionally the routine computes the reciprocal condition numbers of
     !! the cluster of eigenvalues and/or the invariant subspace.
     !! T must be in Schur canonical form (as returned by SHSEQR), that is,
     !! block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
     !! 2-by-2 diagonal block has its diagonal elements equal and its
     !! off-diagonal elements of opposite sign.
               lwork, iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldq, ldt, liwork, lwork, n
           real(sp), intent(out) :: s, sep
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(inout) :: q(ldq,*), t(ldt,*)
           real(sp), intent(out) :: wi(*), work(*), wr(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, pair, swap, wantbh, wantq, wants, wantsp
           integer(ilp) :: ierr, k, kase, kk, ks, liwmin, lwmin, n1, n2, nn
           real(sp) :: est, rnorm, scale
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantsp = stdlib_lsame( job, 'V' ) .or. wantbh
           wantq = stdlib_lsame( compq, 'V' )
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.wants .and. .not.wantsp )then
              info = -1
           else if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -8
           else
              ! set m to the dimension of the specified invariant subspace,
              ! and test lwork and liwork.
              m = 0
              pair = .false.
              do k = 1, n
                 if( pair ) then
                    pair = .false.
                 else
                    if( k<n ) then
                       if( t( k+1, k )==zero ) then
                          if( select( k ) )m = m + 1
                       else
                          pair = .true.
                          if( select( k ) .or. select( k+1 ) )m = m + 2
                       end if
                    else
                       if( select( n ) )m = m + 1
                    end if
                 end if
              end do
              n1 = m
              n2 = n - m
              nn = n1*n2
              if(  wantsp ) then
                 lwmin = max( 1, 2*nn )
                 liwmin = max( 1, nn )
              else if( stdlib_lsame( job, 'N' ) ) then
                 lwmin = max( 1, n )
                 liwmin = 1
              else if( stdlib_lsame( job, 'E' ) ) then
                 lwmin = max( 1, nn )
                 liwmin = 1
              end if
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -15
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -17
              end if
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STRSEN', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( m==n .or. m==0 ) then
              if( wants )s = one
              if( wantsp )sep = stdlib_slange( '1', n, n, t, ldt, work )
              go to 40
           end if
           ! collect the selected blocks at the top-left corner of t.
           ks = 0
           pair = .false.
           loop_20: do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 swap = select( k )
                 if( k<n ) then
                    if( t( k+1, k )/=zero ) then
                       pair = .true.
                       swap = swap .or. select( k+1 )
                    end if
                 end if
                 if( swap ) then
                    ks = ks + 1
                    ! swap the k-th block to position ks.
                    ierr = 0
                    kk = k
                    if( k/=ks )call stdlib_strexc( compq, n, t, ldt, q, ldq, kk, ks, work,ierr )
                              
                    if( ierr==1 .or. ierr==2 ) then
                       ! blocks too close to swap: exit.
                       info = 1
                       if( wants )s = zero
                       if( wantsp )sep = zero
                       go to 40
                    end if
                    if( pair )ks = ks + 1
                 end if
              end if
           end do loop_20
           if( wants ) then
              ! solve sylvester equation for r:
                 ! t11*r - r*t22 = scale*t12
              call stdlib_slacpy( 'F', n1, n2, t( 1, n1+1 ), ldt, work, n1 )
              call stdlib_strsyl( 'N', 'N', -1, n1, n2, t, ldt, t( n1+1, n1+1 ),ldt, work, n1, &
                        scale, ierr )
              ! estimate the reciprocal of the condition number of the cluster
              ! of eigenvalues.
              rnorm = stdlib_slange( 'F', n1, n2, work, n1, work )
              if( rnorm==zero ) then
                 s = one
              else
                 s = scale / ( sqrt( scale*scale / rnorm+rnorm )*sqrt( rnorm ) )
              end if
           end if
           if( wantsp ) then
              ! estimate sep(t11,t22).
              est = zero
              kase = 0
              30 continue
              call stdlib_slacn2( nn, work( nn+1 ), work, iwork, est, kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! solve  t11*r - r*t22 = scale*x.
                    call stdlib_strsyl( 'N', 'N', -1, n1, n2, t, ldt,t( n1+1, n1+1 ), ldt, work, &
                              n1, scale,ierr )
                 else
                    ! solve t11**t*r - r*t22**t = scale*x.
                    call stdlib_strsyl( 'T', 'T', -1, n1, n2, t, ldt,t( n1+1, n1+1 ), ldt, work, &
                              n1, scale,ierr )
                 end if
                 go to 30
              end if
              sep = scale / est
           end if
           40 continue
           ! store the output eigenvalues in wr and wi.
           do k = 1, n
              wr( k ) = t( k, k )
              wi( k ) = zero
           end do
           do k = 1, n - 1
              if( t( k+1, k )/=zero ) then
                 wi( k ) = sqrt( abs( t( k, k+1 ) ) )*sqrt( abs( t( k+1, k ) ) )
                 wi( k+1 ) = -wi( k )
              end if
           end do
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_strsen

     module subroutine stdlib_dtrsen( job, compq, select, n, t, ldt, q, ldq, wr, wi,m, s, sep, work, &
     !! DTRSEN reorders the real Schur factorization of a real matrix
     !! A = Q*T*Q**T, so that a selected cluster of eigenvalues appears in
     !! the leading diagonal blocks of the upper quasi-triangular matrix T,
     !! and the leading columns of Q form an orthonormal basis of the
     !! corresponding right invariant subspace.
     !! Optionally the routine computes the reciprocal condition numbers of
     !! the cluster of eigenvalues and/or the invariant subspace.
     !! T must be in Schur canonical form (as returned by DHSEQR), that is,
     !! block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
     !! 2-by-2 diagonal block has its diagonal elements equal and its
     !! off-diagonal elements of opposite sign.
               lwork, iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldq, ldt, liwork, lwork, n
           real(dp), intent(out) :: s, sep
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(inout) :: q(ldq,*), t(ldt,*)
           real(dp), intent(out) :: wi(*), work(*), wr(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, pair, swap, wantbh, wantq, wants, wantsp
           integer(ilp) :: ierr, k, kase, kk, ks, liwmin, lwmin, n1, n2, nn
           real(dp) :: est, rnorm, scale
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantsp = stdlib_lsame( job, 'V' ) .or. wantbh
           wantq = stdlib_lsame( compq, 'V' )
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.wants .and. .not.wantsp )then
              info = -1
           else if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -8
           else
              ! set m to the dimension of the specified invariant subspace,
              ! and test lwork and liwork.
              m = 0
              pair = .false.
              do k = 1, n
                 if( pair ) then
                    pair = .false.
                 else
                    if( k<n ) then
                       if( t( k+1, k )==zero ) then
                          if( select( k ) )m = m + 1
                       else
                          pair = .true.
                          if( select( k ) .or. select( k+1 ) )m = m + 2
                       end if
                    else
                       if( select( n ) )m = m + 1
                    end if
                 end if
              end do
              n1 = m
              n2 = n - m
              nn = n1*n2
              if( wantsp ) then
                 lwmin = max( 1, 2*nn )
                 liwmin = max( 1, nn )
              else if( stdlib_lsame( job, 'N' ) ) then
                 lwmin = max( 1, n )
                 liwmin = 1
              else if( stdlib_lsame( job, 'E' ) ) then
                 lwmin = max( 1, nn )
                 liwmin = 1
              end if
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -15
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -17
              end if
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTRSEN', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( m==n .or. m==0 ) then
              if( wants )s = one
              if( wantsp )sep = stdlib_dlange( '1', n, n, t, ldt, work )
              go to 40
           end if
           ! collect the selected blocks at the top-left corner of t.
           ks = 0
           pair = .false.
           loop_20: do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 swap = select( k )
                 if( k<n ) then
                    if( t( k+1, k )/=zero ) then
                       pair = .true.
                       swap = swap .or. select( k+1 )
                    end if
                 end if
                 if( swap ) then
                    ks = ks + 1
                    ! swap the k-th block to position ks.
                    ierr = 0
                    kk = k
                    if( k/=ks )call stdlib_dtrexc( compq, n, t, ldt, q, ldq, kk, ks, work,ierr )
                              
                    if( ierr==1 .or. ierr==2 ) then
                       ! blocks too close to swap: exit.
                       info = 1
                       if( wants )s = zero
                       if( wantsp )sep = zero
                       go to 40
                    end if
                    if( pair )ks = ks + 1
                 end if
              end if
           end do loop_20
           if( wants ) then
              ! solve sylvester equation for r:
                 ! t11*r - r*t22 = scale*t12
              call stdlib_dlacpy( 'F', n1, n2, t( 1, n1+1 ), ldt, work, n1 )
              call stdlib_dtrsyl( 'N', 'N', -1, n1, n2, t, ldt, t( n1+1, n1+1 ),ldt, work, n1, &
                        scale, ierr )
              ! estimate the reciprocal of the condition number of the cluster
              ! of eigenvalues.
              rnorm = stdlib_dlange( 'F', n1, n2, work, n1, work )
              if( rnorm==zero ) then
                 s = one
              else
                 s = scale / ( sqrt( scale*scale / rnorm+rnorm )*sqrt( rnorm ) )
              end if
           end if
           if( wantsp ) then
              ! estimate sep(t11,t22).
              est = zero
              kase = 0
              30 continue
              call stdlib_dlacn2( nn, work( nn+1 ), work, iwork, est, kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! solve  t11*r - r*t22 = scale*x.
                    call stdlib_dtrsyl( 'N', 'N', -1, n1, n2, t, ldt,t( n1+1, n1+1 ), ldt, work, &
                              n1, scale,ierr )
                 else
                    ! solve t11**t*r - r*t22**t = scale*x.
                    call stdlib_dtrsyl( 'T', 'T', -1, n1, n2, t, ldt,t( n1+1, n1+1 ), ldt, work, &
                              n1, scale,ierr )
                 end if
                 go to 30
              end if
              sep = scale / est
           end if
           40 continue
           ! store the output eigenvalues in wr and wi.
           do k = 1, n
              wr( k ) = t( k, k )
              wi( k ) = zero
           end do
           do k = 1, n - 1
              if( t( k+1, k )/=zero ) then
                 wi( k ) = sqrt( abs( t( k, k+1 ) ) )*sqrt( abs( t( k+1, k ) ) )
                 wi( k+1 ) = -wi( k )
              end if
           end do
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_dtrsen

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$trsen( job, compq, select, n, t, ldt, q, ldq, wr, wi,m, s, sep, work, &
     !! DTRSEN: reorders the real Schur factorization of a real matrix
     !! A = Q*T*Q**T, so that a selected cluster of eigenvalues appears in
     !! the leading diagonal blocks of the upper quasi-triangular matrix T,
     !! and the leading columns of Q form an orthonormal basis of the
     !! corresponding right invariant subspace.
     !! Optionally the routine computes the reciprocal condition numbers of
     !! the cluster of eigenvalues and/or the invariant subspace.
     !! T must be in Schur canonical form (as returned by DHSEQR), that is,
     !! block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
     !! 2-by-2 diagonal block has its diagonal elements equal and its
     !! off-diagonal elements of opposite sign.
               lwork, iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldq, ldt, liwork, lwork, n
           real(${rk}$), intent(out) :: s, sep
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: q(ldq,*), t(ldt,*)
           real(${rk}$), intent(out) :: wi(*), work(*), wr(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, pair, swap, wantbh, wantq, wants, wantsp
           integer(ilp) :: ierr, k, kase, kk, ks, liwmin, lwmin, n1, n2, nn
           real(${rk}$) :: est, rnorm, scale
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantsp = stdlib_lsame( job, 'V' ) .or. wantbh
           wantq = stdlib_lsame( compq, 'V' )
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.wants .and. .not.wantsp )then
              info = -1
           else if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -8
           else
              ! set m to the dimension of the specified invariant subspace,
              ! and test lwork and liwork.
              m = 0
              pair = .false.
              do k = 1, n
                 if( pair ) then
                    pair = .false.
                 else
                    if( k<n ) then
                       if( t( k+1, k )==zero ) then
                          if( select( k ) )m = m + 1
                       else
                          pair = .true.
                          if( select( k ) .or. select( k+1 ) )m = m + 2
                       end if
                    else
                       if( select( n ) )m = m + 1
                    end if
                 end if
              end do
              n1 = m
              n2 = n - m
              nn = n1*n2
              if( wantsp ) then
                 lwmin = max( 1, 2*nn )
                 liwmin = max( 1, nn )
              else if( stdlib_lsame( job, 'N' ) ) then
                 lwmin = max( 1, n )
                 liwmin = 1
              else if( stdlib_lsame( job, 'E' ) ) then
                 lwmin = max( 1, nn )
                 liwmin = 1
              end if
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -15
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -17
              end if
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTRSEN', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( m==n .or. m==0 ) then
              if( wants )s = one
              if( wantsp )sep = stdlib_${ri}$lange( '1', n, n, t, ldt, work )
              go to 40
           end if
           ! collect the selected blocks at the top-left corner of t.
           ks = 0
           pair = .false.
           loop_20: do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 swap = select( k )
                 if( k<n ) then
                    if( t( k+1, k )/=zero ) then
                       pair = .true.
                       swap = swap .or. select( k+1 )
                    end if
                 end if
                 if( swap ) then
                    ks = ks + 1
                    ! swap the k-th block to position ks.
                    ierr = 0
                    kk = k
                    if( k/=ks )call stdlib_${ri}$trexc( compq, n, t, ldt, q, ldq, kk, ks, work,ierr )
                              
                    if( ierr==1 .or. ierr==2 ) then
                       ! blocks too close to swap: exit.
                       info = 1
                       if( wants )s = zero
                       if( wantsp )sep = zero
                       go to 40
                    end if
                    if( pair )ks = ks + 1
                 end if
              end if
           end do loop_20
           if( wants ) then
              ! solve sylvester equation for r:
                 ! t11*r - r*t22 = scale*t12
              call stdlib_${ri}$lacpy( 'F', n1, n2, t( 1, n1+1 ), ldt, work, n1 )
              call stdlib_${ri}$trsyl( 'N', 'N', -1, n1, n2, t, ldt, t( n1+1, n1+1 ),ldt, work, n1, &
                        scale, ierr )
              ! estimate the reciprocal of the condition number of the cluster
              ! of eigenvalues.
              rnorm = stdlib_${ri}$lange( 'F', n1, n2, work, n1, work )
              if( rnorm==zero ) then
                 s = one
              else
                 s = scale / ( sqrt( scale*scale / rnorm+rnorm )*sqrt( rnorm ) )
              end if
           end if
           if( wantsp ) then
              ! estimate sep(t11,t22).
              est = zero
              kase = 0
              30 continue
              call stdlib_${ri}$lacn2( nn, work( nn+1 ), work, iwork, est, kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! solve  t11*r - r*t22 = scale*x.
                    call stdlib_${ri}$trsyl( 'N', 'N', -1, n1, n2, t, ldt,t( n1+1, n1+1 ), ldt, work, &
                              n1, scale,ierr )
                 else
                    ! solve t11**t*r - r*t22**t = scale*x.
                    call stdlib_${ri}$trsyl( 'T', 'T', -1, n1, n2, t, ldt,t( n1+1, n1+1 ), ldt, work, &
                              n1, scale,ierr )
                 end if
                 go to 30
              end if
              sep = scale / est
           end if
           40 continue
           ! store the output eigenvalues in wr and wi.
           do k = 1, n
              wr( k ) = t( k, k )
              wi( k ) = zero
           end do
           do k = 1, n - 1
              if( t( k+1, k )/=zero ) then
                 wi( k ) = sqrt( abs( t( k, k+1 ) ) )*sqrt( abs( t( k+1, k ) ) )
                 wi( k+1 ) = -wi( k )
              end if
           end do
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ri}$trsen

#:endif
#:endfor

     module subroutine stdlib_ctrsen( job, compq, select, n, t, ldt, q, ldq, w, m, s,sep, work, lwork, &
     !! CTRSEN reorders the Schur factorization of a complex matrix
     !! A = Q*T*Q**H, so that a selected cluster of eigenvalues appears in
     !! the leading positions on the diagonal of the upper triangular matrix
     !! T, and the leading columns of Q form an orthonormal basis of the
     !! corresponding right invariant subspace.
     !! Optionally the routine computes the reciprocal condition numbers of
     !! the cluster of eigenvalues and/or the invariant subspace.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldq, ldt, lwork, n
           real(sp), intent(out) :: s, sep
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           complex(sp), intent(inout) :: q(ldq,*), t(ldt,*)
           complex(sp), intent(out) :: w(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, wantbh, wantq, wants, wantsp
           integer(ilp) :: ierr, k, kase, ks, lwmin, n1, n2, nn
           real(sp) :: est, rnorm, scale
           ! Local Arrays 
           integer(ilp) :: isave(3)
           real(sp) :: rwork(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantsp = stdlib_lsame( job, 'V' ) .or. wantbh
           wantq = stdlib_lsame( compq, 'V' )
           ! set m to the number of selected eigenvalues.
           m = 0
           do k = 1, n
              if( select( k ) )m = m + 1
           end do
           n1 = m
           n2 = n - m
           nn = n1*n2
           info = 0
           lquery = ( lwork==-1 )
           if( wantsp ) then
              lwmin = max( 1, 2*nn )
           else if( stdlib_lsame( job, 'N' ) ) then
              lwmin = 1
           else if( stdlib_lsame( job, 'E' ) ) then
              lwmin = max( 1, nn )
           end if
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.wants .and. .not.wantsp )then
              info = -1
           else if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -8
           else if( lwork<lwmin .and. .not.lquery ) then
              info = -14
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTRSEN', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==n .or. m==0 ) then
              if( wants )s = one
              if( wantsp )sep = stdlib_clange( '1', n, n, t, ldt, rwork )
              go to 40
           end if
           ! collect the selected eigenvalues at the top left corner of t.
           ks = 0
           do k = 1, n
              if( select( k ) ) then
                 ks = ks + 1
                 ! swap the k-th eigenvalue to position ks.
                 if( k/=ks )call stdlib_ctrexc( compq, n, t, ldt, q, ldq, k, ks, ierr )
              end if
           end do
           if( wants ) then
              ! solve the sylvester equation for r:
                 ! t11*r - r*t22 = scale*t12
              call stdlib_clacpy( 'F', n1, n2, t( 1, n1+1 ), ldt, work, n1 )
              call stdlib_ctrsyl( 'N', 'N', -1, n1, n2, t, ldt, t( n1+1, n1+1 ),ldt, work, n1, &
                        scale, ierr )
              ! estimate the reciprocal of the condition number of the cluster
              ! of eigenvalues.
              rnorm = stdlib_clange( 'F', n1, n2, work, n1, rwork )
              if( rnorm==zero ) then
                 s = one
              else
                 s = scale / ( sqrt( scale*scale / rnorm+rnorm )*sqrt( rnorm ) )
              end if
           end if
           if( wantsp ) then
              ! estimate sep(t11,t22).
              est = zero
              kase = 0
              30 continue
              call stdlib_clacn2( nn, work( nn+1 ), work, est, kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! solve t11*r - r*t22 = scale*x.
                    call stdlib_ctrsyl( 'N', 'N', -1, n1, n2, t, ldt,t( n1+1, n1+1 ), ldt, work, &
                              n1, scale,ierr )
                 else
                    ! solve t11**h*r - r*t22**h = scale*x.
                    call stdlib_ctrsyl( 'C', 'C', -1, n1, n2, t, ldt,t( n1+1, n1+1 ), ldt, work, &
                              n1, scale,ierr )
                 end if
                 go to 30
              end if
              sep = scale / est
           end if
           40 continue
           ! copy reordered eigenvalues to w.
           do k = 1, n
              w( k ) = t( k, k )
           end do
           work( 1 ) = lwmin
           return
     end subroutine stdlib_ctrsen

     module subroutine stdlib_ztrsen( job, compq, select, n, t, ldt, q, ldq, w, m, s,sep, work, lwork, &
     !! ZTRSEN reorders the Schur factorization of a complex matrix
     !! A = Q*T*Q**H, so that a selected cluster of eigenvalues appears in
     !! the leading positions on the diagonal of the upper triangular matrix
     !! T, and the leading columns of Q form an orthonormal basis of the
     !! corresponding right invariant subspace.
     !! Optionally the routine computes the reciprocal condition numbers of
     !! the cluster of eigenvalues and/or the invariant subspace.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldq, ldt, lwork, n
           real(dp), intent(out) :: s, sep
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           complex(dp), intent(inout) :: q(ldq,*), t(ldt,*)
           complex(dp), intent(out) :: w(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, wantbh, wantq, wants, wantsp
           integer(ilp) :: ierr, k, kase, ks, lwmin, n1, n2, nn
           real(dp) :: est, rnorm, scale
           ! Local Arrays 
           integer(ilp) :: isave(3)
           real(dp) :: rwork(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantsp = stdlib_lsame( job, 'V' ) .or. wantbh
           wantq = stdlib_lsame( compq, 'V' )
           ! set m to the number of selected eigenvalues.
           m = 0
           do k = 1, n
              if( select( k ) )m = m + 1
           end do
           n1 = m
           n2 = n - m
           nn = n1*n2
           info = 0
           lquery = ( lwork==-1 )
           if( wantsp ) then
              lwmin = max( 1, 2*nn )
           else if( stdlib_lsame( job, 'N' ) ) then
              lwmin = 1
           else if( stdlib_lsame( job, 'E' ) ) then
              lwmin = max( 1, nn )
           end if
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.wants .and. .not.wantsp )then
              info = -1
           else if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -8
           else if( lwork<lwmin .and. .not.lquery ) then
              info = -14
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTRSEN', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==n .or. m==0 ) then
              if( wants )s = one
              if( wantsp )sep = stdlib_zlange( '1', n, n, t, ldt, rwork )
              go to 40
           end if
           ! collect the selected eigenvalues at the top left corner of t.
           ks = 0
           do k = 1, n
              if( select( k ) ) then
                 ks = ks + 1
                 ! swap the k-th eigenvalue to position ks.
                 if( k/=ks )call stdlib_ztrexc( compq, n, t, ldt, q, ldq, k, ks, ierr )
              end if
           end do
           if( wants ) then
              ! solve the sylvester equation for r:
                 ! t11*r - r*t22 = scale*t12
              call stdlib_zlacpy( 'F', n1, n2, t( 1, n1+1 ), ldt, work, n1 )
              call stdlib_ztrsyl( 'N', 'N', -1, n1, n2, t, ldt, t( n1+1, n1+1 ),ldt, work, n1, &
                        scale, ierr )
              ! estimate the reciprocal of the condition number of the cluster
              ! of eigenvalues.
              rnorm = stdlib_zlange( 'F', n1, n2, work, n1, rwork )
              if( rnorm==zero ) then
                 s = one
              else
                 s = scale / ( sqrt( scale*scale / rnorm+rnorm )*sqrt( rnorm ) )
              end if
           end if
           if( wantsp ) then
              ! estimate sep(t11,t22).
              est = zero
              kase = 0
              30 continue
              call stdlib_zlacn2( nn, work( nn+1 ), work, est, kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! solve t11*r - r*t22 = scale*x.
                    call stdlib_ztrsyl( 'N', 'N', -1, n1, n2, t, ldt,t( n1+1, n1+1 ), ldt, work, &
                              n1, scale,ierr )
                 else
                    ! solve t11**h*r - r*t22**h = scale*x.
                    call stdlib_ztrsyl( 'C', 'C', -1, n1, n2, t, ldt,t( n1+1, n1+1 ), ldt, work, &
                              n1, scale,ierr )
                 end if
                 go to 30
              end if
              sep = scale / est
           end if
           40 continue
           ! copy reordered eigenvalues to w.
           do k = 1, n
              w( k ) = t( k, k )
           end do
           work( 1 ) = lwmin
           return
     end subroutine stdlib_ztrsen

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$trsen( job, compq, select, n, t, ldt, q, ldq, w, m, s,sep, work, lwork, &
     !! ZTRSEN: reorders the Schur factorization of a complex matrix
     !! A = Q*T*Q**H, so that a selected cluster of eigenvalues appears in
     !! the leading positions on the diagonal of the upper triangular matrix
     !! T, and the leading columns of Q form an orthonormal basis of the
     !! corresponding right invariant subspace.
     !! Optionally the routine computes the reciprocal condition numbers of
     !! the cluster of eigenvalues and/or the invariant subspace.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldq, ldt, lwork, n
           real(${ck}$), intent(out) :: s, sep
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           complex(${ck}$), intent(inout) :: q(ldq,*), t(ldt,*)
           complex(${ck}$), intent(out) :: w(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, wantbh, wantq, wants, wantsp
           integer(ilp) :: ierr, k, kase, ks, lwmin, n1, n2, nn
           real(${ck}$) :: est, rnorm, scale
           ! Local Arrays 
           integer(ilp) :: isave(3)
           real(${ck}$) :: rwork(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantsp = stdlib_lsame( job, 'V' ) .or. wantbh
           wantq = stdlib_lsame( compq, 'V' )
           ! set m to the number of selected eigenvalues.
           m = 0
           do k = 1, n
              if( select( k ) )m = m + 1
           end do
           n1 = m
           n2 = n - m
           nn = n1*n2
           info = 0
           lquery = ( lwork==-1 )
           if( wantsp ) then
              lwmin = max( 1, 2*nn )
           else if( stdlib_lsame( job, 'N' ) ) then
              lwmin = 1
           else if( stdlib_lsame( job, 'E' ) ) then
              lwmin = max( 1, nn )
           end if
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.wants .and. .not.wantsp )then
              info = -1
           else if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -8
           else if( lwork<lwmin .and. .not.lquery ) then
              info = -14
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTRSEN', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==n .or. m==0 ) then
              if( wants )s = one
              if( wantsp )sep = stdlib_${ci}$lange( '1', n, n, t, ldt, rwork )
              go to 40
           end if
           ! collect the selected eigenvalues at the top left corner of t.
           ks = 0
           do k = 1, n
              if( select( k ) ) then
                 ks = ks + 1
                 ! swap the k-th eigenvalue to position ks.
                 if( k/=ks )call stdlib_${ci}$trexc( compq, n, t, ldt, q, ldq, k, ks, ierr )
              end if
           end do
           if( wants ) then
              ! solve the sylvester equation for r:
                 ! t11*r - r*t22 = scale*t12
              call stdlib_${ci}$lacpy( 'F', n1, n2, t( 1, n1+1 ), ldt, work, n1 )
              call stdlib_${ci}$trsyl( 'N', 'N', -1, n1, n2, t, ldt, t( n1+1, n1+1 ),ldt, work, n1, &
                        scale, ierr )
              ! estimate the reciprocal of the condition number of the cluster
              ! of eigenvalues.
              rnorm = stdlib_${ci}$lange( 'F', n1, n2, work, n1, rwork )
              if( rnorm==zero ) then
                 s = one
              else
                 s = scale / ( sqrt( scale*scale / rnorm+rnorm )*sqrt( rnorm ) )
              end if
           end if
           if( wantsp ) then
              ! estimate sep(t11,t22).
              est = zero
              kase = 0
              30 continue
              call stdlib_${ci}$lacn2( nn, work( nn+1 ), work, est, kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! solve t11*r - r*t22 = scale*x.
                    call stdlib_${ci}$trsyl( 'N', 'N', -1, n1, n2, t, ldt,t( n1+1, n1+1 ), ldt, work, &
                              n1, scale,ierr )
                 else
                    ! solve t11**h*r - r*t22**h = scale*x.
                    call stdlib_${ci}$trsyl( 'C', 'C', -1, n1, n2, t, ldt,t( n1+1, n1+1 ), ldt, work, &
                              n1, scale,ierr )
                 end if
                 go to 30
              end if
              sep = scale / est
           end if
           40 continue
           ! copy reordered eigenvalues to w.
           do k = 1, n
              w( k ) = t( k, k )
           end do
           work( 1 ) = lwmin
           return
     end subroutine stdlib_${ci}$trsen

#:endif
#:endfor



     module pure subroutine stdlib_slaqr1( n, h, ldh, sr1, si1, sr2, si2, v )
     !! Given a 2-by-2 or 3-by-3 matrix H, SLAQR1: sets v to a
     !! scalar multiple of the first column of the product
     !! (*)  K = (H - (sr1 + i*si1)*I)*(H - (sr2 + i*si2)*I)
     !! scaling to avoid overflows and most underflows. It
     !! is assumed that either
     !! 1) sr1 = sr2 and si1 = -si2
     !! or
     !! 2) si1 = si2 = 0.
     !! This is useful for starting double implicit shift bulges
     !! in the QR algorithm.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(sp), intent(in) :: si1, si2, sr1, sr2
           integer(ilp), intent(in) :: ldh, n
           ! Array Arguments 
           real(sp), intent(in) :: h(ldh,*)
           real(sp), intent(out) :: v(*)
        ! ================================================================
           
           ! Local Scalars 
           real(sp) :: h21s, h31s, s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n/=2 .and. n/=3 ) then
              return
           end if
           if( n==2 ) then
              s = abs( h( 1, 1 )-sr2 ) + abs( si2 ) + abs( h( 2, 1 ) )
              if( s==zero ) then
                 v( 1 ) = zero
                 v( 2 ) = zero
              else
                 h21s = h( 2, 1 ) / s
                 v( 1 ) = h21s*h( 1, 2 ) + ( h( 1, 1 )-sr1 )*( ( h( 1, 1 )-sr2 ) / s ) - si1*( &
                           si2 / s )
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-sr1-sr2 )
              end if
           else
              s = abs( h( 1, 1 )-sr2 ) + abs( si2 ) + abs( h( 2, 1 ) ) +abs( h( 3, 1 ) )
              if( s==zero ) then
                 v( 1 ) = zero
                 v( 2 ) = zero
                 v( 3 ) = zero
              else
                 h21s = h( 2, 1 ) / s
                 h31s = h( 3, 1 ) / s
                 v( 1 ) = ( h( 1, 1 )-sr1 )*( ( h( 1, 1 )-sr2 ) / s ) -si1*( si2 / s ) + h( 1, 2 )&
                           *h21s + h( 1, 3 )*h31s
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-sr1-sr2 ) +h( 2, 3 )*h31s
                 v( 3 ) = h31s*( h( 1, 1 )+h( 3, 3 )-sr1-sr2 ) +h21s*h( 3, 2 )
              end if
           end if
     end subroutine stdlib_slaqr1

     module pure subroutine stdlib_dlaqr1( n, h, ldh, sr1, si1, sr2, si2, v )
     !! Given a 2-by-2 or 3-by-3 matrix H, DLAQR1: sets v to a
     !! scalar multiple of the first column of the product
     !! (*)  K = (H - (sr1 + i*si1)*I)*(H - (sr2 + i*si2)*I)
     !! scaling to avoid overflows and most underflows. It
     !! is assumed that either
     !! 1) sr1 = sr2 and si1 = -si2
     !! or
     !! 2) si1 = si2 = 0.
     !! This is useful for starting double implicit shift bulges
     !! in the QR algorithm.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(dp), intent(in) :: si1, si2, sr1, sr2
           integer(ilp), intent(in) :: ldh, n
           ! Array Arguments 
           real(dp), intent(in) :: h(ldh,*)
           real(dp), intent(out) :: v(*)
        ! ================================================================
           
           ! Local Scalars 
           real(dp) :: h21s, h31s, s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n/=2 .and. n/=3 ) then
              return
           end if
           if( n==2 ) then
              s = abs( h( 1, 1 )-sr2 ) + abs( si2 ) + abs( h( 2, 1 ) )
              if( s==zero ) then
                 v( 1 ) = zero
                 v( 2 ) = zero
              else
                 h21s = h( 2, 1 ) / s
                 v( 1 ) = h21s*h( 1, 2 ) + ( h( 1, 1 )-sr1 )*( ( h( 1, 1 )-sr2 ) / s ) - si1*( &
                           si2 / s )
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-sr1-sr2 )
              end if
           else
              s = abs( h( 1, 1 )-sr2 ) + abs( si2 ) + abs( h( 2, 1 ) ) +abs( h( 3, 1 ) )
              if( s==zero ) then
                 v( 1 ) = zero
                 v( 2 ) = zero
                 v( 3 ) = zero
              else
                 h21s = h( 2, 1 ) / s
                 h31s = h( 3, 1 ) / s
                 v( 1 ) = ( h( 1, 1 )-sr1 )*( ( h( 1, 1 )-sr2 ) / s ) -si1*( si2 / s ) + h( 1, 2 )&
                           *h21s + h( 1, 3 )*h31s
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-sr1-sr2 ) +h( 2, 3 )*h31s
                 v( 3 ) = h31s*( h( 1, 1 )+h( 3, 3 )-sr1-sr2 ) +h21s*h( 3, 2 )
              end if
           end if
     end subroutine stdlib_dlaqr1

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$laqr1( n, h, ldh, sr1, si1, sr2, si2, v )
     !! Given a 2-by-2 or 3-by-3 matrix H, DLAQR1: sets v to a
     !! scalar multiple of the first column of the product
     !! (*)  K = (H - (sr1 + i*si1)*I)*(H - (sr2 + i*si2)*I)
     !! scaling to avoid overflows and most underflows. It
     !! is assumed that either
     !! 1) sr1 = sr2 and si1 = -si2
     !! or
     !! 2) si1 = si2 = 0.
     !! This is useful for starting double implicit shift bulges
     !! in the QR algorithm.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: si1, si2, sr1, sr2
           integer(ilp), intent(in) :: ldh, n
           ! Array Arguments 
           real(${rk}$), intent(in) :: h(ldh,*)
           real(${rk}$), intent(out) :: v(*)
        ! ================================================================
           
           ! Local Scalars 
           real(${rk}$) :: h21s, h31s, s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n/=2 .and. n/=3 ) then
              return
           end if
           if( n==2 ) then
              s = abs( h( 1, 1 )-sr2 ) + abs( si2 ) + abs( h( 2, 1 ) )
              if( s==zero ) then
                 v( 1 ) = zero
                 v( 2 ) = zero
              else
                 h21s = h( 2, 1 ) / s
                 v( 1 ) = h21s*h( 1, 2 ) + ( h( 1, 1 )-sr1 )*( ( h( 1, 1 )-sr2 ) / s ) - si1*( &
                           si2 / s )
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-sr1-sr2 )
              end if
           else
              s = abs( h( 1, 1 )-sr2 ) + abs( si2 ) + abs( h( 2, 1 ) ) +abs( h( 3, 1 ) )
              if( s==zero ) then
                 v( 1 ) = zero
                 v( 2 ) = zero
                 v( 3 ) = zero
              else
                 h21s = h( 2, 1 ) / s
                 h31s = h( 3, 1 ) / s
                 v( 1 ) = ( h( 1, 1 )-sr1 )*( ( h( 1, 1 )-sr2 ) / s ) -si1*( si2 / s ) + h( 1, 2 )&
                           *h21s + h( 1, 3 )*h31s
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-sr1-sr2 ) +h( 2, 3 )*h31s
                 v( 3 ) = h31s*( h( 1, 1 )+h( 3, 3 )-sr1-sr2 ) +h21s*h( 3, 2 )
              end if
           end if
     end subroutine stdlib_${ri}$laqr1

#:endif
#:endfor

     module pure subroutine stdlib_claqr1( n, h, ldh, s1, s2, v )
     !! Given a 2-by-2 or 3-by-3 matrix H, CLAQR1: sets v to a
     !! scalar multiple of the first column of the product
     !! (*)  K = (H - s1*I)*(H - s2*I)
     !! scaling to avoid overflows and most underflows.
     !! This is useful for starting double implicit shift bulges
     !! in the QR algorithm.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           complex(sp), intent(in) :: s1, s2
           integer(ilp), intent(in) :: ldh, n
           ! Array Arguments 
           complex(sp), intent(in) :: h(ldh,*)
           complex(sp), intent(out) :: v(*)
        ! ================================================================
           ! Parameters 
           real(sp), parameter :: rzero = 0.0_sp
           
           
           ! Local Scalars 
           complex(sp) :: cdum, h21s, h31s
           real(sp) :: s
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! quick return if possible
           if( n/=2 .and. n/=3 ) then
              return
           end if
           if( n==2 ) then
              s = cabs1( h( 1, 1 )-s2 ) + cabs1( h( 2, 1 ) )
              if( s==rzero ) then
                 v( 1 ) = czero
                 v( 2 ) = czero
              else
                 h21s = h( 2, 1 ) / s
                 v( 1 ) = h21s*h( 1, 2 ) + ( h( 1, 1 )-s1 )*( ( h( 1, 1 )-s2 ) / s )
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-s1-s2 )
              end if
           else
              s = cabs1( h( 1, 1 )-s2 ) + cabs1( h( 2, 1 ) ) +cabs1( h( 3, 1 ) )
              if( s==czero ) then
                 v( 1 ) = czero
                 v( 2 ) = czero
                 v( 3 ) = czero
              else
                 h21s = h( 2, 1 ) / s
                 h31s = h( 3, 1 ) / s
                 v( 1 ) = ( h( 1, 1 )-s1 )*( ( h( 1, 1 )-s2 ) / s ) +h( 1, 2 )*h21s + h( 1, 3 )&
                           *h31s
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-s1-s2 ) + h( 2, 3 )*h31s
                 v( 3 ) = h31s*( h( 1, 1 )+h( 3, 3 )-s1-s2 ) + h21s*h( 3, 2 )
              end if
           end if
     end subroutine stdlib_claqr1

     module pure subroutine stdlib_zlaqr1( n, h, ldh, s1, s2, v )
     !! Given a 2-by-2 or 3-by-3 matrix H, ZLAQR1: sets v to a
     !! scalar multiple of the first column of the product
     !! (*)  K = (H - s1*I)*(H - s2*I)
     !! scaling to avoid overflows and most underflows.
     !! This is useful for starting double implicit shift bulges
     !! in the QR algorithm.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           complex(dp), intent(in) :: s1, s2
           integer(ilp), intent(in) :: ldh, n
           ! Array Arguments 
           complex(dp), intent(in) :: h(ldh,*)
           complex(dp), intent(out) :: v(*)
        ! ================================================================
           ! Parameters 
           real(dp), parameter :: rzero = 0.0_dp
           
           
           ! Local Scalars 
           complex(dp) :: cdum, h21s, h31s
           real(dp) :: s
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! quick return if possible
           if( n/=2 .and. n/=3 ) then
              return
           end if
           if( n==2 ) then
              s = cabs1( h( 1, 1 )-s2 ) + cabs1( h( 2, 1 ) )
              if( s==rzero ) then
                 v( 1 ) = czero
                 v( 2 ) = czero
              else
                 h21s = h( 2, 1 ) / s
                 v( 1 ) = h21s*h( 1, 2 ) + ( h( 1, 1 )-s1 )*( ( h( 1, 1 )-s2 ) / s )
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-s1-s2 )
              end if
           else
              s = cabs1( h( 1, 1 )-s2 ) + cabs1( h( 2, 1 ) ) +cabs1( h( 3, 1 ) )
              if( s==czero ) then
                 v( 1 ) = czero
                 v( 2 ) = czero
                 v( 3 ) = czero
              else
                 h21s = h( 2, 1 ) / s
                 h31s = h( 3, 1 ) / s
                 v( 1 ) = ( h( 1, 1 )-s1 )*( ( h( 1, 1 )-s2 ) / s ) +h( 1, 2 )*h21s + h( 1, 3 )&
                           *h31s
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-s1-s2 ) + h( 2, 3 )*h31s
                 v( 3 ) = h31s*( h( 1, 1 )+h( 3, 3 )-s1-s2 ) + h21s*h( 3, 2 )
              end if
           end if
     end subroutine stdlib_zlaqr1

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$laqr1( n, h, ldh, s1, s2, v )
     !! Given a 2-by-2 or 3-by-3 matrix H, ZLAQR1: sets v to a
     !! scalar multiple of the first column of the product
     !! (*)  K = (H - s1*I)*(H - s2*I)
     !! scaling to avoid overflows and most underflows.
     !! This is useful for starting double implicit shift bulges
     !! in the QR algorithm.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           complex(${ck}$), intent(in) :: s1, s2
           integer(ilp), intent(in) :: ldh, n
           ! Array Arguments 
           complex(${ck}$), intent(in) :: h(ldh,*)
           complex(${ck}$), intent(out) :: v(*)
        ! ================================================================
           ! Parameters 
           real(${ck}$), parameter :: rzero = 0.0_${ck}$
           
           
           ! Local Scalars 
           complex(${ck}$) :: cdum, h21s, h31s
           real(${ck}$) :: s
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! quick return if possible
           if( n/=2 .and. n/=3 ) then
              return
           end if
           if( n==2 ) then
              s = cabs1( h( 1, 1 )-s2 ) + cabs1( h( 2, 1 ) )
              if( s==rzero ) then
                 v( 1 ) = czero
                 v( 2 ) = czero
              else
                 h21s = h( 2, 1 ) / s
                 v( 1 ) = h21s*h( 1, 2 ) + ( h( 1, 1 )-s1 )*( ( h( 1, 1 )-s2 ) / s )
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-s1-s2 )
              end if
           else
              s = cabs1( h( 1, 1 )-s2 ) + cabs1( h( 2, 1 ) ) +cabs1( h( 3, 1 ) )
              if( s==czero ) then
                 v( 1 ) = czero
                 v( 2 ) = czero
                 v( 3 ) = czero
              else
                 h21s = h( 2, 1 ) / s
                 h31s = h( 3, 1 ) / s
                 v( 1 ) = ( h( 1, 1 )-s1 )*( ( h( 1, 1 )-s2 ) / s ) +h( 1, 2 )*h21s + h( 1, 3 )&
                           *h31s
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-s1-s2 ) + h( 2, 3 )*h31s
                 v( 3 ) = h31s*( h( 1, 1 )+h( 3, 3 )-s1-s2 ) + h21s*h( 3, 2 )
              end if
           end if
     end subroutine stdlib_${ci}$laqr1

#:endif
#:endfor





     module pure subroutine stdlib_stgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr, &
     !! STGEVC computes some or all of the right and/or left eigenvectors of
     !! a pair of real matrices (S,P), where S is a quasi-triangular matrix
     !! and P is upper triangular.  Matrix pairs of this type are produced by
     !! the generalized Schur factorization of a matrix pair (A,B):
     !! A = Q*S*Z**T,  B = Q*P*Z**T
     !! as computed by SGGHRD + SHGEQZ.
     !! The right eigenvector x and the left eigenvector y of (S,P)
     !! corresponding to an eigenvalue w are defined by:
     !! S*x = w*P*x,  (y**H)*S = w*(y**H)*P,
     !! where y**H denotes the conjugate tranpose of y.
     !! The eigenvalues are not input to this routine, but are computed
     !! directly from the diagonal blocks of S and P.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of (S,P), or the products Z*X and/or Q*Y,
     !! where Z and Q are input matrices.
     !! If Q and Z are the orthogonal factors from the generalized Schur
     !! factorization of a matrix pair (A,B), then Z*X and Q*Y
     !! are the matrices of right and left eigenvectors of (A,B).
               mm, m, work, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldp, lds, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(sp), intent(in) :: p(ldp,*), s(lds,*)
           real(sp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: safety = 1.0e+2_sp
           
           ! Local Scalars 
           logical(lk) :: compl, compr, il2by2, ilabad, ilall, ilback, ilbbad, ilcomp, ilcplx, &
                     lsa, lsb
           integer(ilp) :: i, ibeg, ieig, iend, ihwmny, iinfo, im, iside, j, ja, jc, je, jr, jw, &
                     na, nw
           real(sp) :: acoef, acoefa, anorm, ascale, bcoefa, bcoefi, bcoefr, big, bignum, bnorm, &
           bscale, cim2a, cim2b, cimaga, cimagb, cre2a, cre2b, creala, crealb, dmin, safmin, &
                     salfar, sbeta, scale, small, temp, temp2, temp2i, temp2r, ulp, xmax, xscale
           ! Local Arrays 
           real(sp) :: bdiag(2), sum(2,2), sums(2,2), sump(2,2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           if( stdlib_lsame( howmny, 'A' ) ) then
              ihwmny = 1
              ilall = .true.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'S' ) ) then
              ihwmny = 2
              ilall = .false.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'B' ) ) then
              ihwmny = 3
              ilall = .true.
              ilback = .true.
           else
              ihwmny = -1
              ilall = .true.
           end if
           if( stdlib_lsame( side, 'R' ) ) then
              iside = 1
              compl = .false.
              compr = .true.
           else if( stdlib_lsame( side, 'L' ) ) then
              iside = 2
              compl = .true.
              compr = .false.
           else if( stdlib_lsame( side, 'B' ) ) then
              iside = 3
              compl = .true.
              compr = .true.
           else
              iside = -1
           end if
           info = 0
           if( iside<0 ) then
              info = -1
           else if( ihwmny<0 ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lds<max( 1, n ) ) then
              info = -6
           else if( ldp<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STGEVC', -info )
              return
           end if
           ! count the number of eigenvectors to be computed
           if( .not.ilall ) then
              im = 0
              ilcplx = .false.
              loop_10: do j = 1, n
                 if( ilcplx ) then
                    ilcplx = .false.
                    cycle loop_10
                 end if
                 if( j<n ) then
                    if( s( j+1, j )/=zero )ilcplx = .true.
                 end if
                 if( ilcplx ) then
                    if( select( j ) .or. select( j+1 ) )im = im + 2
                 else
                    if( select( j ) )im = im + 1
                 end if
              end do loop_10
           else
              im = n
           end if
           ! check 2-by-2 diagonal blocks of a, b
           ilabad = .false.
           ilbbad = .false.
           do j = 1, n - 1
              if( s( j+1, j )/=zero ) then
                 if( p( j, j )==zero .or. p( j+1, j+1 )==zero .or.p( j, j+1 )/=zero )ilbbad = &
                           .true.
                 if( j<n-1 ) then
                    if( s( j+2, j+1 )/=zero )ilabad = .true.
                 end if
              end if
           end do
           if( ilabad ) then
              info = -5
           else if( ilbbad ) then
              info = -7
           else if( compl .and. ldvl<n .or. ldvl<1 ) then
              info = -10
           else if( compr .and. ldvr<n .or. ldvr<1 ) then
              info = -12
           else if( mm<im ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STGEVC', -info )
              return
           end if
           ! quick return if possible
           m = im
           if( n==0 )return
           ! machine constants
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           big = one / safmin
           call stdlib_slabad( safmin, big )
           ulp = stdlib_slamch( 'EPSILON' )*stdlib_slamch( 'BASE' )
           small = safmin*n / ulp
           big = one / small
           bignum = one / ( safmin*n )
           ! compute the 1-norm of each column of the strictly upper triangular
           ! part (i.e., excluding all elements belonging to the diagonal
           ! blocks) of a and b to check for possible overflow in the
           ! triangular solver.
           anorm = abs( s( 1, 1 ) )
           if( n>1 )anorm = anorm + abs( s( 2, 1 ) )
           bnorm = abs( p( 1, 1 ) )
           work( 1 ) = zero
           work( n+1 ) = zero
           do j = 2, n
              temp = zero
              temp2 = zero
              if( s( j, j-1 )==zero ) then
                 iend = j - 1
              else
                 iend = j - 2
              end if
              do i = 1, iend
                 temp = temp + abs( s( i, j ) )
                 temp2 = temp2 + abs( p( i, j ) )
              end do
              work( j ) = temp
              work( n+j ) = temp2
              do i = iend + 1, min( j+1, n )
                 temp = temp + abs( s( i, j ) )
                 temp2 = temp2 + abs( p( i, j ) )
              end do
              anorm = max( anorm, temp )
              bnorm = max( bnorm, temp2 )
           end do
           ascale = one / max( anorm, safmin )
           bscale = one / max( bnorm, safmin )
           ! left eigenvectors
           if( compl ) then
              ieig = 0
              ! main loop over eigenvalues
              ilcplx = .false.
              loop_220: do je = 1, n
                 ! skip this iteration if (a) howmny='s' and select=.false., or
                 ! (b) this would be the second of a complex pair.
                 ! check for complex eigenvalue, so as to be sure of which
                 ! entry(-ies) of select to look at.
                 if( ilcplx ) then
                    ilcplx = .false.
                    cycle loop_220
                 end if
                 nw = 1
                 if( je<n ) then
                    if( s( je+1, je )/=zero ) then
                       ilcplx = .true.
                       nw = 2
                    end if
                 end if
                 if( ilall ) then
                    ilcomp = .true.
                 else if( ilcplx ) then
                    ilcomp = select( je ) .or. select( je+1 )
                 else
                    ilcomp = select( je )
                 end if
                 if( .not.ilcomp )cycle loop_220
                 ! decide if (a) singular pencil, (b) real eigenvalue, or
                 ! (c) complex eigenvalue.
                 if( .not.ilcplx ) then
                    if( abs( s( je, je ) )<=safmin .and.abs( p( je, je ) )<=safmin ) then
                       ! singular matrix pencil -- return unit eigenvector
                       ieig = ieig + 1
                       do jr = 1, n
                          vl( jr, ieig ) = zero
                       end do
                       vl( ieig, ieig ) = one
                       cycle loop_220
                    end if
                 end if
                 ! clear vector
                 do jr = 1, nw*n
                    work( 2*n+jr ) = zero
                 end do
                                                       ! t
                 ! compute coefficients in  ( a a - b b )  y = 0
                    ! a  is  acoef
                    ! b  is  bcoefr + i*bcoefi
                 if( .not.ilcplx ) then
                    ! real eigenvalue
                    temp = one / max( abs( s( je, je ) )*ascale,abs( p( je, je ) )*bscale, safmin &
                              )
                    salfar = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*p( je, je ) )*bscale
                    acoef = sbeta*ascale
                    bcoefr = salfar*bscale
                    bcoefi = zero
                    ! scale to avoid underflow
                    scale = one
                    lsa = abs( sbeta )>=safmin .and. abs( acoef )<small
                    lsb = abs( salfar )>=safmin .and. abs( bcoefr )<small
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs( salfar ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoef ),abs( bcoefr ) ) ) &
                                 )
                       if( lsa ) then
                          acoef = ascale*( scale*sbeta )
                       else
                          acoef = scale*acoef
                       end if
                       if( lsb ) then
                          bcoefr = bscale*( scale*salfar )
                       else
                          bcoefr = scale*bcoefr
                       end if
                    end if
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr )
                    ! first component is 1
                    work( 2*n+je ) = one
                    xmax = one
                 else
                    ! complex eigenvalue
                    call stdlib_slag2( s( je, je ), lds, p( je, je ), ldp,safmin*safety, acoef, &
                              temp, bcoefr, temp2,bcoefi )
                    bcoefi = -bcoefi
                    if( bcoefi==zero ) then
                       info = je
                       return
                    end if
                    ! scale to avoid over/underflow
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr ) + abs( bcoefi )
                    scale = one
                    if( acoefa*ulp<safmin .and. acoefa>=safmin )scale = ( safmin / ulp ) / &
                              acoefa
                    if( bcoefa*ulp<safmin .and. bcoefa>=safmin )scale = max( scale, ( safmin / &
                              ulp ) / bcoefa )
                    if( safmin*acoefa>ascale )scale = ascale / ( safmin*acoefa )
                    if( safmin*bcoefa>bscale )scale = min( scale, bscale / ( safmin*bcoefa ) )
                              
                    if( scale/=one ) then
                       acoef = scale*acoef
                       acoefa = abs( acoef )
                       bcoefr = scale*bcoefr
                       bcoefi = scale*bcoefi
                       bcoefa = abs( bcoefr ) + abs( bcoefi )
                    end if
                    ! compute first two components of eigenvector
                    temp = acoef*s( je+1, je )
                    temp2r = acoef*s( je, je ) - bcoefr*p( je, je )
                    temp2i = -bcoefi*p( je, je )
                    if( abs( temp )>abs( temp2r )+abs( temp2i ) ) then
                       work( 2*n+je ) = one
                       work( 3*n+je ) = zero
                       work( 2*n+je+1 ) = -temp2r / temp
                       work( 3*n+je+1 ) = -temp2i / temp
                    else
                       work( 2*n+je+1 ) = one
                       work( 3*n+je+1 ) = zero
                       temp = acoef*s( je, je+1 )
                       work( 2*n+je ) = ( bcoefr*p( je+1, je+1 )-acoef*s( je+1, je+1 ) ) / &
                                 temp
                       work( 3*n+je ) = bcoefi*p( je+1, je+1 ) / temp
                    end if
                    xmax = max( abs( work( 2*n+je ) )+abs( work( 3*n+je ) ),abs( work( 2*n+je+1 ) &
                              )+abs( work( 3*n+je+1 ) ) )
                 end if
                 dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                                                 ! t
                 ! triangular solve of  (a a - b b)  y = 0
                                         ! t
                 ! (rowwise in  (a a - b b) , or columnwise in (a a - b b) )
                 il2by2 = .false.
                 loop_160: do j = je + nw, n
                    if( il2by2 ) then
                       il2by2 = .false.
                       cycle loop_160
                    end if
                    na = 1
                    bdiag( 1 ) = p( j, j )
                    if( j<n ) then
                       if( s( j+1, j )/=zero ) then
                          il2by2 = .true.
                          bdiag( 2 ) = p( j+1, j+1 )
                          na = 2
                       end if
                    end if
                    ! check whether scaling is necessary for dot products
                    xscale = one / max( one, xmax )
                    temp = max( work( j ), work( n+j ),acoefa*work( j )+bcoefa*work( n+j ) )
                              
                    if( il2by2 )temp = max( temp, work( j+1 ), work( n+j+1 ),acoefa*work( j+1 )+&
                              bcoefa*work( n+j+1 ) )
                    if( temp>bignum*xscale ) then
                       do jw = 0, nw - 1
                          do jr = je, j - 1
                             work( ( jw+2 )*n+jr ) = xscale*work( ( jw+2 )*n+jr )
                          end do
                       end do
                       xmax = xmax*xscale
                    end if
                    ! compute dot products
                          ! j-1
                    ! sum = sum  conjg( a*s(k,j) - b*p(k,j) )*x(k)
                          ! k=je
                    ! to reduce the op count, this is done as
                    ! _        j-1                  _        j-1
                    ! a*conjg( sum  s(k,j)*x(k) ) - b*conjg( sum  p(k,j)*x(k) )
                             ! k=je                          k=je
                    ! which may cause underflow problems if a or b are close
                    ! to underflow.  (e.g., less than small.)
                    do jw = 1, nw
                       do ja = 1, na
                          sums( ja, jw ) = zero
                          sump( ja, jw ) = zero
                          do jr = je, j - 1
                             sums( ja, jw ) = sums( ja, jw ) +s( jr, j+ja-1 )*work( ( jw+1 )*n+jr &
                                       )
                             sump( ja, jw ) = sump( ja, jw ) +p( jr, j+ja-1 )*work( ( jw+1 )*n+jr &
                                       )
                          end do
                       end do
                    end do
                    do ja = 1, na
                       if( ilcplx ) then
                          sum( ja, 1 ) = -acoef*sums( ja, 1 ) +bcoefr*sump( ja, 1 ) -bcoefi*sump( &
                                    ja, 2 )
                          sum( ja, 2 ) = -acoef*sums( ja, 2 ) +bcoefr*sump( ja, 2 ) +bcoefi*sump( &
                                    ja, 1 )
                       else
                          sum( ja, 1 ) = -acoef*sums( ja, 1 ) +bcoefr*sump( ja, 1 )
                       end if
                    end do
                                        ! t
                    ! solve  ( a a - b b )  y = sum(,)
                    ! with scaling and perturbation of the denominator
                    call stdlib_slaln2( .true., na, nw, dmin, acoef, s( j, j ), lds,bdiag( 1 ), &
                    bdiag( 2 ), sum, 2, bcoefr,bcoefi, work( 2*n+j ), n, scale, temp,iinfo )
                              
                    if( scale<one ) then
                       do jw = 0, nw - 1
                          do jr = je, j - 1
                             work( ( jw+2 )*n+jr ) = scale*work( ( jw+2 )*n+jr )
                          end do
                       end do
                       xmax = scale*xmax
                    end if
                    xmax = max( xmax, temp )
                 end do loop_160
                 ! copy eigenvector to vl, back transforming if
                 ! howmny='b'.
                 ieig = ieig + 1
                 if( ilback ) then
                    do jw = 0, nw - 1
                       call stdlib_sgemv( 'N', n, n+1-je, one, vl( 1, je ), ldvl,work( ( jw+2 )*n+&
                                 je ), 1, zero,work( ( jw+4 )*n+1 ), 1 )
                    end do
                    call stdlib_slacpy( ' ', n, nw, work( 4*n+1 ), n, vl( 1, je ),ldvl )
                    ibeg = 1
                 else
                    call stdlib_slacpy( ' ', n, nw, work( 2*n+1 ), n, vl( 1, ieig ),ldvl )
                    ibeg = je
                 end if
                 ! scale eigenvector
                 xmax = zero
                 if( ilcplx ) then
                    do j = ibeg, n
                       xmax = max( xmax, abs( vl( j, ieig ) )+abs( vl( j, ieig+1 ) ) )
                    end do
                 else
                    do j = ibeg, n
                       xmax = max( xmax, abs( vl( j, ieig ) ) )
                    end do
                 end if
                 if( xmax>safmin ) then
                    xscale = one / xmax
                    do jw = 0, nw - 1
                       do jr = ibeg, n
                          vl( jr, ieig+jw ) = xscale*vl( jr, ieig+jw )
                       end do
                    end do
                 end if
                 ieig = ieig + nw - 1
              end do loop_220
           end if
           ! right eigenvectors
           if( compr ) then
              ieig = im + 1
              ! main loop over eigenvalues
              ilcplx = .false.
              loop_500: do je = n, 1, -1
                 ! skip this iteration if (a) howmny='s' and select=.false., or
                 ! (b) this would be the second of a complex pair.
                 ! check for complex eigenvalue, so as to be sure of which
                 ! entry(-ies) of select to look at -- if complex, select(je)
                 ! or select(je-1).
                 ! if this is a complex pair, the 2-by-2 diagonal block
                 ! corresponding to the eigenvalue is in rows/columns je-1:je
                 if( ilcplx ) then
                    ilcplx = .false.
                    cycle loop_500
                 end if
                 nw = 1
                 if( je>1 ) then
                    if( s( je, je-1 )/=zero ) then
                       ilcplx = .true.
                       nw = 2
                    end if
                 end if
                 if( ilall ) then
                    ilcomp = .true.
                 else if( ilcplx ) then
                    ilcomp = select( je ) .or. select( je-1 )
                 else
                    ilcomp = select( je )
                 end if
                 if( .not.ilcomp )cycle loop_500
                 ! decide if (a) singular pencil, (b) real eigenvalue, or
                 ! (c) complex eigenvalue.
                 if( .not.ilcplx ) then
                    if( abs( s( je, je ) )<=safmin .and.abs( p( je, je ) )<=safmin ) then
                       ! singular matrix pencil -- unit eigenvector
                       ieig = ieig - 1
                       do jr = 1, n
                          vr( jr, ieig ) = zero
                       end do
                       vr( ieig, ieig ) = one
                       cycle loop_500
                    end if
                 end if
                 ! clear vector
                 do jw = 0, nw - 1
                    do jr = 1, n
                       work( ( jw+2 )*n+jr ) = zero
                    end do
                 end do
                 ! compute coefficients in  ( a a - b b ) x = 0
                    ! a  is  acoef
                    ! b  is  bcoefr + i*bcoefi
                 if( .not.ilcplx ) then
                    ! real eigenvalue
                    temp = one / max( abs( s( je, je ) )*ascale,abs( p( je, je ) )*bscale, safmin &
                              )
                    salfar = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*p( je, je ) )*bscale
                    acoef = sbeta*ascale
                    bcoefr = salfar*bscale
                    bcoefi = zero
                    ! scale to avoid underflow
                    scale = one
                    lsa = abs( sbeta )>=safmin .and. abs( acoef )<small
                    lsb = abs( salfar )>=safmin .and. abs( bcoefr )<small
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs( salfar ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoef ),abs( bcoefr ) ) ) &
                                 )
                       if( lsa ) then
                          acoef = ascale*( scale*sbeta )
                       else
                          acoef = scale*acoef
                       end if
                       if( lsb ) then
                          bcoefr = bscale*( scale*salfar )
                       else
                          bcoefr = scale*bcoefr
                       end if
                    end if
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr )
                    ! first component is 1
                    work( 2*n+je ) = one
                    xmax = one
                    ! compute contribution from column je of a and b to sum
                    ! (see "further details", above.)
                    do jr = 1, je - 1
                       work( 2*n+jr ) = bcoefr*p( jr, je ) -acoef*s( jr, je )
                    end do
                 else
                    ! complex eigenvalue
                    call stdlib_slag2( s( je-1, je-1 ), lds, p( je-1, je-1 ), ldp,safmin*safety, &
                              acoef, temp, bcoefr, temp2,bcoefi )
                    if( bcoefi==zero ) then
                       info = je - 1
                       return
                    end if
                    ! scale to avoid over/underflow
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr ) + abs( bcoefi )
                    scale = one
                    if( acoefa*ulp<safmin .and. acoefa>=safmin )scale = ( safmin / ulp ) / &
                              acoefa
                    if( bcoefa*ulp<safmin .and. bcoefa>=safmin )scale = max( scale, ( safmin / &
                              ulp ) / bcoefa )
                    if( safmin*acoefa>ascale )scale = ascale / ( safmin*acoefa )
                    if( safmin*bcoefa>bscale )scale = min( scale, bscale / ( safmin*bcoefa ) )
                              
                    if( scale/=one ) then
                       acoef = scale*acoef
                       acoefa = abs( acoef )
                       bcoefr = scale*bcoefr
                       bcoefi = scale*bcoefi
                       bcoefa = abs( bcoefr ) + abs( bcoefi )
                    end if
                    ! compute first two components of eigenvector
                    ! and contribution to sums
                    temp = acoef*s( je, je-1 )
                    temp2r = acoef*s( je, je ) - bcoefr*p( je, je )
                    temp2i = -bcoefi*p( je, je )
                    if( abs( temp )>=abs( temp2r )+abs( temp2i ) ) then
                       work( 2*n+je ) = one
                       work( 3*n+je ) = zero
                       work( 2*n+je-1 ) = -temp2r / temp
                       work( 3*n+je-1 ) = -temp2i / temp
                    else
                       work( 2*n+je-1 ) = one
                       work( 3*n+je-1 ) = zero
                       temp = acoef*s( je-1, je )
                       work( 2*n+je ) = ( bcoefr*p( je-1, je-1 )-acoef*s( je-1, je-1 ) ) / &
                                 temp
                       work( 3*n+je ) = bcoefi*p( je-1, je-1 ) / temp
                    end if
                    xmax = max( abs( work( 2*n+je ) )+abs( work( 3*n+je ) ),abs( work( 2*n+je-1 ) &
                              )+abs( work( 3*n+je-1 ) ) )
                    ! compute contribution from columns je and je-1
                    ! of a and b to the sums.
                    creala = acoef*work( 2*n+je-1 )
                    cimaga = acoef*work( 3*n+je-1 )
                    crealb = bcoefr*work( 2*n+je-1 ) -bcoefi*work( 3*n+je-1 )
                    cimagb = bcoefi*work( 2*n+je-1 ) +bcoefr*work( 3*n+je-1 )
                    cre2a = acoef*work( 2*n+je )
                    cim2a = acoef*work( 3*n+je )
                    cre2b = bcoefr*work( 2*n+je ) - bcoefi*work( 3*n+je )
                    cim2b = bcoefi*work( 2*n+je ) + bcoefr*work( 3*n+je )
                    do jr = 1, je - 2
                       work( 2*n+jr ) = -creala*s( jr, je-1 ) +crealb*p( jr, je-1 ) -cre2a*s( jr, &
                                 je ) + cre2b*p( jr, je )
                       work( 3*n+jr ) = -cimaga*s( jr, je-1 ) +cimagb*p( jr, je-1 ) -cim2a*s( jr, &
                                 je ) + cim2b*p( jr, je )
                    end do
                 end if
                 dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                 ! columnwise triangular solve of  (a a - b b)  x = 0
                 il2by2 = .false.
                 loop_370: do j = je - nw, 1, -1
                    ! if a 2-by-2 block, is in position j-1:j, wait until
                    ! next iteration to process it (when it will be j:j+1)
                    if( .not.il2by2 .and. j>1 ) then
                       if( s( j, j-1 )/=zero ) then
                          il2by2 = .true.
                          cycle loop_370
                       end if
                    end if
                    bdiag( 1 ) = p( j, j )
                    if( il2by2 ) then
                       na = 2
                       bdiag( 2 ) = p( j+1, j+1 )
                    else
                       na = 1
                    end if
                    ! compute x(j) (and x(j+1), if 2-by-2 block)
                    call stdlib_slaln2( .false., na, nw, dmin, acoef, s( j, j ),lds, bdiag( 1 ), &
                    bdiag( 2 ), work( 2*n+j ),n, bcoefr, bcoefi, sum, 2, scale, temp,iinfo )
                              
                    if( scale<one ) then
                       do jw = 0, nw - 1
                          do jr = 1, je
                             work( ( jw+2 )*n+jr ) = scale*work( ( jw+2 )*n+jr )
                          end do
                       end do
                    end if
                    xmax = max( scale*xmax, temp )
                    do jw = 1, nw
                       do ja = 1, na
                          work( ( jw+1 )*n+j+ja-1 ) = sum( ja, jw )
                       end do
                    end do
                    ! w = w + x(j)*(a s(*,j) - b p(*,j) ) with scaling
                    if( j>1 ) then
                       ! check whether scaling is necessary for sum.
                       xscale = one / max( one, xmax )
                       temp = acoefa*work( j ) + bcoefa*work( n+j )
                       if( il2by2 )temp = max( temp, acoefa*work( j+1 )+bcoefa*work( n+j+1 ) )
                                 
                       temp = max( temp, acoefa, bcoefa )
                       if( temp>bignum*xscale ) then
                          do jw = 0, nw - 1
                             do jr = 1, je
                                work( ( jw+2 )*n+jr ) = xscale*work( ( jw+2 )*n+jr )
                             end do
                          end do
                          xmax = xmax*xscale
                       end if
                       ! compute the contributions of the off-diagonals of
                       ! column j (and j+1, if 2-by-2 block) of a and b to the
                       ! sums.
                       do ja = 1, na
                          if( ilcplx ) then
                             creala = acoef*work( 2*n+j+ja-1 )
                             cimaga = acoef*work( 3*n+j+ja-1 )
                             crealb = bcoefr*work( 2*n+j+ja-1 ) -bcoefi*work( 3*n+j+ja-1 )
                             cimagb = bcoefi*work( 2*n+j+ja-1 ) +bcoefr*work( 3*n+j+ja-1 )
                             do jr = 1, j - 1
                                work( 2*n+jr ) = work( 2*n+jr ) -creala*s( jr, j+ja-1 ) +crealb*p(&
                                           jr, j+ja-1 )
                                work( 3*n+jr ) = work( 3*n+jr ) -cimaga*s( jr, j+ja-1 ) +cimagb*p(&
                                           jr, j+ja-1 )
                             end do
                          else
                             creala = acoef*work( 2*n+j+ja-1 )
                             crealb = bcoefr*work( 2*n+j+ja-1 )
                             do jr = 1, j - 1
                                work( 2*n+jr ) = work( 2*n+jr ) -creala*s( jr, j+ja-1 ) +crealb*p(&
                                           jr, j+ja-1 )
                             end do
                          end if
                       end do
                    end if
                    il2by2 = .false.
                 end do loop_370
                 ! copy eigenvector to vr, back transforming if
                 ! howmny='b'.
                 ieig = ieig - nw
                 if( ilback ) then
                    do jw = 0, nw - 1
                       do jr = 1, n
                          work( ( jw+4 )*n+jr ) = work( ( jw+2 )*n+1 )*vr( jr, 1 )
                       end do
                       ! a series of compiler directives to defeat
                       ! vectorization for the next loop
                       do jc = 2, je
                          do jr = 1, n
                             work( ( jw+4 )*n+jr ) = work( ( jw+4 )*n+jr ) +work( ( jw+2 )*n+jc )&
                                       *vr( jr, jc )
                          end do
                       end do
                    end do
                    do jw = 0, nw - 1
                       do jr = 1, n
                          vr( jr, ieig+jw ) = work( ( jw+4 )*n+jr )
                       end do
                    end do
                    iend = n
                 else
                    do jw = 0, nw - 1
                       do jr = 1, n
                          vr( jr, ieig+jw ) = work( ( jw+2 )*n+jr )
                       end do
                    end do
                    iend = je
                 end if
                 ! scale eigenvector
                 xmax = zero
                 if( ilcplx ) then
                    do j = 1, iend
                       xmax = max( xmax, abs( vr( j, ieig ) )+abs( vr( j, ieig+1 ) ) )
                    end do
                 else
                    do j = 1, iend
                       xmax = max( xmax, abs( vr( j, ieig ) ) )
                    end do
                 end if
                 if( xmax>safmin ) then
                    xscale = one / xmax
                    do jw = 0, nw - 1
                       do jr = 1, iend
                          vr( jr, ieig+jw ) = xscale*vr( jr, ieig+jw )
                       end do
                    end do
                 end if
              end do loop_500
           end if
           return
     end subroutine stdlib_stgevc

     module pure subroutine stdlib_dtgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr, &
     !! DTGEVC computes some or all of the right and/or left eigenvectors of
     !! a pair of real matrices (S,P), where S is a quasi-triangular matrix
     !! and P is upper triangular.  Matrix pairs of this type are produced by
     !! the generalized Schur factorization of a matrix pair (A,B):
     !! A = Q*S*Z**T,  B = Q*P*Z**T
     !! as computed by DGGHRD + DHGEQZ.
     !! The right eigenvector x and the left eigenvector y of (S,P)
     !! corresponding to an eigenvalue w are defined by:
     !! S*x = w*P*x,  (y**H)*S = w*(y**H)*P,
     !! where y**H denotes the conjugate tranpose of y.
     !! The eigenvalues are not input to this routine, but are computed
     !! directly from the diagonal blocks of S and P.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of (S,P), or the products Z*X and/or Q*Y,
     !! where Z and Q are input matrices.
     !! If Q and Z are the orthogonal factors from the generalized Schur
     !! factorization of a matrix pair (A,B), then Z*X and Q*Y
     !! are the matrices of right and left eigenvectors of (A,B).
               mm, m, work, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldp, lds, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(dp), intent(in) :: p(ldp,*), s(lds,*)
           real(dp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: safety = 1.0e+2_dp
           
           ! Local Scalars 
           logical(lk) :: compl, compr, il2by2, ilabad, ilall, ilback, ilbbad, ilcomp, ilcplx, &
                     lsa, lsb
           integer(ilp) :: i, ibeg, ieig, iend, ihwmny, iinfo, im, iside, j, ja, jc, je, jr, jw, &
                     na, nw
           real(dp) :: acoef, acoefa, anorm, ascale, bcoefa, bcoefi, bcoefr, big, bignum, bnorm, &
           bscale, cim2a, cim2b, cimaga, cimagb, cre2a, cre2b, creala, crealb, dmin, safmin, &
                     salfar, sbeta, scale, small, temp, temp2, temp2i, temp2r, ulp, xmax, xscale
           ! Local Arrays 
           real(dp) :: bdiag(2), sum(2,2), sums(2,2), sump(2,2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           if( stdlib_lsame( howmny, 'A' ) ) then
              ihwmny = 1
              ilall = .true.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'S' ) ) then
              ihwmny = 2
              ilall = .false.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'B' ) ) then
              ihwmny = 3
              ilall = .true.
              ilback = .true.
           else
              ihwmny = -1
              ilall = .true.
           end if
           if( stdlib_lsame( side, 'R' ) ) then
              iside = 1
              compl = .false.
              compr = .true.
           else if( stdlib_lsame( side, 'L' ) ) then
              iside = 2
              compl = .true.
              compr = .false.
           else if( stdlib_lsame( side, 'B' ) ) then
              iside = 3
              compl = .true.
              compr = .true.
           else
              iside = -1
           end if
           info = 0
           if( iside<0 ) then
              info = -1
           else if( ihwmny<0 ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lds<max( 1, n ) ) then
              info = -6
           else if( ldp<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGEVC', -info )
              return
           end if
           ! count the number of eigenvectors to be computed
           if( .not.ilall ) then
              im = 0
              ilcplx = .false.
              loop_10: do j = 1, n
                 if( ilcplx ) then
                    ilcplx = .false.
                    cycle loop_10
                 end if
                 if( j<n ) then
                    if( s( j+1, j )/=zero )ilcplx = .true.
                 end if
                 if( ilcplx ) then
                    if( select( j ) .or. select( j+1 ) )im = im + 2
                 else
                    if( select( j ) )im = im + 1
                 end if
              end do loop_10
           else
              im = n
           end if
           ! check 2-by-2 diagonal blocks of a, b
           ilabad = .false.
           ilbbad = .false.
           do j = 1, n - 1
              if( s( j+1, j )/=zero ) then
                 if( p( j, j )==zero .or. p( j+1, j+1 )==zero .or.p( j, j+1 )/=zero )ilbbad = &
                           .true.
                 if( j<n-1 ) then
                    if( s( j+2, j+1 )/=zero )ilabad = .true.
                 end if
              end if
           end do
           if( ilabad ) then
              info = -5
           else if( ilbbad ) then
              info = -7
           else if( compl .and. ldvl<n .or. ldvl<1 ) then
              info = -10
           else if( compr .and. ldvr<n .or. ldvr<1 ) then
              info = -12
           else if( mm<im ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGEVC', -info )
              return
           end if
           ! quick return if possible
           m = im
           if( n==0 )return
           ! machine constants
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           big = one / safmin
           call stdlib_dlabad( safmin, big )
           ulp = stdlib_dlamch( 'EPSILON' )*stdlib_dlamch( 'BASE' )
           small = safmin*n / ulp
           big = one / small
           bignum = one / ( safmin*n )
           ! compute the 1-norm of each column of the strictly upper triangular
           ! part (i.e., excluding all elements belonging to the diagonal
           ! blocks) of a and b to check for possible overflow in the
           ! triangular solver.
           anorm = abs( s( 1, 1 ) )
           if( n>1 )anorm = anorm + abs( s( 2, 1 ) )
           bnorm = abs( p( 1, 1 ) )
           work( 1 ) = zero
           work( n+1 ) = zero
           do j = 2, n
              temp = zero
              temp2 = zero
              if( s( j, j-1 )==zero ) then
                 iend = j - 1
              else
                 iend = j - 2
              end if
              do i = 1, iend
                 temp = temp + abs( s( i, j ) )
                 temp2 = temp2 + abs( p( i, j ) )
              end do
              work( j ) = temp
              work( n+j ) = temp2
              do i = iend + 1, min( j+1, n )
                 temp = temp + abs( s( i, j ) )
                 temp2 = temp2 + abs( p( i, j ) )
              end do
              anorm = max( anorm, temp )
              bnorm = max( bnorm, temp2 )
           end do
           ascale = one / max( anorm, safmin )
           bscale = one / max( bnorm, safmin )
           ! left eigenvectors
           if( compl ) then
              ieig = 0
              ! main loop over eigenvalues
              ilcplx = .false.
              loop_220: do je = 1, n
                 ! skip this iteration if (a) howmny='s' and select=.false., or
                 ! (b) this would be the second of a complex pair.
                 ! check for complex eigenvalue, so as to be sure of which
                 ! entry(-ies) of select to look at.
                 if( ilcplx ) then
                    ilcplx = .false.
                    cycle loop_220
                 end if
                 nw = 1
                 if( je<n ) then
                    if( s( je+1, je )/=zero ) then
                       ilcplx = .true.
                       nw = 2
                    end if
                 end if
                 if( ilall ) then
                    ilcomp = .true.
                 else if( ilcplx ) then
                    ilcomp = select( je ) .or. select( je+1 )
                 else
                    ilcomp = select( je )
                 end if
                 if( .not.ilcomp )cycle loop_220
                 ! decide if (a) singular pencil, (b) real eigenvalue, or
                 ! (c) complex eigenvalue.
                 if( .not.ilcplx ) then
                    if( abs( s( je, je ) )<=safmin .and.abs( p( je, je ) )<=safmin ) then
                       ! singular matrix pencil -- return unit eigenvector
                       ieig = ieig + 1
                       do jr = 1, n
                          vl( jr, ieig ) = zero
                       end do
                       vl( ieig, ieig ) = one
                       cycle loop_220
                    end if
                 end if
                 ! clear vector
                 do jr = 1, nw*n
                    work( 2*n+jr ) = zero
                 end do
                                                       ! t
                 ! compute coefficients in  ( a a - b b )  y = 0
                    ! a  is  acoef
                    ! b  is  bcoefr + i*bcoefi
                 if( .not.ilcplx ) then
                    ! real eigenvalue
                    temp = one / max( abs( s( je, je ) )*ascale,abs( p( je, je ) )*bscale, safmin &
                              )
                    salfar = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*p( je, je ) )*bscale
                    acoef = sbeta*ascale
                    bcoefr = salfar*bscale
                    bcoefi = zero
                    ! scale to avoid underflow
                    scale = one
                    lsa = abs( sbeta )>=safmin .and. abs( acoef )<small
                    lsb = abs( salfar )>=safmin .and. abs( bcoefr )<small
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs( salfar ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoef ),abs( bcoefr ) ) ) &
                                 )
                       if( lsa ) then
                          acoef = ascale*( scale*sbeta )
                       else
                          acoef = scale*acoef
                       end if
                       if( lsb ) then
                          bcoefr = bscale*( scale*salfar )
                       else
                          bcoefr = scale*bcoefr
                       end if
                    end if
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr )
                    ! first component is 1
                    work( 2*n+je ) = one
                    xmax = one
                 else
                    ! complex eigenvalue
                    call stdlib_dlag2( s( je, je ), lds, p( je, je ), ldp,safmin*safety, acoef, &
                              temp, bcoefr, temp2,bcoefi )
                    bcoefi = -bcoefi
                    if( bcoefi==zero ) then
                       info = je
                       return
                    end if
                    ! scale to avoid over/underflow
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr ) + abs( bcoefi )
                    scale = one
                    if( acoefa*ulp<safmin .and. acoefa>=safmin )scale = ( safmin / ulp ) / &
                              acoefa
                    if( bcoefa*ulp<safmin .and. bcoefa>=safmin )scale = max( scale, ( safmin / &
                              ulp ) / bcoefa )
                    if( safmin*acoefa>ascale )scale = ascale / ( safmin*acoefa )
                    if( safmin*bcoefa>bscale )scale = min( scale, bscale / ( safmin*bcoefa ) )
                              
                    if( scale/=one ) then
                       acoef = scale*acoef
                       acoefa = abs( acoef )
                       bcoefr = scale*bcoefr
                       bcoefi = scale*bcoefi
                       bcoefa = abs( bcoefr ) + abs( bcoefi )
                    end if
                    ! compute first two components of eigenvector
                    temp = acoef*s( je+1, je )
                    temp2r = acoef*s( je, je ) - bcoefr*p( je, je )
                    temp2i = -bcoefi*p( je, je )
                    if( abs( temp )>abs( temp2r )+abs( temp2i ) ) then
                       work( 2*n+je ) = one
                       work( 3*n+je ) = zero
                       work( 2*n+je+1 ) = -temp2r / temp
                       work( 3*n+je+1 ) = -temp2i / temp
                    else
                       work( 2*n+je+1 ) = one
                       work( 3*n+je+1 ) = zero
                       temp = acoef*s( je, je+1 )
                       work( 2*n+je ) = ( bcoefr*p( je+1, je+1 )-acoef*s( je+1, je+1 ) ) / &
                                 temp
                       work( 3*n+je ) = bcoefi*p( je+1, je+1 ) / temp
                    end if
                    xmax = max( abs( work( 2*n+je ) )+abs( work( 3*n+je ) ),abs( work( 2*n+je+1 ) &
                              )+abs( work( 3*n+je+1 ) ) )
                 end if
                 dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                                                 ! t
                 ! triangular solve of  (a a - b b)  y = 0
                                         ! t
                 ! (rowwise in  (a a - b b) , or columnwise in (a a - b b) )
                 il2by2 = .false.
                 loop_160: do j = je + nw, n
                    if( il2by2 ) then
                       il2by2 = .false.
                       cycle loop_160
                    end if
                    na = 1
                    bdiag( 1 ) = p( j, j )
                    if( j<n ) then
                       if( s( j+1, j )/=zero ) then
                          il2by2 = .true.
                          bdiag( 2 ) = p( j+1, j+1 )
                          na = 2
                       end if
                    end if
                    ! check whether scaling is necessary for dot products
                    xscale = one / max( one, xmax )
                    temp = max( work( j ), work( n+j ),acoefa*work( j )+bcoefa*work( n+j ) )
                              
                    if( il2by2 )temp = max( temp, work( j+1 ), work( n+j+1 ),acoefa*work( j+1 )+&
                              bcoefa*work( n+j+1 ) )
                    if( temp>bignum*xscale ) then
                       do jw = 0, nw - 1
                          do jr = je, j - 1
                             work( ( jw+2 )*n+jr ) = xscale*work( ( jw+2 )*n+jr )
                          end do
                       end do
                       xmax = xmax*xscale
                    end if
                    ! compute dot products
                          ! j-1
                    ! sum = sum  conjg( a*s(k,j) - b*p(k,j) )*x(k)
                          ! k=je
                    ! to reduce the op count, this is done as
                    ! _        j-1                  _        j-1
                    ! a*conjg( sum  s(k,j)*x(k) ) - b*conjg( sum  p(k,j)*x(k) )
                             ! k=je                          k=je
                    ! which may cause underflow problems if a or b are close
                    ! to underflow.  (e.g., less than small.)
                    do jw = 1, nw
                       do ja = 1, na
                          sums( ja, jw ) = zero
                          sump( ja, jw ) = zero
                          do jr = je, j - 1
                             sums( ja, jw ) = sums( ja, jw ) +s( jr, j+ja-1 )*work( ( jw+1 )*n+jr &
                                       )
                             sump( ja, jw ) = sump( ja, jw ) +p( jr, j+ja-1 )*work( ( jw+1 )*n+jr &
                                       )
                          end do
                       end do
                    end do
                    do ja = 1, na
                       if( ilcplx ) then
                          sum( ja, 1 ) = -acoef*sums( ja, 1 ) +bcoefr*sump( ja, 1 ) -bcoefi*sump( &
                                    ja, 2 )
                          sum( ja, 2 ) = -acoef*sums( ja, 2 ) +bcoefr*sump( ja, 2 ) +bcoefi*sump( &
                                    ja, 1 )
                       else
                          sum( ja, 1 ) = -acoef*sums( ja, 1 ) +bcoefr*sump( ja, 1 )
                       end if
                    end do
                                        ! t
                    ! solve  ( a a - b b )  y = sum(,)
                    ! with scaling and perturbation of the denominator
                    call stdlib_dlaln2( .true., na, nw, dmin, acoef, s( j, j ), lds,bdiag( 1 ), &
                    bdiag( 2 ), sum, 2, bcoefr,bcoefi, work( 2*n+j ), n, scale, temp,iinfo )
                              
                    if( scale<one ) then
                       do jw = 0, nw - 1
                          do jr = je, j - 1
                             work( ( jw+2 )*n+jr ) = scale*work( ( jw+2 )*n+jr )
                          end do
                       end do
                       xmax = scale*xmax
                    end if
                    xmax = max( xmax, temp )
                 end do loop_160
                 ! copy eigenvector to vl, back transforming if
                 ! howmny='b'.
                 ieig = ieig + 1
                 if( ilback ) then
                    do jw = 0, nw - 1
                       call stdlib_dgemv( 'N', n, n+1-je, one, vl( 1, je ), ldvl,work( ( jw+2 )*n+&
                                 je ), 1, zero,work( ( jw+4 )*n+1 ), 1 )
                    end do
                    call stdlib_dlacpy( ' ', n, nw, work( 4*n+1 ), n, vl( 1, je ),ldvl )
                    ibeg = 1
                 else
                    call stdlib_dlacpy( ' ', n, nw, work( 2*n+1 ), n, vl( 1, ieig ),ldvl )
                    ibeg = je
                 end if
                 ! scale eigenvector
                 xmax = zero
                 if( ilcplx ) then
                    do j = ibeg, n
                       xmax = max( xmax, abs( vl( j, ieig ) )+abs( vl( j, ieig+1 ) ) )
                    end do
                 else
                    do j = ibeg, n
                       xmax = max( xmax, abs( vl( j, ieig ) ) )
                    end do
                 end if
                 if( xmax>safmin ) then
                    xscale = one / xmax
                    do jw = 0, nw - 1
                       do jr = ibeg, n
                          vl( jr, ieig+jw ) = xscale*vl( jr, ieig+jw )
                       end do
                    end do
                 end if
                 ieig = ieig + nw - 1
              end do loop_220
           end if
           ! right eigenvectors
           if( compr ) then
              ieig = im + 1
              ! main loop over eigenvalues
              ilcplx = .false.
              loop_500: do je = n, 1, -1
                 ! skip this iteration if (a) howmny='s' and select=.false., or
                 ! (b) this would be the second of a complex pair.
                 ! check for complex eigenvalue, so as to be sure of which
                 ! entry(-ies) of select to look at -- if complex, select(je)
                 ! or select(je-1).
                 ! if this is a complex pair, the 2-by-2 diagonal block
                 ! corresponding to the eigenvalue is in rows/columns je-1:je
                 if( ilcplx ) then
                    ilcplx = .false.
                    cycle loop_500
                 end if
                 nw = 1
                 if( je>1 ) then
                    if( s( je, je-1 )/=zero ) then
                       ilcplx = .true.
                       nw = 2
                    end if
                 end if
                 if( ilall ) then
                    ilcomp = .true.
                 else if( ilcplx ) then
                    ilcomp = select( je ) .or. select( je-1 )
                 else
                    ilcomp = select( je )
                 end if
                 if( .not.ilcomp )cycle loop_500
                 ! decide if (a) singular pencil, (b) real eigenvalue, or
                 ! (c) complex eigenvalue.
                 if( .not.ilcplx ) then
                    if( abs( s( je, je ) )<=safmin .and.abs( p( je, je ) )<=safmin ) then
                       ! singular matrix pencil -- unit eigenvector
                       ieig = ieig - 1
                       do jr = 1, n
                          vr( jr, ieig ) = zero
                       end do
                       vr( ieig, ieig ) = one
                       cycle loop_500
                    end if
                 end if
                 ! clear vector
                 do jw = 0, nw - 1
                    do jr = 1, n
                       work( ( jw+2 )*n+jr ) = zero
                    end do
                 end do
                 ! compute coefficients in  ( a a - b b ) x = 0
                    ! a  is  acoef
                    ! b  is  bcoefr + i*bcoefi
                 if( .not.ilcplx ) then
                    ! real eigenvalue
                    temp = one / max( abs( s( je, je ) )*ascale,abs( p( je, je ) )*bscale, safmin &
                              )
                    salfar = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*p( je, je ) )*bscale
                    acoef = sbeta*ascale
                    bcoefr = salfar*bscale
                    bcoefi = zero
                    ! scale to avoid underflow
                    scale = one
                    lsa = abs( sbeta )>=safmin .and. abs( acoef )<small
                    lsb = abs( salfar )>=safmin .and. abs( bcoefr )<small
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs( salfar ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoef ),abs( bcoefr ) ) ) &
                                 )
                       if( lsa ) then
                          acoef = ascale*( scale*sbeta )
                       else
                          acoef = scale*acoef
                       end if
                       if( lsb ) then
                          bcoefr = bscale*( scale*salfar )
                       else
                          bcoefr = scale*bcoefr
                       end if
                    end if
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr )
                    ! first component is 1
                    work( 2*n+je ) = one
                    xmax = one
                    ! compute contribution from column je of a and b to sum
                    ! (see "further details", above.)
                    do jr = 1, je - 1
                       work( 2*n+jr ) = bcoefr*p( jr, je ) -acoef*s( jr, je )
                    end do
                 else
                    ! complex eigenvalue
                    call stdlib_dlag2( s( je-1, je-1 ), lds, p( je-1, je-1 ), ldp,safmin*safety, &
                              acoef, temp, bcoefr, temp2,bcoefi )
                    if( bcoefi==zero ) then
                       info = je - 1
                       return
                    end if
                    ! scale to avoid over/underflow
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr ) + abs( bcoefi )
                    scale = one
                    if( acoefa*ulp<safmin .and. acoefa>=safmin )scale = ( safmin / ulp ) / &
                              acoefa
                    if( bcoefa*ulp<safmin .and. bcoefa>=safmin )scale = max( scale, ( safmin / &
                              ulp ) / bcoefa )
                    if( safmin*acoefa>ascale )scale = ascale / ( safmin*acoefa )
                    if( safmin*bcoefa>bscale )scale = min( scale, bscale / ( safmin*bcoefa ) )
                              
                    if( scale/=one ) then
                       acoef = scale*acoef
                       acoefa = abs( acoef )
                       bcoefr = scale*bcoefr
                       bcoefi = scale*bcoefi
                       bcoefa = abs( bcoefr ) + abs( bcoefi )
                    end if
                    ! compute first two components of eigenvector
                    ! and contribution to sums
                    temp = acoef*s( je, je-1 )
                    temp2r = acoef*s( je, je ) - bcoefr*p( je, je )
                    temp2i = -bcoefi*p( je, je )
                    if( abs( temp )>=abs( temp2r )+abs( temp2i ) ) then
                       work( 2*n+je ) = one
                       work( 3*n+je ) = zero
                       work( 2*n+je-1 ) = -temp2r / temp
                       work( 3*n+je-1 ) = -temp2i / temp
                    else
                       work( 2*n+je-1 ) = one
                       work( 3*n+je-1 ) = zero
                       temp = acoef*s( je-1, je )
                       work( 2*n+je ) = ( bcoefr*p( je-1, je-1 )-acoef*s( je-1, je-1 ) ) / &
                                 temp
                       work( 3*n+je ) = bcoefi*p( je-1, je-1 ) / temp
                    end if
                    xmax = max( abs( work( 2*n+je ) )+abs( work( 3*n+je ) ),abs( work( 2*n+je-1 ) &
                              )+abs( work( 3*n+je-1 ) ) )
                    ! compute contribution from columns je and je-1
                    ! of a and b to the sums.
                    creala = acoef*work( 2*n+je-1 )
                    cimaga = acoef*work( 3*n+je-1 )
                    crealb = bcoefr*work( 2*n+je-1 ) -bcoefi*work( 3*n+je-1 )
                    cimagb = bcoefi*work( 2*n+je-1 ) +bcoefr*work( 3*n+je-1 )
                    cre2a = acoef*work( 2*n+je )
                    cim2a = acoef*work( 3*n+je )
                    cre2b = bcoefr*work( 2*n+je ) - bcoefi*work( 3*n+je )
                    cim2b = bcoefi*work( 2*n+je ) + bcoefr*work( 3*n+je )
                    do jr = 1, je - 2
                       work( 2*n+jr ) = -creala*s( jr, je-1 ) +crealb*p( jr, je-1 ) -cre2a*s( jr, &
                                 je ) + cre2b*p( jr, je )
                       work( 3*n+jr ) = -cimaga*s( jr, je-1 ) +cimagb*p( jr, je-1 ) -cim2a*s( jr, &
                                 je ) + cim2b*p( jr, je )
                    end do
                 end if
                 dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                 ! columnwise triangular solve of  (a a - b b)  x = 0
                 il2by2 = .false.
                 loop_370: do j = je - nw, 1, -1
                    ! if a 2-by-2 block, is in position j-1:j, wait until
                    ! next iteration to process it (when it will be j:j+1)
                    if( .not.il2by2 .and. j>1 ) then
                       if( s( j, j-1 )/=zero ) then
                          il2by2 = .true.
                          cycle loop_370
                       end if
                    end if
                    bdiag( 1 ) = p( j, j )
                    if( il2by2 ) then
                       na = 2
                       bdiag( 2 ) = p( j+1, j+1 )
                    else
                       na = 1
                    end if
                    ! compute x(j) (and x(j+1), if 2-by-2 block)
                    call stdlib_dlaln2( .false., na, nw, dmin, acoef, s( j, j ),lds, bdiag( 1 ), &
                    bdiag( 2 ), work( 2*n+j ),n, bcoefr, bcoefi, sum, 2, scale, temp,iinfo )
                              
                    if( scale<one ) then
                       do jw = 0, nw - 1
                          do jr = 1, je
                             work( ( jw+2 )*n+jr ) = scale*work( ( jw+2 )*n+jr )
                          end do
                       end do
                    end if
                    xmax = max( scale*xmax, temp )
                    do jw = 1, nw
                       do ja = 1, na
                          work( ( jw+1 )*n+j+ja-1 ) = sum( ja, jw )
                       end do
                    end do
                    ! w = w + x(j)*(a s(*,j) - b p(*,j) ) with scaling
                    if( j>1 ) then
                       ! check whether scaling is necessary for sum.
                       xscale = one / max( one, xmax )
                       temp = acoefa*work( j ) + bcoefa*work( n+j )
                       if( il2by2 )temp = max( temp, acoefa*work( j+1 )+bcoefa*work( n+j+1 ) )
                                 
                       temp = max( temp, acoefa, bcoefa )
                       if( temp>bignum*xscale ) then
                          do jw = 0, nw - 1
                             do jr = 1, je
                                work( ( jw+2 )*n+jr ) = xscale*work( ( jw+2 )*n+jr )
                             end do
                          end do
                          xmax = xmax*xscale
                       end if
                       ! compute the contributions of the off-diagonals of
                       ! column j (and j+1, if 2-by-2 block) of a and b to the
                       ! sums.
                       do ja = 1, na
                          if( ilcplx ) then
                             creala = acoef*work( 2*n+j+ja-1 )
                             cimaga = acoef*work( 3*n+j+ja-1 )
                             crealb = bcoefr*work( 2*n+j+ja-1 ) -bcoefi*work( 3*n+j+ja-1 )
                             cimagb = bcoefi*work( 2*n+j+ja-1 ) +bcoefr*work( 3*n+j+ja-1 )
                             do jr = 1, j - 1
                                work( 2*n+jr ) = work( 2*n+jr ) -creala*s( jr, j+ja-1 ) +crealb*p(&
                                           jr, j+ja-1 )
                                work( 3*n+jr ) = work( 3*n+jr ) -cimaga*s( jr, j+ja-1 ) +cimagb*p(&
                                           jr, j+ja-1 )
                             end do
                          else
                             creala = acoef*work( 2*n+j+ja-1 )
                             crealb = bcoefr*work( 2*n+j+ja-1 )
                             do jr = 1, j - 1
                                work( 2*n+jr ) = work( 2*n+jr ) -creala*s( jr, j+ja-1 ) +crealb*p(&
                                           jr, j+ja-1 )
                             end do
                          end if
                       end do
                    end if
                    il2by2 = .false.
                 end do loop_370
                 ! copy eigenvector to vr, back transforming if
                 ! howmny='b'.
                 ieig = ieig - nw
                 if( ilback ) then
                    do jw = 0, nw - 1
                       do jr = 1, n
                          work( ( jw+4 )*n+jr ) = work( ( jw+2 )*n+1 )*vr( jr, 1 )
                       end do
                       ! a series of compiler directives to defeat
                       ! vectorization for the next loop
                       do jc = 2, je
                          do jr = 1, n
                             work( ( jw+4 )*n+jr ) = work( ( jw+4 )*n+jr ) +work( ( jw+2 )*n+jc )&
                                       *vr( jr, jc )
                          end do
                       end do
                    end do
                    do jw = 0, nw - 1
                       do jr = 1, n
                          vr( jr, ieig+jw ) = work( ( jw+4 )*n+jr )
                       end do
                    end do
                    iend = n
                 else
                    do jw = 0, nw - 1
                       do jr = 1, n
                          vr( jr, ieig+jw ) = work( ( jw+2 )*n+jr )
                       end do
                    end do
                    iend = je
                 end if
                 ! scale eigenvector
                 xmax = zero
                 if( ilcplx ) then
                    do j = 1, iend
                       xmax = max( xmax, abs( vr( j, ieig ) )+abs( vr( j, ieig+1 ) ) )
                    end do
                 else
                    do j = 1, iend
                       xmax = max( xmax, abs( vr( j, ieig ) ) )
                    end do
                 end if
                 if( xmax>safmin ) then
                    xscale = one / xmax
                    do jw = 0, nw - 1
                       do jr = 1, iend
                          vr( jr, ieig+jw ) = xscale*vr( jr, ieig+jw )
                       end do
                    end do
                 end if
              end do loop_500
           end if
           return
     end subroutine stdlib_dtgevc

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$tgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr, &
     !! DTGEVC: computes some or all of the right and/or left eigenvectors of
     !! a pair of real matrices (S,P), where S is a quasi-triangular matrix
     !! and P is upper triangular.  Matrix pairs of this type are produced by
     !! the generalized Schur factorization of a matrix pair (A,B):
     !! A = Q*S*Z**T,  B = Q*P*Z**T
     !! as computed by DGGHRD + DHGEQZ.
     !! The right eigenvector x and the left eigenvector y of (S,P)
     !! corresponding to an eigenvalue w are defined by:
     !! S*x = w*P*x,  (y**H)*S = w*(y**H)*P,
     !! where y**H denotes the conjugate tranpose of y.
     !! The eigenvalues are not input to this routine, but are computed
     !! directly from the diagonal blocks of S and P.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of (S,P), or the products Z*X and/or Q*Y,
     !! where Z and Q are input matrices.
     !! If Q and Z are the orthogonal factors from the generalized Schur
     !! factorization of a matrix pair (A,B), then Z*X and Q*Y
     !! are the matrices of right and left eigenvectors of (A,B).
               mm, m, work, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldp, lds, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(${rk}$), intent(in) :: p(ldp,*), s(lds,*)
           real(${rk}$), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: safety = 1.0e+2_${rk}$
           
           ! Local Scalars 
           logical(lk) :: compl, compr, il2by2, ilabad, ilall, ilback, ilbbad, ilcomp, ilcplx, &
                     lsa, lsb
           integer(ilp) :: i, ibeg, ieig, iend, ihwmny, iinfo, im, iside, j, ja, jc, je, jr, jw, &
                     na, nw
           real(${rk}$) :: acoef, acoefa, anorm, ascale, bcoefa, bcoefi, bcoefr, big, bignum, bnorm, &
           bscale, cim2a, cim2b, cimaga, cimagb, cre2a, cre2b, creala, crealb, dmin, safmin, &
                     salfar, sbeta, scale, small, temp, temp2, temp2i, temp2r, ulp, xmax, xscale
           ! Local Arrays 
           real(${rk}$) :: bdiag(2), sum(2,2), sums(2,2), sump(2,2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           if( stdlib_lsame( howmny, 'A' ) ) then
              ihwmny = 1
              ilall = .true.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'S' ) ) then
              ihwmny = 2
              ilall = .false.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'B' ) ) then
              ihwmny = 3
              ilall = .true.
              ilback = .true.
           else
              ihwmny = -1
              ilall = .true.
           end if
           if( stdlib_lsame( side, 'R' ) ) then
              iside = 1
              compl = .false.
              compr = .true.
           else if( stdlib_lsame( side, 'L' ) ) then
              iside = 2
              compl = .true.
              compr = .false.
           else if( stdlib_lsame( side, 'B' ) ) then
              iside = 3
              compl = .true.
              compr = .true.
           else
              iside = -1
           end if
           info = 0
           if( iside<0 ) then
              info = -1
           else if( ihwmny<0 ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lds<max( 1, n ) ) then
              info = -6
           else if( ldp<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGEVC', -info )
              return
           end if
           ! count the number of eigenvectors to be computed
           if( .not.ilall ) then
              im = 0
              ilcplx = .false.
              loop_10: do j = 1, n
                 if( ilcplx ) then
                    ilcplx = .false.
                    cycle loop_10
                 end if
                 if( j<n ) then
                    if( s( j+1, j )/=zero )ilcplx = .true.
                 end if
                 if( ilcplx ) then
                    if( select( j ) .or. select( j+1 ) )im = im + 2
                 else
                    if( select( j ) )im = im + 1
                 end if
              end do loop_10
           else
              im = n
           end if
           ! check 2-by-2 diagonal blocks of a, b
           ilabad = .false.
           ilbbad = .false.
           do j = 1, n - 1
              if( s( j+1, j )/=zero ) then
                 if( p( j, j )==zero .or. p( j+1, j+1 )==zero .or.p( j, j+1 )/=zero )ilbbad = &
                           .true.
                 if( j<n-1 ) then
                    if( s( j+2, j+1 )/=zero )ilabad = .true.
                 end if
              end if
           end do
           if( ilabad ) then
              info = -5
           else if( ilbbad ) then
              info = -7
           else if( compl .and. ldvl<n .or. ldvl<1 ) then
              info = -10
           else if( compr .and. ldvr<n .or. ldvr<1 ) then
              info = -12
           else if( mm<im ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGEVC', -info )
              return
           end if
           ! quick return if possible
           m = im
           if( n==0 )return
           ! machine constants
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           big = one / safmin
           call stdlib_${ri}$labad( safmin, big )
           ulp = stdlib_${ri}$lamch( 'EPSILON' )*stdlib_${ri}$lamch( 'BASE' )
           small = safmin*n / ulp
           big = one / small
           bignum = one / ( safmin*n )
           ! compute the 1-norm of each column of the strictly upper triangular
           ! part (i.e., excluding all elements belonging to the diagonal
           ! blocks) of a and b to check for possible overflow in the
           ! triangular solver.
           anorm = abs( s( 1, 1 ) )
           if( n>1 )anorm = anorm + abs( s( 2, 1 ) )
           bnorm = abs( p( 1, 1 ) )
           work( 1 ) = zero
           work( n+1 ) = zero
           do j = 2, n
              temp = zero
              temp2 = zero
              if( s( j, j-1 )==zero ) then
                 iend = j - 1
              else
                 iend = j - 2
              end if
              do i = 1, iend
                 temp = temp + abs( s( i, j ) )
                 temp2 = temp2 + abs( p( i, j ) )
              end do
              work( j ) = temp
              work( n+j ) = temp2
              do i = iend + 1, min( j+1, n )
                 temp = temp + abs( s( i, j ) )
                 temp2 = temp2 + abs( p( i, j ) )
              end do
              anorm = max( anorm, temp )
              bnorm = max( bnorm, temp2 )
           end do
           ascale = one / max( anorm, safmin )
           bscale = one / max( bnorm, safmin )
           ! left eigenvectors
           if( compl ) then
              ieig = 0
              ! main loop over eigenvalues
              ilcplx = .false.
              loop_220: do je = 1, n
                 ! skip this iteration if (a) howmny='s' and select=.false., or
                 ! (b) this would be the second of a complex pair.
                 ! check for complex eigenvalue, so as to be sure of which
                 ! entry(-ies) of select to look at.
                 if( ilcplx ) then
                    ilcplx = .false.
                    cycle loop_220
                 end if
                 nw = 1
                 if( je<n ) then
                    if( s( je+1, je )/=zero ) then
                       ilcplx = .true.
                       nw = 2
                    end if
                 end if
                 if( ilall ) then
                    ilcomp = .true.
                 else if( ilcplx ) then
                    ilcomp = select( je ) .or. select( je+1 )
                 else
                    ilcomp = select( je )
                 end if
                 if( .not.ilcomp )cycle loop_220
                 ! decide if (a) singular pencil, (b) real eigenvalue, or
                 ! (c) complex eigenvalue.
                 if( .not.ilcplx ) then
                    if( abs( s( je, je ) )<=safmin .and.abs( p( je, je ) )<=safmin ) then
                       ! singular matrix pencil -- return unit eigenvector
                       ieig = ieig + 1
                       do jr = 1, n
                          vl( jr, ieig ) = zero
                       end do
                       vl( ieig, ieig ) = one
                       cycle loop_220
                    end if
                 end if
                 ! clear vector
                 do jr = 1, nw*n
                    work( 2*n+jr ) = zero
                 end do
                                                       ! t
                 ! compute coefficients in  ( a a - b b )  y = 0
                    ! a  is  acoef
                    ! b  is  bcoefr + i*bcoefi
                 if( .not.ilcplx ) then
                    ! real eigenvalue
                    temp = one / max( abs( s( je, je ) )*ascale,abs( p( je, je ) )*bscale, safmin &
                              )
                    salfar = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*p( je, je ) )*bscale
                    acoef = sbeta*ascale
                    bcoefr = salfar*bscale
                    bcoefi = zero
                    ! scale to avoid underflow
                    scale = one
                    lsa = abs( sbeta )>=safmin .and. abs( acoef )<small
                    lsb = abs( salfar )>=safmin .and. abs( bcoefr )<small
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs( salfar ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoef ),abs( bcoefr ) ) ) &
                                 )
                       if( lsa ) then
                          acoef = ascale*( scale*sbeta )
                       else
                          acoef = scale*acoef
                       end if
                       if( lsb ) then
                          bcoefr = bscale*( scale*salfar )
                       else
                          bcoefr = scale*bcoefr
                       end if
                    end if
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr )
                    ! first component is 1
                    work( 2*n+je ) = one
                    xmax = one
                 else
                    ! complex eigenvalue
                    call stdlib_${ri}$lag2( s( je, je ), lds, p( je, je ), ldp,safmin*safety, acoef, &
                              temp, bcoefr, temp2,bcoefi )
                    bcoefi = -bcoefi
                    if( bcoefi==zero ) then
                       info = je
                       return
                    end if
                    ! scale to avoid over/underflow
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr ) + abs( bcoefi )
                    scale = one
                    if( acoefa*ulp<safmin .and. acoefa>=safmin )scale = ( safmin / ulp ) / &
                              acoefa
                    if( bcoefa*ulp<safmin .and. bcoefa>=safmin )scale = max( scale, ( safmin / &
                              ulp ) / bcoefa )
                    if( safmin*acoefa>ascale )scale = ascale / ( safmin*acoefa )
                    if( safmin*bcoefa>bscale )scale = min( scale, bscale / ( safmin*bcoefa ) )
                              
                    if( scale/=one ) then
                       acoef = scale*acoef
                       acoefa = abs( acoef )
                       bcoefr = scale*bcoefr
                       bcoefi = scale*bcoefi
                       bcoefa = abs( bcoefr ) + abs( bcoefi )
                    end if
                    ! compute first two components of eigenvector
                    temp = acoef*s( je+1, je )
                    temp2r = acoef*s( je, je ) - bcoefr*p( je, je )
                    temp2i = -bcoefi*p( je, je )
                    if( abs( temp )>abs( temp2r )+abs( temp2i ) ) then
                       work( 2*n+je ) = one
                       work( 3*n+je ) = zero
                       work( 2*n+je+1 ) = -temp2r / temp
                       work( 3*n+je+1 ) = -temp2i / temp
                    else
                       work( 2*n+je+1 ) = one
                       work( 3*n+je+1 ) = zero
                       temp = acoef*s( je, je+1 )
                       work( 2*n+je ) = ( bcoefr*p( je+1, je+1 )-acoef*s( je+1, je+1 ) ) / &
                                 temp
                       work( 3*n+je ) = bcoefi*p( je+1, je+1 ) / temp
                    end if
                    xmax = max( abs( work( 2*n+je ) )+abs( work( 3*n+je ) ),abs( work( 2*n+je+1 ) &
                              )+abs( work( 3*n+je+1 ) ) )
                 end if
                 dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                                                 ! t
                 ! triangular solve of  (a a - b b)  y = 0
                                         ! t
                 ! (rowwise in  (a a - b b) , or columnwise in (a a - b b) )
                 il2by2 = .false.
                 loop_160: do j = je + nw, n
                    if( il2by2 ) then
                       il2by2 = .false.
                       cycle loop_160
                    end if
                    na = 1
                    bdiag( 1 ) = p( j, j )
                    if( j<n ) then
                       if( s( j+1, j )/=zero ) then
                          il2by2 = .true.
                          bdiag( 2 ) = p( j+1, j+1 )
                          na = 2
                       end if
                    end if
                    ! check whether scaling is necessary for dot products
                    xscale = one / max( one, xmax )
                    temp = max( work( j ), work( n+j ),acoefa*work( j )+bcoefa*work( n+j ) )
                              
                    if( il2by2 )temp = max( temp, work( j+1 ), work( n+j+1 ),acoefa*work( j+1 )+&
                              bcoefa*work( n+j+1 ) )
                    if( temp>bignum*xscale ) then
                       do jw = 0, nw - 1
                          do jr = je, j - 1
                             work( ( jw+2 )*n+jr ) = xscale*work( ( jw+2 )*n+jr )
                          end do
                       end do
                       xmax = xmax*xscale
                    end if
                    ! compute dot products
                          ! j-1
                    ! sum = sum  conjg( a*s(k,j) - b*p(k,j) )*x(k)
                          ! k=je
                    ! to reduce the op count, this is done as
                    ! _        j-1                  _        j-1
                    ! a*conjg( sum  s(k,j)*x(k) ) - b*conjg( sum  p(k,j)*x(k) )
                             ! k=je                          k=je
                    ! which may cause underflow problems if a or b are close
                    ! to underflow.  (e.g., less than small.)
                    do jw = 1, nw
                       do ja = 1, na
                          sums( ja, jw ) = zero
                          sump( ja, jw ) = zero
                          do jr = je, j - 1
                             sums( ja, jw ) = sums( ja, jw ) +s( jr, j+ja-1 )*work( ( jw+1 )*n+jr &
                                       )
                             sump( ja, jw ) = sump( ja, jw ) +p( jr, j+ja-1 )*work( ( jw+1 )*n+jr &
                                       )
                          end do
                       end do
                    end do
                    do ja = 1, na
                       if( ilcplx ) then
                          sum( ja, 1 ) = -acoef*sums( ja, 1 ) +bcoefr*sump( ja, 1 ) -bcoefi*sump( &
                                    ja, 2 )
                          sum( ja, 2 ) = -acoef*sums( ja, 2 ) +bcoefr*sump( ja, 2 ) +bcoefi*sump( &
                                    ja, 1 )
                       else
                          sum( ja, 1 ) = -acoef*sums( ja, 1 ) +bcoefr*sump( ja, 1 )
                       end if
                    end do
                                        ! t
                    ! solve  ( a a - b b )  y = sum(,)
                    ! with scaling and perturbation of the denominator
                    call stdlib_${ri}$laln2( .true., na, nw, dmin, acoef, s( j, j ), lds,bdiag( 1 ), &
                    bdiag( 2 ), sum, 2, bcoefr,bcoefi, work( 2*n+j ), n, scale, temp,iinfo )
                              
                    if( scale<one ) then
                       do jw = 0, nw - 1
                          do jr = je, j - 1
                             work( ( jw+2 )*n+jr ) = scale*work( ( jw+2 )*n+jr )
                          end do
                       end do
                       xmax = scale*xmax
                    end if
                    xmax = max( xmax, temp )
                 end do loop_160
                 ! copy eigenvector to vl, back transforming if
                 ! howmny='b'.
                 ieig = ieig + 1
                 if( ilback ) then
                    do jw = 0, nw - 1
                       call stdlib_${ri}$gemv( 'N', n, n+1-je, one, vl( 1, je ), ldvl,work( ( jw+2 )*n+&
                                 je ), 1, zero,work( ( jw+4 )*n+1 ), 1 )
                    end do
                    call stdlib_${ri}$lacpy( ' ', n, nw, work( 4*n+1 ), n, vl( 1, je ),ldvl )
                    ibeg = 1
                 else
                    call stdlib_${ri}$lacpy( ' ', n, nw, work( 2*n+1 ), n, vl( 1, ieig ),ldvl )
                    ibeg = je
                 end if
                 ! scale eigenvector
                 xmax = zero
                 if( ilcplx ) then
                    do j = ibeg, n
                       xmax = max( xmax, abs( vl( j, ieig ) )+abs( vl( j, ieig+1 ) ) )
                    end do
                 else
                    do j = ibeg, n
                       xmax = max( xmax, abs( vl( j, ieig ) ) )
                    end do
                 end if
                 if( xmax>safmin ) then
                    xscale = one / xmax
                    do jw = 0, nw - 1
                       do jr = ibeg, n
                          vl( jr, ieig+jw ) = xscale*vl( jr, ieig+jw )
                       end do
                    end do
                 end if
                 ieig = ieig + nw - 1
              end do loop_220
           end if
           ! right eigenvectors
           if( compr ) then
              ieig = im + 1
              ! main loop over eigenvalues
              ilcplx = .false.
              loop_500: do je = n, 1, -1
                 ! skip this iteration if (a) howmny='s' and select=.false., or
                 ! (b) this would be the second of a complex pair.
                 ! check for complex eigenvalue, so as to be sure of which
                 ! entry(-ies) of select to look at -- if complex, select(je)
                 ! or select(je-1).
                 ! if this is a complex pair, the 2-by-2 diagonal block
                 ! corresponding to the eigenvalue is in rows/columns je-1:je
                 if( ilcplx ) then
                    ilcplx = .false.
                    cycle loop_500
                 end if
                 nw = 1
                 if( je>1 ) then
                    if( s( je, je-1 )/=zero ) then
                       ilcplx = .true.
                       nw = 2
                    end if
                 end if
                 if( ilall ) then
                    ilcomp = .true.
                 else if( ilcplx ) then
                    ilcomp = select( je ) .or. select( je-1 )
                 else
                    ilcomp = select( je )
                 end if
                 if( .not.ilcomp )cycle loop_500
                 ! decide if (a) singular pencil, (b) real eigenvalue, or
                 ! (c) complex eigenvalue.
                 if( .not.ilcplx ) then
                    if( abs( s( je, je ) )<=safmin .and.abs( p( je, je ) )<=safmin ) then
                       ! singular matrix pencil -- unit eigenvector
                       ieig = ieig - 1
                       do jr = 1, n
                          vr( jr, ieig ) = zero
                       end do
                       vr( ieig, ieig ) = one
                       cycle loop_500
                    end if
                 end if
                 ! clear vector
                 do jw = 0, nw - 1
                    do jr = 1, n
                       work( ( jw+2 )*n+jr ) = zero
                    end do
                 end do
                 ! compute coefficients in  ( a a - b b ) x = 0
                    ! a  is  acoef
                    ! b  is  bcoefr + i*bcoefi
                 if( .not.ilcplx ) then
                    ! real eigenvalue
                    temp = one / max( abs( s( je, je ) )*ascale,abs( p( je, je ) )*bscale, safmin &
                              )
                    salfar = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*p( je, je ) )*bscale
                    acoef = sbeta*ascale
                    bcoefr = salfar*bscale
                    bcoefi = zero
                    ! scale to avoid underflow
                    scale = one
                    lsa = abs( sbeta )>=safmin .and. abs( acoef )<small
                    lsb = abs( salfar )>=safmin .and. abs( bcoefr )<small
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs( salfar ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoef ),abs( bcoefr ) ) ) &
                                 )
                       if( lsa ) then
                          acoef = ascale*( scale*sbeta )
                       else
                          acoef = scale*acoef
                       end if
                       if( lsb ) then
                          bcoefr = bscale*( scale*salfar )
                       else
                          bcoefr = scale*bcoefr
                       end if
                    end if
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr )
                    ! first component is 1
                    work( 2*n+je ) = one
                    xmax = one
                    ! compute contribution from column je of a and b to sum
                    ! (see "further details", above.)
                    do jr = 1, je - 1
                       work( 2*n+jr ) = bcoefr*p( jr, je ) -acoef*s( jr, je )
                    end do
                 else
                    ! complex eigenvalue
                    call stdlib_${ri}$lag2( s( je-1, je-1 ), lds, p( je-1, je-1 ), ldp,safmin*safety, &
                              acoef, temp, bcoefr, temp2,bcoefi )
                    if( bcoefi==zero ) then
                       info = je - 1
                       return
                    end if
                    ! scale to avoid over/underflow
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr ) + abs( bcoefi )
                    scale = one
                    if( acoefa*ulp<safmin .and. acoefa>=safmin )scale = ( safmin / ulp ) / &
                              acoefa
                    if( bcoefa*ulp<safmin .and. bcoefa>=safmin )scale = max( scale, ( safmin / &
                              ulp ) / bcoefa )
                    if( safmin*acoefa>ascale )scale = ascale / ( safmin*acoefa )
                    if( safmin*bcoefa>bscale )scale = min( scale, bscale / ( safmin*bcoefa ) )
                              
                    if( scale/=one ) then
                       acoef = scale*acoef
                       acoefa = abs( acoef )
                       bcoefr = scale*bcoefr
                       bcoefi = scale*bcoefi
                       bcoefa = abs( bcoefr ) + abs( bcoefi )
                    end if
                    ! compute first two components of eigenvector
                    ! and contribution to sums
                    temp = acoef*s( je, je-1 )
                    temp2r = acoef*s( je, je ) - bcoefr*p( je, je )
                    temp2i = -bcoefi*p( je, je )
                    if( abs( temp )>=abs( temp2r )+abs( temp2i ) ) then
                       work( 2*n+je ) = one
                       work( 3*n+je ) = zero
                       work( 2*n+je-1 ) = -temp2r / temp
                       work( 3*n+je-1 ) = -temp2i / temp
                    else
                       work( 2*n+je-1 ) = one
                       work( 3*n+je-1 ) = zero
                       temp = acoef*s( je-1, je )
                       work( 2*n+je ) = ( bcoefr*p( je-1, je-1 )-acoef*s( je-1, je-1 ) ) / &
                                 temp
                       work( 3*n+je ) = bcoefi*p( je-1, je-1 ) / temp
                    end if
                    xmax = max( abs( work( 2*n+je ) )+abs( work( 3*n+je ) ),abs( work( 2*n+je-1 ) &
                              )+abs( work( 3*n+je-1 ) ) )
                    ! compute contribution from columns je and je-1
                    ! of a and b to the sums.
                    creala = acoef*work( 2*n+je-1 )
                    cimaga = acoef*work( 3*n+je-1 )
                    crealb = bcoefr*work( 2*n+je-1 ) -bcoefi*work( 3*n+je-1 )
                    cimagb = bcoefi*work( 2*n+je-1 ) +bcoefr*work( 3*n+je-1 )
                    cre2a = acoef*work( 2*n+je )
                    cim2a = acoef*work( 3*n+je )
                    cre2b = bcoefr*work( 2*n+je ) - bcoefi*work( 3*n+je )
                    cim2b = bcoefi*work( 2*n+je ) + bcoefr*work( 3*n+je )
                    do jr = 1, je - 2
                       work( 2*n+jr ) = -creala*s( jr, je-1 ) +crealb*p( jr, je-1 ) -cre2a*s( jr, &
                                 je ) + cre2b*p( jr, je )
                       work( 3*n+jr ) = -cimaga*s( jr, je-1 ) +cimagb*p( jr, je-1 ) -cim2a*s( jr, &
                                 je ) + cim2b*p( jr, je )
                    end do
                 end if
                 dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                 ! columnwise triangular solve of  (a a - b b)  x = 0
                 il2by2 = .false.
                 loop_370: do j = je - nw, 1, -1
                    ! if a 2-by-2 block, is in position j-1:j, wait until
                    ! next iteration to process it (when it will be j:j+1)
                    if( .not.il2by2 .and. j>1 ) then
                       if( s( j, j-1 )/=zero ) then
                          il2by2 = .true.
                          cycle loop_370
                       end if
                    end if
                    bdiag( 1 ) = p( j, j )
                    if( il2by2 ) then
                       na = 2
                       bdiag( 2 ) = p( j+1, j+1 )
                    else
                       na = 1
                    end if
                    ! compute x(j) (and x(j+1), if 2-by-2 block)
                    call stdlib_${ri}$laln2( .false., na, nw, dmin, acoef, s( j, j ),lds, bdiag( 1 ), &
                    bdiag( 2 ), work( 2*n+j ),n, bcoefr, bcoefi, sum, 2, scale, temp,iinfo )
                              
                    if( scale<one ) then
                       do jw = 0, nw - 1
                          do jr = 1, je
                             work( ( jw+2 )*n+jr ) = scale*work( ( jw+2 )*n+jr )
                          end do
                       end do
                    end if
                    xmax = max( scale*xmax, temp )
                    do jw = 1, nw
                       do ja = 1, na
                          work( ( jw+1 )*n+j+ja-1 ) = sum( ja, jw )
                       end do
                    end do
                    ! w = w + x(j)*(a s(*,j) - b p(*,j) ) with scaling
                    if( j>1 ) then
                       ! check whether scaling is necessary for sum.
                       xscale = one / max( one, xmax )
                       temp = acoefa*work( j ) + bcoefa*work( n+j )
                       if( il2by2 )temp = max( temp, acoefa*work( j+1 )+bcoefa*work( n+j+1 ) )
                                 
                       temp = max( temp, acoefa, bcoefa )
                       if( temp>bignum*xscale ) then
                          do jw = 0, nw - 1
                             do jr = 1, je
                                work( ( jw+2 )*n+jr ) = xscale*work( ( jw+2 )*n+jr )
                             end do
                          end do
                          xmax = xmax*xscale
                       end if
                       ! compute the contributions of the off-diagonals of
                       ! column j (and j+1, if 2-by-2 block) of a and b to the
                       ! sums.
                       do ja = 1, na
                          if( ilcplx ) then
                             creala = acoef*work( 2*n+j+ja-1 )
                             cimaga = acoef*work( 3*n+j+ja-1 )
                             crealb = bcoefr*work( 2*n+j+ja-1 ) -bcoefi*work( 3*n+j+ja-1 )
                             cimagb = bcoefi*work( 2*n+j+ja-1 ) +bcoefr*work( 3*n+j+ja-1 )
                             do jr = 1, j - 1
                                work( 2*n+jr ) = work( 2*n+jr ) -creala*s( jr, j+ja-1 ) +crealb*p(&
                                           jr, j+ja-1 )
                                work( 3*n+jr ) = work( 3*n+jr ) -cimaga*s( jr, j+ja-1 ) +cimagb*p(&
                                           jr, j+ja-1 )
                             end do
                          else
                             creala = acoef*work( 2*n+j+ja-1 )
                             crealb = bcoefr*work( 2*n+j+ja-1 )
                             do jr = 1, j - 1
                                work( 2*n+jr ) = work( 2*n+jr ) -creala*s( jr, j+ja-1 ) +crealb*p(&
                                           jr, j+ja-1 )
                             end do
                          end if
                       end do
                    end if
                    il2by2 = .false.
                 end do loop_370
                 ! copy eigenvector to vr, back transforming if
                 ! howmny='b'.
                 ieig = ieig - nw
                 if( ilback ) then
                    do jw = 0, nw - 1
                       do jr = 1, n
                          work( ( jw+4 )*n+jr ) = work( ( jw+2 )*n+1 )*vr( jr, 1 )
                       end do
                       ! a series of compiler directives to defeat
                       ! vectorization for the next loop
                       do jc = 2, je
                          do jr = 1, n
                             work( ( jw+4 )*n+jr ) = work( ( jw+4 )*n+jr ) +work( ( jw+2 )*n+jc )&
                                       *vr( jr, jc )
                          end do
                       end do
                    end do
                    do jw = 0, nw - 1
                       do jr = 1, n
                          vr( jr, ieig+jw ) = work( ( jw+4 )*n+jr )
                       end do
                    end do
                    iend = n
                 else
                    do jw = 0, nw - 1
                       do jr = 1, n
                          vr( jr, ieig+jw ) = work( ( jw+2 )*n+jr )
                       end do
                    end do
                    iend = je
                 end if
                 ! scale eigenvector
                 xmax = zero
                 if( ilcplx ) then
                    do j = 1, iend
                       xmax = max( xmax, abs( vr( j, ieig ) )+abs( vr( j, ieig+1 ) ) )
                    end do
                 else
                    do j = 1, iend
                       xmax = max( xmax, abs( vr( j, ieig ) ) )
                    end do
                 end if
                 if( xmax>safmin ) then
                    xscale = one / xmax
                    do jw = 0, nw - 1
                       do jr = 1, iend
                          vr( jr, ieig+jw ) = xscale*vr( jr, ieig+jw )
                       end do
                    end do
                 end if
              end do loop_500
           end if
           return
     end subroutine stdlib_${ri}$tgevc

#:endif
#:endfor

     module pure subroutine stdlib_ctgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr, &
     !! CTGEVC computes some or all of the right and/or left eigenvectors of
     !! a pair of complex matrices (S,P), where S and P are upper triangular.
     !! Matrix pairs of this type are produced by the generalized Schur
     !! factorization of a complex matrix pair (A,B):
     !! A = Q*S*Z**H,  B = Q*P*Z**H
     !! as computed by CGGHRD + CHGEQZ.
     !! The right eigenvector x and the left eigenvector y of (S,P)
     !! corresponding to an eigenvalue w are defined by:
     !! S*x = w*P*x,  (y**H)*S = w*(y**H)*P,
     !! where y**H denotes the conjugate tranpose of y.
     !! The eigenvalues are not input to this routine, but are computed
     !! directly from the diagonal elements of S and P.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of (S,P), or the products Z*X and/or Q*Y,
     !! where Z and Q are input matrices.
     !! If Q and Z are the unitary factors from the generalized Schur
     !! factorization of a matrix pair (A,B), then Z*X and Q*Y
     !! are the matrices of right and left eigenvectors of (A,B).
               mm, m, work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldp, lds, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(in) :: p(ldp,*), s(lds,*)
           complex(sp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: compl, compr, ilall, ilback, ilbbad, ilcomp, lsa, lsb
           integer(ilp) :: i, ibeg, ieig, iend, ihwmny, im, iside, isrc, j, je, jr
           real(sp) :: acoefa, acoeff, anorm, ascale, bcoefa, big, bignum, bnorm, bscale, dmin, &
                     safmin, sbeta, scale, small, temp, ulp, xmax
           complex(sp) :: bcoeff, ca, cb, d, salpha, sum, suma, sumb, x
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=sp) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode and test the input parameters
           if( stdlib_lsame( howmny, 'A' ) ) then
              ihwmny = 1
              ilall = .true.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'S' ) ) then
              ihwmny = 2
              ilall = .false.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'B' ) ) then
              ihwmny = 3
              ilall = .true.
              ilback = .true.
           else
              ihwmny = -1
           end if
           if( stdlib_lsame( side, 'R' ) ) then
              iside = 1
              compl = .false.
              compr = .true.
           else if( stdlib_lsame( side, 'L' ) ) then
              iside = 2
              compl = .true.
              compr = .false.
           else if( stdlib_lsame( side, 'B' ) ) then
              iside = 3
              compl = .true.
              compr = .true.
           else
              iside = -1
           end if
           info = 0
           if( iside<0 ) then
              info = -1
           else if( ihwmny<0 ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lds<max( 1, n ) ) then
              info = -6
           else if( ldp<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGEVC', -info )
              return
           end if
           ! count the number of eigenvectors
           if( .not.ilall ) then
              im = 0
              do j = 1, n
                 if( select( j ) )im = im + 1
              end do
           else
              im = n
           end if
           ! check diagonal of b
           ilbbad = .false.
           do j = 1, n
              if( aimag( p( j, j ) )/=zero )ilbbad = .true.
           end do
           if( ilbbad ) then
              info = -7
           else if( compl .and. ldvl<n .or. ldvl<1 ) then
              info = -10
           else if( compr .and. ldvr<n .or. ldvr<1 ) then
              info = -12
           else if( mm<im ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGEVC', -info )
              return
           end if
           ! quick return if possible
           m = im
           if( n==0 )return
           ! machine constants
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           big = one / safmin
           call stdlib_slabad( safmin, big )
           ulp = stdlib_slamch( 'EPSILON' )*stdlib_slamch( 'BASE' )
           small = safmin*n / ulp
           big = one / small
           bignum = one / ( safmin*n )
           ! compute the 1-norm of each column of the strictly upper triangular
           ! part of a and b to check for possible overflow in the triangular
           ! solver.
           anorm = abs1( s( 1, 1 ) )
           bnorm = abs1( p( 1, 1 ) )
           rwork( 1 ) = zero
           rwork( n+1 ) = zero
           do j = 2, n
              rwork( j ) = zero
              rwork( n+j ) = zero
              do i = 1, j - 1
                 rwork( j ) = rwork( j ) + abs1( s( i, j ) )
                 rwork( n+j ) = rwork( n+j ) + abs1( p( i, j ) )
              end do
              anorm = max( anorm, rwork( j )+abs1( s( j, j ) ) )
              bnorm = max( bnorm, rwork( n+j )+abs1( p( j, j ) ) )
           end do
           ascale = one / max( anorm, safmin )
           bscale = one / max( bnorm, safmin )
           ! left eigenvectors
           if( compl ) then
              ieig = 0
              ! main loop over eigenvalues
              loop_140: do je = 1, n
                 if( ilall ) then
                    ilcomp = .true.
                 else
                    ilcomp = select( je )
                 end if
                 if( ilcomp ) then
                    ieig = ieig + 1
                    if( abs1( s( je, je ) )<=safmin .and.abs( real( p( je, je ),KIND=sp) )&
                              <=safmin ) then
                       ! singular matrix pencil -- return unit eigenvector
                       do jr = 1, n
                          vl( jr, ieig ) = czero
                       end do
                       vl( ieig, ieig ) = cone
                       cycle loop_140
                    end if
                    ! non-singular eigenvalue:
                    ! compute coefficients  a  and  b  in
                         ! h
                       ! y  ( a a - b b ) = 0
                    temp = one / max( abs1( s( je, je ) )*ascale,abs( real( p( je, je ),KIND=sp) )&
                              *bscale, safmin )
                    salpha = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*real( p( je, je ),KIND=sp) )*bscale
                    acoeff = sbeta*ascale
                    bcoeff = salpha*bscale
                    ! scale to avoid underflow
                    lsa = abs( sbeta )>=safmin .and. abs( acoeff )<small
                    lsb = abs1( salpha )>=safmin .and. abs1( bcoeff )<small
                    scale = one
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs1( salpha ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoeff ),abs1( bcoeff ) ) &
                                 ) )
                       if( lsa ) then
                          acoeff = ascale*( scale*sbeta )
                       else
                          acoeff = scale*acoeff
                       end if
                       if( lsb ) then
                          bcoeff = bscale*( scale*salpha )
                       else
                          bcoeff = scale*bcoeff
                       end if
                    end if
                    acoefa = abs( acoeff )
                    bcoefa = abs1( bcoeff )
                    xmax = one
                    do jr = 1, n
                       work( jr ) = czero
                    end do
                    work( je ) = cone
                    dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                                                    ! h
                    ! triangular solve of  (a a - b b)  y = 0
                                            ! h
                    ! (rowwise in  (a a - b b) , or columnwise in a a - b b)
                    loop_100: do j = je + 1, n
                       ! compute
                             ! j-1
                       ! sum = sum  conjg( a*s(k,j) - b*p(k,j) )*x(k)
                             ! k=je
                       ! (scale if necessary)
                       temp = one / xmax
                       if( acoefa*rwork( j )+bcoefa*rwork( n+j )>bignum*temp ) then
                          do jr = je, j - 1
                             work( jr ) = temp*work( jr )
                          end do
                          xmax = one
                       end if
                       suma = czero
                       sumb = czero
                       do jr = je, j - 1
                          suma = suma + conjg( s( jr, j ) )*work( jr )
                          sumb = sumb + conjg( p( jr, j ) )*work( jr )
                       end do
                       sum = acoeff*suma - conjg( bcoeff )*sumb
                       ! form x(j) = - sum / conjg( a*s(j,j) - b*p(j,j) )
                       ! with scaling and perturbation of the denominator
                       d = conjg( acoeff*s( j, j )-bcoeff*p( j, j ) )
                       if( abs1( d )<=dmin )d = cmplx( dmin,KIND=sp)
                       if( abs1( d )<one ) then
                          if( abs1( sum )>=bignum*abs1( d ) ) then
                             temp = one / abs1( sum )
                             do jr = je, j - 1
                                work( jr ) = temp*work( jr )
                             end do
                             xmax = temp*xmax
                             sum = temp*sum
                          end if
                       end if
                       work( j ) = stdlib_cladiv( -sum, d )
                       xmax = max( xmax, abs1( work( j ) ) )
                    end do loop_100
                    ! back transform eigenvector if howmny='b'.
                    if( ilback ) then
                       call stdlib_cgemv( 'N', n, n+1-je, cone, vl( 1, je ), ldvl,work( je ), 1, &
                                 czero, work( n+1 ), 1 )
                       isrc = 2
                       ibeg = 1
                    else
                       isrc = 1
                       ibeg = je
                    end if
                    ! copy and scale eigenvector into column of vl
                    xmax = zero
                    do jr = ibeg, n
                       xmax = max( xmax, abs1( work( ( isrc-1 )*n+jr ) ) )
                    end do
                    if( xmax>safmin ) then
                       temp = one / xmax
                       do jr = ibeg, n
                          vl( jr, ieig ) = temp*work( ( isrc-1 )*n+jr )
                       end do
                    else
                       ibeg = n + 1
                    end if
                    do jr = 1, ibeg - 1
                       vl( jr, ieig ) = czero
                    end do
                 end if
              end do loop_140
           end if
           ! right eigenvectors
           if( compr ) then
              ieig = im + 1
              ! main loop over eigenvalues
              loop_250: do je = n, 1, -1
                 if( ilall ) then
                    ilcomp = .true.
                 else
                    ilcomp = select( je )
                 end if
                 if( ilcomp ) then
                    ieig = ieig - 1
                    if( abs1( s( je, je ) )<=safmin .and.abs( real( p( je, je ),KIND=sp) )&
                              <=safmin ) then
                       ! singular matrix pencil -- return unit eigenvector
                       do jr = 1, n
                          vr( jr, ieig ) = czero
                       end do
                       vr( ieig, ieig ) = cone
                       cycle loop_250
                    end if
                    ! non-singular eigenvalue:
                    ! compute coefficients  a  and  b  in
                    ! ( a a - b b ) x  = 0
                    temp = one / max( abs1( s( je, je ) )*ascale,abs( real( p( je, je ),KIND=sp) )&
                              *bscale, safmin )
                    salpha = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*real( p( je, je ),KIND=sp) )*bscale
                    acoeff = sbeta*ascale
                    bcoeff = salpha*bscale
                    ! scale to avoid underflow
                    lsa = abs( sbeta )>=safmin .and. abs( acoeff )<small
                    lsb = abs1( salpha )>=safmin .and. abs1( bcoeff )<small
                    scale = one
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs1( salpha ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoeff ),abs1( bcoeff ) ) &
                                 ) )
                       if( lsa ) then
                          acoeff = ascale*( scale*sbeta )
                       else
                          acoeff = scale*acoeff
                       end if
                       if( lsb ) then
                          bcoeff = bscale*( scale*salpha )
                       else
                          bcoeff = scale*bcoeff
                       end if
                    end if
                    acoefa = abs( acoeff )
                    bcoefa = abs1( bcoeff )
                    xmax = one
                    do jr = 1, n
                       work( jr ) = czero
                    end do
                    work( je ) = cone
                    dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                    ! triangular solve of  (a a - b b) x = 0  (columnwise)
                    ! work(1:j-1) contains sums w,
                    ! work(j+1:je) contains x
                    do jr = 1, je - 1
                       work( jr ) = acoeff*s( jr, je ) - bcoeff*p( jr, je )
                    end do
                    work( je ) = cone
                    loop_210: do j = je - 1, 1, -1
                       ! form x(j) := - w(j) / d
                       ! with scaling and perturbation of the denominator
                       d = acoeff*s( j, j ) - bcoeff*p( j, j )
                       if( abs1( d )<=dmin )d = cmplx( dmin,KIND=sp)
                       if( abs1( d )<one ) then
                          if( abs1( work( j ) )>=bignum*abs1( d ) ) then
                             temp = one / abs1( work( j ) )
                             do jr = 1, je
                                work( jr ) = temp*work( jr )
                             end do
                          end if
                       end if
                       work( j ) = stdlib_cladiv( -work( j ), d )
                       if( j>1 ) then
                          ! w = w + x(j)*(a s(*,j) - b p(*,j) ) with scaling
                          if( abs1( work( j ) )>one ) then
                             temp = one / abs1( work( j ) )
                             if( acoefa*rwork( j )+bcoefa*rwork( n+j )>=bignum*temp ) then
                                do jr = 1, je
                                   work( jr ) = temp*work( jr )
                                end do
                             end if
                          end if
                          ca = acoeff*work( j )
                          cb = bcoeff*work( j )
                          do jr = 1, j - 1
                             work( jr ) = work( jr ) + ca*s( jr, j ) -cb*p( jr, j )
                          end do
                       end if
                    end do loop_210
                    ! back transform eigenvector if howmny='b'.
                    if( ilback ) then
                       call stdlib_cgemv( 'N', n, je, cone, vr, ldvr, work, 1,czero, work( n+1 ), &
                                 1 )
                       isrc = 2
                       iend = n
                    else
                       isrc = 1
                       iend = je
                    end if
                    ! copy and scale eigenvector into column of vr
                    xmax = zero
                    do jr = 1, iend
                       xmax = max( xmax, abs1( work( ( isrc-1 )*n+jr ) ) )
                    end do
                    if( xmax>safmin ) then
                       temp = one / xmax
                       do jr = 1, iend
                          vr( jr, ieig ) = temp*work( ( isrc-1 )*n+jr )
                       end do
                    else
                       iend = 0
                    end if
                    do jr = iend + 1, n
                       vr( jr, ieig ) = czero
                    end do
                 end if
              end do loop_250
           end if
           return
     end subroutine stdlib_ctgevc

     module pure subroutine stdlib_ztgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr, &
     !! ZTGEVC computes some or all of the right and/or left eigenvectors of
     !! a pair of complex matrices (S,P), where S and P are upper triangular.
     !! Matrix pairs of this type are produced by the generalized Schur
     !! factorization of a complex matrix pair (A,B):
     !! A = Q*S*Z**H,  B = Q*P*Z**H
     !! as computed by ZGGHRD + ZHGEQZ.
     !! The right eigenvector x and the left eigenvector y of (S,P)
     !! corresponding to an eigenvalue w are defined by:
     !! S*x = w*P*x,  (y**H)*S = w*(y**H)*P,
     !! where y**H denotes the conjugate tranpose of y.
     !! The eigenvalues are not input to this routine, but are computed
     !! directly from the diagonal elements of S and P.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of (S,P), or the products Z*X and/or Q*Y,
     !! where Z and Q are input matrices.
     !! If Q and Z are the unitary factors from the generalized Schur
     !! factorization of a matrix pair (A,B), then Z*X and Q*Y
     !! are the matrices of right and left eigenvectors of (A,B).
               mm, m, work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldp, lds, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(in) :: p(ldp,*), s(lds,*)
           complex(dp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: compl, compr, ilall, ilback, ilbbad, ilcomp, lsa, lsb
           integer(ilp) :: i, ibeg, ieig, iend, ihwmny, im, iside, isrc, j, je, jr
           real(dp) :: acoefa, acoeff, anorm, ascale, bcoefa, big, bignum, bnorm, bscale, dmin, &
                     safmin, sbeta, scale, small, temp, ulp, xmax
           complex(dp) :: bcoeff, ca, cb, d, salpha, sum, suma, sumb, x
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=dp) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode and test the input parameters
           if( stdlib_lsame( howmny, 'A' ) ) then
              ihwmny = 1
              ilall = .true.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'S' ) ) then
              ihwmny = 2
              ilall = .false.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'B' ) ) then
              ihwmny = 3
              ilall = .true.
              ilback = .true.
           else
              ihwmny = -1
           end if
           if( stdlib_lsame( side, 'R' ) ) then
              iside = 1
              compl = .false.
              compr = .true.
           else if( stdlib_lsame( side, 'L' ) ) then
              iside = 2
              compl = .true.
              compr = .false.
           else if( stdlib_lsame( side, 'B' ) ) then
              iside = 3
              compl = .true.
              compr = .true.
           else
              iside = -1
           end if
           info = 0
           if( iside<0 ) then
              info = -1
           else if( ihwmny<0 ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lds<max( 1, n ) ) then
              info = -6
           else if( ldp<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGEVC', -info )
              return
           end if
           ! count the number of eigenvectors
           if( .not.ilall ) then
              im = 0
              do j = 1, n
                 if( select( j ) )im = im + 1
              end do
           else
              im = n
           end if
           ! check diagonal of b
           ilbbad = .false.
           do j = 1, n
              if( aimag( p( j, j ) )/=zero )ilbbad = .true.
           end do
           if( ilbbad ) then
              info = -7
           else if( compl .and. ldvl<n .or. ldvl<1 ) then
              info = -10
           else if( compr .and. ldvr<n .or. ldvr<1 ) then
              info = -12
           else if( mm<im ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGEVC', -info )
              return
           end if
           ! quick return if possible
           m = im
           if( n==0 )return
           ! machine constants
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           big = one / safmin
           call stdlib_dlabad( safmin, big )
           ulp = stdlib_dlamch( 'EPSILON' )*stdlib_dlamch( 'BASE' )
           small = safmin*n / ulp
           big = one / small
           bignum = one / ( safmin*n )
           ! compute the 1-norm of each column of the strictly upper triangular
           ! part of a and b to check for possible overflow in the triangular
           ! solver.
           anorm = abs1( s( 1, 1 ) )
           bnorm = abs1( p( 1, 1 ) )
           rwork( 1 ) = zero
           rwork( n+1 ) = zero
           do j = 2, n
              rwork( j ) = zero
              rwork( n+j ) = zero
              do i = 1, j - 1
                 rwork( j ) = rwork( j ) + abs1( s( i, j ) )
                 rwork( n+j ) = rwork( n+j ) + abs1( p( i, j ) )
              end do
              anorm = max( anorm, rwork( j )+abs1( s( j, j ) ) )
              bnorm = max( bnorm, rwork( n+j )+abs1( p( j, j ) ) )
           end do
           ascale = one / max( anorm, safmin )
           bscale = one / max( bnorm, safmin )
           ! left eigenvectors
           if( compl ) then
              ieig = 0
              ! main loop over eigenvalues
              loop_140: do je = 1, n
                 if( ilall ) then
                    ilcomp = .true.
                 else
                    ilcomp = select( je )
                 end if
                 if( ilcomp ) then
                    ieig = ieig + 1
                    if( abs1( s( je, je ) )<=safmin .and.abs( real( p( je, je ),KIND=dp) )&
                              <=safmin ) then
                       ! singular matrix pencil -- return unit eigenvector
                       do jr = 1, n
                          vl( jr, ieig ) = czero
                       end do
                       vl( ieig, ieig ) = cone
                       cycle loop_140
                    end if
                    ! non-singular eigenvalue:
                    ! compute coefficients  a  and  b  in
                         ! h
                       ! y  ( a a - b b ) = 0
                    temp = one / max( abs1( s( je, je ) )*ascale,abs( real( p( je, je ),KIND=dp) )&
                              *bscale, safmin )
                    salpha = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*real( p( je, je ),KIND=dp) )*bscale
                    acoeff = sbeta*ascale
                    bcoeff = salpha*bscale
                    ! scale to avoid underflow
                    lsa = abs( sbeta )>=safmin .and. abs( acoeff )<small
                    lsb = abs1( salpha )>=safmin .and. abs1( bcoeff )<small
                    scale = one
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs1( salpha ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoeff ),abs1( bcoeff ) ) &
                                 ) )
                       if( lsa ) then
                          acoeff = ascale*( scale*sbeta )
                       else
                          acoeff = scale*acoeff
                       end if
                       if( lsb ) then
                          bcoeff = bscale*( scale*salpha )
                       else
                          bcoeff = scale*bcoeff
                       end if
                    end if
                    acoefa = abs( acoeff )
                    bcoefa = abs1( bcoeff )
                    xmax = one
                    do jr = 1, n
                       work( jr ) = czero
                    end do
                    work( je ) = cone
                    dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                                                    ! h
                    ! triangular solve of  (a a - b b)  y = 0
                                            ! h
                    ! (rowwise in  (a a - b b) , or columnwise in a a - b b)
                    loop_100: do j = je + 1, n
                       ! compute
                             ! j-1
                       ! sum = sum  conjg( a*s(k,j) - b*p(k,j) )*x(k)
                             ! k=je
                       ! (scale if necessary)
                       temp = one / xmax
                       if( acoefa*rwork( j )+bcoefa*rwork( n+j )>bignum*temp ) then
                          do jr = je, j - 1
                             work( jr ) = temp*work( jr )
                          end do
                          xmax = one
                       end if
                       suma = czero
                       sumb = czero
                       do jr = je, j - 1
                          suma = suma + conjg( s( jr, j ) )*work( jr )
                          sumb = sumb + conjg( p( jr, j ) )*work( jr )
                       end do
                       sum = acoeff*suma - conjg( bcoeff )*sumb
                       ! form x(j) = - sum / conjg( a*s(j,j) - b*p(j,j) )
                       ! with scaling and perturbation of the denominator
                       d = conjg( acoeff*s( j, j )-bcoeff*p( j, j ) )
                       if( abs1( d )<=dmin )d = cmplx( dmin,KIND=dp)
                       if( abs1( d )<one ) then
                          if( abs1( sum )>=bignum*abs1( d ) ) then
                             temp = one / abs1( sum )
                             do jr = je, j - 1
                                work( jr ) = temp*work( jr )
                             end do
                             xmax = temp*xmax
                             sum = temp*sum
                          end if
                       end if
                       work( j ) = stdlib_zladiv( -sum, d )
                       xmax = max( xmax, abs1( work( j ) ) )
                    end do loop_100
                    ! back transform eigenvector if howmny='b'.
                    if( ilback ) then
                       call stdlib_zgemv( 'N', n, n+1-je, cone, vl( 1, je ), ldvl,work( je ), 1, &
                                 czero, work( n+1 ), 1 )
                       isrc = 2
                       ibeg = 1
                    else
                       isrc = 1
                       ibeg = je
                    end if
                    ! copy and scale eigenvector into column of vl
                    xmax = zero
                    do jr = ibeg, n
                       xmax = max( xmax, abs1( work( ( isrc-1 )*n+jr ) ) )
                    end do
                    if( xmax>safmin ) then
                       temp = one / xmax
                       do jr = ibeg, n
                          vl( jr, ieig ) = temp*work( ( isrc-1 )*n+jr )
                       end do
                    else
                       ibeg = n + 1
                    end if
                    do jr = 1, ibeg - 1
                       vl( jr, ieig ) = czero
                    end do
                 end if
              end do loop_140
           end if
           ! right eigenvectors
           if( compr ) then
              ieig = im + 1
              ! main loop over eigenvalues
              loop_250: do je = n, 1, -1
                 if( ilall ) then
                    ilcomp = .true.
                 else
                    ilcomp = select( je )
                 end if
                 if( ilcomp ) then
                    ieig = ieig - 1
                    if( abs1( s( je, je ) )<=safmin .and.abs( real( p( je, je ),KIND=dp) )&
                              <=safmin ) then
                       ! singular matrix pencil -- return unit eigenvector
                       do jr = 1, n
                          vr( jr, ieig ) = czero
                       end do
                       vr( ieig, ieig ) = cone
                       cycle loop_250
                    end if
                    ! non-singular eigenvalue:
                    ! compute coefficients  a  and  b  in
                    ! ( a a - b b ) x  = 0
                    temp = one / max( abs1( s( je, je ) )*ascale,abs( real( p( je, je ),KIND=dp) )&
                              *bscale, safmin )
                    salpha = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*real( p( je, je ),KIND=dp) )*bscale
                    acoeff = sbeta*ascale
                    bcoeff = salpha*bscale
                    ! scale to avoid underflow
                    lsa = abs( sbeta )>=safmin .and. abs( acoeff )<small
                    lsb = abs1( salpha )>=safmin .and. abs1( bcoeff )<small
                    scale = one
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs1( salpha ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoeff ),abs1( bcoeff ) ) &
                                 ) )
                       if( lsa ) then
                          acoeff = ascale*( scale*sbeta )
                       else
                          acoeff = scale*acoeff
                       end if
                       if( lsb ) then
                          bcoeff = bscale*( scale*salpha )
                       else
                          bcoeff = scale*bcoeff
                       end if
                    end if
                    acoefa = abs( acoeff )
                    bcoefa = abs1( bcoeff )
                    xmax = one
                    do jr = 1, n
                       work( jr ) = czero
                    end do
                    work( je ) = cone
                    dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                    ! triangular solve of  (a a - b b) x = 0  (columnwise)
                    ! work(1:j-1) contains sums w,
                    ! work(j+1:je) contains x
                    do jr = 1, je - 1
                       work( jr ) = acoeff*s( jr, je ) - bcoeff*p( jr, je )
                    end do
                    work( je ) = cone
                    loop_210: do j = je - 1, 1, -1
                       ! form x(j) := - w(j) / d
                       ! with scaling and perturbation of the denominator
                       d = acoeff*s( j, j ) - bcoeff*p( j, j )
                       if( abs1( d )<=dmin )d = cmplx( dmin,KIND=dp)
                       if( abs1( d )<one ) then
                          if( abs1( work( j ) )>=bignum*abs1( d ) ) then
                             temp = one / abs1( work( j ) )
                             do jr = 1, je
                                work( jr ) = temp*work( jr )
                             end do
                          end if
                       end if
                       work( j ) = stdlib_zladiv( -work( j ), d )
                       if( j>1 ) then
                          ! w = w + x(j)*(a s(*,j) - b p(*,j) ) with scaling
                          if( abs1( work( j ) )>one ) then
                             temp = one / abs1( work( j ) )
                             if( acoefa*rwork( j )+bcoefa*rwork( n+j )>=bignum*temp ) then
                                do jr = 1, je
                                   work( jr ) = temp*work( jr )
                                end do
                             end if
                          end if
                          ca = acoeff*work( j )
                          cb = bcoeff*work( j )
                          do jr = 1, j - 1
                             work( jr ) = work( jr ) + ca*s( jr, j ) -cb*p( jr, j )
                          end do
                       end if
                    end do loop_210
                    ! back transform eigenvector if howmny='b'.
                    if( ilback ) then
                       call stdlib_zgemv( 'N', n, je, cone, vr, ldvr, work, 1,czero, work( n+1 ), &
                                 1 )
                       isrc = 2
                       iend = n
                    else
                       isrc = 1
                       iend = je
                    end if
                    ! copy and scale eigenvector into column of vr
                    xmax = zero
                    do jr = 1, iend
                       xmax = max( xmax, abs1( work( ( isrc-1 )*n+jr ) ) )
                    end do
                    if( xmax>safmin ) then
                       temp = one / xmax
                       do jr = 1, iend
                          vr( jr, ieig ) = temp*work( ( isrc-1 )*n+jr )
                       end do
                    else
                       iend = 0
                    end if
                    do jr = iend + 1, n
                       vr( jr, ieig ) = czero
                    end do
                 end if
              end do loop_250
           end if
           return
     end subroutine stdlib_ztgevc

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$tgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr, &
     !! ZTGEVC: computes some or all of the right and/or left eigenvectors of
     !! a pair of complex matrices (S,P), where S and P are upper triangular.
     !! Matrix pairs of this type are produced by the generalized Schur
     !! factorization of a complex matrix pair (A,B):
     !! A = Q*S*Z**H,  B = Q*P*Z**H
     !! as computed by ZGGHRD + ZHGEQZ.
     !! The right eigenvector x and the left eigenvector y of (S,P)
     !! corresponding to an eigenvalue w are defined by:
     !! S*x = w*P*x,  (y**H)*S = w*(y**H)*P,
     !! where y**H denotes the conjugate tranpose of y.
     !! The eigenvalues are not input to this routine, but are computed
     !! directly from the diagonal elements of S and P.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of (S,P), or the products Z*X and/or Q*Y,
     !! where Z and Q are input matrices.
     !! If Q and Z are the unitary factors from the generalized Schur
     !! factorization of a matrix pair (A,B), then Z*X and Q*Y
     !! are the matrices of right and left eigenvectors of (A,B).
               mm, m, work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldp, lds, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(in) :: p(ldp,*), s(lds,*)
           complex(${ck}$), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: compl, compr, ilall, ilback, ilbbad, ilcomp, lsa, lsb
           integer(ilp) :: i, ibeg, ieig, iend, ihwmny, im, iside, isrc, j, je, jr
           real(${ck}$) :: acoefa, acoeff, anorm, ascale, bcoefa, big, bignum, bnorm, bscale, dmin, &
                     safmin, sbeta, scale, small, temp, ulp, xmax
           complex(${ck}$) :: bcoeff, ca, cb, d, salpha, sum, suma, sumb, x
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=${ck}$) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode and test the input parameters
           if( stdlib_lsame( howmny, 'A' ) ) then
              ihwmny = 1
              ilall = .true.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'S' ) ) then
              ihwmny = 2
              ilall = .false.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'B' ) ) then
              ihwmny = 3
              ilall = .true.
              ilback = .true.
           else
              ihwmny = -1
           end if
           if( stdlib_lsame( side, 'R' ) ) then
              iside = 1
              compl = .false.
              compr = .true.
           else if( stdlib_lsame( side, 'L' ) ) then
              iside = 2
              compl = .true.
              compr = .false.
           else if( stdlib_lsame( side, 'B' ) ) then
              iside = 3
              compl = .true.
              compr = .true.
           else
              iside = -1
           end if
           info = 0
           if( iside<0 ) then
              info = -1
           else if( ihwmny<0 ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lds<max( 1, n ) ) then
              info = -6
           else if( ldp<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGEVC', -info )
              return
           end if
           ! count the number of eigenvectors
           if( .not.ilall ) then
              im = 0
              do j = 1, n
                 if( select( j ) )im = im + 1
              end do
           else
              im = n
           end if
           ! check diagonal of b
           ilbbad = .false.
           do j = 1, n
              if( aimag( p( j, j ) )/=zero )ilbbad = .true.
           end do
           if( ilbbad ) then
              info = -7
           else if( compl .and. ldvl<n .or. ldvl<1 ) then
              info = -10
           else if( compr .and. ldvr<n .or. ldvr<1 ) then
              info = -12
           else if( mm<im ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGEVC', -info )
              return
           end if
           ! quick return if possible
           m = im
           if( n==0 )return
           ! machine constants
           safmin = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           big = one / safmin
           call stdlib_${c2ri(ci)}$labad( safmin, big )
           ulp = stdlib_${c2ri(ci)}$lamch( 'EPSILON' )*stdlib_${c2ri(ci)}$lamch( 'BASE' )
           small = safmin*n / ulp
           big = one / small
           bignum = one / ( safmin*n )
           ! compute the 1-norm of each column of the strictly upper triangular
           ! part of a and b to check for possible overflow in the triangular
           ! solver.
           anorm = abs1( s( 1, 1 ) )
           bnorm = abs1( p( 1, 1 ) )
           rwork( 1 ) = zero
           rwork( n+1 ) = zero
           do j = 2, n
              rwork( j ) = zero
              rwork( n+j ) = zero
              do i = 1, j - 1
                 rwork( j ) = rwork( j ) + abs1( s( i, j ) )
                 rwork( n+j ) = rwork( n+j ) + abs1( p( i, j ) )
              end do
              anorm = max( anorm, rwork( j )+abs1( s( j, j ) ) )
              bnorm = max( bnorm, rwork( n+j )+abs1( p( j, j ) ) )
           end do
           ascale = one / max( anorm, safmin )
           bscale = one / max( bnorm, safmin )
           ! left eigenvectors
           if( compl ) then
              ieig = 0
              ! main loop over eigenvalues
              loop_140: do je = 1, n
                 if( ilall ) then
                    ilcomp = .true.
                 else
                    ilcomp = select( je )
                 end if
                 if( ilcomp ) then
                    ieig = ieig + 1
                    if( abs1( s( je, je ) )<=safmin .and.abs( real( p( je, je ),KIND=${ck}$) )&
                              <=safmin ) then
                       ! singular matrix pencil -- return unit eigenvector
                       do jr = 1, n
                          vl( jr, ieig ) = czero
                       end do
                       vl( ieig, ieig ) = cone
                       cycle loop_140
                    end if
                    ! non-singular eigenvalue:
                    ! compute coefficients  a  and  b  in
                         ! h
                       ! y  ( a a - b b ) = 0
                    temp = one / max( abs1( s( je, je ) )*ascale,abs( real( p( je, je ),KIND=${ck}$) )&
                              *bscale, safmin )
                    salpha = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*real( p( je, je ),KIND=${ck}$) )*bscale
                    acoeff = sbeta*ascale
                    bcoeff = salpha*bscale
                    ! scale to avoid underflow
                    lsa = abs( sbeta )>=safmin .and. abs( acoeff )<small
                    lsb = abs1( salpha )>=safmin .and. abs1( bcoeff )<small
                    scale = one
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs1( salpha ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoeff ),abs1( bcoeff ) ) &
                                 ) )
                       if( lsa ) then
                          acoeff = ascale*( scale*sbeta )
                       else
                          acoeff = scale*acoeff
                       end if
                       if( lsb ) then
                          bcoeff = bscale*( scale*salpha )
                       else
                          bcoeff = scale*bcoeff
                       end if
                    end if
                    acoefa = abs( acoeff )
                    bcoefa = abs1( bcoeff )
                    xmax = one
                    do jr = 1, n
                       work( jr ) = czero
                    end do
                    work( je ) = cone
                    dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                                                    ! h
                    ! triangular solve of  (a a - b b)  y = 0
                                            ! h
                    ! (rowwise in  (a a - b b) , or columnwise in a a - b b)
                    loop_100: do j = je + 1, n
                       ! compute
                             ! j-1
                       ! sum = sum  conjg( a*s(k,j) - b*p(k,j) )*x(k)
                             ! k=je
                       ! (scale if necessary)
                       temp = one / xmax
                       if( acoefa*rwork( j )+bcoefa*rwork( n+j )>bignum*temp ) then
                          do jr = je, j - 1
                             work( jr ) = temp*work( jr )
                          end do
                          xmax = one
                       end if
                       suma = czero
                       sumb = czero
                       do jr = je, j - 1
                          suma = suma + conjg( s( jr, j ) )*work( jr )
                          sumb = sumb + conjg( p( jr, j ) )*work( jr )
                       end do
                       sum = acoeff*suma - conjg( bcoeff )*sumb
                       ! form x(j) = - sum / conjg( a*s(j,j) - b*p(j,j) )
                       ! with scaling and perturbation of the denominator
                       d = conjg( acoeff*s( j, j )-bcoeff*p( j, j ) )
                       if( abs1( d )<=dmin )d = cmplx( dmin,KIND=${ck}$)
                       if( abs1( d )<one ) then
                          if( abs1( sum )>=bignum*abs1( d ) ) then
                             temp = one / abs1( sum )
                             do jr = je, j - 1
                                work( jr ) = temp*work( jr )
                             end do
                             xmax = temp*xmax
                             sum = temp*sum
                          end if
                       end if
                       work( j ) = stdlib_${ci}$ladiv( -sum, d )
                       xmax = max( xmax, abs1( work( j ) ) )
                    end do loop_100
                    ! back transform eigenvector if howmny='b'.
                    if( ilback ) then
                       call stdlib_${ci}$gemv( 'N', n, n+1-je, cone, vl( 1, je ), ldvl,work( je ), 1, &
                                 czero, work( n+1 ), 1 )
                       isrc = 2
                       ibeg = 1
                    else
                       isrc = 1
                       ibeg = je
                    end if
                    ! copy and scale eigenvector into column of vl
                    xmax = zero
                    do jr = ibeg, n
                       xmax = max( xmax, abs1( work( ( isrc-1 )*n+jr ) ) )
                    end do
                    if( xmax>safmin ) then
                       temp = one / xmax
                       do jr = ibeg, n
                          vl( jr, ieig ) = temp*work( ( isrc-1 )*n+jr )
                       end do
                    else
                       ibeg = n + 1
                    end if
                    do jr = 1, ibeg - 1
                       vl( jr, ieig ) = czero
                    end do
                 end if
              end do loop_140
           end if
           ! right eigenvectors
           if( compr ) then
              ieig = im + 1
              ! main loop over eigenvalues
              loop_250: do je = n, 1, -1
                 if( ilall ) then
                    ilcomp = .true.
                 else
                    ilcomp = select( je )
                 end if
                 if( ilcomp ) then
                    ieig = ieig - 1
                    if( abs1( s( je, je ) )<=safmin .and.abs( real( p( je, je ),KIND=${ck}$) )&
                              <=safmin ) then
                       ! singular matrix pencil -- return unit eigenvector
                       do jr = 1, n
                          vr( jr, ieig ) = czero
                       end do
                       vr( ieig, ieig ) = cone
                       cycle loop_250
                    end if
                    ! non-singular eigenvalue:
                    ! compute coefficients  a  and  b  in
                    ! ( a a - b b ) x  = 0
                    temp = one / max( abs1( s( je, je ) )*ascale,abs( real( p( je, je ),KIND=${ck}$) )&
                              *bscale, safmin )
                    salpha = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*real( p( je, je ),KIND=${ck}$) )*bscale
                    acoeff = sbeta*ascale
                    bcoeff = salpha*bscale
                    ! scale to avoid underflow
                    lsa = abs( sbeta )>=safmin .and. abs( acoeff )<small
                    lsb = abs1( salpha )>=safmin .and. abs1( bcoeff )<small
                    scale = one
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs1( salpha ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoeff ),abs1( bcoeff ) ) &
                                 ) )
                       if( lsa ) then
                          acoeff = ascale*( scale*sbeta )
                       else
                          acoeff = scale*acoeff
                       end if
                       if( lsb ) then
                          bcoeff = bscale*( scale*salpha )
                       else
                          bcoeff = scale*bcoeff
                       end if
                    end if
                    acoefa = abs( acoeff )
                    bcoefa = abs1( bcoeff )
                    xmax = one
                    do jr = 1, n
                       work( jr ) = czero
                    end do
                    work( je ) = cone
                    dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                    ! triangular solve of  (a a - b b) x = 0  (columnwise)
                    ! work(1:j-1) contains sums w,
                    ! work(j+1:je) contains x
                    do jr = 1, je - 1
                       work( jr ) = acoeff*s( jr, je ) - bcoeff*p( jr, je )
                    end do
                    work( je ) = cone
                    loop_210: do j = je - 1, 1, -1
                       ! form x(j) := - w(j) / d
                       ! with scaling and perturbation of the denominator
                       d = acoeff*s( j, j ) - bcoeff*p( j, j )
                       if( abs1( d )<=dmin )d = cmplx( dmin,KIND=${ck}$)
                       if( abs1( d )<one ) then
                          if( abs1( work( j ) )>=bignum*abs1( d ) ) then
                             temp = one / abs1( work( j ) )
                             do jr = 1, je
                                work( jr ) = temp*work( jr )
                             end do
                          end if
                       end if
                       work( j ) = stdlib_${ci}$ladiv( -work( j ), d )
                       if( j>1 ) then
                          ! w = w + x(j)*(a s(*,j) - b p(*,j) ) with scaling
                          if( abs1( work( j ) )>one ) then
                             temp = one / abs1( work( j ) )
                             if( acoefa*rwork( j )+bcoefa*rwork( n+j )>=bignum*temp ) then
                                do jr = 1, je
                                   work( jr ) = temp*work( jr )
                                end do
                             end if
                          end if
                          ca = acoeff*work( j )
                          cb = bcoeff*work( j )
                          do jr = 1, j - 1
                             work( jr ) = work( jr ) + ca*s( jr, j ) -cb*p( jr, j )
                          end do
                       end if
                    end do loop_210
                    ! back transform eigenvector if howmny='b'.
                    if( ilback ) then
                       call stdlib_${ci}$gemv( 'N', n, je, cone, vr, ldvr, work, 1,czero, work( n+1 ), &
                                 1 )
                       isrc = 2
                       iend = n
                    else
                       isrc = 1
                       iend = je
                    end if
                    ! copy and scale eigenvector into column of vr
                    xmax = zero
                    do jr = 1, iend
                       xmax = max( xmax, abs1( work( ( isrc-1 )*n+jr ) ) )
                    end do
                    if( xmax>safmin ) then
                       temp = one / xmax
                       do jr = 1, iend
                          vr( jr, ieig ) = temp*work( ( isrc-1 )*n+jr )
                       end do
                    else
                       iend = 0
                    end if
                    do jr = iend + 1, n
                       vr( jr, ieig ) = czero
                    end do
                 end if
              end do loop_250
           end if
           return
     end subroutine stdlib_${ci}$tgevc

#:endif
#:endfor



     module subroutine stdlib_sgges3( jobvsl, jobvsr, sort, selctg, n, a, lda, b,ldb, sdim, alphar, &
     !! SGGES3 computes for a pair of N-by-N real nonsymmetric matrices (A,B),
     !! the generalized eigenvalues, the generalized real Schur form (S,T),
     !! optionally, the left and/or right matrices of Schur vectors (VSL and
     !! VSR). This gives the generalized Schur factorization
     !! (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! quasi-triangular matrix S and the upper triangular matrix T.The
     !! leading columns of VSL and VSR then form an orthonormal basis for the
     !! corresponding left and right eigenspaces (deflating subspaces).
     !! (If only the generalized eigenvalues are needed, use the driver
     !! SGGEV instead, which is faster.)
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0 or both being zero.
     !! A pair of matrices (S,T) is in generalized real Schur form if T is
     !! upper triangular with non-negative diagonal and S is block upper
     !! triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
     !! to real generalized eigenvalues, while 2-by-2 blocks of S will be
     !! "standardized" by making the corresponding elements of T have the
     !! form:
     !! [  a  0  ]
     !! [  0  b  ]
     !! and the pair of corresponding 2-by-2 blocks in S and T will have a
     !! complex conjugate pair of generalized eigenvalues.
               alphai, beta, vsl, ldvsl,vsr, ldvsr, work, lwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: alphai(*), alphar(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), &
                     work(*)
           ! Function Arguments 
           procedure(stdlib_selctg_s) :: selctg
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, lst2sl, &
                     wantst
           integer(ilp) :: i, icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, ip, iright, irows, &
                     itau, iwrk, lwkopt
           real(sp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl, pvsr, safmax, safmin, &
                     smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(sp) :: dif(2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -15
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -17
           else if( lwork<6*n+16 .and. .not.lquery ) then
              info = -19
           end if
           ! compute workspace
           if( info==0 ) then
              call stdlib_sgeqrf( n, n, b, ldb, work, work, -1, ierr )
              lwkopt = max( 6*n+16, 3*n+int( work( 1 ),KIND=ilp) )
              call stdlib_sormqr( 'L', 'T', n, n, n, b, ldb, work, a, lda, work,-1, ierr )
              lwkopt = max( lwkopt, 3*n+int( work( 1 ),KIND=ilp) )
              if( ilvsl ) then
                 call stdlib_sorgqr( n, n, n, vsl, ldvsl, work, work, -1, ierr )
                 lwkopt = max( lwkopt, 3*n+int( work( 1 ),KIND=ilp) )
              end if
              call stdlib_sgghd3( jobvsl, jobvsr, n, 1, n, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr, &
                        work, -1, ierr )
              lwkopt = max( lwkopt, 3*n+int( work( 1 ),KIND=ilp) )
              call stdlib_slaqz0( 'S', jobvsl, jobvsr, n, 1, n, a, lda, b, ldb,alphar, alphai, &
                        beta, vsl, ldvsl, vsr, ldvsr,work, -1, 0, ierr )
              lwkopt = max( lwkopt, 2*n+int( work( 1 ),KIND=ilp) )
              if( wantst ) then
                 call stdlib_stgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb,alphar, alphai, &
                 beta, vsl, ldvsl, vsr, ldvsr,sdim, pvsl, pvsr, dif, work, -1, idum, 1,ierr )
                           
                 lwkopt = max( lwkopt, 2*n+int( work( 1 ),KIND=ilp) )
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGGES3 ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           safmin = stdlib_slamch( 'S' )
           safmax = one / safmin
           call stdlib_slabad( safmin, safmax )
           smlnum = sqrt( safmin ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_slange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_slascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_slange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_slascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ileft = 1
           iright = n + 1
           iwrk = iright + n
           call stdlib_sggbal( 'P', n, a, lda, b, ldb, ilo, ihi, work( ileft ),work( iright ), &
                     work( iwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = iwrk
           iwrk = itau + irows
           call stdlib_sgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           call stdlib_sormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           if( ilvsl ) then
              call stdlib_slaset( 'FULL', n, n, zero, one, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_slacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_sorgqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_slaset( 'FULL', n, n, zero, one, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           call stdlib_sgghd3( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      work( iwrk ), lwork+1-iwrk, ierr )
           ! perform qz algorithm, computing schur vectors if desired
           iwrk = itau
           call stdlib_slaqz0( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vsl, ldvsl, vsr, ldvsr,work( iwrk ), lwork+1-iwrk, 0, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 40
           end if
           ! sort eigenvalues alpha/beta if desired
           sdim = 0
           if( wantst ) then
              ! undo scaling on eigenvalues before selctging
              if( ilascl ) then
                 call stdlib_slascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n,ierr )
                 call stdlib_slascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n,ierr )
              end if
              if( ilbscl )call stdlib_slascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alphar( i ), alphai( i ), beta( i ) )
              end do
              call stdlib_stgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb, alphar,alphai, beta, &
              vsl, ldvsl, vsr, ldvsr, sdim, pvsl,pvsr, dif, work( iwrk ), lwork-iwrk+1, idum, 1,&
                        ierr )
              if( ierr==1 )info = n + 3
           end if
           ! apply back-permutation to vsl and vsr
           if( ilvsl )call stdlib_sggbak( 'P', 'L', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_sggbak( 'P', 'R', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsr, ldvsr, ierr )
           ! check if unscaling would cause over/underflow, if so, rescale
           ! (alphar(i),alphai(i),beta(i)) so beta(i) is on the order of
           ! b(i,i) and alphar(i) and alphai(i) are on the order of a(i,i)
           if( ilascl )then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                    if( ( alphar( i )/safmax )>( anrmto/anrm ) .or.( safmin/alphar( i ) )>( &
                              anrm/anrmto ) ) then
                       work( 1 ) = abs( a( i, i )/alphar( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    else if( ( alphai( i )/safmax )>( anrmto/anrm ) .or.( safmin/alphai( i ) )>( &
                              anrm/anrmto ) ) then
                       work( 1 ) = abs( a( i, i+1 )/alphai( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    end if
                 end if
              end do
           end if
           if( ilbscl )then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                     if( ( beta( i )/safmax )>( bnrmto/bnrm ) .or.( safmin/beta( i ) )>( &
                               bnrm/bnrmto ) ) then
                        work( 1 ) = abs(b( i, i )/beta( i ))
                        beta( i ) = beta( i )*work( 1 )
                        alphar( i ) = alphar( i )*work( 1 )
                        alphai( i ) = alphai( i )*work( 1 )
                     end if
                  end if
              end do
           end if
           ! undo scaling
           if( ilascl ) then
              call stdlib_slascl( 'H', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_slascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_slascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_slascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_slascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              lst2sl = .true.
              sdim = 0
              ip = 0
              do i = 1, n
                 cursl = selctg( alphar( i ), alphai( i ), beta( i ) )
                 if( alphai( i )==zero ) then
                    if( cursl )sdim = sdim + 1
                    ip = 0
                    if( cursl .and. .not.lastsl )info = n + 2
                 else
                    if( ip==1 ) then
                       ! last eigenvalue of conjugate pair
                       cursl = cursl .or. lastsl
                       lastsl = cursl
                       if( cursl )sdim = sdim + 2
                       ip = -1
                       if( cursl .and. .not.lst2sl )info = n + 2
                    else
                       ! first eigenvalue of conjugate pair
                       ip = 1
                    end if
                 end if
                 lst2sl = lastsl
                 lastsl = cursl
              end do
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_sgges3

     module subroutine stdlib_dgges3( jobvsl, jobvsr, sort, selctg, n, a, lda, b,ldb, sdim, alphar, &
     !! DGGES3 computes for a pair of N-by-N real nonsymmetric matrices (A,B),
     !! the generalized eigenvalues, the generalized real Schur form (S,T),
     !! optionally, the left and/or right matrices of Schur vectors (VSL and
     !! VSR). This gives the generalized Schur factorization
     !! (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! quasi-triangular matrix S and the upper triangular matrix T.The
     !! leading columns of VSL and VSR then form an orthonormal basis for the
     !! corresponding left and right eigenspaces (deflating subspaces).
     !! (If only the generalized eigenvalues are needed, use the driver
     !! DGGEV instead, which is faster.)
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0 or both being zero.
     !! A pair of matrices (S,T) is in generalized real Schur form if T is
     !! upper triangular with non-negative diagonal and S is block upper
     !! triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
     !! to real generalized eigenvalues, while 2-by-2 blocks of S will be
     !! "standardized" by making the corresponding elements of T have the
     !! form:
     !! [  a  0  ]
     !! [  0  b  ]
     !! and the pair of corresponding 2-by-2 blocks in S and T will have a
     !! complex conjugate pair of generalized eigenvalues.
               alphai, beta, vsl, ldvsl,vsr, ldvsr, work, lwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: alphai(*), alphar(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), &
                     work(*)
           ! Function Arguments 
           procedure(stdlib_selctg_d) :: selctg
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, lst2sl, &
                     wantst
           integer(ilp) :: i, icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, ip, iright, irows, &
                     itau, iwrk, lwkopt
           real(dp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl, pvsr, safmax, safmin, &
                     smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(dp) :: dif(2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -15
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -17
           else if( lwork<6*n+16 .and. .not.lquery ) then
              info = -19
           end if
           ! compute workspace
           if( info==0 ) then
              call stdlib_dgeqrf( n, n, b, ldb, work, work, -1, ierr )
              lwkopt = max( 6*n+16, 3*n+int( work ( 1 ),KIND=ilp) )
              call stdlib_dormqr( 'L', 'T', n, n, n, b, ldb, work, a, lda, work,-1, ierr )
              lwkopt = max( lwkopt, 3*n+int( work ( 1 ),KIND=ilp) )
              if( ilvsl ) then
                 call stdlib_dorgqr( n, n, n, vsl, ldvsl, work, work, -1, ierr )
                 lwkopt = max( lwkopt, 3*n+int( work ( 1 ),KIND=ilp) )
              end if
              call stdlib_dgghd3( jobvsl, jobvsr, n, 1, n, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr, &
                        work, -1, ierr )
              lwkopt = max( lwkopt, 3*n+int( work ( 1 ),KIND=ilp) )
              call stdlib_dlaqz0( 'S', jobvsl, jobvsr, n, 1, n, a, lda, b, ldb,alphar, alphai, &
                        beta, vsl, ldvsl, vsr, ldvsr,work, -1, 0, ierr )
              lwkopt = max( lwkopt, 2*n+int( work ( 1 ),KIND=ilp) )
              if( wantst ) then
                 call stdlib_dtgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb,alphar, alphai, &
                 beta, vsl, ldvsl, vsr, ldvsr,sdim, pvsl, pvsr, dif, work, -1, idum, 1,ierr )
                           
                 lwkopt = max( lwkopt, 2*n+int( work ( 1 ),KIND=ilp) )
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGES3 ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           safmin = stdlib_dlamch( 'S' )
           safmax = one / safmin
           call stdlib_dlabad( safmin, safmax )
           smlnum = sqrt( safmin ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_dlange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_dlascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_dlange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_dlascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ileft = 1
           iright = n + 1
           iwrk = iright + n
           call stdlib_dggbal( 'P', n, a, lda, b, ldb, ilo, ihi, work( ileft ),work( iright ), &
                     work( iwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = iwrk
           iwrk = itau + irows
           call stdlib_dgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           call stdlib_dormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           if( ilvsl ) then
              call stdlib_dlaset( 'FULL', n, n, zero, one, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_dlacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_dorgqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_dlaset( 'FULL', n, n, zero, one, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           call stdlib_dgghd3( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      work( iwrk ), lwork+1-iwrk,ierr )
           ! perform qz algorithm, computing schur vectors if desired
           iwrk = itau
           call stdlib_dlaqz0( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vsl, ldvsl, vsr, ldvsr,work( iwrk ), lwork+1-iwrk, 0, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 50
           end if
           ! sort eigenvalues alpha/beta if desired
           sdim = 0
           if( wantst ) then
              ! undo scaling on eigenvalues before selctging
              if( ilascl ) then
                 call stdlib_dlascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n,ierr )
                 call stdlib_dlascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n,ierr )
              end if
              if( ilbscl )call stdlib_dlascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alphar( i ), alphai( i ), beta( i ) )
              end do
              call stdlib_dtgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb, alphar,alphai, beta, &
              vsl, ldvsl, vsr, ldvsr, sdim, pvsl,pvsr, dif, work( iwrk ), lwork-iwrk+1, idum, 1,&
                        ierr )
              if( ierr==1 )info = n + 3
           end if
           ! apply back-permutation to vsl and vsr
           if( ilvsl )call stdlib_dggbak( 'P', 'L', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_dggbak( 'P', 'R', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsr, ldvsr, ierr )
           ! check if unscaling would cause over/underflow, if so, rescale
           ! (alphar(i),alphai(i),beta(i)) so beta(i) is on the order of
           ! b(i,i) and alphar(i) and alphai(i) are on the order of a(i,i)
           if( ilascl ) then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                    if( ( alphar( i ) / safmax )>( anrmto / anrm ) .or.( safmin / alphar( i ) )>( &
                              anrm / anrmto ) ) then
                       work( 1 ) = abs( a( i, i ) / alphar( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    else if( ( alphai( i ) / safmax )>( anrmto / anrm ) .or.( safmin / alphai( i )&
                               )>( anrm / anrmto ) )then
                       work( 1 ) = abs( a( i, i+1 ) / alphai( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    end if
                 end if
              end do
           end if
           if( ilbscl ) then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                    if( ( beta( i ) / safmax )>( bnrmto / bnrm ) .or.( safmin / beta( i ) )>( &
                              bnrm / bnrmto ) ) then
                       work( 1 ) = abs( b( i, i ) / beta( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    end if
                 end if
              end do
           end if
           ! undo scaling
           if( ilascl ) then
              call stdlib_dlascl( 'H', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_dlascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_dlascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_dlascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_dlascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              lst2sl = .true.
              sdim = 0
              ip = 0
              do i = 1, n
                 cursl = selctg( alphar( i ), alphai( i ), beta( i ) )
                 if( alphai( i )==zero ) then
                    if( cursl )sdim = sdim + 1
                    ip = 0
                    if( cursl .and. .not.lastsl )info = n + 2
                 else
                    if( ip==1 ) then
                       ! last eigenvalue of conjugate pair
                       cursl = cursl .or. lastsl
                       lastsl = cursl
                       if( cursl )sdim = sdim + 2
                       ip = -1
                       if( cursl .and. .not.lst2sl )info = n + 2
                    else
                       ! first eigenvalue of conjugate pair
                       ip = 1
                    end if
                 end if
                 lst2sl = lastsl
                 lastsl = cursl
              end do
           end if
           50 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dgges3

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$gges3( jobvsl, jobvsr, sort, selctg, n, a, lda, b,ldb, sdim, alphar, &
     !! DGGES3: computes for a pair of N-by-N real nonsymmetric matrices (A,B),
     !! the generalized eigenvalues, the generalized real Schur form (S,T),
     !! optionally, the left and/or right matrices of Schur vectors (VSL and
     !! VSR). This gives the generalized Schur factorization
     !! (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! quasi-triangular matrix S and the upper triangular matrix T.The
     !! leading columns of VSL and VSR then form an orthonormal basis for the
     !! corresponding left and right eigenspaces (deflating subspaces).
     !! (If only the generalized eigenvalues are needed, use the driver
     !! DGGEV instead, which is faster.)
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0 or both being zero.
     !! A pair of matrices (S,T) is in generalized real Schur form if T is
     !! upper triangular with non-negative diagonal and S is block upper
     !! triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
     !! to real generalized eigenvalues, while 2-by-2 blocks of S will be
     !! "standardized" by making the corresponding elements of T have the
     !! form:
     !! [  a  0  ]
     !! [  0  b  ]
     !! and the pair of corresponding 2-by-2 blocks in S and T will have a
     !! complex conjugate pair of generalized eigenvalues.
               alphai, beta, vsl, ldvsl,vsr, ldvsr, work, lwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), &
                     work(*)
           ! Function Arguments 
           procedure(stdlib_selctg_${ri}$) :: selctg
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, lst2sl, &
                     wantst
           integer(ilp) :: i, icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, ip, iright, irows, &
                     itau, iwrk, lwkopt
           real(${rk}$) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl, pvsr, safmax, safmin, &
                     smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(${rk}$) :: dif(2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -15
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -17
           else if( lwork<6*n+16 .and. .not.lquery ) then
              info = -19
           end if
           ! compute workspace
           if( info==0 ) then
              call stdlib_${ri}$geqrf( n, n, b, ldb, work, work, -1, ierr )
              lwkopt = max( 6*n+16, 3*n+int( work ( 1 ),KIND=ilp) )
              call stdlib_${ri}$ormqr( 'L', 'T', n, n, n, b, ldb, work, a, lda, work,-1, ierr )
              lwkopt = max( lwkopt, 3*n+int( work ( 1 ),KIND=ilp) )
              if( ilvsl ) then
                 call stdlib_${ri}$orgqr( n, n, n, vsl, ldvsl, work, work, -1, ierr )
                 lwkopt = max( lwkopt, 3*n+int( work ( 1 ),KIND=ilp) )
              end if
              call stdlib_${ri}$gghd3( jobvsl, jobvsr, n, 1, n, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr, &
                        work, -1, ierr )
              lwkopt = max( lwkopt, 3*n+int( work ( 1 ),KIND=ilp) )
              call stdlib_${ri}$laqz0( 'S', jobvsl, jobvsr, n, 1, n, a, lda, b, ldb,alphar, alphai, &
                        beta, vsl, ldvsl, vsr, ldvsr,work, -1, 0, ierr )
              lwkopt = max( lwkopt, 2*n+int( work ( 1 ),KIND=ilp) )
              if( wantst ) then
                 call stdlib_${ri}$tgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb,alphar, alphai, &
                 beta, vsl, ldvsl, vsr, ldvsr,sdim, pvsl, pvsr, dif, work, -1, idum, 1,ierr )
                           
                 lwkopt = max( lwkopt, 2*n+int( work ( 1 ),KIND=ilp) )
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGES3 ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           safmin = stdlib_${ri}$lamch( 'S' )
           safmax = one / safmin
           call stdlib_${ri}$labad( safmin, safmax )
           smlnum = sqrt( safmin ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', n, n, a, lda, work )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_${ri}$lascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_${ri}$lange( 'M', n, n, b, ldb, work )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_${ri}$lascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ileft = 1
           iright = n + 1
           iwrk = iright + n
           call stdlib_${ri}$ggbal( 'P', n, a, lda, b, ldb, ilo, ihi, work( ileft ),work( iright ), &
                     work( iwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = iwrk
           iwrk = itau + irows
           call stdlib_${ri}$geqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           call stdlib_${ri}$ormqr( 'L', 'T', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           if( ilvsl ) then
              call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_${ri}$lacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_${ri}$orgqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           call stdlib_${ri}$gghd3( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      work( iwrk ), lwork+1-iwrk,ierr )
           ! perform qz algorithm, computing schur vectors if desired
           iwrk = itau
           call stdlib_${ri}$laqz0( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alphar, alphai, &
                     beta, vsl, ldvsl, vsr, ldvsr,work( iwrk ), lwork+1-iwrk, 0, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 50
           end if
           ! sort eigenvalues alpha/beta if desired
           sdim = 0
           if( wantst ) then
              ! undo scaling on eigenvalues before selctging
              if( ilascl ) then
                 call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n,ierr )
                 call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n,ierr )
              end if
              if( ilbscl )call stdlib_${ri}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alphar( i ), alphai( i ), beta( i ) )
              end do
              call stdlib_${ri}$tgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb, alphar,alphai, beta, &
              vsl, ldvsl, vsr, ldvsr, sdim, pvsl,pvsr, dif, work( iwrk ), lwork-iwrk+1, idum, 1,&
                        ierr )
              if( ierr==1 )info = n + 3
           end if
           ! apply back-permutation to vsl and vsr
           if( ilvsl )call stdlib_${ri}$ggbak( 'P', 'L', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_${ri}$ggbak( 'P', 'R', n, ilo, ihi, work( ileft ),work( iright ), n, &
                     vsr, ldvsr, ierr )
           ! check if unscaling would cause over/underflow, if so, rescale
           ! (alphar(i),alphai(i),beta(i)) so beta(i) is on the order of
           ! b(i,i) and alphar(i) and alphai(i) are on the order of a(i,i)
           if( ilascl ) then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                    if( ( alphar( i ) / safmax )>( anrmto / anrm ) .or.( safmin / alphar( i ) )>( &
                              anrm / anrmto ) ) then
                       work( 1 ) = abs( a( i, i ) / alphar( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    else if( ( alphai( i ) / safmax )>( anrmto / anrm ) .or.( safmin / alphai( i )&
                               )>( anrm / anrmto ) )then
                       work( 1 ) = abs( a( i, i+1 ) / alphai( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    end if
                 end if
              end do
           end if
           if( ilbscl ) then
              do i = 1, n
                 if( alphai( i )/=zero ) then
                    if( ( beta( i ) / safmax )>( bnrmto / bnrm ) .or.( safmin / beta( i ) )>( &
                              bnrm / bnrmto ) ) then
                       work( 1 ) = abs( b( i, i ) / beta( i ) )
                       beta( i ) = beta( i )*work( 1 )
                       alphar( i ) = alphar( i )*work( 1 )
                       alphai( i ) = alphai( i )*work( 1 )
                    end if
                 end if
              end do
           end if
           ! undo scaling
           if( ilascl ) then
              call stdlib_${ri}$lascl( 'H', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphar, n, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alphai, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_${ri}$lascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_${ri}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              lst2sl = .true.
              sdim = 0
              ip = 0
              do i = 1, n
                 cursl = selctg( alphar( i ), alphai( i ), beta( i ) )
                 if( alphai( i )==zero ) then
                    if( cursl )sdim = sdim + 1
                    ip = 0
                    if( cursl .and. .not.lastsl )info = n + 2
                 else
                    if( ip==1 ) then
                       ! last eigenvalue of conjugate pair
                       cursl = cursl .or. lastsl
                       lastsl = cursl
                       if( cursl )sdim = sdim + 2
                       ip = -1
                       if( cursl .and. .not.lst2sl )info = n + 2
                    else
                       ! first eigenvalue of conjugate pair
                       ip = 1
                    end if
                 end if
                 lst2sl = lastsl
                 lastsl = cursl
              end do
           end if
           50 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$gges3

#:endif
#:endfor

     module subroutine stdlib_cgges3( jobvsl, jobvsr, sort, selctg, n, a, lda, b,ldb, sdim, alpha, beta, &
     !! CGGES3 computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, the generalized complex Schur
     !! form (S, T), and optionally left and/or right Schur vectors (VSL
     !! and VSR). This gives the generalized Schur factorization
     !! (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )
     !! where (VSR)**H is the conjugate-transpose of VSR.
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! triangular matrix S and the upper triangular matrix T. The leading
     !! columns of VSL and VSR then form an unitary basis for the
     !! corresponding left and right eigenspaces (deflating subspaces).
     !! (If only the generalized eigenvalues are needed, use the driver
     !! CGGEV instead, which is faster.)
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0, and even for both being zero.
     !! A pair of matrices (S,T) is in generalized complex Schur form if S
     !! and T are upper triangular and, in addition, the diagonal elements
     !! of T are non-negative real numbers.
               vsl, ldvsl, vsr, ldvsr,work, lwork, rwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: alpha(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), work(*)
                     
           ! Function Arguments 
           procedure(stdlib_selctg_c) :: selctg
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, wantst
           integer(ilp) :: i, icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, iright, irows, irwrk, &
                     itau, iwrk, lwkopt
           real(sp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl, pvsr, smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(sp) :: dif(2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -14
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -16
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -18
           end if
           ! compute workspace
           if( info==0 ) then
              call stdlib_cgeqrf( n, n, b, ldb, work, work, -1, ierr )
              lwkopt = max( 1,  n + int( work( 1 ),KIND=ilp) )
              call stdlib_cunmqr( 'L', 'C', n, n, n, b, ldb, work, a, lda, work,-1, ierr )
              lwkopt = max( lwkopt, n + int( work( 1 ),KIND=ilp) )
              if( ilvsl ) then
                 call stdlib_cungqr( n, n, n, vsl, ldvsl, work, work, -1,ierr )
                 lwkopt = max( lwkopt, n + int( work( 1 ),KIND=ilp) )
              end if
              call stdlib_cgghd3( jobvsl, jobvsr, n, 1, n, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr, &
                        work, -1, ierr )
              lwkopt = max( lwkopt, n + int( work( 1 ),KIND=ilp) )
              call stdlib_claqz0( 'S', jobvsl, jobvsr, n, 1, n, a, lda, b, ldb,alpha, beta, vsl, &
                        ldvsl, vsr, ldvsr, work, -1,rwork, 0, ierr )
              lwkopt = max( lwkopt, int( work( 1 ),KIND=ilp) )
              if( wantst ) then
                 call stdlib_ctgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb,alpha, beta, vsl, &
                           ldvsl, vsr, ldvsr, sdim,pvsl, pvsr, dif, work, -1, idum, 1, ierr )
                 lwkopt = max( lwkopt, int( work( 1 ),KIND=ilp) )
              end if
              work( 1 ) = cmplx( lwkopt,KIND=sp)
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGES3 ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' )
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_clascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_clange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ileft = 1
           iright = n + 1
           irwrk = iright + n
           call stdlib_cggbal( 'P', n, a, lda, b, ldb, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     rwork( irwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = 1
           iwrk = itau + irows
           call stdlib_cgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           call stdlib_cunmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           if( ilvsl ) then
              call stdlib_claset( 'FULL', n, n, czero, cone, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_clacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_cungqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_claset( 'FULL', n, n, czero, cone, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           call stdlib_cgghd3( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      work( iwrk ), lwork+1-iwrk, ierr )
           sdim = 0
           ! perform qz algorithm, computing schur vectors if desired
           iwrk = itau
           call stdlib_claqz0( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vsl, &
                     ldvsl, vsr, ldvsr, work( iwrk ),lwork+1-iwrk, rwork( irwrk ), 0, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 30
           end if
           ! sort eigenvalues alpha/beta if desired
           if( wantst ) then
              ! undo scaling on eigenvalues before selecting
              if( ilascl )call stdlib_clascl( 'G', 0, 0, anrm, anrmto, n, 1, alpha, n, ierr )
                        
              if( ilbscl )call stdlib_clascl( 'G', 0, 0, bnrm, bnrmto, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alpha( i ), beta( i ) )
              end do
              call stdlib_ctgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb, alpha,beta, vsl, &
              ldvsl, vsr, ldvsr, sdim, pvsl, pvsr,dif, work( iwrk ), lwork-iwrk+1, idum, 1, ierr )
                        
              if( ierr==1 )info = n + 3
           end if
           ! apply back-permutation to vsl and vsr
           if( ilvsl )call stdlib_cggbak( 'P', 'L', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_cggbak( 'P', 'R', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsr, ldvsr, ierr )
           ! undo scaling
           if( ilascl ) then
              call stdlib_clascl( 'U', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_clascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_clascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_clascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              sdim = 0
              do i = 1, n
                 cursl = selctg( alpha( i ), beta( i ) )
                 if( cursl )sdim = sdim + 1
                 if( cursl .and. .not.lastsl )info = n + 2
                 lastsl = cursl
              end do
           end if
           30 continue
           work( 1 ) = cmplx( lwkopt,KIND=sp)
           return
     end subroutine stdlib_cgges3

     module subroutine stdlib_zgges3( jobvsl, jobvsr, sort, selctg, n, a, lda, b,ldb, sdim, alpha, beta, &
     !! ZGGES3 computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, the generalized complex Schur
     !! form (S, T), and optionally left and/or right Schur vectors (VSL
     !! and VSR). This gives the generalized Schur factorization
     !! (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )
     !! where (VSR)**H is the conjugate-transpose of VSR.
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! triangular matrix S and the upper triangular matrix T. The leading
     !! columns of VSL and VSR then form an unitary basis for the
     !! corresponding left and right eigenspaces (deflating subspaces).
     !! (If only the generalized eigenvalues are needed, use the driver
     !! ZGGEV instead, which is faster.)
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0, and even for both being zero.
     !! A pair of matrices (S,T) is in generalized complex Schur form if S
     !! and T are upper triangular and, in addition, the diagonal elements
     !! of T are non-negative real numbers.
               vsl, ldvsl, vsr, ldvsr,work, lwork, rwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: alpha(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), work(*)
                     
           ! Function Arguments 
           procedure(stdlib_selctg_z) :: selctg
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, wantst
           integer(ilp) :: i, icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, iright, irows, irwrk, &
                     itau, iwrk, lwkopt
           real(dp) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl, pvsr, smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(dp) :: dif(2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -14
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -16
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -18
           end if
           ! compute workspace
           if( info==0 ) then
              call stdlib_zgeqrf( n, n, b, ldb, work, work, -1, ierr )
              lwkopt = max( 1,  n + int( work( 1 ),KIND=ilp) )
              call stdlib_zunmqr( 'L', 'C', n, n, n, b, ldb, work, a, lda, work,-1, ierr )
              lwkopt = max( lwkopt, n + int( work( 1 ),KIND=ilp) )
              if( ilvsl ) then
                 call stdlib_zungqr( n, n, n, vsl, ldvsl, work, work, -1, ierr )
                 lwkopt = max( lwkopt, n + int( work( 1 ),KIND=ilp) )
              end if
              call stdlib_zgghd3( jobvsl, jobvsr, n, 1, n, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr, &
                        work, -1, ierr )
              lwkopt = max( lwkopt, n + int( work( 1 ),KIND=ilp) )
              call stdlib_zlaqz0( 'S', jobvsl, jobvsr, n, 1, n, a, lda, b, ldb,alpha, beta, vsl, &
                        ldvsl, vsr, ldvsr, work, -1,rwork, 0, ierr )
              lwkopt = max( lwkopt, int( work( 1 ),KIND=ilp) )
              if( wantst ) then
                 call stdlib_ztgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb,alpha, beta, vsl, &
                           ldvsl, vsr, ldvsr, sdim,pvsl, pvsr, dif, work, -1, idum, 1, ierr )
                 lwkopt = max( lwkopt, int( work( 1 ),KIND=ilp) )
              end if
              work( 1 ) = cmplx( lwkopt,KIND=dp)
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGES3 ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' )
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_zlange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_zlascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_zlange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_zlascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ileft = 1
           iright = n + 1
           irwrk = iright + n
           call stdlib_zggbal( 'P', n, a, lda, b, ldb, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     rwork( irwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = 1
           iwrk = itau + irows
           call stdlib_zgeqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           call stdlib_zunmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           if( ilvsl ) then
              call stdlib_zlaset( 'FULL', n, n, czero, cone, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_zlacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_zungqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_zlaset( 'FULL', n, n, czero, cone, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           call stdlib_zgghd3( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      work( iwrk ), lwork+1-iwrk, ierr )
           sdim = 0
           ! perform qz algorithm, computing schur vectors if desired
           iwrk = itau
           call stdlib_zlaqz0( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vsl, &
                     ldvsl, vsr, ldvsr, work( iwrk ),lwork+1-iwrk, rwork( irwrk ), 0, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 30
           end if
           ! sort eigenvalues alpha/beta if desired
           if( wantst ) then
              ! undo scaling on eigenvalues before selecting
              if( ilascl )call stdlib_zlascl( 'G', 0, 0, anrm, anrmto, n, 1, alpha, n, ierr )
                        
              if( ilbscl )call stdlib_zlascl( 'G', 0, 0, bnrm, bnrmto, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alpha( i ), beta( i ) )
              end do
              call stdlib_ztgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb, alpha,beta, vsl, &
              ldvsl, vsr, ldvsr, sdim, pvsl, pvsr,dif, work( iwrk ), lwork-iwrk+1, idum, 1, ierr )
                        
              if( ierr==1 )info = n + 3
           end if
           ! apply back-permutation to vsl and vsr
           if( ilvsl )call stdlib_zggbak( 'P', 'L', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_zggbak( 'P', 'R', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsr, ldvsr, ierr )
           ! undo scaling
           if( ilascl ) then
              call stdlib_zlascl( 'U', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_zlascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_zlascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_zlascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              sdim = 0
              do i = 1, n
                 cursl = selctg( alpha( i ), beta( i ) )
                 if( cursl )sdim = sdim + 1
                 if( cursl .and. .not.lastsl )info = n + 2
                 lastsl = cursl
              end do
           end if
           30 continue
           work( 1 ) = cmplx( lwkopt,KIND=dp)
           return
     end subroutine stdlib_zgges3

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$gges3( jobvsl, jobvsr, sort, selctg, n, a, lda, b,ldb, sdim, alpha, beta, &
     !! ZGGES3: computes for a pair of N-by-N complex nonsymmetric matrices
     !! (A,B), the generalized eigenvalues, the generalized complex Schur
     !! form (S, T), and optionally left and/or right Schur vectors (VSL
     !! and VSR). This gives the generalized Schur factorization
     !! (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )
     !! where (VSR)**H is the conjugate-transpose of VSR.
     !! Optionally, it also orders the eigenvalues so that a selected cluster
     !! of eigenvalues appears in the leading diagonal blocks of the upper
     !! triangular matrix S and the upper triangular matrix T. The leading
     !! columns of VSL and VSR then form an unitary basis for the
     !! corresponding left and right eigenspaces (deflating subspaces).
     !! (If only the generalized eigenvalues are needed, use the driver
     !! ZGGEV instead, which is faster.)
     !! A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
     !! or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
     !! usually represented as the pair (alpha,beta), as there is a
     !! reasonable interpretation for beta=0, and even for both being zero.
     !! A pair of matrices (S,T) is in generalized complex Schur form if S
     !! and T are upper triangular and, in addition, the diagonal elements
     !! of T are non-negative real numbers.
               vsl, ldvsl, vsr, ldvsr,work, lwork, rwork, bwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobvsl, jobvsr, sort
           integer(ilp), intent(out) :: info, sdim
           integer(ilp), intent(in) :: lda, ldb, ldvsl, ldvsr, lwork, n
           ! Array Arguments 
           logical(lk), intent(out) :: bwork(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: alpha(*), beta(*), vsl(ldvsl,*), vsr(ldvsr,*), work(*)
                     
           ! Function Arguments 
           procedure(stdlib_selctg_${ci}$) :: selctg
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: cursl, ilascl, ilbscl, ilvsl, ilvsr, lastsl, lquery, wantst
           integer(ilp) :: i, icols, ierr, ihi, ijobvl, ijobvr, ileft, ilo, iright, irows, irwrk, &
                     itau, iwrk, lwkopt
           real(${ck}$) :: anrm, anrmto, bignum, bnrm, bnrmto, eps, pvsl, pvsr, smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(${ck}$) :: dif(2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode the input arguments
           if( stdlib_lsame( jobvsl, 'N' ) ) then
              ijobvl = 1
              ilvsl = .false.
           else if( stdlib_lsame( jobvsl, 'V' ) ) then
              ijobvl = 2
              ilvsl = .true.
           else
              ijobvl = -1
              ilvsl = .false.
           end if
           if( stdlib_lsame( jobvsr, 'N' ) ) then
              ijobvr = 1
              ilvsr = .false.
           else if( stdlib_lsame( jobvsr, 'V' ) ) then
              ijobvr = 2
              ilvsr = .true.
           else
              ijobvr = -1
              ilvsr = .false.
           end if
           wantst = stdlib_lsame( sort, 'S' )
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           if( ijobvl<=0 ) then
              info = -1
           else if( ijobvr<=0 ) then
              info = -2
           else if( ( .not.wantst ) .and. ( .not.stdlib_lsame( sort, 'N' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldvsl<1 .or. ( ilvsl .and. ldvsl<n ) ) then
              info = -14
           else if( ldvsr<1 .or. ( ilvsr .and. ldvsr<n ) ) then
              info = -16
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -18
           end if
           ! compute workspace
           if( info==0 ) then
              call stdlib_${ci}$geqrf( n, n, b, ldb, work, work, -1, ierr )
              lwkopt = max( 1,  n + int( work( 1 ),KIND=ilp) )
              call stdlib_${ci}$unmqr( 'L', 'C', n, n, n, b, ldb, work, a, lda, work,-1, ierr )
              lwkopt = max( lwkopt, n + int( work( 1 ),KIND=ilp) )
              if( ilvsl ) then
                 call stdlib_${ci}$ungqr( n, n, n, vsl, ldvsl, work, work, -1, ierr )
                 lwkopt = max( lwkopt, n + int( work( 1 ),KIND=ilp) )
              end if
              call stdlib_${ci}$gghd3( jobvsl, jobvsr, n, 1, n, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr, &
                        work, -1, ierr )
              lwkopt = max( lwkopt, n + int( work( 1 ),KIND=ilp) )
              call stdlib_${ci}$laqz0( 'S', jobvsl, jobvsr, n, 1, n, a, lda, b, ldb,alpha, beta, vsl, &
                        ldvsl, vsr, ldvsr, work, -1,rwork, 0, ierr )
              lwkopt = max( lwkopt, int( work( 1 ),KIND=ilp) )
              if( wantst ) then
                 call stdlib_${ci}$tgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb,alpha, beta, vsl, &
                           ldvsl, vsr, ldvsr, sdim,pvsl, pvsr, dif, work, -1, idum, 1, ierr )
                 lwkopt = max( lwkopt, int( work( 1 ),KIND=ilp) )
              end if
              work( 1 ) = cmplx( lwkopt,KIND=${ck}$)
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGES3 ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              sdim = 0
              return
           end if
           ! get machine constants
           eps = stdlib_${c2ri(ci)}$lamch( 'P' )
           smlnum = stdlib_${c2ri(ci)}$lamch( 'S' )
           bignum = one / smlnum
           call stdlib_${c2ri(ci)}$labad( smlnum, bignum )
           smlnum = sqrt( smlnum ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ci}$lange( 'M', n, n, a, lda, rwork )
           ilascl = .false.
           if( anrm>zero .and. anrm<smlnum ) then
              anrmto = smlnum
              ilascl = .true.
           else if( anrm>bignum ) then
              anrmto = bignum
              ilascl = .true.
           end if
           if( ilascl )call stdlib_${ci}$lascl( 'G', 0, 0, anrm, anrmto, n, n, a, lda, ierr )
           ! scale b if max element outside range [smlnum,bignum]
           bnrm = stdlib_${ci}$lange( 'M', n, n, b, ldb, rwork )
           ilbscl = .false.
           if( bnrm>zero .and. bnrm<smlnum ) then
              bnrmto = smlnum
              ilbscl = .true.
           else if( bnrm>bignum ) then
              bnrmto = bignum
              ilbscl = .true.
           end if
           if( ilbscl )call stdlib_${ci}$lascl( 'G', 0, 0, bnrm, bnrmto, n, n, b, ldb, ierr )
           ! permute the matrix to make it more nearly triangular
           ileft = 1
           iright = n + 1
           irwrk = iright + n
           call stdlib_${ci}$ggbal( 'P', n, a, lda, b, ldb, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     rwork( irwrk ), ierr )
           ! reduce b to triangular form (qr decomposition of b)
           irows = ihi + 1 - ilo
           icols = n + 1 - ilo
           itau = 1
           iwrk = itau + irows
           call stdlib_${ci}$geqrf( irows, icols, b( ilo, ilo ), ldb, work( itau ),work( iwrk ), lwork+&
                     1-iwrk, ierr )
           ! apply the orthogonal transformation to matrix a
           call stdlib_${ci}$unmqr( 'L', 'C', irows, icols, irows, b( ilo, ilo ), ldb,work( itau ), a( &
                     ilo, ilo ), lda, work( iwrk ),lwork+1-iwrk, ierr )
           ! initialize vsl
           if( ilvsl ) then
              call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, vsl, ldvsl )
              if( irows>1 ) then
                 call stdlib_${ci}$lacpy( 'L', irows-1, irows-1, b( ilo+1, ilo ), ldb,vsl( ilo+1, ilo )&
                           , ldvsl )
              end if
              call stdlib_${ci}$ungqr( irows, irows, irows, vsl( ilo, ilo ), ldvsl,work( itau ), work( &
                        iwrk ), lwork+1-iwrk, ierr )
           end if
           ! initialize vsr
           if( ilvsr )call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, vsr, ldvsr )
           ! reduce to generalized hessenberg form
           call stdlib_${ci}$gghd3( jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb, vsl,ldvsl, vsr, ldvsr,&
                      work( iwrk ), lwork+1-iwrk, ierr )
           sdim = 0
           ! perform qz algorithm, computing schur vectors if desired
           iwrk = itau
           call stdlib_${ci}$laqz0( 'S', jobvsl, jobvsr, n, ilo, ihi, a, lda, b, ldb,alpha, beta, vsl, &
                     ldvsl, vsr, ldvsr, work( iwrk ),lwork+1-iwrk, rwork( irwrk ), 0, ierr )
           if( ierr/=0 ) then
              if( ierr>0 .and. ierr<=n ) then
                 info = ierr
              else if( ierr>n .and. ierr<=2*n ) then
                 info = ierr - n
              else
                 info = n + 1
              end if
              go to 30
           end if
           ! sort eigenvalues alpha/beta if desired
           if( wantst ) then
              ! undo scaling on eigenvalues before selecting
              if( ilascl )call stdlib_${ci}$lascl( 'G', 0, 0, anrm, anrmto, n, 1, alpha, n, ierr )
                        
              if( ilbscl )call stdlib_${ci}$lascl( 'G', 0, 0, bnrm, bnrmto, n, 1, beta, n, ierr )
                        
              ! select eigenvalues
              do i = 1, n
                 bwork( i ) = selctg( alpha( i ), beta( i ) )
              end do
              call stdlib_${ci}$tgsen( 0, ilvsl, ilvsr, bwork, n, a, lda, b, ldb, alpha,beta, vsl, &
              ldvsl, vsr, ldvsr, sdim, pvsl, pvsr,dif, work( iwrk ), lwork-iwrk+1, idum, 1, ierr )
                        
              if( ierr==1 )info = n + 3
           end if
           ! apply back-permutation to vsl and vsr
           if( ilvsl )call stdlib_${ci}$ggbak( 'P', 'L', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsl, ldvsl, ierr )
           if( ilvsr )call stdlib_${ci}$ggbak( 'P', 'R', n, ilo, ihi, rwork( ileft ),rwork( iright ), &
                     n, vsr, ldvsr, ierr )
           ! undo scaling
           if( ilascl ) then
              call stdlib_${ci}$lascl( 'U', 0, 0, anrmto, anrm, n, n, a, lda, ierr )
              call stdlib_${ci}$lascl( 'G', 0, 0, anrmto, anrm, n, 1, alpha, n, ierr )
           end if
           if( ilbscl ) then
              call stdlib_${ci}$lascl( 'U', 0, 0, bnrmto, bnrm, n, n, b, ldb, ierr )
              call stdlib_${ci}$lascl( 'G', 0, 0, bnrmto, bnrm, n, 1, beta, n, ierr )
           end if
           if( wantst ) then
              ! check if reordering is correct
              lastsl = .true.
              sdim = 0
              do i = 1, n
                 cursl = selctg( alpha( i ), beta( i ) )
                 if( cursl )sdim = sdim + 1
                 if( cursl .and. .not.lastsl )info = n + 2
                 lastsl = cursl
              end do
           end if
           30 continue
           work( 1 ) = cmplx( lwkopt,KIND=${ck}$)
           return
     end subroutine stdlib_${ci}$gges3

#:endif
#:endfor



     module subroutine stdlib_slaqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, work, lwork, info )
     !! SLAQR0 computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**T, where T is an upper quasi-triangular matrix (the
     !! Schur form), and Z is the orthogonal matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input orthogonal
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
                
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(sp), intent(out) :: wi(*), work(*), wr(*)
        ! ================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: kexnw = 5
           integer(ilp), parameter :: kexsh = 6
           real(sp), parameter :: wilk1 = 0.75_sp
           real(sp), parameter :: wilk2 = -0.4375_sp
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_slahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== exceptional deflation windows:  try to cure rare
           ! .    slow convergence by varying the size of the
           ! .    deflation window after kexnw iterations. ====
           
           ! ==== exceptional shifts: try to cure rare slow convergence
           ! .    with ad-hoc exceptional shifts every kexsh iterations.
           ! .    ====
           
           ! ==== the constants wilk1 and wilk2 are used to form the
           ! .    exceptional shifts. ====
           
           
           ! Local Scalars 
           real(sp) :: aa, bb, cc, cs, dd, sn, ss, swap
           integer(ilp) :: i, inf, it, itmax, k, kacc22, kbot, kdu, ks, kt, ktop, ku, kv, kwh, &
           kwtop, kwv, ld, ls, lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns, nsmax, nsr, nve, nw,&
                      nwmax, nwr, nwupbd
           logical(lk) :: sorted
           character :: jbcmpz*2
           ! Local Arrays 
           real(sp) :: zdum(1,1)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! ==== quick return for n = 0: nothing to do. ====
           if( n==0 ) then
              work( 1 ) = one
              return
           end if
           if( n<=ntiny ) then
              ! ==== tiny matrices must use stdlib_slahqr. ====
              lwkopt = 1
              if( lwork/=-1 )call stdlib_slahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, &
                        ihiz, z, ldz, info )
           else
              ! ==== use small bulge multi-shift qr with aggressive early
              ! .    deflation on larger-than-tiny matrices. ====
              ! ==== hope for the best. ====
              info = 0
              ! ==== set up job flags for stdlib_ilaenv. ====
              if( wantt ) then
                 jbcmpz( 1: 1 ) = 'S'
              else
                 jbcmpz( 1: 1 ) = 'E'
              end if
              if( wantz ) then
                 jbcmpz( 2: 2 ) = 'V'
              else
                 jbcmpz( 2: 2 ) = 'N'
              end if
              ! ==== nwr = recommended deflation window size.  at this
              ! .    point,  n > ntiny = 15, so there is enough
              ! .    subdiagonal workspace for nwr>=2 as required.
              ! .    (in fact, there is enough subdiagonal space for
              ! .    nwr>=4.) ====
              nwr = stdlib_ilaenv( 13, 'SLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nwr = max( 2, nwr )
              nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
              ! ==== nsr = recommended number of simultaneous shifts.
              ! .    at this point n > ntiny = 15, so there is at
              ! .    enough subdiagonal workspace for nsr to be even
              ! .    and greater than or equal to two as required. ====
              nsr = stdlib_ilaenv( 15, 'SLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nsr = min( nsr, ( n-3 ) / 6, ihi-ilo )
              nsr = max( 2, nsr-mod( nsr, 2 ) )
              ! ==== estimate optimal workspace ====
              ! ==== workspace query call to stdlib_slaqr3 ====
              call stdlib_slaqr3( wantt, wantz, n, ilo, ihi, nwr+1, h, ldh, iloz,ihiz, z, ldz, ls,&
                         ld, wr, wi, h, ldh, n, h, ldh,n, h, ldh, work, -1 )
              ! ==== optimal workspace = max(stdlib_slaqr5, stdlib_slaqr3) ====
              lwkopt = max( 3*nsr / 2, int( work( 1 ),KIND=ilp) )
              ! ==== quick return in case of workspace query. ====
              if( lwork==-1 ) then
                 work( 1 ) = real( lwkopt,KIND=sp)
                 return
              end if
              ! ==== stdlib_slahqr/stdlib_slaqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'SLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nmin = max( ntiny, nmin )
              ! ==== nibble crossover point ====
              nibble = stdlib_ilaenv( 14, 'SLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nibble = max( 0, nibble )
              ! ==== accumulate reflections during ttswp?  use block
              ! .    2-by-2 structure during matrix-matrix multiply? ====
              kacc22 = stdlib_ilaenv( 16, 'SLAQR0', jbcmpz, n, ilo, ihi, lwork )
              kacc22 = max( 0, kacc22 )
              kacc22 = min( 2, kacc22 )
              ! ==== nwmax = the largest possible deflation window for
              ! .    which there is sufficient workspace. ====
              nwmax = min( ( n-1 ) / 3, lwork / 2 )
              nw = nwmax
              ! ==== nsmax = the largest number of simultaneous shifts
              ! .    for which there is sufficient workspace. ====
              nsmax = min( ( n-3 ) / 6, 2*lwork / 3 )
              nsmax = nsmax - mod( nsmax, 2 )
              ! ==== ndfl: an iteration count restarted at deflation. ====
              ndfl = 1
              ! ==== itmax = iteration limit ====
              itmax = max( 30, 2*kexsh )*max( 10, ( ihi-ilo+1 ) )
              ! ==== last row and column in the active block ====
              kbot = ihi
              ! ==== main loop ====
              loop_80: do it = 1, itmax
                 ! ==== done when kbot falls below ilo ====
                 if( kbot<ilo )go to 90
                 ! ==== locate active block ====
                 do k = kbot, ilo + 1, -1
                    if( h( k, k-1 )==zero )go to 20
                 end do
                 k = ilo
                 20 continue
                 ktop = k
                 ! ==== select deflation window size:
                 ! .    typical case:
                 ! .      if possible and advisable, nibble the entire
                 ! .      active block.  if not, use size min(nwr,nwmax)
                 ! .      or min(nwr+1,nwmax) depending upon which has
                 ! .      the smaller corresponding subdiagonal entry
                 ! .      (a heuristic).
                 ! .    exceptional case:
                 ! .      if there have been no deflations in kexnw or
                 ! .      more iterations, then vary the deflation window
                 ! .      size.   at first, because, larger windows are,
                 ! .      in general, more powerful than smaller ones,
                 ! .      rapidly increase the window to the maximum possible.
                 ! .      then, gradually reduce the window size. ====
                 nh = kbot - ktop + 1
                 nwupbd = min( nh, nwmax )
                 if( ndfl<kexnw ) then
                    nw = min( nwupbd, nwr )
                 else
                    nw = min( nwupbd, 2*nw )
                 end if
                 if( nw<nwmax ) then
                    if( nw>=nh-1 ) then
                       nw = nh
                    else
                       kwtop = kbot - nw + 1
                       if( abs( h( kwtop, kwtop-1 ) )>abs( h( kwtop-1, kwtop-2 ) ) )nw = nw + &
                                 1
                    end if
                 end if
                 if( ndfl<kexnw ) then
                    ndec = -1
                 else if( ndec>=0 .or. nw>=nwupbd ) then
                    ndec = ndec + 1
                    if( nw-ndec<2 )ndec = 0
                    nw = nw - ndec
                 end if
                 ! ==== aggressive early deflation:
                 ! .    split workspace under the subdiagonal into
                 ! .      - an nw-by-nw work array v in the lower
                 ! .        left-hand-corner,
                 ! .      - an nw-by-at-least-nw-but-more-is-better
                 ! .        (nw-by-nho) horizontal work array along
                 ! .        the bottom edge,
                 ! .      - an at-least-nw-but-more-is-better (nhv-by-nw)
                 ! .        vertical work array along the left-hand-edge.
                 ! .        ====
                 kv = n - nw + 1
                 kt = nw + 1
                 nho = ( n-nw-1 ) - kt + 1
                 kwv = nw + 2
                 nve = ( n-nw ) - kwv + 1
                 ! ==== aggressive early deflation ====
                 call stdlib_slaqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
                 ls, ld, wr, wi, h( kv, 1 ), ldh,nho, h( kv, kt ), ldh, nve, h( kwv, 1 ), ldh,&
                           work, lwork )
                 ! ==== adjust kbot accounting for new deflations. ====
                 kbot = kbot - ld
                 ! ==== ks points to the shifts. ====
                 ks = kbot - ls + 1
                 ! ==== skip an expensive qr sweep if there is a (partly
                 ! .    heuristic) reason to expect that many eigenvalues
                 ! .    will deflate without it.  here, the qr sweep is
                 ! .    skipped if many eigenvalues have just been deflated
                 ! .    or if the remaining active block is small.
                 if( ( ld==0 ) .or. ( ( 100*ld<=nw*nibble ) .and. ( kbot-ktop+1>min( nmin, nwmax )&
                            ) ) ) then
                    ! ==== ns = nominal number of simultaneous shifts.
                    ! .    this may be lowered (slightly) if stdlib_slaqr3
                    ! .    did not provide that many shifts. ====
                    ns = min( nsmax, nsr, max( 2, kbot-ktop ) )
                    ns = ns - mod( ns, 2 )
                    ! ==== if there have been no deflations
                    ! .    in a multiple of kexsh iterations,
                    ! .    then try exceptional shifts.
                    ! .    otherwise use shifts provided by
                    ! .    stdlib_slaqr3 above or from the eigenvalues
                    ! .    of a trailing principal submatrix. ====
                    if( mod( ndfl, kexsh )==0 ) then
                       ks = kbot - ns + 1
                       do i = kbot, max( ks+1, ktop+2 ), -2
                          ss = abs( h( i, i-1 ) ) + abs( h( i-1, i-2 ) )
                          aa = wilk1*ss + h( i, i )
                          bb = ss
                          cc = wilk2*ss
                          dd = aa
                          call stdlib_slanv2( aa, bb, cc, dd, wr( i-1 ), wi( i-1 ),wr( i ), wi( i &
                                    ), cs, sn )
                       end do
                       if( ks==ktop ) then
                          wr( ks+1 ) = h( ks+1, ks+1 )
                          wi( ks+1 ) = zero
                          wr( ks ) = wr( ks+1 )
                          wi( ks ) = wi( ks+1 )
                       end if
                    else
                       ! ==== got ns/2 or fewer shifts? use stdlib_slaqr4 or
                       ! .    stdlib_slahqr on a trailing principal submatrix to
                       ! .    get more. (since ns<=nsmax<=(n-3)/6,
                       ! .    there is enough space below the subdiagonal
                       ! .    to fit an ns-by-ns scratch array.) ====
                       if( kbot-ks+1<=ns / 2 ) then
                          ks = kbot - ns + 1
                          kt = n - ns + 1
                          call stdlib_slacpy( 'A', ns, ns, h( ks, ks ), ldh,h( kt, 1 ), ldh )
                                    
                          if( ns>nmin ) then
                             call stdlib_slaqr4( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, wr( &
                                       ks ),wi( ks ), 1, 1, zdum, 1, work,lwork, inf )
                          else
                             call stdlib_slahqr( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, wr( &
                                       ks ),wi( ks ), 1, 1, zdum, 1, inf )
                          end if
                          ks = ks + inf
                          ! ==== in case of a rare qr failure use
                          ! .    eigenvalues of the trailing 2-by-2
                          ! .    principal submatrix.  ====
                          if( ks>=kbot ) then
                             aa = h( kbot-1, kbot-1 )
                             cc = h( kbot, kbot-1 )
                             bb = h( kbot-1, kbot )
                             dd = h( kbot, kbot )
                             call stdlib_slanv2( aa, bb, cc, dd, wr( kbot-1 ),wi( kbot-1 ), wr( &
                                       kbot ),wi( kbot ), cs, sn )
                             ks = kbot - 1
                          end if
                       end if
                       if( kbot-ks+1>ns ) then
                          ! ==== sort the shifts (helps a little)
                          ! .    bubble sort keeps complex conjugate
                          ! .    pairs together. ====
                          sorted = .false.
                          do k = kbot, ks + 1, -1
                             if( sorted )go to 60
                             sorted = .true.
                             do i = ks, k - 1
                                if( abs( wr( i ) )+abs( wi( i ) )<abs( wr( i+1 ) )+abs( wi( i+1 ) &
                                          ) ) then
                                   sorted = .false.
                                   swap = wr( i )
                                   wr( i ) = wr( i+1 )
                                   wr( i+1 ) = swap
                                   swap = wi( i )
                                   wi( i ) = wi( i+1 )
                                   wi( i+1 ) = swap
                                end if
                             end do
                          end do
                          60 continue
                       end if
                       ! ==== shuffle shifts into pairs of real shifts
                       ! .    and pairs of complex conjugate shifts
                       ! .    assuming complex conjugate shifts are
                       ! .    already adjacent to one another. (yes,
                       ! .    they are.)  ====
                       do i = kbot, ks + 2, -2
                          if( wi( i )/=-wi( i-1 ) ) then
                             swap = wr( i )
                             wr( i ) = wr( i-1 )
                             wr( i-1 ) = wr( i-2 )
                             wr( i-2 ) = swap
                             swap = wi( i )
                             wi( i ) = wi( i-1 )
                             wi( i-1 ) = wi( i-2 )
                             wi( i-2 ) = swap
                          end if
                       end do
                    end if
                    ! ==== if there are only two shifts and both are
                    ! .    real, then use only one.  ====
                    if( kbot-ks+1==2 ) then
                       if( wi( kbot )==zero ) then
                          if( abs( wr( kbot )-h( kbot, kbot ) )<abs( wr( kbot-1 )-h( kbot, kbot ) &
                                    ) ) then
                             wr( kbot-1 ) = wr( kbot )
                          else
                             wr( kbot ) = wr( kbot-1 )
                          end if
                       end if
                    end if
                    ! ==== use up to ns of the the smallest magnitude
                    ! .    shifts.  if there aren't ns shifts available,
                    ! .    then use them all, possibly dropping one to
                    ! .    make the number of shifts even. ====
                    ns = min( ns, kbot-ks+1 )
                    ns = ns - mod( ns, 2 )
                    ks = kbot - ns + 1
                    ! ==== small-bulge multi-shift qr sweep:
                    ! .    split workspace under the subdiagonal into
                    ! .    - a kdu-by-kdu work array u in the lower
                    ! .      left-hand-corner,
                    ! .    - a kdu-by-at-least-kdu-but-more-is-better
                    ! .      (kdu-by-nho) horizontal work array wh along
                    ! .      the bottom edge,
                    ! .    - and an at-least-kdu-but-more-is-better-by-kdu
                    ! .      (nve-by-kdu) vertical work wv arrow along
                    ! .      the left-hand-edge. ====
                    kdu = 2*ns
                    ku = n - kdu + 1
                    kwh = kdu + 1
                    nho = ( n-kdu+1-4 ) - ( kdu+1 ) + 1
                    kwv = kdu + 4
                    nve = n - kdu - kwv + 1
                    ! ==== small-bulge multi-shift qr sweep ====
                    call stdlib_slaqr5( wantt, wantz, kacc22, n, ktop, kbot, ns,wr( ks ), wi( ks )&
                    , h, ldh, iloz, ihiz, z,ldz, work, 3, h( ku, 1 ), ldh, nve,h( kwv, 1 ), ldh, &
                              nho, h( ku, kwh ), ldh )
                 end if
                 ! ==== note progress (or the lack of it). ====
                 if( ld>0 ) then
                    ndfl = 1
                 else
                    ndfl = ndfl + 1
                 end if
                 ! ==== end of main loop ====
              end do loop_80
              ! ==== iteration limit exceeded.  set info to show where
              ! .    the problem occurred and exit. ====
              info = kbot
              90 continue
           end if
           ! ==== return the optimal value of lwork. ====
           work( 1 ) = real( lwkopt,KIND=sp)
     end subroutine stdlib_slaqr0

     module subroutine stdlib_dlaqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, work, lwork, info )
     !! DLAQR0 computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**T, where T is an upper quasi-triangular matrix (the
     !! Schur form), and Z is the orthogonal matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input orthogonal
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
                
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(dp), intent(out) :: wi(*), work(*), wr(*)
        ! ================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: kexnw = 5
           integer(ilp), parameter :: kexsh = 6
           real(dp), parameter :: wilk1 = 0.75_dp
           real(dp), parameter :: wilk2 = -0.4375_dp
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_dlahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== exceptional deflation windows:  try to cure rare
           ! .    slow convergence by varying the size of the
           ! .    deflation window after kexnw iterations. ====
           
           ! ==== exceptional shifts: try to cure rare slow convergence
           ! .    with ad-hoc exceptional shifts every kexsh iterations.
           ! .    ====
           
           ! ==== the constants wilk1 and wilk2 are used to form the
           ! .    exceptional shifts. ====
           
           
           ! Local Scalars 
           real(dp) :: aa, bb, cc, cs, dd, sn, ss, swap
           integer(ilp) :: i, inf, it, itmax, k, kacc22, kbot, kdu, ks, kt, ktop, ku, kv, kwh, &
           kwtop, kwv, ld, ls, lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns, nsmax, nsr, nve, nw,&
                      nwmax, nwr, nwupbd
           logical(lk) :: sorted
           character :: jbcmpz*2
           ! Local Arrays 
           real(dp) :: zdum(1,1)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! ==== quick return for n = 0: nothing to do. ====
           if( n==0 ) then
              work( 1 ) = one
              return
           end if
           if( n<=ntiny ) then
              ! ==== tiny matrices must use stdlib_dlahqr. ====
              lwkopt = 1
              if( lwork/=-1 )call stdlib_dlahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, &
                        ihiz, z, ldz, info )
           else
              ! ==== use small bulge multi-shift qr with aggressive early
              ! .    deflation on larger-than-tiny matrices. ====
              ! ==== hope for the best. ====
              info = 0
              ! ==== set up job flags for stdlib_ilaenv. ====
              if( wantt ) then
                 jbcmpz( 1: 1 ) = 'S'
              else
                 jbcmpz( 1: 1 ) = 'E'
              end if
              if( wantz ) then
                 jbcmpz( 2: 2 ) = 'V'
              else
                 jbcmpz( 2: 2 ) = 'N'
              end if
              ! ==== nwr = recommended deflation window size.  at this
              ! .    point,  n > ntiny = 15, so there is enough
              ! .    subdiagonal workspace for nwr>=2 as required.
              ! .    (in fact, there is enough subdiagonal space for
              ! .    nwr>=4.) ====
              nwr = stdlib_ilaenv( 13, 'DLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nwr = max( 2, nwr )
              nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
              ! ==== nsr = recommended number of simultaneous shifts.
              ! .    at this point n > ntiny = 15, so there is at
              ! .    enough subdiagonal workspace for nsr to be even
              ! .    and greater than or equal to two as required. ====
              nsr = stdlib_ilaenv( 15, 'DLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nsr = min( nsr, ( n-3 ) / 6, ihi-ilo )
              nsr = max( 2, nsr-mod( nsr, 2 ) )
              ! ==== estimate optimal workspace ====
              ! ==== workspace query call to stdlib_dlaqr3 ====
              call stdlib_dlaqr3( wantt, wantz, n, ilo, ihi, nwr+1, h, ldh, iloz,ihiz, z, ldz, ls,&
                         ld, wr, wi, h, ldh, n, h, ldh,n, h, ldh, work, -1 )
              ! ==== optimal workspace = max(stdlib_dlaqr5, stdlib_dlaqr3) ====
              lwkopt = max( 3*nsr / 2, int( work( 1 ),KIND=ilp) )
              ! ==== quick return in case of workspace query. ====
              if( lwork==-1 ) then
                 work( 1 ) = real( lwkopt,KIND=dp)
                 return
              end if
              ! ==== stdlib_dlahqr/stdlib_dlaqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'DLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nmin = max( ntiny, nmin )
              ! ==== nibble crossover point ====
              nibble = stdlib_ilaenv( 14, 'DLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nibble = max( 0, nibble )
              ! ==== accumulate reflections during ttswp?  use block
              ! .    2-by-2 structure during matrix-matrix multiply? ====
              kacc22 = stdlib_ilaenv( 16, 'DLAQR0', jbcmpz, n, ilo, ihi, lwork )
              kacc22 = max( 0, kacc22 )
              kacc22 = min( 2, kacc22 )
              ! ==== nwmax = the largest possible deflation window for
              ! .    which there is sufficient workspace. ====
              nwmax = min( ( n-1 ) / 3, lwork / 2 )
              nw = nwmax
              ! ==== nsmax = the largest number of simultaneous shifts
              ! .    for which there is sufficient workspace. ====
              nsmax = min( ( n-3 ) / 6, 2*lwork / 3 )
              nsmax = nsmax - mod( nsmax, 2 )
              ! ==== ndfl: an iteration count restarted at deflation. ====
              ndfl = 1
              ! ==== itmax = iteration limit ====
              itmax = max( 30, 2*kexsh )*max( 10, ( ihi-ilo+1 ) )
              ! ==== last row and column in the active block ====
              kbot = ihi
              ! ==== main loop ====
              loop_80: do it = 1, itmax
                 ! ==== done when kbot falls below ilo ====
                 if( kbot<ilo )go to 90
                 ! ==== locate active block ====
                 do k = kbot, ilo + 1, -1
                    if( h( k, k-1 )==zero )go to 20
                 end do
                 k = ilo
                 20 continue
                 ktop = k
                 ! ==== select deflation window size:
                 ! .    typical case:
                 ! .      if possible and advisable, nibble the entire
                 ! .      active block.  if not, use size min(nwr,nwmax)
                 ! .      or min(nwr+1,nwmax) depending upon which has
                 ! .      the smaller corresponding subdiagonal entry
                 ! .      (a heuristic).
                 ! .    exceptional case:
                 ! .      if there have been no deflations in kexnw or
                 ! .      more iterations, then vary the deflation window
                 ! .      size.   at first, because, larger windows are,
                 ! .      in general, more powerful than smaller ones,
                 ! .      rapidly increase the window to the maximum possible.
                 ! .      then, gradually reduce the window size. ====
                 nh = kbot - ktop + 1
                 nwupbd = min( nh, nwmax )
                 if( ndfl<kexnw ) then
                    nw = min( nwupbd, nwr )
                 else
                    nw = min( nwupbd, 2*nw )
                 end if
                 if( nw<nwmax ) then
                    if( nw>=nh-1 ) then
                       nw = nh
                    else
                       kwtop = kbot - nw + 1
                       if( abs( h( kwtop, kwtop-1 ) )>abs( h( kwtop-1, kwtop-2 ) ) )nw = nw + &
                                 1
                    end if
                 end if
                 if( ndfl<kexnw ) then
                    ndec = -1
                 else if( ndec>=0 .or. nw>=nwupbd ) then
                    ndec = ndec + 1
                    if( nw-ndec<2 )ndec = 0
                    nw = nw - ndec
                 end if
                 ! ==== aggressive early deflation:
                 ! .    split workspace under the subdiagonal into
                 ! .      - an nw-by-nw work array v in the lower
                 ! .        left-hand-corner,
                 ! .      - an nw-by-at-least-nw-but-more-is-better
                 ! .        (nw-by-nho) horizontal work array along
                 ! .        the bottom edge,
                 ! .      - an at-least-nw-but-more-is-better (nhv-by-nw)
                 ! .        vertical work array along the left-hand-edge.
                 ! .        ====
                 kv = n - nw + 1
                 kt = nw + 1
                 nho = ( n-nw-1 ) - kt + 1
                 kwv = nw + 2
                 nve = ( n-nw ) - kwv + 1
                 ! ==== aggressive early deflation ====
                 call stdlib_dlaqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
                 ls, ld, wr, wi, h( kv, 1 ), ldh,nho, h( kv, kt ), ldh, nve, h( kwv, 1 ), ldh,&
                           work, lwork )
                 ! ==== adjust kbot accounting for new deflations. ====
                 kbot = kbot - ld
                 ! ==== ks points to the shifts. ====
                 ks = kbot - ls + 1
                 ! ==== skip an expensive qr sweep if there is a (partly
                 ! .    heuristic) reason to expect that many eigenvalues
                 ! .    will deflate without it.  here, the qr sweep is
                 ! .    skipped if many eigenvalues have just been deflated
                 ! .    or if the remaining active block is small.
                 if( ( ld==0 ) .or. ( ( 100*ld<=nw*nibble ) .and. ( kbot-ktop+1>min( nmin, nwmax )&
                            ) ) ) then
                    ! ==== ns = nominal number of simultaneous shifts.
                    ! .    this may be lowered (slightly) if stdlib_dlaqr3
                    ! .    did not provide that many shifts. ====
                    ns = min( nsmax, nsr, max( 2, kbot-ktop ) )
                    ns = ns - mod( ns, 2 )
                    ! ==== if there have been no deflations
                    ! .    in a multiple of kexsh iterations,
                    ! .    then try exceptional shifts.
                    ! .    otherwise use shifts provided by
                    ! .    stdlib_dlaqr3 above or from the eigenvalues
                    ! .    of a trailing principal submatrix. ====
                    if( mod( ndfl, kexsh )==0 ) then
                       ks = kbot - ns + 1
                       do i = kbot, max( ks+1, ktop+2 ), -2
                          ss = abs( h( i, i-1 ) ) + abs( h( i-1, i-2 ) )
                          aa = wilk1*ss + h( i, i )
                          bb = ss
                          cc = wilk2*ss
                          dd = aa
                          call stdlib_dlanv2( aa, bb, cc, dd, wr( i-1 ), wi( i-1 ),wr( i ), wi( i &
                                    ), cs, sn )
                       end do
                       if( ks==ktop ) then
                          wr( ks+1 ) = h( ks+1, ks+1 )
                          wi( ks+1 ) = zero
                          wr( ks ) = wr( ks+1 )
                          wi( ks ) = wi( ks+1 )
                       end if
                    else
                       ! ==== got ns/2 or fewer shifts? use stdlib_dlaqr4 or
                       ! .    stdlib_dlahqr on a trailing principal submatrix to
                       ! .    get more. (since ns<=nsmax<=(n-3)/6,
                       ! .    there is enough space below the subdiagonal
                       ! .    to fit an ns-by-ns scratch array.) ====
                       if( kbot-ks+1<=ns / 2 ) then
                          ks = kbot - ns + 1
                          kt = n - ns + 1
                          call stdlib_dlacpy( 'A', ns, ns, h( ks, ks ), ldh,h( kt, 1 ), ldh )
                                    
                          if( ns>nmin ) then
                             call stdlib_dlaqr4( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, wr( &
                                       ks ),wi( ks ), 1, 1, zdum, 1, work,lwork, inf )
                          else
                             call stdlib_dlahqr( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, wr( &
                                       ks ),wi( ks ), 1, 1, zdum, 1, inf )
                          end if
                          ks = ks + inf
                          ! ==== in case of a rare qr failure use
                          ! .    eigenvalues of the trailing 2-by-2
                          ! .    principal submatrix.  ====
                          if( ks>=kbot ) then
                             aa = h( kbot-1, kbot-1 )
                             cc = h( kbot, kbot-1 )
                             bb = h( kbot-1, kbot )
                             dd = h( kbot, kbot )
                             call stdlib_dlanv2( aa, bb, cc, dd, wr( kbot-1 ),wi( kbot-1 ), wr( &
                                       kbot ),wi( kbot ), cs, sn )
                             ks = kbot - 1
                          end if
                       end if
                       if( kbot-ks+1>ns ) then
                          ! ==== sort the shifts (helps a little)
                          ! .    bubble sort keeps complex conjugate
                          ! .    pairs together. ====
                          sorted = .false.
                          do k = kbot, ks + 1, -1
                             if( sorted )go to 60
                             sorted = .true.
                             do i = ks, k - 1
                                if( abs( wr( i ) )+abs( wi( i ) )<abs( wr( i+1 ) )+abs( wi( i+1 ) &
                                          ) ) then
                                   sorted = .false.
                                   swap = wr( i )
                                   wr( i ) = wr( i+1 )
                                   wr( i+1 ) = swap
                                   swap = wi( i )
                                   wi( i ) = wi( i+1 )
                                   wi( i+1 ) = swap
                                end if
                             end do
                          end do
                          60 continue
                       end if
                       ! ==== shuffle shifts into pairs of real shifts
                       ! .    and pairs of complex conjugate shifts
                       ! .    assuming complex conjugate shifts are
                       ! .    already adjacent to one another. (yes,
                       ! .    they are.)  ====
                       do i = kbot, ks + 2, -2
                          if( wi( i )/=-wi( i-1 ) ) then
                             swap = wr( i )
                             wr( i ) = wr( i-1 )
                             wr( i-1 ) = wr( i-2 )
                             wr( i-2 ) = swap
                             swap = wi( i )
                             wi( i ) = wi( i-1 )
                             wi( i-1 ) = wi( i-2 )
                             wi( i-2 ) = swap
                          end if
                       end do
                    end if
                    ! ==== if there are only two shifts and both are
                    ! .    real, then use only one.  ====
                    if( kbot-ks+1==2 ) then
                       if( wi( kbot )==zero ) then
                          if( abs( wr( kbot )-h( kbot, kbot ) )<abs( wr( kbot-1 )-h( kbot, kbot ) &
                                    ) ) then
                             wr( kbot-1 ) = wr( kbot )
                          else
                             wr( kbot ) = wr( kbot-1 )
                          end if
                       end if
                    end if
                    ! ==== use up to ns of the the smallest magnitude
                    ! .    shifts.  if there aren't ns shifts available,
                    ! .    then use them all, possibly dropping one to
                    ! .    make the number of shifts even. ====
                    ns = min( ns, kbot-ks+1 )
                    ns = ns - mod( ns, 2 )
                    ks = kbot - ns + 1
                    ! ==== small-bulge multi-shift qr sweep:
                    ! .    split workspace under the subdiagonal into
                    ! .    - a kdu-by-kdu work array u in the lower
                    ! .      left-hand-corner,
                    ! .    - a kdu-by-at-least-kdu-but-more-is-better
                    ! .      (kdu-by-nho) horizontal work array wh along
                    ! .      the bottom edge,
                    ! .    - and an at-least-kdu-but-more-is-better-by-kdu
                    ! .      (nve-by-kdu) vertical work wv arrow along
                    ! .      the left-hand-edge. ====
                    kdu = 2*ns
                    ku = n - kdu + 1
                    kwh = kdu + 1
                    nho = ( n-kdu+1-4 ) - ( kdu+1 ) + 1
                    kwv = kdu + 4
                    nve = n - kdu - kwv + 1
                    ! ==== small-bulge multi-shift qr sweep ====
                    call stdlib_dlaqr5( wantt, wantz, kacc22, n, ktop, kbot, ns,wr( ks ), wi( ks )&
                    , h, ldh, iloz, ihiz, z,ldz, work, 3, h( ku, 1 ), ldh, nve,h( kwv, 1 ), ldh, &
                              nho, h( ku, kwh ), ldh )
                 end if
                 ! ==== note progress (or the lack of it). ====
                 if( ld>0 ) then
                    ndfl = 1
                 else
                    ndfl = ndfl + 1
                 end if
                 ! ==== end of main loop ====
              end do loop_80
              ! ==== iteration limit exceeded.  set info to show where
              ! .    the problem occurred and exit. ====
              info = kbot
              90 continue
           end if
           ! ==== return the optimal value of lwork. ====
           work( 1 ) = real( lwkopt,KIND=dp)
     end subroutine stdlib_dlaqr0

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$laqr0( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, work, lwork, info )
     !! DLAQR0: computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**T, where T is an upper quasi-triangular matrix (the
     !! Schur form), and Z is the orthogonal matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input orthogonal
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
                
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(${rk}$), intent(inout) :: h(ldh,*), z(ldz,*)
           real(${rk}$), intent(out) :: wi(*), work(*), wr(*)
        ! ================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: kexnw = 5
           integer(ilp), parameter :: kexsh = 6
           real(${rk}$), parameter :: wilk1 = 0.75_${rk}$
           real(${rk}$), parameter :: wilk2 = -0.4375_${rk}$
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_${ri}$lahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== exceptional deflation windows:  try to cure rare
           ! .    slow convergence by varying the size of the
           ! .    deflation window after kexnw iterations. ====
           
           ! ==== exceptional shifts: try to cure rare slow convergence
           ! .    with ad-hoc exceptional shifts every kexsh iterations.
           ! .    ====
           
           ! ==== the constants wilk1 and wilk2 are used to form the
           ! .    exceptional shifts. ====
           
           
           ! Local Scalars 
           real(${rk}$) :: aa, bb, cc, cs, dd, sn, ss, swap
           integer(ilp) :: i, inf, it, itmax, k, kacc22, kbot, kdu, ks, kt, ktop, ku, kv, kwh, &
           kwtop, kwv, ld, ls, lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns, nsmax, nsr, nve, nw,&
                      nwmax, nwr, nwupbd
           logical(lk) :: sorted
           character :: jbcmpz*2
           ! Local Arrays 
           real(${rk}$) :: zdum(1,1)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! ==== quick return for n = 0: nothing to do. ====
           if( n==0 ) then
              work( 1 ) = one
              return
           end if
           if( n<=ntiny ) then
              ! ==== tiny matrices must use stdlib_${ri}$lahqr. ====
              lwkopt = 1
              if( lwork/=-1 )call stdlib_${ri}$lahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, &
                        ihiz, z, ldz, info )
           else
              ! ==== use small bulge multi-shift qr with aggressive early
              ! .    deflation on larger-than-tiny matrices. ====
              ! ==== hope for the best. ====
              info = 0
              ! ==== set up job flags for stdlib_ilaenv. ====
              if( wantt ) then
                 jbcmpz( 1: 1 ) = 'S'
              else
                 jbcmpz( 1: 1 ) = 'E'
              end if
              if( wantz ) then
                 jbcmpz( 2: 2 ) = 'V'
              else
                 jbcmpz( 2: 2 ) = 'N'
              end if
              ! ==== nwr = recommended deflation window size.  at this
              ! .    point,  n > ntiny = 15, so there is enough
              ! .    subdiagonal workspace for nwr>=2 as required.
              ! .    (in fact, there is enough subdiagonal space for
              ! .    nwr>=4.) ====
              nwr = stdlib_ilaenv( 13, 'DLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nwr = max( 2, nwr )
              nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
              ! ==== nsr = recommended number of simultaneous shifts.
              ! .    at this point n > ntiny = 15, so there is at
              ! .    enough subdiagonal workspace for nsr to be even
              ! .    and greater than or equal to two as required. ====
              nsr = stdlib_ilaenv( 15, 'DLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nsr = min( nsr, ( n-3 ) / 6, ihi-ilo )
              nsr = max( 2, nsr-mod( nsr, 2 ) )
              ! ==== estimate optimal workspace ====
              ! ==== workspace query call to stdlib_${ri}$laqr3 ====
              call stdlib_${ri}$laqr3( wantt, wantz, n, ilo, ihi, nwr+1, h, ldh, iloz,ihiz, z, ldz, ls,&
                         ld, wr, wi, h, ldh, n, h, ldh,n, h, ldh, work, -1 )
              ! ==== optimal workspace = max(stdlib_${ri}$laqr5, stdlib_${ri}$laqr3) ====
              lwkopt = max( 3*nsr / 2, int( work( 1 ),KIND=ilp) )
              ! ==== quick return in case of workspace query. ====
              if( lwork==-1 ) then
                 work( 1 ) = real( lwkopt,KIND=${rk}$)
                 return
              end if
              ! ==== stdlib_${ri}$lahqr/stdlib_${ri}$laqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'DLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nmin = max( ntiny, nmin )
              ! ==== nibble crossover point ====
              nibble = stdlib_ilaenv( 14, 'DLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nibble = max( 0, nibble )
              ! ==== accumulate reflections during ttswp?  use block
              ! .    2-by-2 structure during matrix-matrix multiply? ====
              kacc22 = stdlib_ilaenv( 16, 'DLAQR0', jbcmpz, n, ilo, ihi, lwork )
              kacc22 = max( 0, kacc22 )
              kacc22 = min( 2, kacc22 )
              ! ==== nwmax = the largest possible deflation window for
              ! .    which there is sufficient workspace. ====
              nwmax = min( ( n-1 ) / 3, lwork / 2 )
              nw = nwmax
              ! ==== nsmax = the largest number of simultaneous shifts
              ! .    for which there is sufficient workspace. ====
              nsmax = min( ( n-3 ) / 6, 2*lwork / 3 )
              nsmax = nsmax - mod( nsmax, 2 )
              ! ==== ndfl: an iteration count restarted at deflation. ====
              ndfl = 1
              ! ==== itmax = iteration limit ====
              itmax = max( 30, 2*kexsh )*max( 10, ( ihi-ilo+1 ) )
              ! ==== last row and column in the active block ====
              kbot = ihi
              ! ==== main loop ====
              loop_80: do it = 1, itmax
                 ! ==== done when kbot falls below ilo ====
                 if( kbot<ilo )go to 90
                 ! ==== locate active block ====
                 do k = kbot, ilo + 1, -1
                    if( h( k, k-1 )==zero )go to 20
                 end do
                 k = ilo
                 20 continue
                 ktop = k
                 ! ==== select deflation window size:
                 ! .    typical case:
                 ! .      if possible and advisable, nibble the entire
                 ! .      active block.  if not, use size min(nwr,nwmax)
                 ! .      or min(nwr+1,nwmax) depending upon which has
                 ! .      the smaller corresponding subdiagonal entry
                 ! .      (a heuristic).
                 ! .    exceptional case:
                 ! .      if there have been no deflations in kexnw or
                 ! .      more iterations, then vary the deflation window
                 ! .      size.   at first, because, larger windows are,
                 ! .      in general, more powerful than smaller ones,
                 ! .      rapidly increase the window to the maximum possible.
                 ! .      then, gradually reduce the window size. ====
                 nh = kbot - ktop + 1
                 nwupbd = min( nh, nwmax )
                 if( ndfl<kexnw ) then
                    nw = min( nwupbd, nwr )
                 else
                    nw = min( nwupbd, 2*nw )
                 end if
                 if( nw<nwmax ) then
                    if( nw>=nh-1 ) then
                       nw = nh
                    else
                       kwtop = kbot - nw + 1
                       if( abs( h( kwtop, kwtop-1 ) )>abs( h( kwtop-1, kwtop-2 ) ) )nw = nw + &
                                 1
                    end if
                 end if
                 if( ndfl<kexnw ) then
                    ndec = -1
                 else if( ndec>=0 .or. nw>=nwupbd ) then
                    ndec = ndec + 1
                    if( nw-ndec<2 )ndec = 0
                    nw = nw - ndec
                 end if
                 ! ==== aggressive early deflation:
                 ! .    split workspace under the subdiagonal into
                 ! .      - an nw-by-nw work array v in the lower
                 ! .        left-hand-corner,
                 ! .      - an nw-by-at-least-nw-but-more-is-better
                 ! .        (nw-by-nho) horizontal work array along
                 ! .        the bottom edge,
                 ! .      - an at-least-nw-but-more-is-better (nhv-by-nw)
                 ! .        vertical work array along the left-hand-edge.
                 ! .        ====
                 kv = n - nw + 1
                 kt = nw + 1
                 nho = ( n-nw-1 ) - kt + 1
                 kwv = nw + 2
                 nve = ( n-nw ) - kwv + 1
                 ! ==== aggressive early deflation ====
                 call stdlib_${ri}$laqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
                 ls, ld, wr, wi, h( kv, 1 ), ldh,nho, h( kv, kt ), ldh, nve, h( kwv, 1 ), ldh,&
                           work, lwork )
                 ! ==== adjust kbot accounting for new deflations. ====
                 kbot = kbot - ld
                 ! ==== ks points to the shifts. ====
                 ks = kbot - ls + 1
                 ! ==== skip an expensive qr sweep if there is a (partly
                 ! .    heuristic) reason to expect that many eigenvalues
                 ! .    will deflate without it.  here, the qr sweep is
                 ! .    skipped if many eigenvalues have just been deflated
                 ! .    or if the remaining active block is small.
                 if( ( ld==0 ) .or. ( ( 100*ld<=nw*nibble ) .and. ( kbot-ktop+1>min( nmin, nwmax )&
                            ) ) ) then
                    ! ==== ns = nominal number of simultaneous shifts.
                    ! .    this may be lowered (slightly) if stdlib_${ri}$laqr3
                    ! .    did not provide that many shifts. ====
                    ns = min( nsmax, nsr, max( 2, kbot-ktop ) )
                    ns = ns - mod( ns, 2 )
                    ! ==== if there have been no deflations
                    ! .    in a multiple of kexsh iterations,
                    ! .    then try exceptional shifts.
                    ! .    otherwise use shifts provided by
                    ! .    stdlib_${ri}$laqr3 above or from the eigenvalues
                    ! .    of a trailing principal submatrix. ====
                    if( mod( ndfl, kexsh )==0 ) then
                       ks = kbot - ns + 1
                       do i = kbot, max( ks+1, ktop+2 ), -2
                          ss = abs( h( i, i-1 ) ) + abs( h( i-1, i-2 ) )
                          aa = wilk1*ss + h( i, i )
                          bb = ss
                          cc = wilk2*ss
                          dd = aa
                          call stdlib_${ri}$lanv2( aa, bb, cc, dd, wr( i-1 ), wi( i-1 ),wr( i ), wi( i &
                                    ), cs, sn )
                       end do
                       if( ks==ktop ) then
                          wr( ks+1 ) = h( ks+1, ks+1 )
                          wi( ks+1 ) = zero
                          wr( ks ) = wr( ks+1 )
                          wi( ks ) = wi( ks+1 )
                       end if
                    else
                       ! ==== got ns/2 or fewer shifts? use stdlib_${ri}$laqr4 or
                       ! .    stdlib_${ri}$lahqr on a trailing principal submatrix to
                       ! .    get more. (since ns<=nsmax<=(n-3)/6,
                       ! .    there is enough space below the subdiagonal
                       ! .    to fit an ns-by-ns scratch array.) ====
                       if( kbot-ks+1<=ns / 2 ) then
                          ks = kbot - ns + 1
                          kt = n - ns + 1
                          call stdlib_${ri}$lacpy( 'A', ns, ns, h( ks, ks ), ldh,h( kt, 1 ), ldh )
                                    
                          if( ns>nmin ) then
                             call stdlib_${ri}$laqr4( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, wr( &
                                       ks ),wi( ks ), 1, 1, zdum, 1, work,lwork, inf )
                          else
                             call stdlib_${ri}$lahqr( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, wr( &
                                       ks ),wi( ks ), 1, 1, zdum, 1, inf )
                          end if
                          ks = ks + inf
                          ! ==== in case of a rare qr failure use
                          ! .    eigenvalues of the trailing 2-by-2
                          ! .    principal submatrix.  ====
                          if( ks>=kbot ) then
                             aa = h( kbot-1, kbot-1 )
                             cc = h( kbot, kbot-1 )
                             bb = h( kbot-1, kbot )
                             dd = h( kbot, kbot )
                             call stdlib_${ri}$lanv2( aa, bb, cc, dd, wr( kbot-1 ),wi( kbot-1 ), wr( &
                                       kbot ),wi( kbot ), cs, sn )
                             ks = kbot - 1
                          end if
                       end if
                       if( kbot-ks+1>ns ) then
                          ! ==== sort the shifts (helps a little)
                          ! .    bubble sort keeps complex conjugate
                          ! .    pairs together. ====
                          sorted = .false.
                          do k = kbot, ks + 1, -1
                             if( sorted )go to 60
                             sorted = .true.
                             do i = ks, k - 1
                                if( abs( wr( i ) )+abs( wi( i ) )<abs( wr( i+1 ) )+abs( wi( i+1 ) &
                                          ) ) then
                                   sorted = .false.
                                   swap = wr( i )
                                   wr( i ) = wr( i+1 )
                                   wr( i+1 ) = swap
                                   swap = wi( i )
                                   wi( i ) = wi( i+1 )
                                   wi( i+1 ) = swap
                                end if
                             end do
                          end do
                          60 continue
                       end if
                       ! ==== shuffle shifts into pairs of real shifts
                       ! .    and pairs of complex conjugate shifts
                       ! .    assuming complex conjugate shifts are
                       ! .    already adjacent to one another. (yes,
                       ! .    they are.)  ====
                       do i = kbot, ks + 2, -2
                          if( wi( i )/=-wi( i-1 ) ) then
                             swap = wr( i )
                             wr( i ) = wr( i-1 )
                             wr( i-1 ) = wr( i-2 )
                             wr( i-2 ) = swap
                             swap = wi( i )
                             wi( i ) = wi( i-1 )
                             wi( i-1 ) = wi( i-2 )
                             wi( i-2 ) = swap
                          end if
                       end do
                    end if
                    ! ==== if there are only two shifts and both are
                    ! .    real, then use only one.  ====
                    if( kbot-ks+1==2 ) then
                       if( wi( kbot )==zero ) then
                          if( abs( wr( kbot )-h( kbot, kbot ) )<abs( wr( kbot-1 )-h( kbot, kbot ) &
                                    ) ) then
                             wr( kbot-1 ) = wr( kbot )
                          else
                             wr( kbot ) = wr( kbot-1 )
                          end if
                       end if
                    end if
                    ! ==== use up to ns of the the smallest magnitude
                    ! .    shifts.  if there aren't ns shifts available,
                    ! .    then use them all, possibly dropping one to
                    ! .    make the number of shifts even. ====
                    ns = min( ns, kbot-ks+1 )
                    ns = ns - mod( ns, 2 )
                    ks = kbot - ns + 1
                    ! ==== small-bulge multi-shift qr sweep:
                    ! .    split workspace under the subdiagonal into
                    ! .    - a kdu-by-kdu work array u in the lower
                    ! .      left-hand-corner,
                    ! .    - a kdu-by-at-least-kdu-but-more-is-better
                    ! .      (kdu-by-nho) horizontal work array wh along
                    ! .      the bottom edge,
                    ! .    - and an at-least-kdu-but-more-is-better-by-kdu
                    ! .      (nve-by-kdu) vertical work wv arrow along
                    ! .      the left-hand-edge. ====
                    kdu = 2*ns
                    ku = n - kdu + 1
                    kwh = kdu + 1
                    nho = ( n-kdu+1-4 ) - ( kdu+1 ) + 1
                    kwv = kdu + 4
                    nve = n - kdu - kwv + 1
                    ! ==== small-bulge multi-shift qr sweep ====
                    call stdlib_${ri}$laqr5( wantt, wantz, kacc22, n, ktop, kbot, ns,wr( ks ), wi( ks )&
                    , h, ldh, iloz, ihiz, z,ldz, work, 3, h( ku, 1 ), ldh, nve,h( kwv, 1 ), ldh, &
                              nho, h( ku, kwh ), ldh )
                 end if
                 ! ==== note progress (or the lack of it). ====
                 if( ld>0 ) then
                    ndfl = 1
                 else
                    ndfl = ndfl + 1
                 end if
                 ! ==== end of main loop ====
              end do loop_80
              ! ==== iteration limit exceeded.  set info to show where
              ! .    the problem occurred and exit. ====
              info = kbot
              90 continue
           end if
           ! ==== return the optimal value of lwork. ====
           work( 1 ) = real( lwkopt,KIND=${rk}$)
     end subroutine stdlib_${ri}$laqr0

#:endif
#:endfor

     module pure subroutine stdlib_claqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, work, lwork, info )
     !! CLAQR0 computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**H, where T is an upper triangular matrix (the
     !! Schur form), and Z is the unitary matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input unitary
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
                
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: w(*), work(*)
        ! ================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: kexnw = 5
           integer(ilp), parameter :: kexsh = 6
           real(sp), parameter :: wilk1 = 0.75_sp
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_clahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== exceptional deflation windows:  try to cure rare
           ! .    slow convergence by varying the size of the
           ! .    deflation window after kexnw iterations. ====
           
           ! ==== exceptional shifts: try to cure rare slow convergence
           ! .    with ad-hoc exceptional shifts every kexsh iterations.
           ! .    ====
           
           ! ==== the constant wilk1 is used to form the exceptional
           ! .    shifts. ====
           
           
           
           ! Local Scalars 
           complex(sp) :: aa, bb, cc, cdum, dd, det, rtdisc, swap, tr2
           real(sp) :: s
           integer(ilp) :: i, inf, it, itmax, k, kacc22, kbot, kdu, ks, kt, ktop, ku, kv, kwh, &
           kwtop, kwv, ld, ls, lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns, nsmax, nsr, nve, nw,&
                      nwmax, nwr, nwupbd
           logical(lk) :: sorted
           character :: jbcmpz*2
           ! Local Arrays 
           complex(sp) :: zdum(1,1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! ==== quick return for n = 0: nothing to do. ====
           if( n==0 ) then
              work( 1 ) = cone
              return
           end if
           if( n<=ntiny ) then
              ! ==== tiny matrices must use stdlib_clahqr. ====
              lwkopt = 1
              if( lwork/=-1 )call stdlib_clahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, &
                        z, ldz, info )
           else
              ! ==== use small bulge multi-shift qr with aggressive early
              ! .    deflation on larger-than-tiny matrices. ====
              ! ==== hope for the best. ====
              info = 0
              ! ==== set up job flags for stdlib_ilaenv. ====
              if( wantt ) then
                 jbcmpz( 1: 1 ) = 'S'
              else
                 jbcmpz( 1: 1 ) = 'E'
              end if
              if( wantz ) then
                 jbcmpz( 2: 2 ) = 'V'
              else
                 jbcmpz( 2: 2 ) = 'N'
              end if
              ! ==== nwr = recommended deflation window size.  at this
              ! .    point,  n > ntiny = 15, so there is enough
              ! .    subdiagonal workspace for nwr>=2 as required.
              ! .    (in fact, there is enough subdiagonal space for
              ! .    nwr>=4.) ====
              nwr = stdlib_ilaenv( 13, 'CLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nwr = max( 2, nwr )
              nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
              ! ==== nsr = recommended number of simultaneous shifts.
              ! .    at this point n > ntiny = 15, so there is at
              ! .    enough subdiagonal workspace for nsr to be even
              ! .    and greater than or equal to two as required. ====
              nsr = stdlib_ilaenv( 15, 'CLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nsr = min( nsr, ( n-3 ) / 6, ihi-ilo )
              nsr = max( 2, nsr-mod( nsr, 2 ) )
              ! ==== estimate optimal workspace ====
              ! ==== workspace query call to stdlib_claqr3 ====
              call stdlib_claqr3( wantt, wantz, n, ilo, ihi, nwr+1, h, ldh, iloz,ihiz, z, ldz, ls,&
                         ld, w, h, ldh, n, h, ldh, n, h,ldh, work, -1 )
              ! ==== optimal workspace = max(stdlib_claqr5, stdlib_claqr3) ====
              lwkopt = max( 3*nsr / 2, int( work( 1 ),KIND=ilp) )
              ! ==== quick return in case of workspace query. ====
              if( lwork==-1 ) then
                 work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
                 return
              end if
              ! ==== stdlib_clahqr/stdlib_claqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'CLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nmin = max( ntiny, nmin )
              ! ==== nibble crossover point ====
              nibble = stdlib_ilaenv( 14, 'CLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nibble = max( 0, nibble )
              ! ==== accumulate reflections during ttswp?  use block
              ! .    2-by-2 structure during matrix-matrix multiply? ====
              kacc22 = stdlib_ilaenv( 16, 'CLAQR0', jbcmpz, n, ilo, ihi, lwork )
              kacc22 = max( 0, kacc22 )
              kacc22 = min( 2, kacc22 )
              ! ==== nwmax = the largest possible deflation window for
              ! .    which there is sufficient workspace. ====
              nwmax = min( ( n-1 ) / 3, lwork / 2 )
              nw = nwmax
              ! ==== nsmax = the largest number of simultaneous shifts
              ! .    for which there is sufficient workspace. ====
              nsmax = min( ( n-3 ) / 6, 2*lwork / 3 )
              nsmax = nsmax - mod( nsmax, 2 )
              ! ==== ndfl: an iteration count restarted at deflation. ====
              ndfl = 1
              ! ==== itmax = iteration limit ====
              itmax = max( 30, 2*kexsh )*max( 10, ( ihi-ilo+1 ) )
              ! ==== last row and column in the active block ====
              kbot = ihi
              ! ==== main loop ====
              loop_70: do it = 1, itmax
                 ! ==== done when kbot falls below ilo ====
                 if( kbot<ilo )go to 80
                 ! ==== locate active block ====
                 do k = kbot, ilo + 1, -1
                    if( h( k, k-1 )==czero )go to 20
                 end do
                 k = ilo
                 20 continue
                 ktop = k
                 ! ==== select deflation window size:
                 ! .    typical case:
                 ! .      if possible and advisable, nibble the entire
                 ! .      active block.  if not, use size min(nwr,nwmax)
                 ! .      or min(nwr+1,nwmax) depending upon which has
                 ! .      the smaller corresponding subdiagonal entry
                 ! .      (a heuristic).
                 ! .    exceptional case:
                 ! .      if there have been no deflations in kexnw or
                 ! .      more iterations, then vary the deflation window
                 ! .      size.   at first, because, larger windows are,
                 ! .      in general, more powerful than smaller ones,
                 ! .      rapidly increase the window to the maximum possible.
                 ! .      then, gradually reduce the window size. ====
                 nh = kbot - ktop + 1
                 nwupbd = min( nh, nwmax )
                 if( ndfl<kexnw ) then
                    nw = min( nwupbd, nwr )
                 else
                    nw = min( nwupbd, 2*nw )
                 end if
                 if( nw<nwmax ) then
                    if( nw>=nh-1 ) then
                       nw = nh
                    else
                       kwtop = kbot - nw + 1
                       if( cabs1( h( kwtop, kwtop-1 ) )>cabs1( h( kwtop-1, kwtop-2 ) ) )nw = nw + &
                                 1
                    end if
                 end if
                 if( ndfl<kexnw ) then
                    ndec = -1
                 else if( ndec>=0 .or. nw>=nwupbd ) then
                    ndec = ndec + 1
                    if( nw-ndec<2 )ndec = 0
                    nw = nw - ndec
                 end if
                 ! ==== aggressive early deflation:
                 ! .    split workspace under the subdiagonal into
                 ! .      - an nw-by-nw work array v in the lower
                 ! .        left-hand-corner,
                 ! .      - an nw-by-at-least-nw-but-more-is-better
                 ! .        (nw-by-nho) horizontal work array along
                 ! .        the bottom edge,
                 ! .      - an at-least-nw-but-more-is-better (nhv-by-nw)
                 ! .        vertical work array along the left-hand-edge.
                 ! .        ====
                 kv = n - nw + 1
                 kt = nw + 1
                 nho = ( n-nw-1 ) - kt + 1
                 kwv = nw + 2
                 nve = ( n-nw ) - kwv + 1
                 ! ==== aggressive early deflation ====
                 call stdlib_claqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
                 ls, ld, w, h( kv, 1 ), ldh, nho,h( kv, kt ), ldh, nve, h( kwv, 1 ), ldh, work,&
                           lwork )
                 ! ==== adjust kbot accounting for new deflations. ====
                 kbot = kbot - ld
                 ! ==== ks points to the shifts. ====
                 ks = kbot - ls + 1
                 ! ==== skip an expensive qr sweep if there is a (partly
                 ! .    heuristic) reason to expect that many eigenvalues
                 ! .    will deflate without it.  here, the qr sweep is
                 ! .    skipped if many eigenvalues have just been deflated
                 ! .    or if the remaining active block is small.
                 if( ( ld==0 ) .or. ( ( 100*ld<=nw*nibble ) .and. ( kbot-ktop+1>min( nmin, nwmax )&
                            ) ) ) then
                    ! ==== ns = nominal number of simultaneous shifts.
                    ! .    this may be lowered (slightly) if stdlib_claqr3
                    ! .    did not provide that many shifts. ====
                    ns = min( nsmax, nsr, max( 2, kbot-ktop ) )
                    ns = ns - mod( ns, 2 )
                    ! ==== if there have been no deflations
                    ! .    in a multiple of kexsh iterations,
                    ! .    then try exceptional shifts.
                    ! .    otherwise use shifts provided by
                    ! .    stdlib_claqr3 above or from the eigenvalues
                    ! .    of a trailing principal submatrix. ====
                    if( mod( ndfl, kexsh )==0 ) then
                       ks = kbot - ns + 1
                       do i = kbot, ks + 1, -2
                          w( i ) = h( i, i ) + wilk1*cabs1( h( i, i-1 ) )
                          w( i-1 ) = w( i )
                       end do
                    else
                       ! ==== got ns/2 or fewer shifts? use stdlib_claqr4 or
                       ! .    stdlib_clahqr on a trailing principal submatrix to
                       ! .    get more. (since ns<=nsmax<=(n-3)/6,
                       ! .    there is enough space below the subdiagonal
                       ! .    to fit an ns-by-ns scratch array.) ====
                       if( kbot-ks+1<=ns / 2 ) then
                          ks = kbot - ns + 1
                          kt = n - ns + 1
                          call stdlib_clacpy( 'A', ns, ns, h( ks, ks ), ldh,h( kt, 1 ), ldh )
                                    
                          if( ns>nmin ) then
                             call stdlib_claqr4( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, w( &
                                       ks ), 1, 1,zdum, 1, work, lwork, inf )
                          else
                             call stdlib_clahqr( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, w( &
                                       ks ), 1, 1,zdum, 1, inf )
                          end if
                          ks = ks + inf
                          ! ==== in case of a rare qr failure use
                          ! .    eigenvalues of the trailing 2-by-2
                          ! .    principal submatrix.  scale to avoid
                          ! .    overflows, underflows and subnormals.
                          ! .    (the scale factor s can not be czero,
                          ! .    because h(kbot,kbot-1) is nonzero.) ====
                          if( ks>=kbot ) then
                             s = cabs1( h( kbot-1, kbot-1 ) ) +cabs1( h( kbot, kbot-1 ) ) +cabs1( &
                                       h( kbot-1, kbot ) ) +cabs1( h( kbot, kbot ) )
                             aa = h( kbot-1, kbot-1 ) / s
                             cc = h( kbot, kbot-1 ) / s
                             bb = h( kbot-1, kbot ) / s
                             dd = h( kbot, kbot ) / s
                             tr2 = ( aa+dd ) / two
                             det = ( aa-tr2 )*( dd-tr2 ) - bb*cc
                             rtdisc = sqrt( -det )
                             w( kbot-1 ) = ( tr2+rtdisc )*s
                             w( kbot ) = ( tr2-rtdisc )*s
                             ks = kbot - 1
                          end if
                       end if
                       if( kbot-ks+1>ns ) then
                          ! ==== sort the shifts (helps a little) ====
                          sorted = .false.
                          do k = kbot, ks + 1, -1
                             if( sorted )go to 60
                             sorted = .true.
                             do i = ks, k - 1
                                if( cabs1( w( i ) )<cabs1( w( i+1 ) ) )then
                                   sorted = .false.
                                   swap = w( i )
                                   w( i ) = w( i+1 )
                                   w( i+1 ) = swap
                                end if
                             end do
                          end do
                          60 continue
                       end if
                    end if
                    ! ==== if there are only two shifts, then use
                    ! .    only cone.  ====
                    if( kbot-ks+1==2 ) then
                       if( cabs1( w( kbot )-h( kbot, kbot ) )<cabs1( w( kbot-1 )-h( kbot, kbot ) )&
                                  ) then
                          w( kbot-1 ) = w( kbot )
                       else
                          w( kbot ) = w( kbot-1 )
                       end if
                    end if
                    ! ==== use up to ns of the the smallest magnitude
                    ! .    shifts.  if there aren't ns shifts available,
                    ! .    then use them all, possibly dropping cone to
                    ! .    make the number of shifts even. ====
                    ns = min( ns, kbot-ks+1 )
                    ns = ns - mod( ns, 2 )
                    ks = kbot - ns + 1
                    ! ==== small-bulge multi-shift qr sweep:
                    ! .    split workspace under the subdiagonal into
                    ! .    - a kdu-by-kdu work array u in the lower
                    ! .      left-hand-corner,
                    ! .    - a kdu-by-at-least-kdu-but-more-is-better
                    ! .      (kdu-by-nho) horizontal work array wh along
                    ! .      the bottom edge,
                    ! .    - and an at-least-kdu-but-more-is-better-by-kdu
                    ! .      (nve-by-kdu) vertical work wv arrow along
                    ! .      the left-hand-edge. ====
                    kdu = 2*ns
                    ku = n - kdu + 1
                    kwh = kdu + 1
                    nho = ( n-kdu+1-4 ) - ( kdu+1 ) + 1
                    kwv = kdu + 4
                    nve = n - kdu - kwv + 1
                    ! ==== small-bulge multi-shift qr sweep ====
                    call stdlib_claqr5( wantt, wantz, kacc22, n, ktop, kbot, ns,w( ks ), h, ldh, &
                    iloz, ihiz, z, ldz, work,3, h( ku, 1 ), ldh, nve, h( kwv, 1 ), ldh,nho, h( ku,&
                               kwh ), ldh )
                 end if
                 ! ==== note progress (or the lack of it). ====
                 if( ld>0 ) then
                    ndfl = 1
                 else
                    ndfl = ndfl + 1
                 end if
                 ! ==== end of main loop ====
              end do loop_70
              ! ==== iteration limit exceeded.  set info to show where
              ! .    the problem occurred and exit. ====
              info = kbot
              80 continue
           end if
           ! ==== return the optimal value of lwork. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
     end subroutine stdlib_claqr0

     module pure subroutine stdlib_zlaqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, work,lwork, info )
     !! ZLAQR0 computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**H, where T is an upper triangular matrix (the
     !! Schur form), and Z is the unitary matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input unitary
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
                
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(dp), intent(out) :: w(*), work(*)
        ! ================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: kexnw = 5
           integer(ilp), parameter :: kexsh = 6
           real(dp), parameter :: wilk1 = 0.75_dp
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_zlahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== exceptional deflation windows:  try to cure rare
           ! .    slow convergence by varying the size of the
           ! .    deflation window after kexnw iterations. ====
           
           ! ==== exceptional shifts: try to cure rare slow convergence
           ! .    with ad-hoc exceptional shifts every kexsh iterations.
           ! .    ====
           
           ! ==== the constant wilk1 is used to form the exceptional
           ! .    shifts. ====
           
           
           
           ! Local Scalars 
           complex(dp) :: aa, bb, cc, cdum, dd, det, rtdisc, swap, tr2
           real(dp) :: s
           integer(ilp) :: i, inf, it, itmax, k, kacc22, kbot, kdu, ks, kt, ktop, ku, kv, kwh, &
           kwtop, kwv, ld, ls, lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns, nsmax, nsr, nve, nw,&
                      nwmax, nwr, nwupbd
           logical(lk) :: sorted
           character :: jbcmpz*2
           ! Local Arrays 
           complex(dp) :: zdum(1,1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! ==== quick return for n = 0: nothing to do. ====
           if( n==0 ) then
              work( 1 ) = cone
              return
           end if
           if( n<=ntiny ) then
              ! ==== tiny matrices must use stdlib_zlahqr. ====
              lwkopt = 1
              if( lwork/=-1 )call stdlib_zlahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, &
                        z, ldz, info )
           else
              ! ==== use small bulge multi-shift qr with aggressive early
              ! .    deflation on larger-than-tiny matrices. ====
              ! ==== hope for the best. ====
              info = 0
              ! ==== set up job flags for stdlib_ilaenv. ====
              if( wantt ) then
                 jbcmpz( 1: 1 ) = 'S'
              else
                 jbcmpz( 1: 1 ) = 'E'
              end if
              if( wantz ) then
                 jbcmpz( 2: 2 ) = 'V'
              else
                 jbcmpz( 2: 2 ) = 'N'
              end if
              ! ==== nwr = recommended deflation window size.  at this
              ! .    point,  n > ntiny = 15, so there is enough
              ! .    subdiagonal workspace for nwr>=2 as required.
              ! .    (in fact, there is enough subdiagonal space for
              ! .    nwr>=4.) ====
              nwr = stdlib_ilaenv( 13, 'ZLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nwr = max( 2, nwr )
              nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
              ! ==== nsr = recommended number of simultaneous shifts.
              ! .    at this point n > ntiny = 15, so there is at
              ! .    enough subdiagonal workspace for nsr to be even
              ! .    and greater than or equal to two as required. ====
              nsr = stdlib_ilaenv( 15, 'ZLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nsr = min( nsr, ( n-3 ) / 6, ihi-ilo )
              nsr = max( 2, nsr-mod( nsr, 2 ) )
              ! ==== estimate optimal workspace ====
              ! ==== workspace query call to stdlib_zlaqr3 ====
              call stdlib_zlaqr3( wantt, wantz, n, ilo, ihi, nwr+1, h, ldh, iloz,ihiz, z, ldz, ls,&
                         ld, w, h, ldh, n, h, ldh, n, h,ldh, work, -1 )
              ! ==== optimal workspace = max(stdlib_zlaqr5, stdlib_zlaqr3) ====
              lwkopt = max( 3*nsr / 2, int( work( 1 ),KIND=ilp) )
              ! ==== quick return in case of workspace query. ====
              if( lwork==-1 ) then
                 work( 1 ) = cmplx( lwkopt, 0,KIND=dp)
                 return
              end if
              ! ==== stdlib_zlahqr/stdlib_zlaqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'ZLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nmin = max( ntiny, nmin )
              ! ==== nibble crossover point ====
              nibble = stdlib_ilaenv( 14, 'ZLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nibble = max( 0, nibble )
              ! ==== accumulate reflections during ttswp?  use block
              ! .    2-by-2 structure during matrix-matrix multiply? ====
              kacc22 = stdlib_ilaenv( 16, 'ZLAQR0', jbcmpz, n, ilo, ihi, lwork )
              kacc22 = max( 0, kacc22 )
              kacc22 = min( 2, kacc22 )
              ! ==== nwmax = the largest possible deflation window for
              ! .    which there is sufficient workspace. ====
              nwmax = min( ( n-1 ) / 3, lwork / 2 )
              nw = nwmax
              ! ==== nsmax = the largest number of simultaneous shifts
              ! .    for which there is sufficient workspace. ====
              nsmax = min( ( n-3 ) / 6, 2*lwork / 3 )
              nsmax = nsmax - mod( nsmax, 2 )
              ! ==== ndfl: an iteration count restarted at deflation. ====
              ndfl = 1
              ! ==== itmax = iteration limit ====
              itmax = max( 30, 2*kexsh )*max( 10, ( ihi-ilo+1 ) )
              ! ==== last row and column in the active block ====
              kbot = ihi
              ! ==== main loop ====
              loop_70: do it = 1, itmax
                 ! ==== done when kbot falls below ilo ====
                 if( kbot<ilo )go to 80
                 ! ==== locate active block ====
                 do k = kbot, ilo + 1, -1
                    if( h( k, k-1 )==czero )go to 20
                 end do
                 k = ilo
                 20 continue
                 ktop = k
                 ! ==== select deflation window size:
                 ! .    typical case:
                 ! .      if possible and advisable, nibble the entire
                 ! .      active block.  if not, use size min(nwr,nwmax)
                 ! .      or min(nwr+1,nwmax) depending upon which has
                 ! .      the smaller corresponding subdiagonal entry
                 ! .      (a heuristic).
                 ! .    exceptional case:
                 ! .      if there have been no deflations in kexnw or
                 ! .      more iterations, then vary the deflation window
                 ! .      size.   at first, because, larger windows are,
                 ! .      in general, more powerful than smaller ones,
                 ! .      rapidly increase the window to the maximum possible.
                 ! .      then, gradually reduce the window size. ====
                 nh = kbot - ktop + 1
                 nwupbd = min( nh, nwmax )
                 if( ndfl<kexnw ) then
                    nw = min( nwupbd, nwr )
                 else
                    nw = min( nwupbd, 2*nw )
                 end if
                 if( nw<nwmax ) then
                    if( nw>=nh-1 ) then
                       nw = nh
                    else
                       kwtop = kbot - nw + 1
                       if( cabs1( h( kwtop, kwtop-1 ) )>cabs1( h( kwtop-1, kwtop-2 ) ) )nw = nw + &
                                 1
                    end if
                 end if
                 if( ndfl<kexnw ) then
                    ndec = -1
                 else if( ndec>=0 .or. nw>=nwupbd ) then
                    ndec = ndec + 1
                    if( nw-ndec<2 )ndec = 0
                    nw = nw - ndec
                 end if
                 ! ==== aggressive early deflation:
                 ! .    split workspace under the subdiagonal into
                 ! .      - an nw-by-nw work array v in the lower
                 ! .        left-hand-corner,
                 ! .      - an nw-by-at-least-nw-but-more-is-better
                 ! .        (nw-by-nho) horizontal work array along
                 ! .        the bottom edge,
                 ! .      - an at-least-nw-but-more-is-better (nhv-by-nw)
                 ! .        vertical work array along the left-hand-edge.
                 ! .        ====
                 kv = n - nw + 1
                 kt = nw + 1
                 nho = ( n-nw-1 ) - kt + 1
                 kwv = nw + 2
                 nve = ( n-nw ) - kwv + 1
                 ! ==== aggressive early deflation ====
                 call stdlib_zlaqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
                 ls, ld, w, h( kv, 1 ), ldh, nho,h( kv, kt ), ldh, nve, h( kwv, 1 ), ldh, work,&
                           lwork )
                 ! ==== adjust kbot accounting for new deflations. ====
                 kbot = kbot - ld
                 ! ==== ks points to the shifts. ====
                 ks = kbot - ls + 1
                 ! ==== skip an expensive qr sweep if there is a (partly
                 ! .    heuristic) reason to expect that many eigenvalues
                 ! .    will deflate without it.  here, the qr sweep is
                 ! .    skipped if many eigenvalues have just been deflated
                 ! .    or if the remaining active block is small.
                 if( ( ld==0 ) .or. ( ( 100*ld<=nw*nibble ) .and. ( kbot-ktop+1>min( nmin, nwmax )&
                            ) ) ) then
                    ! ==== ns = nominal number of simultaneous shifts.
                    ! .    this may be lowered (slightly) if stdlib_zlaqr3
                    ! .    did not provide that many shifts. ====
                    ns = min( nsmax, nsr, max( 2, kbot-ktop ) )
                    ns = ns - mod( ns, 2 )
                    ! ==== if there have been no deflations
                    ! .    in a multiple of kexsh iterations,
                    ! .    then try exceptional shifts.
                    ! .    otherwise use shifts provided by
                    ! .    stdlib_zlaqr3 above or from the eigenvalues
                    ! .    of a trailing principal submatrix. ====
                    if( mod( ndfl, kexsh )==0 ) then
                       ks = kbot - ns + 1
                       do i = kbot, ks + 1, -2
                          w( i ) = h( i, i ) + wilk1*cabs1( h( i, i-1 ) )
                          w( i-1 ) = w( i )
                       end do
                    else
                       ! ==== got ns/2 or fewer shifts? use stdlib_zlaqr4 or
                       ! .    stdlib_zlahqr on a trailing principal submatrix to
                       ! .    get more. (since ns<=nsmax<=(n-3)/6,
                       ! .    there is enough space below the subdiagonal
                       ! .    to fit an ns-by-ns scratch array.) ====
                       if( kbot-ks+1<=ns / 2 ) then
                          ks = kbot - ns + 1
                          kt = n - ns + 1
                          call stdlib_zlacpy( 'A', ns, ns, h( ks, ks ), ldh,h( kt, 1 ), ldh )
                                    
                          if( ns>nmin ) then
                             call stdlib_zlaqr4( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, w( &
                                       ks ), 1, 1,zdum, 1, work, lwork, inf )
                          else
                             call stdlib_zlahqr( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, w( &
                                       ks ), 1, 1,zdum, 1, inf )
                          end if
                          ks = ks + inf
                          ! ==== in case of a rare qr failure use
                          ! .    eigenvalues of the trailing 2-by-2
                          ! .    principal submatrix.  scale to avoid
                          ! .    overflows, underflows and subnormals.
                          ! .    (the scale factor s can not be czero,
                          ! .    because h(kbot,kbot-1) is nonzero.) ====
                          if( ks>=kbot ) then
                             s = cabs1( h( kbot-1, kbot-1 ) ) +cabs1( h( kbot, kbot-1 ) ) +cabs1( &
                                       h( kbot-1, kbot ) ) +cabs1( h( kbot, kbot ) )
                             aa = h( kbot-1, kbot-1 ) / s
                             cc = h( kbot, kbot-1 ) / s
                             bb = h( kbot-1, kbot ) / s
                             dd = h( kbot, kbot ) / s
                             tr2 = ( aa+dd ) / two
                             det = ( aa-tr2 )*( dd-tr2 ) - bb*cc
                             rtdisc = sqrt( -det )
                             w( kbot-1 ) = ( tr2+rtdisc )*s
                             w( kbot ) = ( tr2-rtdisc )*s
                             ks = kbot - 1
                          end if
                       end if
                       if( kbot-ks+1>ns ) then
                          ! ==== sort the shifts (helps a little) ====
                          sorted = .false.
                          do k = kbot, ks + 1, -1
                             if( sorted )go to 60
                             sorted = .true.
                             do i = ks, k - 1
                                if( cabs1( w( i ) )<cabs1( w( i+1 ) ) )then
                                   sorted = .false.
                                   swap = w( i )
                                   w( i ) = w( i+1 )
                                   w( i+1 ) = swap
                                end if
                             end do
                          end do
                          60 continue
                       end if
                    end if
                    ! ==== if there are only two shifts, then use
                    ! .    only cone.  ====
                    if( kbot-ks+1==2 ) then
                       if( cabs1( w( kbot )-h( kbot, kbot ) )<cabs1( w( kbot-1 )-h( kbot, kbot ) )&
                                  ) then
                          w( kbot-1 ) = w( kbot )
                       else
                          w( kbot ) = w( kbot-1 )
                       end if
                    end if
                    ! ==== use up to ns of the the smallest magnitude
                    ! .    shifts.  if there aren't ns shifts available,
                    ! .    then use them all, possibly dropping cone to
                    ! .    make the number of shifts even. ====
                    ns = min( ns, kbot-ks+1 )
                    ns = ns - mod( ns, 2 )
                    ks = kbot - ns + 1
                    ! ==== small-bulge multi-shift qr sweep:
                    ! .    split workspace under the subdiagonal into
                    ! .    - a kdu-by-kdu work array u in the lower
                    ! .      left-hand-corner,
                    ! .    - a kdu-by-at-least-kdu-but-more-is-better
                    ! .      (kdu-by-nho) horizontal work array wh along
                    ! .      the bottom edge,
                    ! .    - and an at-least-kdu-but-more-is-better-by-kdu
                    ! .      (nve-by-kdu) vertical work wv arrow along
                    ! .      the left-hand-edge. ====
                    kdu = 2*ns
                    ku = n - kdu + 1
                    kwh = kdu + 1
                    nho = ( n-kdu+1-4 ) - ( kdu+1 ) + 1
                    kwv = kdu + 4
                    nve = n - kdu - kwv + 1
                    ! ==== small-bulge multi-shift qr sweep ====
                    call stdlib_zlaqr5( wantt, wantz, kacc22, n, ktop, kbot, ns,w( ks ), h, ldh, &
                    iloz, ihiz, z, ldz, work,3, h( ku, 1 ), ldh, nve, h( kwv, 1 ), ldh,nho, h( ku,&
                               kwh ), ldh )
                 end if
                 ! ==== note progress (or the lack of it). ====
                 if( ld>0 ) then
                    ndfl = 1
                 else
                    ndfl = ndfl + 1
                 end if
                 ! ==== end of main loop ====
              end do loop_70
              ! ==== iteration limit exceeded.  set info to show where
              ! .    the problem occurred and exit. ====
              info = kbot
              80 continue
           end if
           ! ==== return the optimal value of lwork. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=dp)
     end subroutine stdlib_zlaqr0

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$laqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, work, lwork, info )
     !! ZLAQR0: computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**H, where T is an upper triangular matrix (the
     !! Schur form), and Z is the unitary matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input unitary
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
                
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(${ck}$), intent(out) :: w(*), work(*)
        ! ================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: kexnw = 5
           integer(ilp), parameter :: kexsh = 6
           real(${ck}$), parameter :: wilk1 = 0.75_${ck}$
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_${ci}$lahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== exceptional deflation windows:  try to cure rare
           ! .    slow convergence by varying the size of the
           ! .    deflation window after kexnw iterations. ====
           
           ! ==== exceptional shifts: try to cure rare slow convergence
           ! .    with ad-hoc exceptional shifts every kexsh iterations.
           ! .    ====
           
           ! ==== the constant wilk1 is used to form the exceptional
           ! .    shifts. ====
           
           
           
           ! Local Scalars 
           complex(${ck}$) :: aa, bb, cc, cdum, dd, det, rtdisc, swap, tr2
           real(${ck}$) :: s
           integer(ilp) :: i, inf, it, itmax, k, kacc22, kbot, kdu, ks, kt, ktop, ku, kv, kwh, &
           kwtop, kwv, ld, ls, lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns, nsmax, nsr, nve, nw,&
                      nwmax, nwr, nwupbd
           logical(lk) :: sorted
           character :: jbcmpz*2
           ! Local Arrays 
           complex(${ck}$) :: zdum(1,1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! ==== quick return for n = 0: nothing to do. ====
           if( n==0 ) then
              work( 1 ) = cone
              return
           end if
           if( n<=ntiny ) then
              ! ==== tiny matrices must use stdlib_${ci}$lahqr. ====
              lwkopt = 1
              if( lwork/=-1 )call stdlib_${ci}$lahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, &
                        z, ldz, info )
           else
              ! ==== use small bulge multi-shift qr with aggressive early
              ! .    deflation on larger-than-tiny matrices. ====
              ! ==== hope for the best. ====
              info = 0
              ! ==== set up job flags for stdlib_ilaenv. ====
              if( wantt ) then
                 jbcmpz( 1: 1 ) = 'S'
              else
                 jbcmpz( 1: 1 ) = 'E'
              end if
              if( wantz ) then
                 jbcmpz( 2: 2 ) = 'V'
              else
                 jbcmpz( 2: 2 ) = 'N'
              end if
              ! ==== nwr = recommended deflation window size.  at this
              ! .    point,  n > ntiny = 15, so there is enough
              ! .    subdiagonal workspace for nwr>=2 as required.
              ! .    (in fact, there is enough subdiagonal space for
              ! .    nwr>=4.) ====
              nwr = stdlib_ilaenv( 13, 'ZLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nwr = max( 2, nwr )
              nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
              ! ==== nsr = recommended number of simultaneous shifts.
              ! .    at this point n > ntiny = 15, so there is at
              ! .    enough subdiagonal workspace for nsr to be even
              ! .    and greater than or equal to two as required. ====
              nsr = stdlib_ilaenv( 15, 'ZLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nsr = min( nsr, ( n-3 ) / 6, ihi-ilo )
              nsr = max( 2, nsr-mod( nsr, 2 ) )
              ! ==== estimate optimal workspace ====
              ! ==== workspace query call to stdlib_${ci}$laqr3 ====
              call stdlib_${ci}$laqr3( wantt, wantz, n, ilo, ihi, nwr+1, h, ldh, iloz,ihiz, z, ldz, ls,&
                         ld, w, h, ldh, n, h, ldh, n, h,ldh, work, -1 )
              ! ==== optimal workspace = max(stdlib_${ci}$laqr5, stdlib_${ci}$laqr3) ====
              lwkopt = max( 3*nsr / 2, int( work( 1 ),KIND=ilp) )
              ! ==== quick return in case of workspace query. ====
              if( lwork==-1 ) then
                 work( 1 ) = cmplx( lwkopt, 0,KIND=${ck}$)
                 return
              end if
              ! ==== stdlib_${ci}$lahqr/stdlib_${ci}$laqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'ZLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nmin = max( ntiny, nmin )
              ! ==== nibble crossover point ====
              nibble = stdlib_ilaenv( 14, 'ZLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nibble = max( 0, nibble )
              ! ==== accumulate reflections during ttswp?  use block
              ! .    2-by-2 structure during matrix-matrix multiply? ====
              kacc22 = stdlib_ilaenv( 16, 'ZLAQR0', jbcmpz, n, ilo, ihi, lwork )
              kacc22 = max( 0, kacc22 )
              kacc22 = min( 2, kacc22 )
              ! ==== nwmax = the largest possible deflation window for
              ! .    which there is sufficient workspace. ====
              nwmax = min( ( n-1 ) / 3, lwork / 2 )
              nw = nwmax
              ! ==== nsmax = the largest number of simultaneous shifts
              ! .    for which there is sufficient workspace. ====
              nsmax = min( ( n-3 ) / 6, 2*lwork / 3 )
              nsmax = nsmax - mod( nsmax, 2 )
              ! ==== ndfl: an iteration count restarted at deflation. ====
              ndfl = 1
              ! ==== itmax = iteration limit ====
              itmax = max( 30, 2*kexsh )*max( 10, ( ihi-ilo+1 ) )
              ! ==== last row and column in the active block ====
              kbot = ihi
              ! ==== main loop ====
              loop_70: do it = 1, itmax
                 ! ==== done when kbot falls below ilo ====
                 if( kbot<ilo )go to 80
                 ! ==== locate active block ====
                 do k = kbot, ilo + 1, -1
                    if( h( k, k-1 )==czero )go to 20
                 end do
                 k = ilo
                 20 continue
                 ktop = k
                 ! ==== select deflation window size:
                 ! .    typical case:
                 ! .      if possible and advisable, nibble the entire
                 ! .      active block.  if not, use size min(nwr,nwmax)
                 ! .      or min(nwr+1,nwmax) depending upon which has
                 ! .      the smaller corresponding subdiagonal entry
                 ! .      (a heuristic).
                 ! .    exceptional case:
                 ! .      if there have been no deflations in kexnw or
                 ! .      more iterations, then vary the deflation window
                 ! .      size.   at first, because, larger windows are,
                 ! .      in general, more powerful than smaller ones,
                 ! .      rapidly increase the window to the maximum possible.
                 ! .      then, gradually reduce the window size. ====
                 nh = kbot - ktop + 1
                 nwupbd = min( nh, nwmax )
                 if( ndfl<kexnw ) then
                    nw = min( nwupbd, nwr )
                 else
                    nw = min( nwupbd, 2*nw )
                 end if
                 if( nw<nwmax ) then
                    if( nw>=nh-1 ) then
                       nw = nh
                    else
                       kwtop = kbot - nw + 1
                       if( cabs1( h( kwtop, kwtop-1 ) )>cabs1( h( kwtop-1, kwtop-2 ) ) )nw = nw + &
                                 1
                    end if
                 end if
                 if( ndfl<kexnw ) then
                    ndec = -1
                 else if( ndec>=0 .or. nw>=nwupbd ) then
                    ndec = ndec + 1
                    if( nw-ndec<2 )ndec = 0
                    nw = nw - ndec
                 end if
                 ! ==== aggressive early deflation:
                 ! .    split workspace under the subdiagonal into
                 ! .      - an nw-by-nw work array v in the lower
                 ! .        left-hand-corner,
                 ! .      - an nw-by-at-least-nw-but-more-is-better
                 ! .        (nw-by-nho) horizontal work array along
                 ! .        the bottom edge,
                 ! .      - an at-least-nw-but-more-is-better (nhv-by-nw)
                 ! .        vertical work array along the left-hand-edge.
                 ! .        ====
                 kv = n - nw + 1
                 kt = nw + 1
                 nho = ( n-nw-1 ) - kt + 1
                 kwv = nw + 2
                 nve = ( n-nw ) - kwv + 1
                 ! ==== aggressive early deflation ====
                 call stdlib_${ci}$laqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
                 ls, ld, w, h( kv, 1 ), ldh, nho,h( kv, kt ), ldh, nve, h( kwv, 1 ), ldh, work,&
                           lwork )
                 ! ==== adjust kbot accounting for new deflations. ====
                 kbot = kbot - ld
                 ! ==== ks points to the shifts. ====
                 ks = kbot - ls + 1
                 ! ==== skip an expensive qr sweep if there is a (partly
                 ! .    heuristic) reason to expect that many eigenvalues
                 ! .    will deflate without it.  here, the qr sweep is
                 ! .    skipped if many eigenvalues have just been deflated
                 ! .    or if the remaining active block is small.
                 if( ( ld==0 ) .or. ( ( 100*ld<=nw*nibble ) .and. ( kbot-ktop+1>min( nmin, nwmax )&
                            ) ) ) then
                    ! ==== ns = nominal number of simultaneous shifts.
                    ! .    this may be lowered (slightly) if stdlib_${ci}$laqr3
                    ! .    did not provide that many shifts. ====
                    ns = min( nsmax, nsr, max( 2, kbot-ktop ) )
                    ns = ns - mod( ns, 2 )
                    ! ==== if there have been no deflations
                    ! .    in a multiple of kexsh iterations,
                    ! .    then try exceptional shifts.
                    ! .    otherwise use shifts provided by
                    ! .    stdlib_${ci}$laqr3 above or from the eigenvalues
                    ! .    of a trailing principal submatrix. ====
                    if( mod( ndfl, kexsh )==0 ) then
                       ks = kbot - ns + 1
                       do i = kbot, ks + 1, -2
                          w( i ) = h( i, i ) + wilk1*cabs1( h( i, i-1 ) )
                          w( i-1 ) = w( i )
                       end do
                    else
                       ! ==== got ns/2 or fewer shifts? use stdlib_${ci}$laqr4 or
                       ! .    stdlib_${ci}$lahqr on a trailing principal submatrix to
                       ! .    get more. (since ns<=nsmax<=(n-3)/6,
                       ! .    there is enough space below the subdiagonal
                       ! .    to fit an ns-by-ns scratch array.) ====
                       if( kbot-ks+1<=ns / 2 ) then
                          ks = kbot - ns + 1
                          kt = n - ns + 1
                          call stdlib_${ci}$lacpy( 'A', ns, ns, h( ks, ks ), ldh,h( kt, 1 ), ldh )
                                    
                          if( ns>nmin ) then
                             call stdlib_${ci}$laqr4( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, w( &
                                       ks ), 1, 1,zdum, 1, work, lwork, inf )
                          else
                             call stdlib_${ci}$lahqr( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, w( &
                                       ks ), 1, 1,zdum, 1, inf )
                          end if
                          ks = ks + inf
                          ! ==== in case of a rare qr failure use
                          ! .    eigenvalues of the trailing 2-by-2
                          ! .    principal submatrix.  scale to avoid
                          ! .    overflows, underflows and subnormals.
                          ! .    (the scale factor s can not be czero,
                          ! .    because h(kbot,kbot-1) is nonzero.) ====
                          if( ks>=kbot ) then
                             s = cabs1( h( kbot-1, kbot-1 ) ) +cabs1( h( kbot, kbot-1 ) ) +cabs1( &
                                       h( kbot-1, kbot ) ) +cabs1( h( kbot, kbot ) )
                             aa = h( kbot-1, kbot-1 ) / s
                             cc = h( kbot, kbot-1 ) / s
                             bb = h( kbot-1, kbot ) / s
                             dd = h( kbot, kbot ) / s
                             tr2 = ( aa+dd ) / two
                             det = ( aa-tr2 )*( dd-tr2 ) - bb*cc
                             rtdisc = sqrt( -det )
                             w( kbot-1 ) = ( tr2+rtdisc )*s
                             w( kbot ) = ( tr2-rtdisc )*s
                             ks = kbot - 1
                          end if
                       end if
                       if( kbot-ks+1>ns ) then
                          ! ==== sort the shifts (helps a little) ====
                          sorted = .false.
                          do k = kbot, ks + 1, -1
                             if( sorted )go to 60
                             sorted = .true.
                             do i = ks, k - 1
                                if( cabs1( w( i ) )<cabs1( w( i+1 ) ) )then
                                   sorted = .false.
                                   swap = w( i )
                                   w( i ) = w( i+1 )
                                   w( i+1 ) = swap
                                end if
                             end do
                          end do
                          60 continue
                       end if
                    end if
                    ! ==== if there are only two shifts, then use
                    ! .    only cone.  ====
                    if( kbot-ks+1==2 ) then
                       if( cabs1( w( kbot )-h( kbot, kbot ) )<cabs1( w( kbot-1 )-h( kbot, kbot ) )&
                                  ) then
                          w( kbot-1 ) = w( kbot )
                       else
                          w( kbot ) = w( kbot-1 )
                       end if
                    end if
                    ! ==== use up to ns of the the smallest magnitude
                    ! .    shifts.  if there aren't ns shifts available,
                    ! .    then use them all, possibly dropping cone to
                    ! .    make the number of shifts even. ====
                    ns = min( ns, kbot-ks+1 )
                    ns = ns - mod( ns, 2 )
                    ks = kbot - ns + 1
                    ! ==== small-bulge multi-shift qr sweep:
                    ! .    split workspace under the subdiagonal into
                    ! .    - a kdu-by-kdu work array u in the lower
                    ! .      left-hand-corner,
                    ! .    - a kdu-by-at-least-kdu-but-more-is-better
                    ! .      (kdu-by-nho) horizontal work array wh along
                    ! .      the bottom edge,
                    ! .    - and an at-least-kdu-but-more-is-better-by-kdu
                    ! .      (nve-by-kdu) vertical work wv arrow along
                    ! .      the left-hand-edge. ====
                    kdu = 2*ns
                    ku = n - kdu + 1
                    kwh = kdu + 1
                    nho = ( n-kdu+1-4 ) - ( kdu+1 ) + 1
                    kwv = kdu + 4
                    nve = n - kdu - kwv + 1
                    ! ==== small-bulge multi-shift qr sweep ====
                    call stdlib_${ci}$laqr5( wantt, wantz, kacc22, n, ktop, kbot, ns,w( ks ), h, ldh, &
                    iloz, ihiz, z, ldz, work,3, h( ku, 1 ), ldh, nve, h( kwv, 1 ), ldh,nho, h( ku,&
                               kwh ), ldh )
                 end if
                 ! ==== note progress (or the lack of it). ====
                 if( ld>0 ) then
                    ndfl = 1
                 else
                    ndfl = ndfl + 1
                 end if
                 ! ==== end of main loop ====
              end do loop_70
              ! ==== iteration limit exceeded.  set info to show where
              ! .    the problem occurred and exit. ====
              info = kbot
              80 continue
           end if
           ! ==== return the optimal value of lwork. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=${ck}$)
     end subroutine stdlib_${ci}$laqr0

#:endif
#:endfor



     module pure subroutine stdlib_slaqz1( a, lda, b, ldb, sr1, sr2, si, beta1, beta2,v )
     !! Given a 3-by-3 matrix pencil (A,B), SLAQZ1: sets v to a
     !! scalar multiple of the first column of the product
     !! (*)  K = (A - (beta2*sr2 - i*si)*B)*B^(-1)*(beta1*A - (sr2 + i*si2)*B)*B^(-1).
     !! It is assumed that either
     !! 1) sr1 = sr2
     !! or
     !! 2) si = 0.
     !! This is useful for starting double implicit shift bulges
     !! in the QZ algorithm.
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           integer(ilp), intent( in ) :: lda, ldb
           real(sp), intent( in ) :: a( lda, * ), b( ldb, * ), sr1, sr2, si,beta1, beta2
           real(sp), intent( out ) :: v( * )
           ! ================================================================
           ! local scalars
           real(sp) :: w(2), safmin, safmax, scale1, scale2
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           ! calculate first shifted vector
           w( 1 ) = beta1*a( 1, 1 )-sr1*b( 1, 1 )
           w( 2 ) = beta1*a( 2, 1 )-sr1*b( 2, 1 )
           scale1 = sqrt( abs( w( 1 ) ) ) * sqrt( abs( w( 2 ) ) )
           if( scale1 >= safmin .and. scale1 <= safmax ) then
              w( 1 ) = w( 1 )/scale1
              w( 2 ) = w( 2 )/scale1
           end if
           ! solve linear system
           w( 2 ) = w( 2 )/b( 2, 2 )
           w( 1 ) = ( w( 1 )-b( 1, 2 )*w( 2 ) )/b( 1, 1 )
           scale2 = sqrt( abs( w( 1 ) ) ) * sqrt( abs( w( 2 ) ) )
           if( scale2 >= safmin .and. scale2 <= safmax ) then
              w( 1 ) = w( 1 )/scale2
              w( 2 ) = w( 2 )/scale2
           end if
           ! apply second shift
           v( 1 ) = beta2*( a( 1, 1 )*w( 1 )+a( 1, 2 )*w( 2 ) )-sr2*( b( 1,1 )*w( 1 )+b( 1, 2 )*w(&
                      2 ) )
           v( 2 ) = beta2*( a( 2, 1 )*w( 1 )+a( 2, 2 )*w( 2 ) )-sr2*( b( 2,1 )*w( 1 )+b( 2, 2 )*w(&
                      2 ) )
           v( 3 ) = beta2*( a( 3, 1 )*w( 1 )+a( 3, 2 )*w( 2 ) )-sr2*( b( 3,1 )*w( 1 )+b( 3, 2 )*w(&
                      2 ) )
           ! account for imaginary part
           v( 1 ) = v( 1 )+si*si*b( 1, 1 )/scale1/scale2
           ! check for overflow
           if( abs( v( 1 ) )>safmax .or. abs( v( 2 ) ) > safmax .or.abs( v( 3 ) )>safmax .or. &
           stdlib_sisnan( v( 1 ) ) .or.stdlib_sisnan( v( 2 ) ) .or. stdlib_sisnan( v( 3 ) ) ) &
                     then
              v( 1 ) = zero
              v( 2 ) = zero
              v( 3 ) = zero
           end if
     end subroutine stdlib_slaqz1

     module pure subroutine stdlib_dlaqz1( a, lda, b, ldb, sr1, sr2, si, beta1, beta2,v )
     !! Given a 3-by-3 matrix pencil (A,B), DLAQZ1: sets v to a
     !! scalar multiple of the first column of the product
     !! (*)  K = (A - (beta2*sr2 - i*si)*B)*B^(-1)*(beta1*A - (sr2 + i*si2)*B)*B^(-1).
     !! It is assumed that either
     !! 1) sr1 = sr2
     !! or
     !! 2) si = 0.
     !! This is useful for starting double implicit shift bulges
     !! in the QZ algorithm.
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           integer(ilp), intent( in ) :: lda, ldb
           real(dp), intent( in ) :: a( lda, * ), b( ldb, * ), sr1,sr2, si, beta1, beta2
           real(dp), intent( out ) :: v( * )
           ! ================================================================
           ! local scalars
           real(dp) :: w(2), safmin, safmax, scale1, scale2
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           ! calculate first shifted vector
           w( 1 ) = beta1*a( 1, 1 )-sr1*b( 1, 1 )
           w( 2 ) = beta1*a( 2, 1 )-sr1*b( 2, 1 )
           scale1 = sqrt( abs( w( 1 ) ) ) * sqrt( abs( w( 2 ) ) )
           if( scale1 >= safmin .and. scale1 <= safmax ) then
              w( 1 ) = w( 1 )/scale1
              w( 2 ) = w( 2 )/scale1
           end if
           ! solve linear system
           w( 2 ) = w( 2 )/b( 2, 2 )
           w( 1 ) = ( w( 1 )-b( 1, 2 )*w( 2 ) )/b( 1, 1 )
           scale2 = sqrt( abs( w( 1 ) ) ) * sqrt( abs( w( 2 ) ) )
           if( scale2 >= safmin .and. scale2 <= safmax ) then
              w( 1 ) = w( 1 )/scale2
              w( 2 ) = w( 2 )/scale2
           end if
           ! apply second shift
           v( 1 ) = beta2*( a( 1, 1 )*w( 1 )+a( 1, 2 )*w( 2 ) )-sr2*( b( 1,1 )*w( 1 )+b( 1, 2 )*w(&
                      2 ) )
           v( 2 ) = beta2*( a( 2, 1 )*w( 1 )+a( 2, 2 )*w( 2 ) )-sr2*( b( 2,1 )*w( 1 )+b( 2, 2 )*w(&
                      2 ) )
           v( 3 ) = beta2*( a( 3, 1 )*w( 1 )+a( 3, 2 )*w( 2 ) )-sr2*( b( 3,1 )*w( 1 )+b( 3, 2 )*w(&
                      2 ) )
           ! account for imaginary part
           v( 1 ) = v( 1 )+si*si*b( 1, 1 )/scale1/scale2
           ! check for overflow
           if( abs( v( 1 ) )>safmax .or. abs( v( 2 ) ) > safmax .or.abs( v( 3 ) )>safmax .or. &
           stdlib_disnan( v( 1 ) ) .or.stdlib_disnan( v( 2 ) ) .or. stdlib_disnan( v( 3 ) ) ) &
                     then
              v( 1 ) = zero
              v( 2 ) = zero
              v( 3 ) = zero
           end if
     end subroutine stdlib_dlaqz1

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$laqz1( a, lda, b, ldb, sr1, sr2, si, beta1, beta2,v )
     !! Given a 3-by-3 matrix pencil (A,B), DLAQZ1: sets v to a
     !! scalar multiple of the first column of the product
     !! (*)  K = (A - (beta2*sr2 - i*si)*B)*B^(-1)*(beta1*A - (sr2 + i*si2)*B)*B^(-1).
     !! It is assumed that either
     !! 1) sr1 = sr2
     !! or
     !! 2) si = 0.
     !! This is useful for starting double implicit shift bulges
     !! in the QZ algorithm.
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           integer(ilp), intent( in ) :: lda, ldb
           real(${rk}$), intent( in ) :: a( lda, * ), b( ldb, * ), sr1,sr2, si, beta1, beta2
           real(${rk}$), intent( out ) :: v( * )
           ! ================================================================
           ! local scalars
           real(${rk}$) :: w(2), safmin, safmax, scale1, scale2
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           ! calculate first shifted vector
           w( 1 ) = beta1*a( 1, 1 )-sr1*b( 1, 1 )
           w( 2 ) = beta1*a( 2, 1 )-sr1*b( 2, 1 )
           scale1 = sqrt( abs( w( 1 ) ) ) * sqrt( abs( w( 2 ) ) )
           if( scale1 >= safmin .and. scale1 <= safmax ) then
              w( 1 ) = w( 1 )/scale1
              w( 2 ) = w( 2 )/scale1
           end if
           ! solve linear system
           w( 2 ) = w( 2 )/b( 2, 2 )
           w( 1 ) = ( w( 1 )-b( 1, 2 )*w( 2 ) )/b( 1, 1 )
           scale2 = sqrt( abs( w( 1 ) ) ) * sqrt( abs( w( 2 ) ) )
           if( scale2 >= safmin .and. scale2 <= safmax ) then
              w( 1 ) = w( 1 )/scale2
              w( 2 ) = w( 2 )/scale2
           end if
           ! apply second shift
           v( 1 ) = beta2*( a( 1, 1 )*w( 1 )+a( 1, 2 )*w( 2 ) )-sr2*( b( 1,1 )*w( 1 )+b( 1, 2 )*w(&
                      2 ) )
           v( 2 ) = beta2*( a( 2, 1 )*w( 1 )+a( 2, 2 )*w( 2 ) )-sr2*( b( 2,1 )*w( 1 )+b( 2, 2 )*w(&
                      2 ) )
           v( 3 ) = beta2*( a( 3, 1 )*w( 1 )+a( 3, 2 )*w( 2 ) )-sr2*( b( 3,1 )*w( 1 )+b( 3, 2 )*w(&
                      2 ) )
           ! account for imaginary part
           v( 1 ) = v( 1 )+si*si*b( 1, 1 )/scale1/scale2
           ! check for overflow
           if( abs( v( 1 ) )>safmax .or. abs( v( 2 ) ) > safmax .or.abs( v( 3 ) )>safmax .or. &
           stdlib_${ri}$isnan( v( 1 ) ) .or.stdlib_${ri}$isnan( v( 2 ) ) .or. stdlib_${ri}$isnan( v( 3 ) ) ) &
                     then
              v( 1 ) = zero
              v( 2 ) = zero
              v( 3 ) = zero
           end if
     end subroutine stdlib_${ri}$laqz1

#:endif
#:endfor

     module pure subroutine stdlib_claqz1( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, qstart, &
     !! CLAQZ1 chases a 1x1 shift bulge in a matrix pencil down a single position
               q, ldq, nz, zstart, z, ldz )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           logical(lk), intent( in ) :: ilq, ilz
           integer(ilp), intent( in ) :: k, lda, ldb, ldq, ldz, istartm, istopm,nq, nz, qstart, &
                     zstart, ihi
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           
           ! ================================================================
           ! local variables
           real(sp) :: c
           complex(sp) :: s, temp
           if( k+1 == ihi ) then
              ! shift is located on the edge of the matrix, remove it
              call stdlib_clartg( b( ihi, ihi ), b( ihi, ihi-1 ), c, s, temp )
              b( ihi, ihi ) = temp
              b( ihi, ihi-1 ) = czero
              call stdlib_crot( ihi-istartm, b( istartm, ihi ), 1, b( istartm,ihi-1 ), 1, c, s )
                        
              call stdlib_crot( ihi-istartm+1, a( istartm, ihi ), 1, a( istartm,ihi-1 ), 1, c, s )
                        
              if ( ilz ) then
                 call stdlib_crot( nz, z( 1, ihi-zstart+1 ), 1, z( 1, ihi-1-zstart+1 ), 1, c, s )
                           
              end if
           else
              ! normal operation, move bulge down
              ! apply transformation from the right
              call stdlib_clartg( b( k+1, k+1 ), b( k+1, k ), c, s, temp )
              b( k+1, k+1 ) = temp
              b( k+1, k ) = czero
              call stdlib_crot( k+2-istartm+1, a( istartm, k+1 ), 1, a( istartm,k ), 1, c, s )
                        
              call stdlib_crot( k-istartm+1, b( istartm, k+1 ), 1, b( istartm, k ),1, c, s )
                        
              if ( ilz ) then
                 call stdlib_crot( nz, z( 1, k+1-zstart+1 ), 1, z( 1, k-zstart+1 ),1, c, s )
                           
              end if
              ! apply transformation from the left
              call stdlib_clartg( a( k+1, k ), a( k+2, k ), c, s, temp )
              a( k+1, k ) = temp
              a( k+2, k ) = czero
              call stdlib_crot( istopm-k, a( k+1, k+1 ), lda, a( k+2, k+1 ), lda, c,s )
              call stdlib_crot( istopm-k, b( k+1, k+1 ), ldb, b( k+2, k+1 ), ldb, c,s )
              if ( ilq ) then
                 call stdlib_crot( nq, q( 1, k+1-qstart+1 ), 1, q( 1, k+2-qstart+1 ), 1, c, conjg(&
                            s ) )
              end if
           end if
     end subroutine stdlib_claqz1

     module pure subroutine stdlib_zlaqz1( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, qstart, &
     !! ZLAQZ1 chases a 1x1 shift bulge in a matrix pencil down a single position
               q, ldq, nz, zstart, z, ldz )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           logical(lk), intent( in ) :: ilq, ilz
           integer(ilp), intent( in ) :: k, lda, ldb, ldq, ldz, istartm, istopm,nq, nz, qstart, &
                     zstart, ihi
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           
           ! ================================================================
           ! local variables
           real(dp) :: c
           complex(dp) :: s, temp
           if( k+1 == ihi ) then
              ! shift is located on the edge of the matrix, remove it
              call stdlib_zlartg( b( ihi, ihi ), b( ihi, ihi-1 ), c, s, temp )
              b( ihi, ihi ) = temp
              b( ihi, ihi-1 ) = czero
              call stdlib_zrot( ihi-istartm, b( istartm, ihi ), 1, b( istartm,ihi-1 ), 1, c, s )
                        
              call stdlib_zrot( ihi-istartm+1, a( istartm, ihi ), 1, a( istartm,ihi-1 ), 1, c, s )
                        
              if ( ilz ) then
                 call stdlib_zrot( nz, z( 1, ihi-zstart+1 ), 1, z( 1, ihi-1-zstart+1 ), 1, c, s )
                           
              end if
           else
              ! normal operation, move bulge down
              ! apply transformation from the right
              call stdlib_zlartg( b( k+1, k+1 ), b( k+1, k ), c, s, temp )
              b( k+1, k+1 ) = temp
              b( k+1, k ) = czero
              call stdlib_zrot( k+2-istartm+1, a( istartm, k+1 ), 1, a( istartm,k ), 1, c, s )
                        
              call stdlib_zrot( k-istartm+1, b( istartm, k+1 ), 1, b( istartm, k ),1, c, s )
                        
              if ( ilz ) then
                 call stdlib_zrot( nz, z( 1, k+1-zstart+1 ), 1, z( 1, k-zstart+1 ),1, c, s )
                           
              end if
              ! apply transformation from the left
              call stdlib_zlartg( a( k+1, k ), a( k+2, k ), c, s, temp )
              a( k+1, k ) = temp
              a( k+2, k ) = czero
              call stdlib_zrot( istopm-k, a( k+1, k+1 ), lda, a( k+2, k+1 ), lda, c,s )
              call stdlib_zrot( istopm-k, b( k+1, k+1 ), ldb, b( k+2, k+1 ), ldb, c,s )
              if ( ilq ) then
                 call stdlib_zrot( nq, q( 1, k+1-qstart+1 ), 1, q( 1, k+2-qstart+1 ), 1, c, conjg(&
                            s ) )
              end if
           end if
     end subroutine stdlib_zlaqz1

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$laqz1( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, qstart, &
     !! ZLAQZ1: chases a 1x1 shift bulge in a matrix pencil down a single position
               q, ldq, nz, zstart, z, ldz )
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           logical(lk), intent( in ) :: ilq, ilz
           integer(ilp), intent( in ) :: k, lda, ldb, ldq, ldz, istartm, istopm,nq, nz, qstart, &
                     zstart, ihi
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           
           ! ================================================================
           ! local variables
           real(${ck}$) :: c
           complex(${ck}$) :: s, temp
           if( k+1 == ihi ) then
              ! shift is located on the edge of the matrix, remove it
              call stdlib_${ci}$lartg( b( ihi, ihi ), b( ihi, ihi-1 ), c, s, temp )
              b( ihi, ihi ) = temp
              b( ihi, ihi-1 ) = czero
              call stdlib_${ci}$rot( ihi-istartm, b( istartm, ihi ), 1, b( istartm,ihi-1 ), 1, c, s )
                        
              call stdlib_${ci}$rot( ihi-istartm+1, a( istartm, ihi ), 1, a( istartm,ihi-1 ), 1, c, s )
                        
              if ( ilz ) then
                 call stdlib_${ci}$rot( nz, z( 1, ihi-zstart+1 ), 1, z( 1, ihi-1-zstart+1 ), 1, c, s )
                           
              end if
           else
              ! normal operation, move bulge down
              ! apply transformation from the right
              call stdlib_${ci}$lartg( b( k+1, k+1 ), b( k+1, k ), c, s, temp )
              b( k+1, k+1 ) = temp
              b( k+1, k ) = czero
              call stdlib_${ci}$rot( k+2-istartm+1, a( istartm, k+1 ), 1, a( istartm,k ), 1, c, s )
                        
              call stdlib_${ci}$rot( k-istartm+1, b( istartm, k+1 ), 1, b( istartm, k ),1, c, s )
                        
              if ( ilz ) then
                 call stdlib_${ci}$rot( nz, z( 1, k+1-zstart+1 ), 1, z( 1, k-zstart+1 ),1, c, s )
                           
              end if
              ! apply transformation from the left
              call stdlib_${ci}$lartg( a( k+1, k ), a( k+2, k ), c, s, temp )
              a( k+1, k ) = temp
              a( k+2, k ) = czero
              call stdlib_${ci}$rot( istopm-k, a( k+1, k+1 ), lda, a( k+2, k+1 ), lda, c,s )
              call stdlib_${ci}$rot( istopm-k, b( k+1, k+1 ), ldb, b( k+2, k+1 ), ldb, c,s )
              if ( ilq ) then
                 call stdlib_${ci}$rot( nq, q( 1, k+1-qstart+1 ), 1, q( 1, k+2-qstart+1 ), 1, c, conjg(&
                            s ) )
              end if
           end if
     end subroutine stdlib_${ci}$laqz1

#:endif
#:endfor


end submodule stdlib_lapack_eigv_gen
