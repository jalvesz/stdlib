#:include "common.fypp" 
module stdlib_lapack_eigv_gen
  use stdlib_linalg_constants
  use stdlib_linalg_lapack_aux
  use stdlib_linalg_blas
  use stdlib_lapack_givens_jacobi_rot
  use stdlib_lapack_orthogonal_factors_qr
  use stdlib_lapack_blas_like_l1
  use stdlib_lapack_blas_like_base
  use stdlib_lapack_solve_tri_comp
  implicit none(type,external)


  contains









     pure subroutine stdlib_sgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! SGEHRD reduces a real general matrix A to upper Hessenberg form H by
     !! an orthogonal similarity transformation:  Q**T * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iwt, j, ldwork, lwkopt, nb, nbmin, nh, nx
           real(sp) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
             ! compute the workspace requirements
              nb = min( nbmax, stdlib_ilaenv( 1, 'SGEHRD', ' ', n, ilo, ihi, -1 ) )
              lwkopt = n*nb + tsize
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGEHRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! set elements 1:ilo-1 and ihi:n-1 of tau to zero
           do i = 1, ilo - 1
              tau( i ) = zero
           end do
           do i = max( 1, ihi ), n - 1
              tau( i ) = zero
           end do
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = 1
              return
           end if
           ! determine the block size
           nb = min( nbmax, stdlib_ilaenv( 1, 'SGEHRD', ' ', n, ilo, ihi, -1 ) )
           nbmin = 2
           if( nb>1 .and. nb<nh ) then
              ! determine when to cross over from blocked to unblocked code
              ! (last block is always handled by unblocked code)
              nx = max( nb, stdlib_ilaenv( 3, 'SGEHRD', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code
                 if( lwork<n*nb+tsize ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code
                    nbmin = max( 2, stdlib_ilaenv( 2, 'SGEHRD', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=(n*nbmin + tsize) ) then
                       nb = (lwork-tsize) / n
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           ldwork = n
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              i = ilo
           else
              ! use blocked code
              iwt = 1 + n*nb
              do i = ilo, ihi - 1 - nx, nb
                 ib = min( nb, ihi-i )
                 ! reduce columns i:i+ib-1 to hessenberg form, returning the
                 ! matrices v and t of the block reflector h = i - v*t*v**t
                 ! which performs the reduction, and also the matrix y = a*v*t
                 call stdlib_slahr2( ihi, i, ib, a( 1, i ), lda, tau( i ),work( iwt ), ldt, work, &
                           ldwork )
                 ! apply the block reflector h to a(1:ihi,i+ib:ihi) from the
                 ! right, computing  a := a - y * v**t. v(i+ib,ib-1) must be set
                 ! to 1
                 ei = a( i+ib, i+ib-1 )
                 a( i+ib, i+ib-1 ) = one
                 call stdlib_sgemm( 'NO TRANSPOSE', 'TRANSPOSE',ihi, ihi-i-ib+1,ib, -one, work, &
                           ldwork, a( i+ib, i ), lda, one,a( 1, i+ib ), lda )
                 a( i+ib, i+ib-1 ) = ei
                 ! apply the block reflector h to a(1:i,i+1:i+ib-1) from the
                 ! right
                 call stdlib_strmm( 'RIGHT', 'LOWER', 'TRANSPOSE','UNIT', i, ib-1,one, a( i+1, i )&
                           , lda, work, ldwork )
                 do j = 0, ib-2
                    call stdlib_saxpy( i, -one, work( ldwork*j+1 ), 1,a( 1, i+j+1 ), 1 )
                 end do
                 ! apply the block reflector h to a(i+1:ihi,i+ib:n) from the
                 ! left
                 call stdlib_slarfb( 'LEFT', 'TRANSPOSE', 'FORWARD','COLUMNWISE',ihi-i, n-i-ib+1, &
                           ib, a( i+1, i ), lda,work( iwt ), ldt, a( i+1, i+ib ), lda,work, ldwork )
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           call stdlib_sgehd2( n, i, ihi, a, lda, tau, work, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_sgehrd

     pure subroutine stdlib_dgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! DGEHRD reduces a real general matrix A to upper Hessenberg form H by
     !! an orthogonal similarity transformation:  Q**T * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iwt, j, ldwork, lwkopt, nb, nbmin, nh, nx
           real(dp) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              nb = min( nbmax, stdlib_ilaenv( 1, 'DGEHRD', ' ', n, ilo, ihi, -1 ) )
              lwkopt = n*nb + tsize
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEHRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! set elements 1:ilo-1 and ihi:n-1 of tau to zero
           do i = 1, ilo - 1
              tau( i ) = zero
           end do
           do i = max( 1, ihi ), n - 1
              tau( i ) = zero
           end do
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = 1
              return
           end if
           ! determine the block size
           nb = min( nbmax, stdlib_ilaenv( 1, 'DGEHRD', ' ', n, ilo, ihi, -1 ) )
           nbmin = 2
           if( nb>1 .and. nb<nh ) then
              ! determine when to cross over from blocked to unblocked code
              ! (last block is always handled by unblocked code)
              nx = max( nb, stdlib_ilaenv( 3, 'DGEHRD', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code
                 if( lwork<n*nb+tsize ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code
                    nbmin = max( 2, stdlib_ilaenv( 2, 'DGEHRD', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=(n*nbmin + tsize) ) then
                       nb = (lwork-tsize) / n
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           ldwork = n
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              i = ilo
           else
              ! use blocked code
              iwt = 1 + n*nb
              do i = ilo, ihi - 1 - nx, nb
                 ib = min( nb, ihi-i )
                 ! reduce columns i:i+ib-1 to hessenberg form, returning the
                 ! matrices v and t of the block reflector h = i - v*t*v**t
                 ! which performs the reduction, and also the matrix y = a*v*t
                 call stdlib_dlahr2( ihi, i, ib, a( 1, i ), lda, tau( i ),work( iwt ), ldt, work, &
                           ldwork )
                 ! apply the block reflector h to a(1:ihi,i+ib:ihi) from the
                 ! right, computing  a := a - y * v**t. v(i+ib,ib-1) must be set
                 ! to 1
                 ei = a( i+ib, i+ib-1 )
                 a( i+ib, i+ib-1 ) = one
                 call stdlib_dgemm( 'NO TRANSPOSE', 'TRANSPOSE',ihi, ihi-i-ib+1,ib, -one, work, &
                           ldwork, a( i+ib, i ), lda, one,a( 1, i+ib ), lda )
                 a( i+ib, i+ib-1 ) = ei
                 ! apply the block reflector h to a(1:i,i+1:i+ib-1) from the
                 ! right
                 call stdlib_dtrmm( 'RIGHT', 'LOWER', 'TRANSPOSE','UNIT', i, ib-1,one, a( i+1, i )&
                           , lda, work, ldwork )
                 do j = 0, ib-2
                    call stdlib_daxpy( i, -one, work( ldwork*j+1 ), 1,a( 1, i+j+1 ), 1 )
                 end do
                 ! apply the block reflector h to a(i+1:ihi,i+ib:n) from the
                 ! left
                 call stdlib_dlarfb( 'LEFT', 'TRANSPOSE', 'FORWARD','COLUMNWISE',ihi-i, n-i-ib+1, &
                           ib, a( i+1, i ), lda,work( iwt ), ldt, a( i+1, i+ib ), lda,work, ldwork )
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           call stdlib_dgehd2( n, i, ihi, a, lda, tau, work, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dgehrd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$gehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! DGEHRD: reduces a real general matrix A to upper Hessenberg form H by
     !! an orthogonal similarity transformation:  Q**T * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iwt, j, ldwork, lwkopt, nb, nbmin, nh, nx
           real(${rk}$) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              nb = min( nbmax, stdlib_ilaenv( 1, 'DGEHRD', ' ', n, ilo, ihi, -1 ) )
              lwkopt = n*nb + tsize
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEHRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! set elements 1:ilo-1 and ihi:n-1 of tau to zero
           do i = 1, ilo - 1
              tau( i ) = zero
           end do
           do i = max( 1, ihi ), n - 1
              tau( i ) = zero
           end do
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = 1
              return
           end if
           ! determine the block size
           nb = min( nbmax, stdlib_ilaenv( 1, 'DGEHRD', ' ', n, ilo, ihi, -1 ) )
           nbmin = 2
           if( nb>1 .and. nb<nh ) then
              ! determine when to cross over from blocked to unblocked code
              ! (last block is always handled by unblocked code)
              nx = max( nb, stdlib_ilaenv( 3, 'DGEHRD', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code
                 if( lwork<n*nb+tsize ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code
                    nbmin = max( 2, stdlib_ilaenv( 2, 'DGEHRD', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=(n*nbmin + tsize) ) then
                       nb = (lwork-tsize) / n
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           ldwork = n
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              i = ilo
           else
              ! use blocked code
              iwt = 1 + n*nb
              do i = ilo, ihi - 1 - nx, nb
                 ib = min( nb, ihi-i )
                 ! reduce columns i:i+ib-1 to hessenberg form, returning the
                 ! matrices v and t of the block reflector h = i - v*t*v**t
                 ! which performs the reduction, and also the matrix y = a*v*t
                 call stdlib_${ri}$lahr2( ihi, i, ib, a( 1, i ), lda, tau( i ),work( iwt ), ldt, work, &
                           ldwork )
                 ! apply the block reflector h to a(1:ihi,i+ib:ihi) from the
                 ! right, computing  a := a - y * v**t. v(i+ib,ib-1) must be set
                 ! to 1
                 ei = a( i+ib, i+ib-1 )
                 a( i+ib, i+ib-1 ) = one
                 call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE',ihi, ihi-i-ib+1,ib, -one, work, &
                           ldwork, a( i+ib, i ), lda, one,a( 1, i+ib ), lda )
                 a( i+ib, i+ib-1 ) = ei
                 ! apply the block reflector h to a(1:i,i+1:i+ib-1) from the
                 ! right
                 call stdlib_${ri}$trmm( 'RIGHT', 'LOWER', 'TRANSPOSE','UNIT', i, ib-1,one, a( i+1, i )&
                           , lda, work, ldwork )
                 do j = 0, ib-2
                    call stdlib_${ri}$axpy( i, -one, work( ldwork*j+1 ), 1,a( 1, i+j+1 ), 1 )
                 end do
                 ! apply the block reflector h to a(i+1:ihi,i+ib:n) from the
                 ! left
                 call stdlib_${ri}$larfb( 'LEFT', 'TRANSPOSE', 'FORWARD','COLUMNWISE',ihi-i, n-i-ib+1, &
                           ib, a( i+1, i ), lda,work( iwt ), ldt, a( i+1, i+ib ), lda,work, ldwork )
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           call stdlib_${ri}$gehd2( n, i, ihi, a, lda, tau, work, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$gehrd

#:endif
#:endfor

     pure subroutine stdlib_cgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! CGEHRD reduces a complex general matrix A to upper Hessenberg form H by
     !! an unitary similarity transformation:  Q**H * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iwt, j, ldwork, lwkopt, nb, nbmin, nh, nx
           complex(sp) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              nb = min( nbmax, stdlib_ilaenv( 1, 'CGEHRD', ' ', n, ilo, ihi, -1 ) )
              lwkopt = n*nb + tsize
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEHRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! set elements 1:ilo-1 and ihi:n-1 of tau to czero
           do i = 1, ilo - 1
              tau( i ) = czero
           end do
           do i = max( 1, ihi ), n - 1
              tau( i ) = czero
           end do
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = 1
              return
           end if
           ! determine the block size
           nb = min( nbmax, stdlib_ilaenv( 1, 'CGEHRD', ' ', n, ilo, ihi, -1 ) )
           nbmin = 2
           if( nb>1 .and. nb<nh ) then
              ! determine when to cross over from blocked to unblocked code
              ! (last block is always handled by unblocked code)
              nx = max( nb, stdlib_ilaenv( 3, 'CGEHRD', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code
                 if( lwork<n*nb+tsize ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code
                    nbmin = max( 2, stdlib_ilaenv( 2, 'CGEHRD', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=(n*nbmin+tsize) ) then
                       nb = (lwork-tsize) / n
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           ldwork = n
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              i = ilo
           else
              ! use blocked code
              iwt = 1 + n*nb
              do i = ilo, ihi - 1 - nx, nb
                 ib = min( nb, ihi-i )
                 ! reduce columns i:i+ib-1 to hessenberg form, returning the
                 ! matrices v and t of the block reflector h = i - v*t*v**h
                 ! which performs the reduction, and also the matrix y = a*v*t
                 call stdlib_clahr2( ihi, i, ib, a( 1, i ), lda, tau( i ),work( iwt ), ldt, work, &
                           ldwork )
                 ! apply the block reflector h to a(1:ihi,i+ib:ihi) from the
                 ! right, computing  a := a - y * v**h. v(i+ib,ib-1) must be set
                 ! to 1
                 ei = a( i+ib, i+ib-1 )
                 a( i+ib, i+ib-1 ) = cone
                 call stdlib_cgemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE',ihi, ihi-i-ib+1,ib, -&
                           cone, work, ldwork, a( i+ib, i ), lda, cone,a( 1, i+ib ), lda )
                 a( i+ib, i+ib-1 ) = ei
                 ! apply the block reflector h to a(1:i,i+1:i+ib-1) from the
                 ! right
                 call stdlib_ctrmm( 'RIGHT', 'LOWER', 'CONJUGATE TRANSPOSE','UNIT', i, ib-1,cone, &
                           a( i+1, i ), lda, work, ldwork )
                 do j = 0, ib-2
                    call stdlib_caxpy( i, -cone, work( ldwork*j+1 ), 1,a( 1, i+j+1 ), 1 )
                 end do
                 ! apply the block reflector h to a(i+1:ihi,i+ib:n) from the
                 ! left
                 call stdlib_clarfb( 'LEFT', 'CONJUGATE TRANSPOSE', 'FORWARD','COLUMNWISE',ihi-i, &
                 n-i-ib+1, ib, a( i+1, i ), lda,work( iwt ), ldt, a( i+1, i+ib ), lda,work, &
                           ldwork )
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           call stdlib_cgehd2( n, i, ihi, a, lda, tau, work, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cgehrd

     pure subroutine stdlib_zgehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! ZGEHRD reduces a complex general matrix A to upper Hessenberg form H by
     !! an unitary similarity transformation:  Q**H * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iwt, j, ldwork, lwkopt, nb, nbmin, nh, nx
           complex(dp) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              nb = min( nbmax, stdlib_ilaenv( 1, 'ZGEHRD', ' ', n, ilo, ihi, -1 ) )
              lwkopt = n*nb + tsize
              work( 1 ) = lwkopt
           endif
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEHRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! set elements 1:ilo-1 and ihi:n-1 of tau to czero
           do i = 1, ilo - 1
              tau( i ) = czero
           end do
           do i = max( 1, ihi ), n - 1
              tau( i ) = czero
           end do
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = 1
              return
           end if
           ! determine the block size
           nb = min( nbmax, stdlib_ilaenv( 1, 'ZGEHRD', ' ', n, ilo, ihi, -1 ) )
           nbmin = 2
           if( nb>1 .and. nb<nh ) then
              ! determine when to cross over from blocked to unblocked code
              ! (last block is always handled by unblocked code)
              nx = max( nb, stdlib_ilaenv( 3, 'ZGEHRD', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code
                 if( lwork<n*nb+tsize ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code
                    nbmin = max( 2, stdlib_ilaenv( 2, 'ZGEHRD', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=(n*nbmin + tsize) ) then
                       nb = (lwork-tsize) / n
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           ldwork = n
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              i = ilo
           else
              ! use blocked code
              iwt = 1 + n*nb
              do i = ilo, ihi - 1 - nx, nb
                 ib = min( nb, ihi-i )
                 ! reduce columns i:i+ib-1 to hessenberg form, returning the
                 ! matrices v and t of the block reflector h = i - v*t*v**h
                 ! which performs the reduction, and also the matrix y = a*v*t
                 call stdlib_zlahr2( ihi, i, ib, a( 1, i ), lda, tau( i ),work( iwt ), ldt, work, &
                           ldwork )
                 ! apply the block reflector h to a(1:ihi,i+ib:ihi) from the
                 ! right, computing  a := a - y * v**h. v(i+ib,ib-1) must be set
                 ! to 1
                 ei = a( i+ib, i+ib-1 )
                 a( i+ib, i+ib-1 ) = cone
                 call stdlib_zgemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE',ihi, ihi-i-ib+1,ib, -&
                           cone, work, ldwork, a( i+ib, i ), lda, cone,a( 1, i+ib ), lda )
                 a( i+ib, i+ib-1 ) = ei
                 ! apply the block reflector h to a(1:i,i+1:i+ib-1) from the
                 ! right
                 call stdlib_ztrmm( 'RIGHT', 'LOWER', 'CONJUGATE TRANSPOSE','UNIT', i, ib-1,cone, &
                           a( i+1, i ), lda, work, ldwork )
                 do j = 0, ib-2
                    call stdlib_zaxpy( i, -cone, work( ldwork*j+1 ), 1,a( 1, i+j+1 ), 1 )
                 end do
                 ! apply the block reflector h to a(i+1:ihi,i+ib:n) from the
                 ! left
                 call stdlib_zlarfb( 'LEFT', 'CONJUGATE TRANSPOSE', 'FORWARD','COLUMNWISE',ihi-i, &
                 n-i-ib+1, ib, a( i+1, i ), lda,work( iwt ), ldt, a( i+1, i+ib ), lda,work, &
                           ldwork )
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           call stdlib_zgehd2( n, i, ihi, a, lda, tau, work, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zgehrd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$gehrd( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! ZGEHRD: reduces a complex general matrix A to upper Hessenberg form H by
     !! an unitary similarity transformation:  Q**H * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmax = 64
           integer(ilp), parameter :: ldt = nbmax+1
           integer(ilp), parameter :: tsize = ldt*nbmax
           
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, ib, iinfo, iwt, j, ldwork, lwkopt, nb, nbmin, nh, nx
           complex(${ck}$) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              nb = min( nbmax, stdlib_ilaenv( 1, 'ZGEHRD', ' ', n, ilo, ihi, -1 ) )
              lwkopt = n*nb + tsize
              work( 1 ) = lwkopt
           endif
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEHRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! set elements 1:ilo-1 and ihi:n-1 of tau to czero
           do i = 1, ilo - 1
              tau( i ) = czero
           end do
           do i = max( 1, ihi ), n - 1
              tau( i ) = czero
           end do
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = 1
              return
           end if
           ! determine the block size
           nb = min( nbmax, stdlib_ilaenv( 1, 'ZGEHRD', ' ', n, ilo, ihi, -1 ) )
           nbmin = 2
           if( nb>1 .and. nb<nh ) then
              ! determine when to cross over from blocked to unblocked code
              ! (last block is always handled by unblocked code)
              nx = max( nb, stdlib_ilaenv( 3, 'ZGEHRD', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code
                 if( lwork<n*nb+tsize ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code
                    nbmin = max( 2, stdlib_ilaenv( 2, 'ZGEHRD', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=(n*nbmin + tsize) ) then
                       nb = (lwork-tsize) / n
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           ldwork = n
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              i = ilo
           else
              ! use blocked code
              iwt = 1 + n*nb
              do i = ilo, ihi - 1 - nx, nb
                 ib = min( nb, ihi-i )
                 ! reduce columns i:i+ib-1 to hessenberg form, returning the
                 ! matrices v and t of the block reflector h = i - v*t*v**h
                 ! which performs the reduction, and also the matrix y = a*v*t
                 call stdlib_${ci}$lahr2( ihi, i, ib, a( 1, i ), lda, tau( i ),work( iwt ), ldt, work, &
                           ldwork )
                 ! apply the block reflector h to a(1:ihi,i+ib:ihi) from the
                 ! right, computing  a := a - y * v**h. v(i+ib,ib-1) must be set
                 ! to 1
                 ei = a( i+ib, i+ib-1 )
                 a( i+ib, i+ib-1 ) = cone
                 call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE',ihi, ihi-i-ib+1,ib, -&
                           cone, work, ldwork, a( i+ib, i ), lda, cone,a( 1, i+ib ), lda )
                 a( i+ib, i+ib-1 ) = ei
                 ! apply the block reflector h to a(1:i,i+1:i+ib-1) from the
                 ! right
                 call stdlib_${ci}$trmm( 'RIGHT', 'LOWER', 'CONJUGATE TRANSPOSE','UNIT', i, ib-1,cone, &
                           a( i+1, i ), lda, work, ldwork )
                 do j = 0, ib-2
                    call stdlib_${ci}$axpy( i, -cone, work( ldwork*j+1 ), 1,a( 1, i+j+1 ), 1 )
                 end do
                 ! apply the block reflector h to a(i+1:ihi,i+ib:n) from the
                 ! left
                 call stdlib_${ci}$larfb( 'LEFT', 'CONJUGATE TRANSPOSE', 'FORWARD','COLUMNWISE',ihi-i, &
                 n-i-ib+1, ib, a( i+1, i ), lda,work( iwt ), ldt, a( i+1, i+ib ), lda,work, &
                           ldwork )
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           call stdlib_${ci}$gehd2( n, i, ihi, a, lda, tau, work, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$gehrd

#:endif
#:endfor





     pure subroutine stdlib_slahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, &
     !! SLAHQR is an auxiliary routine called by SHSEQR to update the
     !! eigenvalues and Schur decomposition already computed by SHSEQR, by
     !! dealing with the Hessenberg submatrix in rows and columns ILO to
     !! IHI.
               info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(sp), intent(out) :: wi(*), wr(*)
        ! =========================================================
           ! Parameters 
           real(sp), parameter :: dat1 = 3.0_sp/4.0_sp
           real(sp), parameter :: dat2 = -0.4375_sp
           integer(ilp), parameter :: kexsh = 10
           
           
           
           ! Local Scalars 
           real(sp) :: aa, ab, ba, bb, cs, det, h11, h12, h21, h21s, h22, rt1i, rt1r, rt2i, rt2r, &
                     rtdisc, s, safmax, safmin, smlnum, sn, sum, t1, t2, t3, tr, tst, ulp, v2, v3
           integer(ilp) :: i, i1, i2, its, itmax, j, k, l, m, nh, nr, nz, kdefl
           ! Local Arrays 
           real(sp) :: v(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n==0 )return
           if( ilo==ihi ) then
              wr( ilo ) = h( ilo, ilo )
              wi( ilo ) = zero
              return
           end if
           ! ==== clear out the trash ====
           do j = ilo, ihi - 3
              h( j+2, j ) = zero
              h( j+3, j ) = zero
           end do
           if( ilo<=ihi-2 )h( ihi, ihi-2 ) = zero
           nh = ihi - ilo + 1
           nz = ihiz - iloz + 1
           ! set machine-dependent constants for the stopping criterion.
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = one / safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( nh,KIND=sp) / ulp )
           ! i1 and i2 are the indices of the first row and last column of h
           ! to which transformations must be applied. if eigenvalues only are
           ! being computed, i1 and i2 are set inside the main loop.
           if( wantt ) then
              i1 = 1
              i2 = n
           end if
           ! itmax is the total number of qr iterations allowed.
           itmax = 30 * max( 10, nh )
           ! kdefl counts the number of iterations since a deflation
           kdefl = 0
           ! the main loop begins here. i is the loop index and decreases from
           ! ihi to ilo in steps of 1 or 2. each iteration of the loop works
           ! with the active submatrix in rows and columns l to i.
           ! eigenvalues i+1 to ihi have already converged. either l = ilo or
           ! h(l,l-1) is negligible so that the matrix splits.
           i = ihi
           20 continue
           l = ilo
           if( i<ilo )go to 160
           ! perform qr iterations on rows and columns ilo to i until a
           ! submatrix of order 1 or 2 splits off at the bottom because a
           ! subdiagonal element has become negligible.
           loop_140: do its = 0, itmax
              ! look for a single small subdiagonal element.
              do k = i, l + 1, -1
                 if( abs( h( k, k-1 ) )<=smlnum )go to 40
                 tst = abs( h( k-1, k-1 ) ) + abs( h( k, k ) )
                 if( tst==zero ) then
                    if( k-2>=ilo )tst = tst + abs( h( k-1, k-2 ) )
                    if( k+1<=ihi )tst = tst + abs( h( k+1, k ) )
                 end if
                 ! ==== the following is a conservative small subdiagonal
                 ! .    deflation  criterion due to ahues
                 ! .    1997). it has better mathematical foundation and
                 ! .    improves accuracy in some cases.  ====
                 if( abs( h( k, k-1 ) )<=ulp*tst ) then
                    ab = max( abs( h( k, k-1 ) ), abs( h( k-1, k ) ) )
                    ba = min( abs( h( k, k-1 ) ), abs( h( k-1, k ) ) )
                    aa = max( abs( h( k, k ) ),abs( h( k-1, k-1 )-h( k, k ) ) )
                    bb = min( abs( h( k, k ) ),abs( h( k-1, k-1 )-h( k, k ) ) )
                    s = aa + ab
                    if( ba*( ab / s )<=max( smlnum,ulp*( bb*( aa / s ) ) ) )go to 40
                 end if
              end do
              40 continue
              l = k
              if( l>ilo ) then
                 ! h(l,l-1) is negligible
                 h( l, l-1 ) = zero
              end if
              ! exit from loop if a submatrix of order 1 or 2 has split off.
              if( l>=i-1 )go to 150
              kdefl = kdefl + 1
              ! now the active submatrix is in rows and columns l to i. if
              ! eigenvalues only are being computed, only the active submatrix
              ! need be transformed.
              if( .not.wantt ) then
                 i1 = l
                 i2 = i
              end if
              if( mod(kdefl,2*kexsh)==0 ) then
                 ! exceptional shift.
                 s = abs( h( i, i-1 ) ) + abs( h( i-1, i-2 ) )
                 h11 = dat1*s + h( i, i )
                 h12 = dat2*s
                 h21 = s
                 h22 = h11
              else if( mod(kdefl,kexsh)==0 ) then
                 ! exceptional shift.
                 s = abs( h( l+1, l ) ) + abs( h( l+2, l+1 ) )
                 h11 = dat1*s + h( l, l )
                 h12 = dat2*s
                 h21 = s
                 h22 = h11
              else
                 ! prepare to use francis' double shift
                 ! (i.e. 2nd degree generalized rayleigh quotient)
                 h11 = h( i-1, i-1 )
                 h21 = h( i, i-1 )
                 h12 = h( i-1, i )
                 h22 = h( i, i )
              end if
              s = abs( h11 ) + abs( h12 ) + abs( h21 ) + abs( h22 )
              if( s==zero ) then
                 rt1r = zero
                 rt1i = zero
                 rt2r = zero
                 rt2i = zero
              else
                 h11 = h11 / s
                 h21 = h21 / s
                 h12 = h12 / s
                 h22 = h22 / s
                 tr = ( h11+h22 ) / two
                 det = ( h11-tr )*( h22-tr ) - h12*h21
                 rtdisc = sqrt( abs( det ) )
                 if( det>=zero ) then
                    ! ==== complex conjugate shifts ====
                    rt1r = tr*s
                    rt2r = rt1r
                    rt1i = rtdisc*s
                    rt2i = -rt1i
                 else
                    ! ==== realshifts (use only one of them,KIND=sp)  ====
                    rt1r = tr + rtdisc
                    rt2r = tr - rtdisc
                    if( abs( rt1r-h22 )<=abs( rt2r-h22 ) ) then
                       rt1r = rt1r*s
                       rt2r = rt1r
                    else
                       rt2r = rt2r*s
                       rt1r = rt2r
                    end if
                    rt1i = zero
                    rt2i = zero
                 end if
              end if
              ! look for two consecutive small subdiagonal elements.
              do m = i - 2, l, -1
                 ! determine the effect of starting the double-shift qr
                 ! iteration at row m, and see if this would make h(m,m-1)
                 ! negligible.  (the following uses scaling to avoid
                 ! overflows and most underflows.)
                 h21s = h( m+1, m )
                 s = abs( h( m, m )-rt2r ) + abs( rt2i ) + abs( h21s )
                 h21s = h( m+1, m ) / s
                 v( 1 ) = h21s*h( m, m+1 ) + ( h( m, m )-rt1r )*( ( h( m, m )-rt2r ) / s ) - &
                           rt1i*( rt2i / s )
                 v( 2 ) = h21s*( h( m, m )+h( m+1, m+1 )-rt1r-rt2r )
                 v( 3 ) = h21s*h( m+2, m+1 )
                 s = abs( v( 1 ) ) + abs( v( 2 ) ) + abs( v( 3 ) )
                 v( 1 ) = v( 1 ) / s
                 v( 2 ) = v( 2 ) / s
                 v( 3 ) = v( 3 ) / s
                 if( m==l )go to 60
                 if( abs( h( m, m-1 ) )*( abs( v( 2 ) )+abs( v( 3 ) ) )<=ulp*abs( v( 1 ) )*( abs( &
                           h( m-1, m-1 ) )+abs( h( m,m ) )+abs( h( m+1, m+1 ) ) ) )go to 60
              end do
              60 continue
              ! double-shift qr step
              loop_130: do k = m, i - 1
                 ! the first iteration of this loop determines a reflection g
                 ! from the vector v and applies it from left and right to h,
                 ! thus creating a nonzero bulge below the subdiagonal.
                 ! each subsequent iteration determines a reflection g to
                 ! restore the hessenberg form in the (k-1)th column, and thus
                 ! chases the bulge one step toward the bottom of the active
                 ! submatrix. nr is the order of g.
                 nr = min( 3, i-k+1 )
                 if( k>m )call stdlib_scopy( nr, h( k, k-1 ), 1, v, 1 )
                 call stdlib_slarfg( nr, v( 1 ), v( 2 ), 1, t1 )
                 if( k>m ) then
                    h( k, k-1 ) = v( 1 )
                    h( k+1, k-1 ) = zero
                    if( k<i-1 )h( k+2, k-1 ) = zero
                 else if( m>l ) then
                     ! ==== use the following instead of
                     ! .    h( k, k-1 ) = -h( k, k-1 ) to
                     ! .    avoid a bug when v(2) and v(3)
                     ! .    underflow. ====
                    h( k, k-1 ) = h( k, k-1 )*( one-t1 )
                 end if
                 v2 = v( 2 )
                 t2 = t1*v2
                 if( nr==3 ) then
                    v3 = v( 3 )
                    t3 = t1*v3
                    ! apply g from the left to transform the rows of the matrix
                    ! in columns k to i2.
                    do j = k, i2
                       sum = h( k, j ) + v2*h( k+1, j ) + v3*h( k+2, j )
                       h( k, j ) = h( k, j ) - sum*t1
                       h( k+1, j ) = h( k+1, j ) - sum*t2
                       h( k+2, j ) = h( k+2, j ) - sum*t3
                    end do
                    ! apply g from the right to transform the columns of the
                    ! matrix in rows i1 to min(k+3,i).
                    do j = i1, min( k+3, i )
                       sum = h( j, k ) + v2*h( j, k+1 ) + v3*h( j, k+2 )
                       h( j, k ) = h( j, k ) - sum*t1
                       h( j, k+1 ) = h( j, k+1 ) - sum*t2
                       h( j, k+2 ) = h( j, k+2 ) - sum*t3
                    end do
                    if( wantz ) then
                       ! accumulate transformations in the matrix z
                       do j = iloz, ihiz
                          sum = z( j, k ) + v2*z( j, k+1 ) + v3*z( j, k+2 )
                          z( j, k ) = z( j, k ) - sum*t1
                          z( j, k+1 ) = z( j, k+1 ) - sum*t2
                          z( j, k+2 ) = z( j, k+2 ) - sum*t3
                       end do
                    end if
                 else if( nr==2 ) then
                    ! apply g from the left to transform the rows of the matrix
                    ! in columns k to i2.
                    do j = k, i2
                       sum = h( k, j ) + v2*h( k+1, j )
                       h( k, j ) = h( k, j ) - sum*t1
                       h( k+1, j ) = h( k+1, j ) - sum*t2
                    end do
                    ! apply g from the right to transform the columns of the
                    ! matrix in rows i1 to min(k+3,i).
                    do j = i1, i
                       sum = h( j, k ) + v2*h( j, k+1 )
                       h( j, k ) = h( j, k ) - sum*t1
                       h( j, k+1 ) = h( j, k+1 ) - sum*t2
                    end do
                    if( wantz ) then
                       ! accumulate transformations in the matrix z
                       do j = iloz, ihiz
                          sum = z( j, k ) + v2*z( j, k+1 )
                          z( j, k ) = z( j, k ) - sum*t1
                          z( j, k+1 ) = z( j, k+1 ) - sum*t2
                       end do
                    end if
                 end if
              end do loop_130
           end do loop_140
           ! failure to converge in remaining number of iterations
           info = i
           return
           150 continue
           if( l==i ) then
              ! h(i,i-1) is negligible: one eigenvalue has converged.
              wr( i ) = h( i, i )
              wi( i ) = zero
           else if( l==i-1 ) then
              ! h(i-1,i-2) is negligible: a pair of eigenvalues have converged.
              ! transform the 2-by-2 submatrix to standard schur form,
              ! and compute and store the eigenvalues.
              call stdlib_slanv2( h( i-1, i-1 ), h( i-1, i ), h( i, i-1 ),h( i, i ), wr( i-1 ), &
                        wi( i-1 ), wr( i ), wi( i ),cs, sn )
              if( wantt ) then
                 ! apply the transformation to the rest of h.
                 if( i2>i )call stdlib_srot( i2-i, h( i-1, i+1 ), ldh, h( i, i+1 ), ldh,cs, sn )
                           
                 call stdlib_srot( i-i1-1, h( i1, i-1 ), 1, h( i1, i ), 1, cs, sn )
              end if
              if( wantz ) then
                 ! apply the transformation to z.
                 call stdlib_srot( nz, z( iloz, i-1 ), 1, z( iloz, i ), 1, cs, sn )
              end if
           end if
           ! reset deflation counter
           kdefl = 0
           ! return to start of the main loop with new value of i.
           i = l - 1
           go to 20
           160 continue
           return
     end subroutine stdlib_slahqr

     pure subroutine stdlib_dlahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, &
     !! DLAHQR is an auxiliary routine called by DHSEQR to update the
     !! eigenvalues and Schur decomposition already computed by DHSEQR, by
     !! dealing with the Hessenberg submatrix in rows and columns ILO to
     !! IHI.
               info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           real(dp), intent(out) :: wi(*), wr(*)
        ! =========================================================
           ! Parameters 
           real(dp), parameter :: dat1 = 3.0_dp/4.0_dp
           real(dp), parameter :: dat2 = -0.4375_dp
           integer(ilp), parameter :: kexsh = 10
           
           
           
           ! Local Scalars 
           real(dp) :: aa, ab, ba, bb, cs, det, h11, h12, h21, h21s, h22, rt1i, rt1r, rt2i, rt2r, &
                     rtdisc, s, safmax, safmin, smlnum, sn, sum, t1, t2, t3, tr, tst, ulp, v2, v3
           integer(ilp) :: i, i1, i2, its, itmax, j, k, l, m, nh, nr, nz, kdefl
           ! Local Arrays 
           real(dp) :: v(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n==0 )return
           if( ilo==ihi ) then
              wr( ilo ) = h( ilo, ilo )
              wi( ilo ) = zero
              return
           end if
           ! ==== clear out the trash ====
           do j = ilo, ihi - 3
              h( j+2, j ) = zero
              h( j+3, j ) = zero
           end do
           if( ilo<=ihi-2 )h( ihi, ihi-2 ) = zero
           nh = ihi - ilo + 1
           nz = ihiz - iloz + 1
           ! set machine-dependent constants for the stopping criterion.
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safmax = one / safmin
           call stdlib_dlabad( safmin, safmax )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin*( real( nh,KIND=dp) / ulp )
           ! i1 and i2 are the indices of the first row and last column of h
           ! to which transformations must be applied. if eigenvalues only are
           ! being computed, i1 and i2 are set inside the main loop.
           if( wantt ) then
              i1 = 1
              i2 = n
           end if
           ! itmax is the total number of qr iterations allowed.
           itmax = 30 * max( 10, nh )
           ! kdefl counts the number of iterations since a deflation
           kdefl = 0
           ! the main loop begins here. i is the loop index and decreases from
           ! ihi to ilo in steps of 1 or 2. each iteration of the loop works
           ! with the active submatrix in rows and columns l to i.
           ! eigenvalues i+1 to ihi have already converged. either l = ilo or
           ! h(l,l-1) is negligible so that the matrix splits.
           i = ihi
           20 continue
           l = ilo
           if( i<ilo )go to 160
           ! perform qr iterations on rows and columns ilo to i until a
           ! submatrix of order 1 or 2 splits off at the bottom because a
           ! subdiagonal element has become negligible.
           loop_140: do its = 0, itmax
              ! look for a single small subdiagonal element.
              do k = i, l + 1, -1
                 if( abs( h( k, k-1 ) )<=smlnum )go to 40
                 tst = abs( h( k-1, k-1 ) ) + abs( h( k, k ) )
                 if( tst==zero ) then
                    if( k-2>=ilo )tst = tst + abs( h( k-1, k-2 ) )
                    if( k+1<=ihi )tst = tst + abs( h( k+1, k ) )
                 end if
                 ! ==== the following is a conservative small subdiagonal
                 ! .    deflation  criterion due to ahues
                 ! .    1997). it has better mathematical foundation and
                 ! .    improves accuracy in some cases.  ====
                 if( abs( h( k, k-1 ) )<=ulp*tst ) then
                    ab = max( abs( h( k, k-1 ) ), abs( h( k-1, k ) ) )
                    ba = min( abs( h( k, k-1 ) ), abs( h( k-1, k ) ) )
                    aa = max( abs( h( k, k ) ),abs( h( k-1, k-1 )-h( k, k ) ) )
                    bb = min( abs( h( k, k ) ),abs( h( k-1, k-1 )-h( k, k ) ) )
                    s = aa + ab
                    if( ba*( ab / s )<=max( smlnum,ulp*( bb*( aa / s ) ) ) )go to 40
                 end if
              end do
              40 continue
              l = k
              if( l>ilo ) then
                 ! h(l,l-1) is negligible
                 h( l, l-1 ) = zero
              end if
              ! exit from loop if a submatrix of order 1 or 2 has split off.
              if( l>=i-1 )go to 150
              kdefl = kdefl + 1
              ! now the active submatrix is in rows and columns l to i. if
              ! eigenvalues only are being computed, only the active submatrix
              ! need be transformed.
              if( .not.wantt ) then
                 i1 = l
                 i2 = i
              end if
              if( mod(kdefl,2*kexsh)==0 ) then
                 ! exceptional shift.
                 s = abs( h( i, i-1 ) ) + abs( h( i-1, i-2 ) )
                 h11 = dat1*s + h( i, i )
                 h12 = dat2*s
                 h21 = s
                 h22 = h11
              else if( mod(kdefl,kexsh)==0 ) then
                 ! exceptional shift.
                 s = abs( h( l+1, l ) ) + abs( h( l+2, l+1 ) )
                 h11 = dat1*s + h( l, l )
                 h12 = dat2*s
                 h21 = s
                 h22 = h11
              else
                 ! prepare to use francis' double shift
                 ! (i.e. 2nd degree generalized rayleigh quotient)
                 h11 = h( i-1, i-1 )
                 h21 = h( i, i-1 )
                 h12 = h( i-1, i )
                 h22 = h( i, i )
              end if
              s = abs( h11 ) + abs( h12 ) + abs( h21 ) + abs( h22 )
              if( s==zero ) then
                 rt1r = zero
                 rt1i = zero
                 rt2r = zero
                 rt2i = zero
              else
                 h11 = h11 / s
                 h21 = h21 / s
                 h12 = h12 / s
                 h22 = h22 / s
                 tr = ( h11+h22 ) / two
                 det = ( h11-tr )*( h22-tr ) - h12*h21
                 rtdisc = sqrt( abs( det ) )
                 if( det>=zero ) then
                    ! ==== complex conjugate shifts ====
                    rt1r = tr*s
                    rt2r = rt1r
                    rt1i = rtdisc*s
                    rt2i = -rt1i
                 else
                    ! ==== realshifts (use only one of them,KIND=dp)  ====
                    rt1r = tr + rtdisc
                    rt2r = tr - rtdisc
                    if( abs( rt1r-h22 )<=abs( rt2r-h22 ) ) then
                       rt1r = rt1r*s
                       rt2r = rt1r
                    else
                       rt2r = rt2r*s
                       rt1r = rt2r
                    end if
                    rt1i = zero
                    rt2i = zero
                 end if
              end if
              ! look for two consecutive small subdiagonal elements.
              do m = i - 2, l, -1
                 ! determine the effect of starting the double-shift qr
                 ! iteration at row m, and see if this would make h(m,m-1)
                 ! negligible.  (the following uses scaling to avoid
                 ! overflows and most underflows.)
                 h21s = h( m+1, m )
                 s = abs( h( m, m )-rt2r ) + abs( rt2i ) + abs( h21s )
                 h21s = h( m+1, m ) / s
                 v( 1 ) = h21s*h( m, m+1 ) + ( h( m, m )-rt1r )*( ( h( m, m )-rt2r ) / s ) - &
                           rt1i*( rt2i / s )
                 v( 2 ) = h21s*( h( m, m )+h( m+1, m+1 )-rt1r-rt2r )
                 v( 3 ) = h21s*h( m+2, m+1 )
                 s = abs( v( 1 ) ) + abs( v( 2 ) ) + abs( v( 3 ) )
                 v( 1 ) = v( 1 ) / s
                 v( 2 ) = v( 2 ) / s
                 v( 3 ) = v( 3 ) / s
                 if( m==l )go to 60
                 if( abs( h( m, m-1 ) )*( abs( v( 2 ) )+abs( v( 3 ) ) )<=ulp*abs( v( 1 ) )*( abs( &
                           h( m-1, m-1 ) )+abs( h( m,m ) )+abs( h( m+1, m+1 ) ) ) )go to 60
              end do
              60 continue
              ! double-shift qr step
              loop_130: do k = m, i - 1
                 ! the first iteration of this loop determines a reflection g
                 ! from the vector v and applies it from left and right to h,
                 ! thus creating a nonzero bulge below the subdiagonal.
                 ! each subsequent iteration determines a reflection g to
                 ! restore the hessenberg form in the (k-1)th column, and thus
                 ! chases the bulge one step toward the bottom of the active
                 ! submatrix. nr is the order of g.
                 nr = min( 3, i-k+1 )
                 if( k>m )call stdlib_dcopy( nr, h( k, k-1 ), 1, v, 1 )
                 call stdlib_dlarfg( nr, v( 1 ), v( 2 ), 1, t1 )
                 if( k>m ) then
                    h( k, k-1 ) = v( 1 )
                    h( k+1, k-1 ) = zero
                    if( k<i-1 )h( k+2, k-1 ) = zero
                 else if( m>l ) then
                     ! ==== use the following instead of
                     ! .    h( k, k-1 ) = -h( k, k-1 ) to
                     ! .    avoid a bug when v(2) and v(3)
                     ! .    underflow. ====
                    h( k, k-1 ) = h( k, k-1 )*( one-t1 )
                 end if
                 v2 = v( 2 )
                 t2 = t1*v2
                 if( nr==3 ) then
                    v3 = v( 3 )
                    t3 = t1*v3
                    ! apply g from the left to transform the rows of the matrix
                    ! in columns k to i2.
                    do j = k, i2
                       sum = h( k, j ) + v2*h( k+1, j ) + v3*h( k+2, j )
                       h( k, j ) = h( k, j ) - sum*t1
                       h( k+1, j ) = h( k+1, j ) - sum*t2
                       h( k+2, j ) = h( k+2, j ) - sum*t3
                    end do
                    ! apply g from the right to transform the columns of the
                    ! matrix in rows i1 to min(k+3,i).
                    do j = i1, min( k+3, i )
                       sum = h( j, k ) + v2*h( j, k+1 ) + v3*h( j, k+2 )
                       h( j, k ) = h( j, k ) - sum*t1
                       h( j, k+1 ) = h( j, k+1 ) - sum*t2
                       h( j, k+2 ) = h( j, k+2 ) - sum*t3
                    end do
                    if( wantz ) then
                       ! accumulate transformations in the matrix z
                       do j = iloz, ihiz
                          sum = z( j, k ) + v2*z( j, k+1 ) + v3*z( j, k+2 )
                          z( j, k ) = z( j, k ) - sum*t1
                          z( j, k+1 ) = z( j, k+1 ) - sum*t2
                          z( j, k+2 ) = z( j, k+2 ) - sum*t3
                       end do
                    end if
                 else if( nr==2 ) then
                    ! apply g from the left to transform the rows of the matrix
                    ! in columns k to i2.
                    do j = k, i2
                       sum = h( k, j ) + v2*h( k+1, j )
                       h( k, j ) = h( k, j ) - sum*t1
                       h( k+1, j ) = h( k+1, j ) - sum*t2
                    end do
                    ! apply g from the right to transform the columns of the
                    ! matrix in rows i1 to min(k+3,i).
                    do j = i1, i
                       sum = h( j, k ) + v2*h( j, k+1 )
                       h( j, k ) = h( j, k ) - sum*t1
                       h( j, k+1 ) = h( j, k+1 ) - sum*t2
                    end do
                    if( wantz ) then
                       ! accumulate transformations in the matrix z
                       do j = iloz, ihiz
                          sum = z( j, k ) + v2*z( j, k+1 )
                          z( j, k ) = z( j, k ) - sum*t1
                          z( j, k+1 ) = z( j, k+1 ) - sum*t2
                       end do
                    end if
                 end if
              end do loop_130
           end do loop_140
           ! failure to converge in remaining number of iterations
           info = i
           return
           150 continue
           if( l==i ) then
              ! h(i,i-1) is negligible: one eigenvalue has converged.
              wr( i ) = h( i, i )
              wi( i ) = zero
           else if( l==i-1 ) then
              ! h(i-1,i-2) is negligible: a pair of eigenvalues have converged.
              ! transform the 2-by-2 submatrix to standard schur form,
              ! and compute and store the eigenvalues.
              call stdlib_dlanv2( h( i-1, i-1 ), h( i-1, i ), h( i, i-1 ),h( i, i ), wr( i-1 ), &
                        wi( i-1 ), wr( i ), wi( i ),cs, sn )
              if( wantt ) then
                 ! apply the transformation to the rest of h.
                 if( i2>i )call stdlib_drot( i2-i, h( i-1, i+1 ), ldh, h( i, i+1 ), ldh,cs, sn )
                           
                 call stdlib_drot( i-i1-1, h( i1, i-1 ), 1, h( i1, i ), 1, cs, sn )
              end if
              if( wantz ) then
                 ! apply the transformation to z.
                 call stdlib_drot( nz, z( iloz, i-1 ), 1, z( iloz, i ), 1, cs, sn )
              end if
           end if
           ! reset deflation counter
           kdefl = 0
           ! return to start of the main loop with new value of i.
           i = l - 1
           go to 20
           160 continue
           return
     end subroutine stdlib_dlahqr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$lahqr( wantt, wantz, n, ilo, ihi, h, ldh, wr, wi,iloz, ihiz, z, ldz, &
     !! DLAHQR: is an auxiliary routine called by DHSEQR to update the
     !! eigenvalues and Schur decomposition already computed by DHSEQR, by
     !! dealing with the Hessenberg submatrix in rows and columns ILO to
     !! IHI.
               info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(${rk}$), intent(inout) :: h(ldh,*), z(ldz,*)
           real(${rk}$), intent(out) :: wi(*), wr(*)
        ! =========================================================
           ! Parameters 
           real(${rk}$), parameter :: dat1 = 3.0_${rk}$/4.0_${rk}$
           real(${rk}$), parameter :: dat2 = -0.4375_${rk}$
           integer(ilp), parameter :: kexsh = 10
           
           
           
           ! Local Scalars 
           real(${rk}$) :: aa, ab, ba, bb, cs, det, h11, h12, h21, h21s, h22, rt1i, rt1r, rt2i, rt2r, &
                     rtdisc, s, safmax, safmin, smlnum, sn, sum, t1, t2, t3, tr, tst, ulp, v2, v3
           integer(ilp) :: i, i1, i2, its, itmax, j, k, l, m, nh, nr, nz, kdefl
           ! Local Arrays 
           real(${rk}$) :: v(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n==0 )return
           if( ilo==ihi ) then
              wr( ilo ) = h( ilo, ilo )
              wi( ilo ) = zero
              return
           end if
           ! ==== clear out the trash ====
           do j = ilo, ihi - 3
              h( j+2, j ) = zero
              h( j+3, j ) = zero
           end do
           if( ilo<=ihi-2 )h( ihi, ihi-2 ) = zero
           nh = ihi - ilo + 1
           nz = ihiz - iloz + 1
           ! set machine-dependent constants for the stopping criterion.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safmax = one / safmin
           call stdlib_${ri}$labad( safmin, safmax )
           ulp = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin*( real( nh,KIND=${rk}$) / ulp )
           ! i1 and i2 are the indices of the first row and last column of h
           ! to which transformations must be applied. if eigenvalues only are
           ! being computed, i1 and i2 are set inside the main loop.
           if( wantt ) then
              i1 = 1
              i2 = n
           end if
           ! itmax is the total number of qr iterations allowed.
           itmax = 30 * max( 10, nh )
           ! kdefl counts the number of iterations since a deflation
           kdefl = 0
           ! the main loop begins here. i is the loop index and decreases from
           ! ihi to ilo in steps of 1 or 2. each iteration of the loop works
           ! with the active submatrix in rows and columns l to i.
           ! eigenvalues i+1 to ihi have already converged. either l = ilo or
           ! h(l,l-1) is negligible so that the matrix splits.
           i = ihi
           20 continue
           l = ilo
           if( i<ilo )go to 160
           ! perform qr iterations on rows and columns ilo to i until a
           ! submatrix of order 1 or 2 splits off at the bottom because a
           ! subdiagonal element has become negligible.
           loop_140: do its = 0, itmax
              ! look for a single small subdiagonal element.
              do k = i, l + 1, -1
                 if( abs( h( k, k-1 ) )<=smlnum )go to 40
                 tst = abs( h( k-1, k-1 ) ) + abs( h( k, k ) )
                 if( tst==zero ) then
                    if( k-2>=ilo )tst = tst + abs( h( k-1, k-2 ) )
                    if( k+1<=ihi )tst = tst + abs( h( k+1, k ) )
                 end if
                 ! ==== the following is a conservative small subdiagonal
                 ! .    deflation  criterion due to ahues
                 ! .    1997). it has better mathematical foundation and
                 ! .    improves accuracy in some cases.  ====
                 if( abs( h( k, k-1 ) )<=ulp*tst ) then
                    ab = max( abs( h( k, k-1 ) ), abs( h( k-1, k ) ) )
                    ba = min( abs( h( k, k-1 ) ), abs( h( k-1, k ) ) )
                    aa = max( abs( h( k, k ) ),abs( h( k-1, k-1 )-h( k, k ) ) )
                    bb = min( abs( h( k, k ) ),abs( h( k-1, k-1 )-h( k, k ) ) )
                    s = aa + ab
                    if( ba*( ab / s )<=max( smlnum,ulp*( bb*( aa / s ) ) ) )go to 40
                 end if
              end do
              40 continue
              l = k
              if( l>ilo ) then
                 ! h(l,l-1) is negligible
                 h( l, l-1 ) = zero
              end if
              ! exit from loop if a submatrix of order 1 or 2 has split off.
              if( l>=i-1 )go to 150
              kdefl = kdefl + 1
              ! now the active submatrix is in rows and columns l to i. if
              ! eigenvalues only are being computed, only the active submatrix
              ! need be transformed.
              if( .not.wantt ) then
                 i1 = l
                 i2 = i
              end if
              if( mod(kdefl,2*kexsh)==0 ) then
                 ! exceptional shift.
                 s = abs( h( i, i-1 ) ) + abs( h( i-1, i-2 ) )
                 h11 = dat1*s + h( i, i )
                 h12 = dat2*s
                 h21 = s
                 h22 = h11
              else if( mod(kdefl,kexsh)==0 ) then
                 ! exceptional shift.
                 s = abs( h( l+1, l ) ) + abs( h( l+2, l+1 ) )
                 h11 = dat1*s + h( l, l )
                 h12 = dat2*s
                 h21 = s
                 h22 = h11
              else
                 ! prepare to use francis' double shift
                 ! (i.e. 2nd degree generalized rayleigh quotient)
                 h11 = h( i-1, i-1 )
                 h21 = h( i, i-1 )
                 h12 = h( i-1, i )
                 h22 = h( i, i )
              end if
              s = abs( h11 ) + abs( h12 ) + abs( h21 ) + abs( h22 )
              if( s==zero ) then
                 rt1r = zero
                 rt1i = zero
                 rt2r = zero
                 rt2i = zero
              else
                 h11 = h11 / s
                 h21 = h21 / s
                 h12 = h12 / s
                 h22 = h22 / s
                 tr = ( h11+h22 ) / two
                 det = ( h11-tr )*( h22-tr ) - h12*h21
                 rtdisc = sqrt( abs( det ) )
                 if( det>=zero ) then
                    ! ==== complex conjugate shifts ====
                    rt1r = tr*s
                    rt2r = rt1r
                    rt1i = rtdisc*s
                    rt2i = -rt1i
                 else
                    ! ==== realshifts (use only one of them,KIND=${rk}$)  ====
                    rt1r = tr + rtdisc
                    rt2r = tr - rtdisc
                    if( abs( rt1r-h22 )<=abs( rt2r-h22 ) ) then
                       rt1r = rt1r*s
                       rt2r = rt1r
                    else
                       rt2r = rt2r*s
                       rt1r = rt2r
                    end if
                    rt1i = zero
                    rt2i = zero
                 end if
              end if
              ! look for two consecutive small subdiagonal elements.
              do m = i - 2, l, -1
                 ! determine the effect of starting the double-shift qr
                 ! iteration at row m, and see if this would make h(m,m-1)
                 ! negligible.  (the following uses scaling to avoid
                 ! overflows and most underflows.)
                 h21s = h( m+1, m )
                 s = abs( h( m, m )-rt2r ) + abs( rt2i ) + abs( h21s )
                 h21s = h( m+1, m ) / s
                 v( 1 ) = h21s*h( m, m+1 ) + ( h( m, m )-rt1r )*( ( h( m, m )-rt2r ) / s ) - &
                           rt1i*( rt2i / s )
                 v( 2 ) = h21s*( h( m, m )+h( m+1, m+1 )-rt1r-rt2r )
                 v( 3 ) = h21s*h( m+2, m+1 )
                 s = abs( v( 1 ) ) + abs( v( 2 ) ) + abs( v( 3 ) )
                 v( 1 ) = v( 1 ) / s
                 v( 2 ) = v( 2 ) / s
                 v( 3 ) = v( 3 ) / s
                 if( m==l )go to 60
                 if( abs( h( m, m-1 ) )*( abs( v( 2 ) )+abs( v( 3 ) ) )<=ulp*abs( v( 1 ) )*( abs( &
                           h( m-1, m-1 ) )+abs( h( m,m ) )+abs( h( m+1, m+1 ) ) ) )go to 60
              end do
              60 continue
              ! double-shift qr step
              loop_130: do k = m, i - 1
                 ! the first iteration of this loop determines a reflection g
                 ! from the vector v and applies it from left and right to h,
                 ! thus creating a nonzero bulge below the subdiagonal.
                 ! each subsequent iteration determines a reflection g to
                 ! restore the hessenberg form in the (k-1)th column, and thus
                 ! chases the bulge one step toward the bottom of the active
                 ! submatrix. nr is the order of g.
                 nr = min( 3, i-k+1 )
                 if( k>m )call stdlib_${ri}$copy( nr, h( k, k-1 ), 1, v, 1 )
                 call stdlib_${ri}$larfg( nr, v( 1 ), v( 2 ), 1, t1 )
                 if( k>m ) then
                    h( k, k-1 ) = v( 1 )
                    h( k+1, k-1 ) = zero
                    if( k<i-1 )h( k+2, k-1 ) = zero
                 else if( m>l ) then
                     ! ==== use the following instead of
                     ! .    h( k, k-1 ) = -h( k, k-1 ) to
                     ! .    avoid a bug when v(2) and v(3)
                     ! .    underflow. ====
                    h( k, k-1 ) = h( k, k-1 )*( one-t1 )
                 end if
                 v2 = v( 2 )
                 t2 = t1*v2
                 if( nr==3 ) then
                    v3 = v( 3 )
                    t3 = t1*v3
                    ! apply g from the left to transform the rows of the matrix
                    ! in columns k to i2.
                    do j = k, i2
                       sum = h( k, j ) + v2*h( k+1, j ) + v3*h( k+2, j )
                       h( k, j ) = h( k, j ) - sum*t1
                       h( k+1, j ) = h( k+1, j ) - sum*t2
                       h( k+2, j ) = h( k+2, j ) - sum*t3
                    end do
                    ! apply g from the right to transform the columns of the
                    ! matrix in rows i1 to min(k+3,i).
                    do j = i1, min( k+3, i )
                       sum = h( j, k ) + v2*h( j, k+1 ) + v3*h( j, k+2 )
                       h( j, k ) = h( j, k ) - sum*t1
                       h( j, k+1 ) = h( j, k+1 ) - sum*t2
                       h( j, k+2 ) = h( j, k+2 ) - sum*t3
                    end do
                    if( wantz ) then
                       ! accumulate transformations in the matrix z
                       do j = iloz, ihiz
                          sum = z( j, k ) + v2*z( j, k+1 ) + v3*z( j, k+2 )
                          z( j, k ) = z( j, k ) - sum*t1
                          z( j, k+1 ) = z( j, k+1 ) - sum*t2
                          z( j, k+2 ) = z( j, k+2 ) - sum*t3
                       end do
                    end if
                 else if( nr==2 ) then
                    ! apply g from the left to transform the rows of the matrix
                    ! in columns k to i2.
                    do j = k, i2
                       sum = h( k, j ) + v2*h( k+1, j )
                       h( k, j ) = h( k, j ) - sum*t1
                       h( k+1, j ) = h( k+1, j ) - sum*t2
                    end do
                    ! apply g from the right to transform the columns of the
                    ! matrix in rows i1 to min(k+3,i).
                    do j = i1, i
                       sum = h( j, k ) + v2*h( j, k+1 )
                       h( j, k ) = h( j, k ) - sum*t1
                       h( j, k+1 ) = h( j, k+1 ) - sum*t2
                    end do
                    if( wantz ) then
                       ! accumulate transformations in the matrix z
                       do j = iloz, ihiz
                          sum = z( j, k ) + v2*z( j, k+1 )
                          z( j, k ) = z( j, k ) - sum*t1
                          z( j, k+1 ) = z( j, k+1 ) - sum*t2
                       end do
                    end if
                 end if
              end do loop_130
           end do loop_140
           ! failure to converge in remaining number of iterations
           info = i
           return
           150 continue
           if( l==i ) then
              ! h(i,i-1) is negligible: one eigenvalue has converged.
              wr( i ) = h( i, i )
              wi( i ) = zero
           else if( l==i-1 ) then
              ! h(i-1,i-2) is negligible: a pair of eigenvalues have converged.
              ! transform the 2-by-2 submatrix to standard schur form,
              ! and compute and store the eigenvalues.
              call stdlib_${ri}$lanv2( h( i-1, i-1 ), h( i-1, i ), h( i, i-1 ),h( i, i ), wr( i-1 ), &
                        wi( i-1 ), wr( i ), wi( i ),cs, sn )
              if( wantt ) then
                 ! apply the transformation to the rest of h.
                 if( i2>i )call stdlib_${ri}$rot( i2-i, h( i-1, i+1 ), ldh, h( i, i+1 ), ldh,cs, sn )
                           
                 call stdlib_${ri}$rot( i-i1-1, h( i1, i-1 ), 1, h( i1, i ), 1, cs, sn )
              end if
              if( wantz ) then
                 ! apply the transformation to z.
                 call stdlib_${ri}$rot( nz, z( iloz, i-1 ), 1, z( iloz, i ), 1, cs, sn )
              end if
           end if
           ! reset deflation counter
           kdefl = 0
           ! return to start of the main loop with new value of i.
           i = l - 1
           go to 20
           160 continue
           return
     end subroutine stdlib_${ri}$lahqr

#:endif
#:endfor

     pure subroutine stdlib_clahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, info &
     !! CLAHQR is an auxiliary routine called by CHSEQR to update the
     !! eigenvalues and Schur decomposition already computed by CHSEQR, by
     !! dealing with the Hessenberg submatrix in rows and columns ILO to
     !! IHI.
               )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: w(*)
        ! =========================================================
           ! Parameters 
           real(sp), parameter :: rzero = 0.0_sp
           real(sp), parameter :: rone = 1.0_sp
           real(sp), parameter :: dat1 = 3.0_sp/4.0_sp
           integer(ilp), parameter :: kexsh = 10
           
           
           
           
           ! Local Scalars 
           complex(sp) :: cdum, h11, h11s, h22, sc, sum, t, t1, temp, u, v2, x, y
           real(sp) :: aa, ab, ba, bb, h10, h21, rtemp, s, safmax, safmin, smlnum, sx, t2, tst, &
                     ulp
           integer(ilp) :: i, i1, i2, its, itmax, j, jhi, jlo, k, l, m, nh, nz, kdefl
           ! Local Arrays 
           complex(sp) :: v(2)
           ! Statement Functions 
           real(sp) :: cabs1
           ! Intrinsic Functions 
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n==0 )return
           if( ilo==ihi ) then
              w( ilo ) = h( ilo, ilo )
              return
           end if
           ! ==== clear out the trash ====
           do j = ilo, ihi - 3
              h( j+2, j ) = czero
              h( j+3, j ) = czero
           end do
           if( ilo<=ihi-2 )h( ihi, ihi-2 ) = czero
           ! ==== ensure that subdiagonal entries are real ====
           if( wantt ) then
              jlo = 1
              jhi = n
           else
              jlo = ilo
              jhi = ihi
           end if
           do i = ilo + 1, ihi
              if( aimag( h( i, i-1 ) )/=rzero ) then
                 ! ==== the following redundant normalization
                 ! .    avoids problems with both gradual and
                 ! .    sudden underflow in abs(h(i,i-1)) ====
                 sc = h( i, i-1 ) / cabs1( h( i, i-1 ) )
                 sc = conjg( sc ) / abs( sc )
                 h( i, i-1 ) = abs( h( i, i-1 ) )
                 call stdlib_cscal( jhi-i+1, sc, h( i, i ), ldh )
                 call stdlib_cscal( min( jhi, i+1 )-jlo+1, conjg( sc ), h( jlo, i ),1 )
                 if( wantz )call stdlib_cscal( ihiz-iloz+1, conjg( sc ), z( iloz, i ), 1 )
              end if
           end do
           nh = ihi - ilo + 1
           nz = ihiz - iloz + 1
           ! set machine-dependent constants for the stopping criterion.
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( nh,KIND=sp) / ulp )
           ! i1 and i2 are the indices of the first row and last column of h
           ! to which transformations must be applied. if eigenvalues only are
           ! being computed, i1 and i2 are set inside the main loop.
           if( wantt ) then
              i1 = 1
              i2 = n
           end if
           ! itmax is the total number of qr iterations allowed.
           itmax = 30 * max( 10, nh )
           ! kdefl counts the number of iterations since a deflation
           kdefl = 0
           ! the main loop begins here. i is the loop index and decreases from
           ! ihi to ilo in steps of 1. each iteration of the loop works
           ! with the active submatrix in rows and columns l to i.
           ! eigenvalues i+1 to ihi have already converged. either l = ilo, or
           ! h(l,l-1) is negligible so that the matrix splits.
           i = ihi
           30 continue
           if( i<ilo )go to 150
           ! perform qr iterations on rows and columns ilo to i until a
           ! submatrix of order 1 splits off at the bottom because a
           ! subdiagonal element has become negligible.
           l = ilo
           loop_130: do its = 0, itmax
              ! look for a single small subdiagonal element.
              do k = i, l + 1, -1
                 if( cabs1( h( k, k-1 ) )<=smlnum )go to 50
                 tst = cabs1( h( k-1, k-1 ) ) + cabs1( h( k, k ) )
                 if( tst==czero ) then
                    if( k-2>=ilo )tst = tst + abs( real( h( k-1, k-2 ),KIND=sp) )
                    if( k+1<=ihi )tst = tst + abs( real( h( k+1, k ),KIND=sp) )
                 end if
                 ! ==== the following is a conservative small subdiagonal
                 ! .    deflation criterion due to ahues
                 ! .    1997). it has better mathematical foundation and
                 ! .    improves accuracy in some examples.  ====
                 if( abs( real( h( k, k-1 ),KIND=sp) )<=ulp*tst ) then
                    ab = max( cabs1( h( k, k-1 ) ), cabs1( h( k-1, k ) ) )
                    ba = min( cabs1( h( k, k-1 ) ), cabs1( h( k-1, k ) ) )
                    aa = max( cabs1( h( k, k ) ),cabs1( h( k-1, k-1 )-h( k, k ) ) )
                    bb = min( cabs1( h( k, k ) ),cabs1( h( k-1, k-1 )-h( k, k ) ) )
                    s = aa + ab
                    if( ba*( ab / s )<=max( smlnum,ulp*( bb*( aa / s ) ) ) )go to 50
                 end if
              end do
              50 continue
              l = k
              if( l>ilo ) then
                 ! h(l,l-1) is negligible
                 h( l, l-1 ) = czero
              end if
              ! exit from loop if a submatrix of order 1 has split off.
              if( l>=i )go to 140
              kdefl = kdefl + 1
              ! now the active submatrix is in rows and columns l to i. if
              ! eigenvalues only are being computed, only the active submatrix
              ! need be transformed.
              if( .not.wantt ) then
                 i1 = l
                 i2 = i
              end if
              if( mod(kdefl,2*kexsh)==0 ) then
                 ! exceptional shift.
                 s = dat1*abs( real( h( i, i-1 ),KIND=sp) )
                 t = s + h( i, i )
              else if( mod(kdefl,kexsh)==0 ) then
                 ! exceptional shift.
                 s = dat1*abs( real( h( l+1, l ),KIND=sp) )
                 t = s + h( l, l )
              else
                 ! wilkinson's shift.
                 t = h( i, i )
                 u = sqrt( h( i-1, i ) )*sqrt( h( i, i-1 ) )
                 s = cabs1( u )
                 if( s/=rzero ) then
                    x = half*( h( i-1, i-1 )-t )
                    sx = cabs1( x )
                    s = max( s, cabs1( x ) )
                    y = s*sqrt( ( x / s )**2+( u / s )**2 )
                    if( sx>rzero ) then
                       if( real( x / sx,KIND=sp)*real( y,KIND=sp)+aimag( x / sx )*aimag( y )&
                                 <rzero )y = -y
                    end if
                    t = t - u*stdlib_cladiv( u, ( x+y ) )
                 end if
              end if
              ! look for two consecutive small subdiagonal elements.
              do m = i - 1, l + 1, -1
                 ! determine the effect of starting the single-shift qr
                 ! iteration at row m, and see if this would make h(m,m-1)
                 ! negligible.
                 h11 = h( m, m )
                 h22 = h( m+1, m+1 )
                 h11s = h11 - t
                 h21 = real( h( m+1, m ),KIND=sp)
                 s = cabs1( h11s ) + abs( h21 )
                 h11s = h11s / s
                 h21 = h21 / s
                 v( 1 ) = h11s
                 v( 2 ) = h21
                 h10 = real( h( m, m-1 ),KIND=sp)
                 if( abs( h10 )*abs( h21 )<=ulp*( cabs1( h11s )*( cabs1( h11 )+cabs1( h22 ) ) ) )&
                           go to 70
              end do
              h11 = h( l, l )
              h22 = h( l+1, l+1 )
              h11s = h11 - t
              h21 = real( h( l+1, l ),KIND=sp)
              s = cabs1( h11s ) + abs( h21 )
              h11s = h11s / s
              h21 = h21 / s
              v( 1 ) = h11s
              v( 2 ) = h21
              70 continue
              ! single-shift qr step
              loop_120: do k = m, i - 1
                 ! the first iteration of this loop determines a reflection g
                 ! from the vector v and applies it from left and right to h,
                 ! thus creating a nonzero bulge below the subdiagonal.
                 ! each subsequent iteration determines a reflection g to
                 ! restore the hessenberg form in the (k-1)th column, and thus
                 ! chases the bulge cone step toward the bottom of the active
                 ! submatrix.
                 ! v(2) is always real before the call to stdlib_clarfg, and hence
                 ! after the call t2 ( = t1*v(2) ) is also real.
                 if( k>m )call stdlib_ccopy( 2, h( k, k-1 ), 1, v, 1 )
                 call stdlib_clarfg( 2, v( 1 ), v( 2 ), 1, t1 )
                 if( k>m ) then
                    h( k, k-1 ) = v( 1 )
                    h( k+1, k-1 ) = czero
                 end if
                 v2 = v( 2 )
                 t2 = real( t1*v2,KIND=sp)
                 ! apply g from the left to transform the rows of the matrix
                 ! in columns k to i2.
                 do j = k, i2
                    sum = conjg( t1 )*h( k, j ) + t2*h( k+1, j )
                    h( k, j ) = h( k, j ) - sum
                    h( k+1, j ) = h( k+1, j ) - sum*v2
                 end do
                 ! apply g from the right to transform the columns of the
                 ! matrix in rows i1 to min(k+2,i).
                 do j = i1, min( k+2, i )
                    sum = t1*h( j, k ) + t2*h( j, k+1 )
                    h( j, k ) = h( j, k ) - sum
                    h( j, k+1 ) = h( j, k+1 ) - sum*conjg( v2 )
                 end do
                 if( wantz ) then
                    ! accumulate transformations in the matrix z
                    do j = iloz, ihiz
                       sum = t1*z( j, k ) + t2*z( j, k+1 )
                       z( j, k ) = z( j, k ) - sum
                       z( j, k+1 ) = z( j, k+1 ) - sum*conjg( v2 )
                    end do
                 end if
                 if( k==m .and. m>l ) then
                    ! if the qr step was started at row m > l because two
                    ! consecutive small subdiagonals were found, then extra
                    ! scaling must be performed to ensure that h(m,m-1) remains
                    ! real.
                    temp = cone - t1
                    temp = temp / abs( temp )
                    h( m+1, m ) = h( m+1, m )*conjg( temp )
                    if( m+2<=i )h( m+2, m+1 ) = h( m+2, m+1 )*temp
                    do j = m, i
                       if( j/=m+1 ) then
                          if( i2>j )call stdlib_cscal( i2-j, temp, h( j, j+1 ), ldh )
                          call stdlib_cscal( j-i1, conjg( temp ), h( i1, j ), 1 )
                          if( wantz ) then
                             call stdlib_cscal( nz, conjg( temp ), z( iloz, j ), 1 )
                          end if
                       end if
                    end do
                 end if
              end do loop_120
              ! ensure that h(i,i-1) is real.
              temp = h( i, i-1 )
              if( aimag( temp )/=rzero ) then
                 rtemp = abs( temp )
                 h( i, i-1 ) = rtemp
                 temp = temp / rtemp
                 if( i2>i )call stdlib_cscal( i2-i, conjg( temp ), h( i, i+1 ), ldh )
                 call stdlib_cscal( i-i1, temp, h( i1, i ), 1 )
                 if( wantz ) then
                    call stdlib_cscal( nz, temp, z( iloz, i ), 1 )
                 end if
              end if
           end do loop_130
           ! failure to converge in remaining number of iterations
           info = i
           return
           140 continue
           ! h(i,i-1) is negligible: cone eigenvalue has converged.
           w( i ) = h( i, i )
           ! reset deflation counter
           kdefl = 0
           ! return to start of the main loop with new value of i.
           i = l - 1
           go to 30
           150 continue
           return
     end subroutine stdlib_clahqr

     pure subroutine stdlib_zlahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, info &
     !! ZLAHQR is an auxiliary routine called by CHSEQR to update the
     !! eigenvalues and Schur decomposition already computed by CHSEQR, by
     !! dealing with the Hessenberg submatrix in rows and columns ILO to
     !! IHI.
               )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(dp), intent(out) :: w(*)
        ! =========================================================
           ! Parameters 
           real(dp), parameter :: rzero = 0.0_dp
           real(dp), parameter :: rone = 1.0_dp
           real(dp), parameter :: dat1 = 3.0_dp/4.0_dp
           integer(ilp), parameter :: kexsh = 10
           
           
           
           
           ! Local Scalars 
           complex(dp) :: cdum, h11, h11s, h22, sc, sum, t, t1, temp, u, v2, x, y
           real(dp) :: aa, ab, ba, bb, h10, h21, rtemp, s, safmax, safmin, smlnum, sx, t2, tst, &
                     ulp
           integer(ilp) :: i, i1, i2, its, itmax, j, jhi, jlo, k, l, m, nh, nz, kdefl
           ! Local Arrays 
           complex(dp) :: v(2)
           ! Statement Functions 
           real(dp) :: cabs1
           ! Intrinsic Functions 
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n==0 )return
           if( ilo==ihi ) then
              w( ilo ) = h( ilo, ilo )
              return
           end if
           ! ==== clear out the trash ====
           do j = ilo, ihi - 3
              h( j+2, j ) = czero
              h( j+3, j ) = czero
           end do
           if( ilo<=ihi-2 )h( ihi, ihi-2 ) = czero
           ! ==== ensure that subdiagonal entries are real ====
           if( wantt ) then
              jlo = 1
              jhi = n
           else
              jlo = ilo
              jhi = ihi
           end if
           do i = ilo + 1, ihi
              if( aimag( h( i, i-1 ) )/=rzero ) then
                 ! ==== the following redundant normalization
                 ! .    avoids problems with both gradual and
                 ! .    sudden underflow in abs(h(i,i-1)) ====
                 sc = h( i, i-1 ) / cabs1( h( i, i-1 ) )
                 sc = conjg( sc ) / abs( sc )
                 h( i, i-1 ) = abs( h( i, i-1 ) )
                 call stdlib_zscal( jhi-i+1, sc, h( i, i ), ldh )
                 call stdlib_zscal( min( jhi, i+1 )-jlo+1, conjg( sc ),h( jlo, i ), 1 )
                 if( wantz )call stdlib_zscal( ihiz-iloz+1, conjg( sc ), z( iloz, i ), 1 )
              end if
           end do
           nh = ihi - ilo + 1
           nz = ihiz - iloz + 1
           ! set machine-dependent constants for the stopping criterion.
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_dlabad( safmin, safmax )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin*( real( nh,KIND=dp) / ulp )
           ! i1 and i2 are the indices of the first row and last column of h
           ! to which transformations must be applied. if eigenvalues only are
           ! being computed, i1 and i2 are set inside the main loop.
           if( wantt ) then
              i1 = 1
              i2 = n
           end if
           ! itmax is the total number of qr iterations allowed.
           itmax = 30 * max( 10, nh )
           ! kdefl counts the number of iterations since a deflation
           kdefl = 0
           ! the main loop begins here. i is the loop index and decreases from
           ! ihi to ilo in steps of 1. each iteration of the loop works
           ! with the active submatrix in rows and columns l to i.
           ! eigenvalues i+1 to ihi have already converged. either l = ilo, or
           ! h(l,l-1) is negligible so that the matrix splits.
           i = ihi
           30 continue
           if( i<ilo )go to 150
           ! perform qr iterations on rows and columns ilo to i until a
           ! submatrix of order 1 splits off at the bottom because a
           ! subdiagonal element has become negligible.
           l = ilo
           loop_130: do its = 0, itmax
              ! look for a single small subdiagonal element.
              do k = i, l + 1, -1
                 if( cabs1( h( k, k-1 ) )<=smlnum )go to 50
                 tst = cabs1( h( k-1, k-1 ) ) + cabs1( h( k, k ) )
                 if( tst==czero ) then
                    if( k-2>=ilo )tst = tst + abs( real( h( k-1, k-2 ),KIND=dp) )
                    if( k+1<=ihi )tst = tst + abs( real( h( k+1, k ),KIND=dp) )
                 end if
                 ! ==== the following is a conservative small subdiagonal
                 ! .    deflation criterion due to ahues
                 ! .    1997). it has better mathematical foundation and
                 ! .    improves accuracy in some examples.  ====
                 if( abs( real( h( k, k-1 ),KIND=dp) )<=ulp*tst ) then
                    ab = max( cabs1( h( k, k-1 ) ), cabs1( h( k-1, k ) ) )
                    ba = min( cabs1( h( k, k-1 ) ), cabs1( h( k-1, k ) ) )
                    aa = max( cabs1( h( k, k ) ),cabs1( h( k-1, k-1 )-h( k, k ) ) )
                    bb = min( cabs1( h( k, k ) ),cabs1( h( k-1, k-1 )-h( k, k ) ) )
                    s = aa + ab
                    if( ba*( ab / s )<=max( smlnum,ulp*( bb*( aa / s ) ) ) )go to 50
                 end if
              end do
              50 continue
              l = k
              if( l>ilo ) then
                 ! h(l,l-1) is negligible
                 h( l, l-1 ) = czero
              end if
              ! exit from loop if a submatrix of order 1 has split off.
              if( l>=i )go to 140
              kdefl = kdefl + 1
              ! now the active submatrix is in rows and columns l to i. if
              ! eigenvalues only are being computed, only the active submatrix
              ! need be transformed.
              if( .not.wantt ) then
                 i1 = l
                 i2 = i
              end if
              if( mod(kdefl,2*kexsh)==0 ) then
                 ! exceptional shift.
                 s = dat1*abs( real( h( i, i-1 ),KIND=dp) )
                 t = s + h( i, i )
              else if( mod(kdefl,kexsh)==0 ) then
                 ! exceptional shift.
                 s = dat1*abs( real( h( l+1, l ),KIND=dp) )
                 t = s + h( l, l )
              else
                 ! wilkinson's shift.
                 t = h( i, i )
                 u = sqrt( h( i-1, i ) )*sqrt( h( i, i-1 ) )
                 s = cabs1( u )
                 if( s/=rzero ) then
                    x = half*( h( i-1, i-1 )-t )
                    sx = cabs1( x )
                    s = max( s, cabs1( x ) )
                    y = s*sqrt( ( x / s )**2+( u / s )**2 )
                    if( sx>rzero ) then
                       if( real( x / sx,KIND=dp)*real( y,KIND=dp)+aimag( x / sx )*aimag( y )&
                                 <rzero )y = -y
                    end if
                    t = t - u*stdlib_zladiv( u, ( x+y ) )
                 end if
              end if
              ! look for two consecutive small subdiagonal elements.
              do m = i - 1, l + 1, -1
                 ! determine the effect of starting the single-shift qr
                 ! iteration at row m, and see if this would make h(m,m-1)
                 ! negligible.
                 h11 = h( m, m )
                 h22 = h( m+1, m+1 )
                 h11s = h11 - t
                 h21 = real( h( m+1, m ),KIND=dp)
                 s = cabs1( h11s ) + abs( h21 )
                 h11s = h11s / s
                 h21 = h21 / s
                 v( 1 ) = h11s
                 v( 2 ) = h21
                 h10 = real( h( m, m-1 ),KIND=dp)
                 if( abs( h10 )*abs( h21 )<=ulp*( cabs1( h11s )*( cabs1( h11 )+cabs1( h22 ) ) ) )&
                           go to 70
              end do
              h11 = h( l, l )
              h22 = h( l+1, l+1 )
              h11s = h11 - t
              h21 = real( h( l+1, l ),KIND=dp)
              s = cabs1( h11s ) + abs( h21 )
              h11s = h11s / s
              h21 = h21 / s
              v( 1 ) = h11s
              v( 2 ) = h21
              70 continue
              ! single-shift qr step
              loop_120: do k = m, i - 1
                 ! the first iteration of this loop determines a reflection g
                 ! from the vector v and applies it from left and right to h,
                 ! thus creating a nonzero bulge below the subdiagonal.
                 ! each subsequent iteration determines a reflection g to
                 ! restore the hessenberg form in the (k-1)th column, and thus
                 ! chases the bulge cone step toward the bottom of the active
                 ! submatrix.
                 ! v(2) is always real before the call to stdlib_zlarfg, and hence
                 ! after the call t2 ( = t1*v(2) ) is also real.
                 if( k>m )call stdlib_zcopy( 2, h( k, k-1 ), 1, v, 1 )
                 call stdlib_zlarfg( 2, v( 1 ), v( 2 ), 1, t1 )
                 if( k>m ) then
                    h( k, k-1 ) = v( 1 )
                    h( k+1, k-1 ) = czero
                 end if
                 v2 = v( 2 )
                 t2 = real( t1*v2,KIND=dp)
                 ! apply g from the left to transform the rows of the matrix
                 ! in columns k to i2.
                 do j = k, i2
                    sum = conjg( t1 )*h( k, j ) + t2*h( k+1, j )
                    h( k, j ) = h( k, j ) - sum
                    h( k+1, j ) = h( k+1, j ) - sum*v2
                 end do
                 ! apply g from the right to transform the columns of the
                 ! matrix in rows i1 to min(k+2,i).
                 do j = i1, min( k+2, i )
                    sum = t1*h( j, k ) + t2*h( j, k+1 )
                    h( j, k ) = h( j, k ) - sum
                    h( j, k+1 ) = h( j, k+1 ) - sum*conjg( v2 )
                 end do
                 if( wantz ) then
                    ! accumulate transformations in the matrix z
                    do j = iloz, ihiz
                       sum = t1*z( j, k ) + t2*z( j, k+1 )
                       z( j, k ) = z( j, k ) - sum
                       z( j, k+1 ) = z( j, k+1 ) - sum*conjg( v2 )
                    end do
                 end if
                 if( k==m .and. m>l ) then
                    ! if the qr step was started at row m > l because two
                    ! consecutive small subdiagonals were found, then extra
                    ! scaling must be performed to ensure that h(m,m-1) remains
                    ! real.
                    temp = cone - t1
                    temp = temp / abs( temp )
                    h( m+1, m ) = h( m+1, m )*conjg( temp )
                    if( m+2<=i )h( m+2, m+1 ) = h( m+2, m+1 )*temp
                    do j = m, i
                       if( j/=m+1 ) then
                          if( i2>j )call stdlib_zscal( i2-j, temp, h( j, j+1 ), ldh )
                          call stdlib_zscal( j-i1, conjg( temp ), h( i1, j ), 1 )
                          if( wantz ) then
                             call stdlib_zscal( nz, conjg( temp ), z( iloz, j ),1 )
                          end if
                       end if
                    end do
                 end if
              end do loop_120
              ! ensure that h(i,i-1) is real.
              temp = h( i, i-1 )
              if( aimag( temp )/=rzero ) then
                 rtemp = abs( temp )
                 h( i, i-1 ) = rtemp
                 temp = temp / rtemp
                 if( i2>i )call stdlib_zscal( i2-i, conjg( temp ), h( i, i+1 ), ldh )
                 call stdlib_zscal( i-i1, temp, h( i1, i ), 1 )
                 if( wantz ) then
                    call stdlib_zscal( nz, temp, z( iloz, i ), 1 )
                 end if
              end if
           end do loop_130
           ! failure to converge in remaining number of iterations
           info = i
           return
           140 continue
           ! h(i,i-1) is negligible: cone eigenvalue has converged.
           w( i ) = h( i, i )
           ! reset deflation counter
           kdefl = 0
           ! return to start of the main loop with new value of i.
           i = l - 1
           go to 30
           150 continue
           return
     end subroutine stdlib_zlahqr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$lahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, info &
     !! ZLAHQR: is an auxiliary routine called by CHSEQR to update the
     !! eigenvalues and Schur decomposition already computed by CHSEQR, by
     !! dealing with the Hessenberg submatrix in rows and columns ILO to
     !! IHI.
               )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(${ck}$), intent(out) :: w(*)
        ! =========================================================
           ! Parameters 
           real(${ck}$), parameter :: rzero = 0.0_${ck}$
           real(${ck}$), parameter :: rone = 1.0_${ck}$
           real(${ck}$), parameter :: dat1 = 3.0_${ck}$/4.0_${ck}$
           integer(ilp), parameter :: kexsh = 10
           
           
           
           
           ! Local Scalars 
           complex(${ck}$) :: cdum, h11, h11s, h22, sc, sum, t, t1, temp, u, v2, x, y
           real(${ck}$) :: aa, ab, ba, bb, h10, h21, rtemp, s, safmax, safmin, smlnum, sx, t2, tst, &
                     ulp
           integer(ilp) :: i, i1, i2, its, itmax, j, jhi, jlo, k, l, m, nh, nz, kdefl
           ! Local Arrays 
           complex(${ck}$) :: v(2)
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Intrinsic Functions 
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n==0 )return
           if( ilo==ihi ) then
              w( ilo ) = h( ilo, ilo )
              return
           end if
           ! ==== clear out the trash ====
           do j = ilo, ihi - 3
              h( j+2, j ) = czero
              h( j+3, j ) = czero
           end do
           if( ilo<=ihi-2 )h( ihi, ihi-2 ) = czero
           ! ==== ensure that subdiagonal entries are real ====
           if( wantt ) then
              jlo = 1
              jhi = n
           else
              jlo = ilo
              jhi = ihi
           end if
           do i = ilo + 1, ihi
              if( aimag( h( i, i-1 ) )/=rzero ) then
                 ! ==== the following redundant normalization
                 ! .    avoids problems with both gradual and
                 ! .    sudden underflow in abs(h(i,i-1)) ====
                 sc = h( i, i-1 ) / cabs1( h( i, i-1 ) )
                 sc = conjg( sc ) / abs( sc )
                 h( i, i-1 ) = abs( h( i, i-1 ) )
                 call stdlib_${ci}$scal( jhi-i+1, sc, h( i, i ), ldh )
                 call stdlib_${ci}$scal( min( jhi, i+1 )-jlo+1, conjg( sc ),h( jlo, i ), 1 )
                 if( wantz )call stdlib_${ci}$scal( ihiz-iloz+1, conjg( sc ), z( iloz, i ), 1 )
              end if
           end do
           nh = ihi - ilo + 1
           nz = ihiz - iloz + 1
           ! set machine-dependent constants for the stopping criterion.
           safmin = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_${c2ri(ci)}$labad( safmin, safmax )
           ulp = stdlib_${c2ri(ci)}$lamch( 'PRECISION' )
           smlnum = safmin*( real( nh,KIND=${ck}$) / ulp )
           ! i1 and i2 are the indices of the first row and last column of h
           ! to which transformations must be applied. if eigenvalues only are
           ! being computed, i1 and i2 are set inside the main loop.
           if( wantt ) then
              i1 = 1
              i2 = n
           end if
           ! itmax is the total number of qr iterations allowed.
           itmax = 30 * max( 10, nh )
           ! kdefl counts the number of iterations since a deflation
           kdefl = 0
           ! the main loop begins here. i is the loop index and decreases from
           ! ihi to ilo in steps of 1. each iteration of the loop works
           ! with the active submatrix in rows and columns l to i.
           ! eigenvalues i+1 to ihi have already converged. either l = ilo, or
           ! h(l,l-1) is negligible so that the matrix splits.
           i = ihi
           30 continue
           if( i<ilo )go to 150
           ! perform qr iterations on rows and columns ilo to i until a
           ! submatrix of order 1 splits off at the bottom because a
           ! subdiagonal element has become negligible.
           l = ilo
           loop_130: do its = 0, itmax
              ! look for a single small subdiagonal element.
              do k = i, l + 1, -1
                 if( cabs1( h( k, k-1 ) )<=smlnum )go to 50
                 tst = cabs1( h( k-1, k-1 ) ) + cabs1( h( k, k ) )
                 if( tst==czero ) then
                    if( k-2>=ilo )tst = tst + abs( real( h( k-1, k-2 ),KIND=${ck}$) )
                    if( k+1<=ihi )tst = tst + abs( real( h( k+1, k ),KIND=${ck}$) )
                 end if
                 ! ==== the following is a conservative small subdiagonal
                 ! .    deflation criterion due to ahues
                 ! .    1997). it has better mathematical foundation and
                 ! .    improves accuracy in some examples.  ====
                 if( abs( real( h( k, k-1 ),KIND=${ck}$) )<=ulp*tst ) then
                    ab = max( cabs1( h( k, k-1 ) ), cabs1( h( k-1, k ) ) )
                    ba = min( cabs1( h( k, k-1 ) ), cabs1( h( k-1, k ) ) )
                    aa = max( cabs1( h( k, k ) ),cabs1( h( k-1, k-1 )-h( k, k ) ) )
                    bb = min( cabs1( h( k, k ) ),cabs1( h( k-1, k-1 )-h( k, k ) ) )
                    s = aa + ab
                    if( ba*( ab / s )<=max( smlnum,ulp*( bb*( aa / s ) ) ) )go to 50
                 end if
              end do
              50 continue
              l = k
              if( l>ilo ) then
                 ! h(l,l-1) is negligible
                 h( l, l-1 ) = czero
              end if
              ! exit from loop if a submatrix of order 1 has split off.
              if( l>=i )go to 140
              kdefl = kdefl + 1
              ! now the active submatrix is in rows and columns l to i. if
              ! eigenvalues only are being computed, only the active submatrix
              ! need be transformed.
              if( .not.wantt ) then
                 i1 = l
                 i2 = i
              end if
              if( mod(kdefl,2*kexsh)==0 ) then
                 ! exceptional shift.
                 s = dat1*abs( real( h( i, i-1 ),KIND=${ck}$) )
                 t = s + h( i, i )
              else if( mod(kdefl,kexsh)==0 ) then
                 ! exceptional shift.
                 s = dat1*abs( real( h( l+1, l ),KIND=${ck}$) )
                 t = s + h( l, l )
              else
                 ! wilkinson's shift.
                 t = h( i, i )
                 u = sqrt( h( i-1, i ) )*sqrt( h( i, i-1 ) )
                 s = cabs1( u )
                 if( s/=rzero ) then
                    x = half*( h( i-1, i-1 )-t )
                    sx = cabs1( x )
                    s = max( s, cabs1( x ) )
                    y = s*sqrt( ( x / s )**2+( u / s )**2 )
                    if( sx>rzero ) then
                       if( real( x / sx,KIND=${ck}$)*real( y,KIND=${ck}$)+aimag( x / sx )*aimag( y )&
                                 <rzero )y = -y
                    end if
                    t = t - u*stdlib_${ci}$ladiv( u, ( x+y ) )
                 end if
              end if
              ! look for two consecutive small subdiagonal elements.
              do m = i - 1, l + 1, -1
                 ! determine the effect of starting the single-shift qr
                 ! iteration at row m, and see if this would make h(m,m-1)
                 ! negligible.
                 h11 = h( m, m )
                 h22 = h( m+1, m+1 )
                 h11s = h11 - t
                 h21 = real( h( m+1, m ),KIND=${ck}$)
                 s = cabs1( h11s ) + abs( h21 )
                 h11s = h11s / s
                 h21 = h21 / s
                 v( 1 ) = h11s
                 v( 2 ) = h21
                 h10 = real( h( m, m-1 ),KIND=${ck}$)
                 if( abs( h10 )*abs( h21 )<=ulp*( cabs1( h11s )*( cabs1( h11 )+cabs1( h22 ) ) ) )&
                           go to 70
              end do
              h11 = h( l, l )
              h22 = h( l+1, l+1 )
              h11s = h11 - t
              h21 = real( h( l+1, l ),KIND=${ck}$)
              s = cabs1( h11s ) + abs( h21 )
              h11s = h11s / s
              h21 = h21 / s
              v( 1 ) = h11s
              v( 2 ) = h21
              70 continue
              ! single-shift qr step
              loop_120: do k = m, i - 1
                 ! the first iteration of this loop determines a reflection g
                 ! from the vector v and applies it from left and right to h,
                 ! thus creating a nonzero bulge below the subdiagonal.
                 ! each subsequent iteration determines a reflection g to
                 ! restore the hessenberg form in the (k-1)th column, and thus
                 ! chases the bulge cone step toward the bottom of the active
                 ! submatrix.
                 ! v(2) is always real before the call to stdlib_${ci}$larfg, and hence
                 ! after the call t2 ( = t1*v(2) ) is also real.
                 if( k>m )call stdlib_${ci}$copy( 2, h( k, k-1 ), 1, v, 1 )
                 call stdlib_${ci}$larfg( 2, v( 1 ), v( 2 ), 1, t1 )
                 if( k>m ) then
                    h( k, k-1 ) = v( 1 )
                    h( k+1, k-1 ) = czero
                 end if
                 v2 = v( 2 )
                 t2 = real( t1*v2,KIND=${ck}$)
                 ! apply g from the left to transform the rows of the matrix
                 ! in columns k to i2.
                 do j = k, i2
                    sum = conjg( t1 )*h( k, j ) + t2*h( k+1, j )
                    h( k, j ) = h( k, j ) - sum
                    h( k+1, j ) = h( k+1, j ) - sum*v2
                 end do
                 ! apply g from the right to transform the columns of the
                 ! matrix in rows i1 to min(k+2,i).
                 do j = i1, min( k+2, i )
                    sum = t1*h( j, k ) + t2*h( j, k+1 )
                    h( j, k ) = h( j, k ) - sum
                    h( j, k+1 ) = h( j, k+1 ) - sum*conjg( v2 )
                 end do
                 if( wantz ) then
                    ! accumulate transformations in the matrix z
                    do j = iloz, ihiz
                       sum = t1*z( j, k ) + t2*z( j, k+1 )
                       z( j, k ) = z( j, k ) - sum
                       z( j, k+1 ) = z( j, k+1 ) - sum*conjg( v2 )
                    end do
                 end if
                 if( k==m .and. m>l ) then
                    ! if the qr step was started at row m > l because two
                    ! consecutive small subdiagonals were found, then extra
                    ! scaling must be performed to ensure that h(m,m-1) remains
                    ! real.
                    temp = cone - t1
                    temp = temp / abs( temp )
                    h( m+1, m ) = h( m+1, m )*conjg( temp )
                    if( m+2<=i )h( m+2, m+1 ) = h( m+2, m+1 )*temp
                    do j = m, i
                       if( j/=m+1 ) then
                          if( i2>j )call stdlib_${ci}$scal( i2-j, temp, h( j, j+1 ), ldh )
                          call stdlib_${ci}$scal( j-i1, conjg( temp ), h( i1, j ), 1 )
                          if( wantz ) then
                             call stdlib_${ci}$scal( nz, conjg( temp ), z( iloz, j ),1 )
                          end if
                       end if
                    end do
                 end if
              end do loop_120
              ! ensure that h(i,i-1) is real.
              temp = h( i, i-1 )
              if( aimag( temp )/=rzero ) then
                 rtemp = abs( temp )
                 h( i, i-1 ) = rtemp
                 temp = temp / rtemp
                 if( i2>i )call stdlib_${ci}$scal( i2-i, conjg( temp ), h( i, i+1 ), ldh )
                 call stdlib_${ci}$scal( i-i1, temp, h( i1, i ), 1 )
                 if( wantz ) then
                    call stdlib_${ci}$scal( nz, temp, z( iloz, i ), 1 )
                 end if
              end if
           end do loop_130
           ! failure to converge in remaining number of iterations
           info = i
           return
           140 continue
           ! h(i,i-1) is negligible: cone eigenvalue has converged.
           w( i ) = h( i, i )
           ! reset deflation counter
           kdefl = 0
           ! return to start of the main loop with new value of i.
           i = l - 1
           go to 30
           150 continue
           return
     end subroutine stdlib_${ci}$lahqr

#:endif
#:endfor



     pure subroutine stdlib_claqr4( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, work, lwork, info )
     !! CLAQR4 implements one level of recursion for CLAQR0.
     !! It is a complete implementation of the small bulge multi-shift
     !! QR algorithm.  It may be called by CLAQR0 and, for large enough
     !! deflation window size, it may be called by CLAQR3.  This
     !! subroutine is identical to CLAQR0 except that it calls CLAQR2
     !! instead of CLAQR3.
     !! CLAQR4 computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**H, where T is an upper triangular matrix (the
     !! Schur form), and Z is the unitary matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input unitary
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
                
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: w(*), work(*)
        ! ================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: kexnw = 5
           integer(ilp), parameter :: kexsh = 6
           real(sp), parameter :: wilk1 = 0.75_sp
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_clahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== exceptional deflation windows:  try to cure rare
           ! .    slow convergence by varying the size of the
           ! .    deflation window after kexnw iterations. ====
           
           ! ==== exceptional shifts: try to cure rare slow convergence
           ! .    with ad-hoc exceptional shifts every kexsh iterations.
           ! .    ====
           
           ! ==== the constant wilk1 is used to form the exceptional
           ! .    shifts. ====
           
           
           
           ! Local Scalars 
           complex(sp) :: aa, bb, cc, cdum, dd, det, rtdisc, swap, tr2
           real(sp) :: s
           integer(ilp) :: i, inf, it, itmax, k, kacc22, kbot, kdu, ks, kt, ktop, ku, kv, kwh, &
           kwtop, kwv, ld, ls, lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns, nsmax, nsr, nve, nw,&
                      nwmax, nwr, nwupbd
           logical(lk) :: sorted
           character :: jbcmpz*2
           ! Local Arrays 
           complex(sp) :: zdum(1,1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! ==== quick return for n = 0: nothing to do. ====
           if( n==0 ) then
              work( 1 ) = cone
              return
           end if
           if( n<=ntiny ) then
              ! ==== tiny matrices must use stdlib_clahqr. ====
              lwkopt = 1
              if( lwork/=-1 )call stdlib_clahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, &
                        z, ldz, info )
           else
              ! ==== use small bulge multi-shift qr with aggressive early
              ! .    deflation on larger-than-tiny matrices. ====
              ! ==== hope for the best. ====
              info = 0
              ! ==== set up job flags for stdlib_ilaenv. ====
              if( wantt ) then
                 jbcmpz( 1: 1 ) = 'S'
              else
                 jbcmpz( 1: 1 ) = 'E'
              end if
              if( wantz ) then
                 jbcmpz( 2: 2 ) = 'V'
              else
                 jbcmpz( 2: 2 ) = 'N'
              end if
              ! ==== nwr = recommended deflation window size.  at this
              ! .    point,  n > ntiny = 15, so there is enough
              ! .    subdiagonal workspace for nwr>=2 as required.
              ! .    (in fact, there is enough subdiagonal space for
              ! .    nwr>=4.) ====
              nwr = stdlib_ilaenv( 13, 'CLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nwr = max( 2, nwr )
              nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
              ! ==== nsr = recommended number of simultaneous shifts.
              ! .    at this point n > ntiny = 15, so there is at
              ! .    enough subdiagonal workspace for nsr to be even
              ! .    and greater than or equal to two as required. ====
              nsr = stdlib_ilaenv( 15, 'CLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nsr = min( nsr, ( n-3 ) / 6, ihi-ilo )
              nsr = max( 2, nsr-mod( nsr, 2 ) )
              ! ==== estimate optimal workspace ====
              ! ==== workspace query call to stdlib_claqr2 ====
              call stdlib_claqr2( wantt, wantz, n, ilo, ihi, nwr+1, h, ldh, iloz,ihiz, z, ldz, ls,&
                         ld, w, h, ldh, n, h, ldh, n, h,ldh, work, -1 )
              ! ==== optimal workspace = max(stdlib_claqr5, stdlib_claqr2) ====
              lwkopt = max( 3*nsr / 2, int( work( 1 ),KIND=ilp) )
              ! ==== quick return in case of workspace query. ====
              if( lwork==-1 ) then
                 work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
                 return
              end if
              ! ==== stdlib_clahqr/stdlib_claqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'CLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nmin = max( ntiny, nmin )
              ! ==== nibble crossover point ====
              nibble = stdlib_ilaenv( 14, 'CLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nibble = max( 0, nibble )
              ! ==== accumulate reflections during ttswp?  use block
              ! .    2-by-2 structure during matrix-matrix multiply? ====
              kacc22 = stdlib_ilaenv( 16, 'CLAQR4', jbcmpz, n, ilo, ihi, lwork )
              kacc22 = max( 0, kacc22 )
              kacc22 = min( 2, kacc22 )
              ! ==== nwmax = the largest possible deflation window for
              ! .    which there is sufficient workspace. ====
              nwmax = min( ( n-1 ) / 3, lwork / 2 )
              nw = nwmax
              ! ==== nsmax = the largest number of simultaneous shifts
              ! .    for which there is sufficient workspace. ====
              nsmax = min( ( n-3 ) / 6, 2*lwork / 3 )
              nsmax = nsmax - mod( nsmax, 2 )
              ! ==== ndfl: an iteration count restarted at deflation. ====
              ndfl = 1
              ! ==== itmax = iteration limit ====
              itmax = max( 30, 2*kexsh )*max( 10, ( ihi-ilo+1 ) )
              ! ==== last row and column in the active block ====
              kbot = ihi
              ! ==== main loop ====
              loop_70: do it = 1, itmax
                 ! ==== done when kbot falls below ilo ====
                 if( kbot<ilo )go to 80
                 ! ==== locate active block ====
                 do k = kbot, ilo + 1, -1
                    if( h( k, k-1 )==czero )go to 20
                 end do
                 k = ilo
                 20 continue
                 ktop = k
                 ! ==== select deflation window size:
                 ! .    typical case:
                 ! .      if possible and advisable, nibble the entire
                 ! .      active block.  if not, use size min(nwr,nwmax)
                 ! .      or min(nwr+1,nwmax) depending upon which has
                 ! .      the smaller corresponding subdiagonal entry
                 ! .      (a heuristic).
                 ! .    exceptional case:
                 ! .      if there have been no deflations in kexnw or
                 ! .      more iterations, then vary the deflation window
                 ! .      size.   at first, because, larger windows are,
                 ! .      in general, more powerful than smaller ones,
                 ! .      rapidly increase the window to the maximum possible.
                 ! .      then, gradually reduce the window size. ====
                 nh = kbot - ktop + 1
                 nwupbd = min( nh, nwmax )
                 if( ndfl<kexnw ) then
                    nw = min( nwupbd, nwr )
                 else
                    nw = min( nwupbd, 2*nw )
                 end if
                 if( nw<nwmax ) then
                    if( nw>=nh-1 ) then
                       nw = nh
                    else
                       kwtop = kbot - nw + 1
                       if( cabs1( h( kwtop, kwtop-1 ) )>cabs1( h( kwtop-1, kwtop-2 ) ) )nw = nw + &
                                 1
                    end if
                 end if
                 if( ndfl<kexnw ) then
                    ndec = -1
                 else if( ndec>=0 .or. nw>=nwupbd ) then
                    ndec = ndec + 1
                    if( nw-ndec<2 )ndec = 0
                    nw = nw - ndec
                 end if
                 ! ==== aggressive early deflation:
                 ! .    split workspace under the subdiagonal into
                 ! .      - an nw-by-nw work array v in the lower
                 ! .        left-hand-corner,
                 ! .      - an nw-by-at-least-nw-but-more-is-better
                 ! .        (nw-by-nho) horizontal work array along
                 ! .        the bottom edge,
                 ! .      - an at-least-nw-but-more-is-better (nhv-by-nw)
                 ! .        vertical work array along the left-hand-edge.
                 ! .        ====
                 kv = n - nw + 1
                 kt = nw + 1
                 nho = ( n-nw-1 ) - kt + 1
                 kwv = nw + 2
                 nve = ( n-nw ) - kwv + 1
                 ! ==== aggressive early deflation ====
                 call stdlib_claqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
                 ls, ld, w, h( kv, 1 ), ldh, nho,h( kv, kt ), ldh, nve, h( kwv, 1 ), ldh, work,&
                           lwork )
                 ! ==== adjust kbot accounting for new deflations. ====
                 kbot = kbot - ld
                 ! ==== ks points to the shifts. ====
                 ks = kbot - ls + 1
                 ! ==== skip an expensive qr sweep if there is a (partly
                 ! .    heuristic) reason to expect that many eigenvalues
                 ! .    will deflate without it.  here, the qr sweep is
                 ! .    skipped if many eigenvalues have just been deflated
                 ! .    or if the remaining active block is small.
                 if( ( ld==0 ) .or. ( ( 100*ld<=nw*nibble ) .and. ( kbot-ktop+1>min( nmin, nwmax )&
                            ) ) ) then
                    ! ==== ns = nominal number of simultaneous shifts.
                    ! .    this may be lowered (slightly) if stdlib_claqr2
                    ! .    did not provide that many shifts. ====
                    ns = min( nsmax, nsr, max( 2, kbot-ktop ) )
                    ns = ns - mod( ns, 2 )
                    ! ==== if there have been no deflations
                    ! .    in a multiple of kexsh iterations,
                    ! .    then try exceptional shifts.
                    ! .    otherwise use shifts provided by
                    ! .    stdlib_claqr2 above or from the eigenvalues
                    ! .    of a trailing principal submatrix. ====
                    if( mod( ndfl, kexsh )==0 ) then
                       ks = kbot - ns + 1
                       do i = kbot, ks + 1, -2
                          w( i ) = h( i, i ) + wilk1*cabs1( h( i, i-1 ) )
                          w( i-1 ) = w( i )
                       end do
                    else
                       ! ==== got ns/2 or fewer shifts? use stdlib_clahqr
                       ! .    on a trailing principal submatrix to
                       ! .    get more. (since ns<=nsmax<=(n-3)/6,
                       ! .    there is enough space below the subdiagonal
                       ! .    to fit an ns-by-ns scratch array.) ====
                       if( kbot-ks+1<=ns / 2 ) then
                          ks = kbot - ns + 1
                          kt = n - ns + 1
                          call stdlib_clacpy( 'A', ns, ns, h( ks, ks ), ldh,h( kt, 1 ), ldh )
                                    
                          call stdlib_clahqr( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, w( ks )&
                                    , 1, 1, zdum,1, inf )
                          ks = ks + inf
                          ! ==== in case of a rare qr failure use
                          ! .    eigenvalues of the trailing 2-by-2
                          ! .    principal submatrix.  scale to avoid
                          ! .    overflows, underflows and subnormals.
                          ! .    (the scale factor s can not be czero,
                          ! .    because h(kbot,kbot-1) is nonzero.) ====
                          if( ks>=kbot ) then
                             s = cabs1( h( kbot-1, kbot-1 ) ) +cabs1( h( kbot, kbot-1 ) ) +cabs1( &
                                       h( kbot-1, kbot ) ) +cabs1( h( kbot, kbot ) )
                             aa = h( kbot-1, kbot-1 ) / s
                             cc = h( kbot, kbot-1 ) / s
                             bb = h( kbot-1, kbot ) / s
                             dd = h( kbot, kbot ) / s
                             tr2 = ( aa+dd ) / two
                             det = ( aa-tr2 )*( dd-tr2 ) - bb*cc
                             rtdisc = sqrt( -det )
                             w( kbot-1 ) = ( tr2+rtdisc )*s
                             w( kbot ) = ( tr2-rtdisc )*s
                             ks = kbot - 1
                          end if
                       end if
                       if( kbot-ks+1>ns ) then
                          ! ==== sort the shifts (helps a little) ====
                          sorted = .false.
                          do k = kbot, ks + 1, -1
                             if( sorted )go to 60
                             sorted = .true.
                             do i = ks, k - 1
                                if( cabs1( w( i ) )<cabs1( w( i+1 ) ) )then
                                   sorted = .false.
                                   swap = w( i )
                                   w( i ) = w( i+1 )
                                   w( i+1 ) = swap
                                end if
                             end do
                          end do
                          60 continue
                       end if
                    end if
                    ! ==== if there are only two shifts, then use
                    ! .    only cone.  ====
                    if( kbot-ks+1==2 ) then
                       if( cabs1( w( kbot )-h( kbot, kbot ) )<cabs1( w( kbot-1 )-h( kbot, kbot ) )&
                                  ) then
                          w( kbot-1 ) = w( kbot )
                       else
                          w( kbot ) = w( kbot-1 )
                       end if
                    end if
                    ! ==== use up to ns of the the smallest magnitude
                    ! .    shifts.  if there aren't ns shifts available,
                    ! .    then use them all, possibly dropping cone to
                    ! .    make the number of shifts even. ====
                    ns = min( ns, kbot-ks+1 )
                    ns = ns - mod( ns, 2 )
                    ks = kbot - ns + 1
                    ! ==== small-bulge multi-shift qr sweep:
                    ! .    split workspace under the subdiagonal into
                    ! .    - a kdu-by-kdu work array u in the lower
                    ! .      left-hand-corner,
                    ! .    - a kdu-by-at-least-kdu-but-more-is-better
                    ! .      (kdu-by-nho) horizontal work array wh along
                    ! .      the bottom edge,
                    ! .    - and an at-least-kdu-but-more-is-better-by-kdu
                    ! .      (nve-by-kdu) vertical work wv arrow along
                    ! .      the left-hand-edge. ====
                    kdu = 2*ns
                    ku = n - kdu + 1
                    kwh = kdu + 1
                    nho = ( n-kdu+1-4 ) - ( kdu+1 ) + 1
                    kwv = kdu + 4
                    nve = n - kdu - kwv + 1
                    ! ==== small-bulge multi-shift qr sweep ====
                    call stdlib_claqr5( wantt, wantz, kacc22, n, ktop, kbot, ns,w( ks ), h, ldh, &
                    iloz, ihiz, z, ldz, work,3, h( ku, 1 ), ldh, nve, h( kwv, 1 ), ldh,nho, h( ku,&
                               kwh ), ldh )
                 end if
                 ! ==== note progress (or the lack of it). ====
                 if( ld>0 ) then
                    ndfl = 1
                 else
                    ndfl = ndfl + 1
                 end if
                 ! ==== end of main loop ====
              end do loop_70
              ! ==== iteration limit exceeded.  set info to show where
              ! .    the problem occurred and exit. ====
              info = kbot
              80 continue
           end if
           ! ==== return the optimal value of lwork. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
     end subroutine stdlib_claqr4

     pure subroutine stdlib_zlaqr4( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, work,lwork, info )
     !! ZLAQR4 implements one level of recursion for ZLAQR0.
     !! It is a complete implementation of the small bulge multi-shift
     !! QR algorithm.  It may be called by ZLAQR0 and, for large enough
     !! deflation window size, it may be called by ZLAQR3.  This
     !! subroutine is identical to ZLAQR0 except that it calls ZLAQR2
     !! instead of ZLAQR3.
     !! ZLAQR4 computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**H, where T is an upper triangular matrix (the
     !! Schur form), and Z is the unitary matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input unitary
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
                
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(dp), intent(out) :: w(*), work(*)
        ! ================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: kexnw = 5
           integer(ilp), parameter :: kexsh = 6
           real(dp), parameter :: wilk1 = 0.75_dp
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_zlahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== exceptional deflation windows:  try to cure rare
           ! .    slow convergence by varying the size of the
           ! .    deflation window after kexnw iterations. ====
           
           ! ==== exceptional shifts: try to cure rare slow convergence
           ! .    with ad-hoc exceptional shifts every kexsh iterations.
           ! .    ====
           
           ! ==== the constant wilk1 is used to form the exceptional
           ! .    shifts. ====
           
           
           
           ! Local Scalars 
           complex(dp) :: aa, bb, cc, cdum, dd, det, rtdisc, swap, tr2
           real(dp) :: s
           integer(ilp) :: i, inf, it, itmax, k, kacc22, kbot, kdu, ks, kt, ktop, ku, kv, kwh, &
           kwtop, kwv, ld, ls, lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns, nsmax, nsr, nve, nw,&
                      nwmax, nwr, nwupbd
           logical(lk) :: sorted
           character :: jbcmpz*2
           ! Local Arrays 
           complex(dp) :: zdum(1,1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! ==== quick return for n = 0: nothing to do. ====
           if( n==0 ) then
              work( 1 ) = cone
              return
           end if
           if( n<=ntiny ) then
              ! ==== tiny matrices must use stdlib_zlahqr. ====
              lwkopt = 1
              if( lwork/=-1 )call stdlib_zlahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, &
                        z, ldz, info )
           else
              ! ==== use small bulge multi-shift qr with aggressive early
              ! .    deflation on larger-than-tiny matrices. ====
              ! ==== hope for the best. ====
              info = 0
              ! ==== set up job flags for stdlib_ilaenv. ====
              if( wantt ) then
                 jbcmpz( 1: 1 ) = 'S'
              else
                 jbcmpz( 1: 1 ) = 'E'
              end if
              if( wantz ) then
                 jbcmpz( 2: 2 ) = 'V'
              else
                 jbcmpz( 2: 2 ) = 'N'
              end if
              ! ==== nwr = recommended deflation window size.  at this
              ! .    point,  n > ntiny = 15, so there is enough
              ! .    subdiagonal workspace for nwr>=2 as required.
              ! .    (in fact, there is enough subdiagonal space for
              ! .    nwr>=4.) ====
              nwr = stdlib_ilaenv( 13, 'ZLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nwr = max( 2, nwr )
              nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
              ! ==== nsr = recommended number of simultaneous shifts.
              ! .    at this point n > ntiny = 15, so there is at
              ! .    enough subdiagonal workspace for nsr to be even
              ! .    and greater than or equal to two as required. ====
              nsr = stdlib_ilaenv( 15, 'ZLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nsr = min( nsr, ( n-3 ) / 6, ihi-ilo )
              nsr = max( 2, nsr-mod( nsr, 2 ) )
              ! ==== estimate optimal workspace ====
              ! ==== workspace query call to stdlib_zlaqr2 ====
              call stdlib_zlaqr2( wantt, wantz, n, ilo, ihi, nwr+1, h, ldh, iloz,ihiz, z, ldz, ls,&
                         ld, w, h, ldh, n, h, ldh, n, h,ldh, work, -1 )
              ! ==== optimal workspace = max(stdlib_zlaqr5, stdlib_zlaqr2) ====
              lwkopt = max( 3*nsr / 2, int( work( 1 ),KIND=ilp) )
              ! ==== quick return in case of workspace query. ====
              if( lwork==-1 ) then
                 work( 1 ) = cmplx( lwkopt, 0,KIND=dp)
                 return
              end if
              ! ==== stdlib_zlahqr/stdlib_zlaqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'ZLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nmin = max( ntiny, nmin )
              ! ==== nibble crossover point ====
              nibble = stdlib_ilaenv( 14, 'ZLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nibble = max( 0, nibble )
              ! ==== accumulate reflections during ttswp?  use block
              ! .    2-by-2 structure during matrix-matrix multiply? ====
              kacc22 = stdlib_ilaenv( 16, 'ZLAQR4', jbcmpz, n, ilo, ihi, lwork )
              kacc22 = max( 0, kacc22 )
              kacc22 = min( 2, kacc22 )
              ! ==== nwmax = the largest possible deflation window for
              ! .    which there is sufficient workspace. ====
              nwmax = min( ( n-1 ) / 3, lwork / 2 )
              nw = nwmax
              ! ==== nsmax = the largest number of simultaneous shifts
              ! .    for which there is sufficient workspace. ====
              nsmax = min( ( n-3 ) / 6, 2*lwork / 3 )
              nsmax = nsmax - mod( nsmax, 2 )
              ! ==== ndfl: an iteration count restarted at deflation. ====
              ndfl = 1
              ! ==== itmax = iteration limit ====
              itmax = max( 30, 2*kexsh )*max( 10, ( ihi-ilo+1 ) )
              ! ==== last row and column in the active block ====
              kbot = ihi
              ! ==== main loop ====
              loop_70: do it = 1, itmax
                 ! ==== done when kbot falls below ilo ====
                 if( kbot<ilo )go to 80
                 ! ==== locate active block ====
                 do k = kbot, ilo + 1, -1
                    if( h( k, k-1 )==czero )go to 20
                 end do
                 k = ilo
                 20 continue
                 ktop = k
                 ! ==== select deflation window size:
                 ! .    typical case:
                 ! .      if possible and advisable, nibble the entire
                 ! .      active block.  if not, use size min(nwr,nwmax)
                 ! .      or min(nwr+1,nwmax) depending upon which has
                 ! .      the smaller corresponding subdiagonal entry
                 ! .      (a heuristic).
                 ! .    exceptional case:
                 ! .      if there have been no deflations in kexnw or
                 ! .      more iterations, then vary the deflation window
                 ! .      size.   at first, because, larger windows are,
                 ! .      in general, more powerful than smaller ones,
                 ! .      rapidly increase the window to the maximum possible.
                 ! .      then, gradually reduce the window size. ====
                 nh = kbot - ktop + 1
                 nwupbd = min( nh, nwmax )
                 if( ndfl<kexnw ) then
                    nw = min( nwupbd, nwr )
                 else
                    nw = min( nwupbd, 2*nw )
                 end if
                 if( nw<nwmax ) then
                    if( nw>=nh-1 ) then
                       nw = nh
                    else
                       kwtop = kbot - nw + 1
                       if( cabs1( h( kwtop, kwtop-1 ) )>cabs1( h( kwtop-1, kwtop-2 ) ) )nw = nw + &
                                 1
                    end if
                 end if
                 if( ndfl<kexnw ) then
                    ndec = -1
                 else if( ndec>=0 .or. nw>=nwupbd ) then
                    ndec = ndec + 1
                    if( nw-ndec<2 )ndec = 0
                    nw = nw - ndec
                 end if
                 ! ==== aggressive early deflation:
                 ! .    split workspace under the subdiagonal into
                 ! .      - an nw-by-nw work array v in the lower
                 ! .        left-hand-corner,
                 ! .      - an nw-by-at-least-nw-but-more-is-better
                 ! .        (nw-by-nho) horizontal work array along
                 ! .        the bottom edge,
                 ! .      - an at-least-nw-but-more-is-better (nhv-by-nw)
                 ! .        vertical work array along the left-hand-edge.
                 ! .        ====
                 kv = n - nw + 1
                 kt = nw + 1
                 nho = ( n-nw-1 ) - kt + 1
                 kwv = nw + 2
                 nve = ( n-nw ) - kwv + 1
                 ! ==== aggressive early deflation ====
                 call stdlib_zlaqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
                 ls, ld, w, h( kv, 1 ), ldh, nho,h( kv, kt ), ldh, nve, h( kwv, 1 ), ldh, work,&
                           lwork )
                 ! ==== adjust kbot accounting for new deflations. ====
                 kbot = kbot - ld
                 ! ==== ks points to the shifts. ====
                 ks = kbot - ls + 1
                 ! ==== skip an expensive qr sweep if there is a (partly
                 ! .    heuristic) reason to expect that many eigenvalues
                 ! .    will deflate without it.  here, the qr sweep is
                 ! .    skipped if many eigenvalues have just been deflated
                 ! .    or if the remaining active block is small.
                 if( ( ld==0 ) .or. ( ( 100*ld<=nw*nibble ) .and. ( kbot-ktop+1>min( nmin, nwmax )&
                            ) ) ) then
                    ! ==== ns = nominal number of simultaneous shifts.
                    ! .    this may be lowered (slightly) if stdlib_zlaqr2
                    ! .    did not provide that many shifts. ====
                    ns = min( nsmax, nsr, max( 2, kbot-ktop ) )
                    ns = ns - mod( ns, 2 )
                    ! ==== if there have been no deflations
                    ! .    in a multiple of kexsh iterations,
                    ! .    then try exceptional shifts.
                    ! .    otherwise use shifts provided by
                    ! .    stdlib_zlaqr2 above or from the eigenvalues
                    ! .    of a trailing principal submatrix. ====
                    if( mod( ndfl, kexsh )==0 ) then
                       ks = kbot - ns + 1
                       do i = kbot, ks + 1, -2
                          w( i ) = h( i, i ) + wilk1*cabs1( h( i, i-1 ) )
                          w( i-1 ) = w( i )
                       end do
                    else
                       ! ==== got ns/2 or fewer shifts? use stdlib_zlahqr
                       ! .    on a trailing principal submatrix to
                       ! .    get more. (since ns<=nsmax<=(n-3)/6,
                       ! .    there is enough space below the subdiagonal
                       ! .    to fit an ns-by-ns scratch array.) ====
                       if( kbot-ks+1<=ns / 2 ) then
                          ks = kbot - ns + 1
                          kt = n - ns + 1
                          call stdlib_zlacpy( 'A', ns, ns, h( ks, ks ), ldh,h( kt, 1 ), ldh )
                                    
                          call stdlib_zlahqr( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, w( ks )&
                                    , 1, 1, zdum,1, inf )
                          ks = ks + inf
                          ! ==== in case of a rare qr failure use
                          ! .    eigenvalues of the trailing 2-by-2
                          ! .    principal submatrix.  scale to avoid
                          ! .    overflows, underflows and subnormals.
                          ! .    (the scale factor s can not be czero,
                          ! .    because h(kbot,kbot-1) is nonzero.) ====
                          if( ks>=kbot ) then
                             s = cabs1( h( kbot-1, kbot-1 ) ) +cabs1( h( kbot, kbot-1 ) ) +cabs1( &
                                       h( kbot-1, kbot ) ) +cabs1( h( kbot, kbot ) )
                             aa = h( kbot-1, kbot-1 ) / s
                             cc = h( kbot, kbot-1 ) / s
                             bb = h( kbot-1, kbot ) / s
                             dd = h( kbot, kbot ) / s
                             tr2 = ( aa+dd ) / two
                             det = ( aa-tr2 )*( dd-tr2 ) - bb*cc
                             rtdisc = sqrt( -det )
                             w( kbot-1 ) = ( tr2+rtdisc )*s
                             w( kbot ) = ( tr2-rtdisc )*s
                             ks = kbot - 1
                          end if
                       end if
                       if( kbot-ks+1>ns ) then
                          ! ==== sort the shifts (helps a little) ====
                          sorted = .false.
                          do k = kbot, ks + 1, -1
                             if( sorted )go to 60
                             sorted = .true.
                             do i = ks, k - 1
                                if( cabs1( w( i ) )<cabs1( w( i+1 ) ) )then
                                   sorted = .false.
                                   swap = w( i )
                                   w( i ) = w( i+1 )
                                   w( i+1 ) = swap
                                end if
                             end do
                          end do
                          60 continue
                       end if
                    end if
                    ! ==== if there are only two shifts, then use
                    ! .    only cone.  ====
                    if( kbot-ks+1==2 ) then
                       if( cabs1( w( kbot )-h( kbot, kbot ) )<cabs1( w( kbot-1 )-h( kbot, kbot ) )&
                                  ) then
                          w( kbot-1 ) = w( kbot )
                       else
                          w( kbot ) = w( kbot-1 )
                       end if
                    end if
                    ! ==== use up to ns of the the smallest magnitude
                    ! .    shifts.  if there aren't ns shifts available,
                    ! .    then use them all, possibly dropping cone to
                    ! .    make the number of shifts even. ====
                    ns = min( ns, kbot-ks+1 )
                    ns = ns - mod( ns, 2 )
                    ks = kbot - ns + 1
                    ! ==== small-bulge multi-shift qr sweep:
                    ! .    split workspace under the subdiagonal into
                    ! .    - a kdu-by-kdu work array u in the lower
                    ! .      left-hand-corner,
                    ! .    - a kdu-by-at-least-kdu-but-more-is-better
                    ! .      (kdu-by-nho) horizontal work array wh along
                    ! .      the bottom edge,
                    ! .    - and an at-least-kdu-but-more-is-better-by-kdu
                    ! .      (nve-by-kdu) vertical work wv arrow along
                    ! .      the left-hand-edge. ====
                    kdu = 2*ns
                    ku = n - kdu + 1
                    kwh = kdu + 1
                    nho = ( n-kdu+1-4 ) - ( kdu+1 ) + 1
                    kwv = kdu + 4
                    nve = n - kdu - kwv + 1
                    ! ==== small-bulge multi-shift qr sweep ====
                    call stdlib_zlaqr5( wantt, wantz, kacc22, n, ktop, kbot, ns,w( ks ), h, ldh, &
                    iloz, ihiz, z, ldz, work,3, h( ku, 1 ), ldh, nve, h( kwv, 1 ), ldh,nho, h( ku,&
                               kwh ), ldh )
                 end if
                 ! ==== note progress (or the lack of it). ====
                 if( ld>0 ) then
                    ndfl = 1
                 else
                    ndfl = ndfl + 1
                 end if
                 ! ==== end of main loop ====
              end do loop_70
              ! ==== iteration limit exceeded.  set info to show where
              ! .    the problem occurred and exit. ====
              info = kbot
              80 continue
           end if
           ! ==== return the optimal value of lwork. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=dp)
     end subroutine stdlib_zlaqr4

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$laqr4( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, work, lwork, info )
     !! ZLAQR4: implements one level of recursion for ZLAQR0.
     !! It is a complete implementation of the small bulge multi-shift
     !! QR algorithm.  It may be called by ZLAQR0 and, for large enough
     !! deflation window size, it may be called by ZLAQR3.  This
     !! subroutine is identical to ZLAQR0 except that it calls ZLAQR2
     !! instead of ZLAQR3.
     !! ZLAQR4 computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**H, where T is an upper triangular matrix (the
     !! Schur form), and Z is the unitary matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input unitary
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
                
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(${ck}$), intent(out) :: w(*), work(*)
        ! ================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: kexnw = 5
           integer(ilp), parameter :: kexsh = 6
           real(${ck}$), parameter :: wilk1 = 0.75_${ck}$
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_${ci}$lahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== exceptional deflation windows:  try to cure rare
           ! .    slow convergence by varying the size of the
           ! .    deflation window after kexnw iterations. ====
           
           ! ==== exceptional shifts: try to cure rare slow convergence
           ! .    with ad-hoc exceptional shifts every kexsh iterations.
           ! .    ====
           
           ! ==== the constant wilk1 is used to form the exceptional
           ! .    shifts. ====
           
           
           
           ! Local Scalars 
           complex(${ck}$) :: aa, bb, cc, cdum, dd, det, rtdisc, swap, tr2
           real(${ck}$) :: s
           integer(ilp) :: i, inf, it, itmax, k, kacc22, kbot, kdu, ks, kt, ktop, ku, kv, kwh, &
           kwtop, kwv, ld, ls, lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns, nsmax, nsr, nve, nw,&
                      nwmax, nwr, nwupbd
           logical(lk) :: sorted
           character :: jbcmpz*2
           ! Local Arrays 
           complex(${ck}$) :: zdum(1,1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! ==== quick return for n = 0: nothing to do. ====
           if( n==0 ) then
              work( 1 ) = cone
              return
           end if
           if( n<=ntiny ) then
              ! ==== tiny matrices must use stdlib_${ci}$lahqr. ====
              lwkopt = 1
              if( lwork/=-1 )call stdlib_${ci}$lahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, &
                        z, ldz, info )
           else
              ! ==== use small bulge multi-shift qr with aggressive early
              ! .    deflation on larger-than-tiny matrices. ====
              ! ==== hope for the best. ====
              info = 0
              ! ==== set up job flags for stdlib_ilaenv. ====
              if( wantt ) then
                 jbcmpz( 1: 1 ) = 'S'
              else
                 jbcmpz( 1: 1 ) = 'E'
              end if
              if( wantz ) then
                 jbcmpz( 2: 2 ) = 'V'
              else
                 jbcmpz( 2: 2 ) = 'N'
              end if
              ! ==== nwr = recommended deflation window size.  at this
              ! .    point,  n > ntiny = 15, so there is enough
              ! .    subdiagonal workspace for nwr>=2 as required.
              ! .    (in fact, there is enough subdiagonal space for
              ! .    nwr>=4.) ====
              nwr = stdlib_ilaenv( 13, 'ZLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nwr = max( 2, nwr )
              nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
              ! ==== nsr = recommended number of simultaneous shifts.
              ! .    at this point n > ntiny = 15, so there is at
              ! .    enough subdiagonal workspace for nsr to be even
              ! .    and greater than or equal to two as required. ====
              nsr = stdlib_ilaenv( 15, 'ZLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nsr = min( nsr, ( n-3 ) / 6, ihi-ilo )
              nsr = max( 2, nsr-mod( nsr, 2 ) )
              ! ==== estimate optimal workspace ====
              ! ==== workspace query call to stdlib_${ci}$laqr2 ====
              call stdlib_${ci}$laqr2( wantt, wantz, n, ilo, ihi, nwr+1, h, ldh, iloz,ihiz, z, ldz, ls,&
                         ld, w, h, ldh, n, h, ldh, n, h,ldh, work, -1 )
              ! ==== optimal workspace = max(stdlib_${ci}$laqr5, stdlib_${ci}$laqr2) ====
              lwkopt = max( 3*nsr / 2, int( work( 1 ),KIND=ilp) )
              ! ==== quick return in case of workspace query. ====
              if( lwork==-1 ) then
                 work( 1 ) = cmplx( lwkopt, 0,KIND=${ck}$)
                 return
              end if
              ! ==== stdlib_${ci}$lahqr/stdlib_${ci}$laqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'ZLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nmin = max( ntiny, nmin )
              ! ==== nibble crossover point ====
              nibble = stdlib_ilaenv( 14, 'ZLAQR4', jbcmpz, n, ilo, ihi, lwork )
              nibble = max( 0, nibble )
              ! ==== accumulate reflections during ttswp?  use block
              ! .    2-by-2 structure during matrix-matrix multiply? ====
              kacc22 = stdlib_ilaenv( 16, 'ZLAQR4', jbcmpz, n, ilo, ihi, lwork )
              kacc22 = max( 0, kacc22 )
              kacc22 = min( 2, kacc22 )
              ! ==== nwmax = the largest possible deflation window for
              ! .    which there is sufficient workspace. ====
              nwmax = min( ( n-1 ) / 3, lwork / 2 )
              nw = nwmax
              ! ==== nsmax = the largest number of simultaneous shifts
              ! .    for which there is sufficient workspace. ====
              nsmax = min( ( n-3 ) / 6, 2*lwork / 3 )
              nsmax = nsmax - mod( nsmax, 2 )
              ! ==== ndfl: an iteration count restarted at deflation. ====
              ndfl = 1
              ! ==== itmax = iteration limit ====
              itmax = max( 30, 2*kexsh )*max( 10, ( ihi-ilo+1 ) )
              ! ==== last row and column in the active block ====
              kbot = ihi
              ! ==== main loop ====
              loop_70: do it = 1, itmax
                 ! ==== done when kbot falls below ilo ====
                 if( kbot<ilo )go to 80
                 ! ==== locate active block ====
                 do k = kbot, ilo + 1, -1
                    if( h( k, k-1 )==czero )go to 20
                 end do
                 k = ilo
                 20 continue
                 ktop = k
                 ! ==== select deflation window size:
                 ! .    typical case:
                 ! .      if possible and advisable, nibble the entire
                 ! .      active block.  if not, use size min(nwr,nwmax)
                 ! .      or min(nwr+1,nwmax) depending upon which has
                 ! .      the smaller corresponding subdiagonal entry
                 ! .      (a heuristic).
                 ! .    exceptional case:
                 ! .      if there have been no deflations in kexnw or
                 ! .      more iterations, then vary the deflation window
                 ! .      size.   at first, because, larger windows are,
                 ! .      in general, more powerful than smaller ones,
                 ! .      rapidly increase the window to the maximum possible.
                 ! .      then, gradually reduce the window size. ====
                 nh = kbot - ktop + 1
                 nwupbd = min( nh, nwmax )
                 if( ndfl<kexnw ) then
                    nw = min( nwupbd, nwr )
                 else
                    nw = min( nwupbd, 2*nw )
                 end if
                 if( nw<nwmax ) then
                    if( nw>=nh-1 ) then
                       nw = nh
                    else
                       kwtop = kbot - nw + 1
                       if( cabs1( h( kwtop, kwtop-1 ) )>cabs1( h( kwtop-1, kwtop-2 ) ) )nw = nw + &
                                 1
                    end if
                 end if
                 if( ndfl<kexnw ) then
                    ndec = -1
                 else if( ndec>=0 .or. nw>=nwupbd ) then
                    ndec = ndec + 1
                    if( nw-ndec<2 )ndec = 0
                    nw = nw - ndec
                 end if
                 ! ==== aggressive early deflation:
                 ! .    split workspace under the subdiagonal into
                 ! .      - an nw-by-nw work array v in the lower
                 ! .        left-hand-corner,
                 ! .      - an nw-by-at-least-nw-but-more-is-better
                 ! .        (nw-by-nho) horizontal work array along
                 ! .        the bottom edge,
                 ! .      - an at-least-nw-but-more-is-better (nhv-by-nw)
                 ! .        vertical work array along the left-hand-edge.
                 ! .        ====
                 kv = n - nw + 1
                 kt = nw + 1
                 nho = ( n-nw-1 ) - kt + 1
                 kwv = nw + 2
                 nve = ( n-nw ) - kwv + 1
                 ! ==== aggressive early deflation ====
                 call stdlib_${ci}$laqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
                 ls, ld, w, h( kv, 1 ), ldh, nho,h( kv, kt ), ldh, nve, h( kwv, 1 ), ldh, work,&
                           lwork )
                 ! ==== adjust kbot accounting for new deflations. ====
                 kbot = kbot - ld
                 ! ==== ks points to the shifts. ====
                 ks = kbot - ls + 1
                 ! ==== skip an expensive qr sweep if there is a (partly
                 ! .    heuristic) reason to expect that many eigenvalues
                 ! .    will deflate without it.  here, the qr sweep is
                 ! .    skipped if many eigenvalues have just been deflated
                 ! .    or if the remaining active block is small.
                 if( ( ld==0 ) .or. ( ( 100*ld<=nw*nibble ) .and. ( kbot-ktop+1>min( nmin, nwmax )&
                            ) ) ) then
                    ! ==== ns = nominal number of simultaneous shifts.
                    ! .    this may be lowered (slightly) if stdlib_${ci}$laqr2
                    ! .    did not provide that many shifts. ====
                    ns = min( nsmax, nsr, max( 2, kbot-ktop ) )
                    ns = ns - mod( ns, 2 )
                    ! ==== if there have been no deflations
                    ! .    in a multiple of kexsh iterations,
                    ! .    then try exceptional shifts.
                    ! .    otherwise use shifts provided by
                    ! .    stdlib_${ci}$laqr2 above or from the eigenvalues
                    ! .    of a trailing principal submatrix. ====
                    if( mod( ndfl, kexsh )==0 ) then
                       ks = kbot - ns + 1
                       do i = kbot, ks + 1, -2
                          w( i ) = h( i, i ) + wilk1*cabs1( h( i, i-1 ) )
                          w( i-1 ) = w( i )
                       end do
                    else
                       ! ==== got ns/2 or fewer shifts? use stdlib_${ci}$lahqr
                       ! .    on a trailing principal submatrix to
                       ! .    get more. (since ns<=nsmax<=(n-3)/6,
                       ! .    there is enough space below the subdiagonal
                       ! .    to fit an ns-by-ns scratch array.) ====
                       if( kbot-ks+1<=ns / 2 ) then
                          ks = kbot - ns + 1
                          kt = n - ns + 1
                          call stdlib_${ci}$lacpy( 'A', ns, ns, h( ks, ks ), ldh,h( kt, 1 ), ldh )
                                    
                          call stdlib_${ci}$lahqr( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, w( ks )&
                                    , 1, 1, zdum,1, inf )
                          ks = ks + inf
                          ! ==== in case of a rare qr failure use
                          ! .    eigenvalues of the trailing 2-by-2
                          ! .    principal submatrix.  scale to avoid
                          ! .    overflows, underflows and subnormals.
                          ! .    (the scale factor s can not be czero,
                          ! .    because h(kbot,kbot-1) is nonzero.) ====
                          if( ks>=kbot ) then
                             s = cabs1( h( kbot-1, kbot-1 ) ) +cabs1( h( kbot, kbot-1 ) ) +cabs1( &
                                       h( kbot-1, kbot ) ) +cabs1( h( kbot, kbot ) )
                             aa = h( kbot-1, kbot-1 ) / s
                             cc = h( kbot, kbot-1 ) / s
                             bb = h( kbot-1, kbot ) / s
                             dd = h( kbot, kbot ) / s
                             tr2 = ( aa+dd ) / two
                             det = ( aa-tr2 )*( dd-tr2 ) - bb*cc
                             rtdisc = sqrt( -det )
                             w( kbot-1 ) = ( tr2+rtdisc )*s
                             w( kbot ) = ( tr2-rtdisc )*s
                             ks = kbot - 1
                          end if
                       end if
                       if( kbot-ks+1>ns ) then
                          ! ==== sort the shifts (helps a little) ====
                          sorted = .false.
                          do k = kbot, ks + 1, -1
                             if( sorted )go to 60
                             sorted = .true.
                             do i = ks, k - 1
                                if( cabs1( w( i ) )<cabs1( w( i+1 ) ) )then
                                   sorted = .false.
                                   swap = w( i )
                                   w( i ) = w( i+1 )
                                   w( i+1 ) = swap
                                end if
                             end do
                          end do
                          60 continue
                       end if
                    end if
                    ! ==== if there are only two shifts, then use
                    ! .    only cone.  ====
                    if( kbot-ks+1==2 ) then
                       if( cabs1( w( kbot )-h( kbot, kbot ) )<cabs1( w( kbot-1 )-h( kbot, kbot ) )&
                                  ) then
                          w( kbot-1 ) = w( kbot )
                       else
                          w( kbot ) = w( kbot-1 )
                       end if
                    end if
                    ! ==== use up to ns of the the smallest magnitude
                    ! .    shifts.  if there aren't ns shifts available,
                    ! .    then use them all, possibly dropping cone to
                    ! .    make the number of shifts even. ====
                    ns = min( ns, kbot-ks+1 )
                    ns = ns - mod( ns, 2 )
                    ks = kbot - ns + 1
                    ! ==== small-bulge multi-shift qr sweep:
                    ! .    split workspace under the subdiagonal into
                    ! .    - a kdu-by-kdu work array u in the lower
                    ! .      left-hand-corner,
                    ! .    - a kdu-by-at-least-kdu-but-more-is-better
                    ! .      (kdu-by-nho) horizontal work array wh along
                    ! .      the bottom edge,
                    ! .    - and an at-least-kdu-but-more-is-better-by-kdu
                    ! .      (nve-by-kdu) vertical work wv arrow along
                    ! .      the left-hand-edge. ====
                    kdu = 2*ns
                    ku = n - kdu + 1
                    kwh = kdu + 1
                    nho = ( n-kdu+1-4 ) - ( kdu+1 ) + 1
                    kwv = kdu + 4
                    nve = n - kdu - kwv + 1
                    ! ==== small-bulge multi-shift qr sweep ====
                    call stdlib_${ci}$laqr5( wantt, wantz, kacc22, n, ktop, kbot, ns,w( ks ), h, ldh, &
                    iloz, ihiz, z, ldz, work,3, h( ku, 1 ), ldh, nve, h( kwv, 1 ), ldh,nho, h( ku,&
                               kwh ), ldh )
                 end if
                 ! ==== note progress (or the lack of it). ====
                 if( ld>0 ) then
                    ndfl = 1
                 else
                    ndfl = ndfl + 1
                 end if
                 ! ==== end of main loop ====
              end do loop_70
              ! ==== iteration limit exceeded.  set info to show where
              ! .    the problem occurred and exit. ====
              info = kbot
              80 continue
           end if
           ! ==== return the optimal value of lwork. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=${ck}$)
     end subroutine stdlib_${ci}$laqr4

#:endif
#:endfor



     pure subroutine stdlib_cunmhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, lwork, &
     !! CUNMHR overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! IHI-ILO elementary reflectors, as returned by CGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(in) :: ihi, ilo, lda, ldc, lwork, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, lquery
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, nh, ni, nq, nw
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           left = stdlib_lsame( side, 'L' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'C' ) )&
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 .or. ilo>max( 1, nq ) ) then
              info = -5
           else if( ihi<min( ilo, nq ) .or. ihi>nq ) then
              info = -6
           else if( lda<max( 1, nq ) ) then
              info = -8
           else if( ldc<max( 1, m ) ) then
              info = -11
           else if( lwork<nw .and. .not.lquery ) then
              info = -13
           end if
           if( info==0 ) then
              if( left ) then
                 nb = stdlib_ilaenv( 1, 'CUNMQR', side // trans, nh, n, nh, -1 )
              else
                 nb = stdlib_ilaenv( 1, 'CUNMQR', side // trans, m, nh, nh, -1 )
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNMHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. nh==0 ) then
              work( 1 ) = 1
              return
           end if
           if( left ) then
              mi = nh
              ni = n
              i1 = ilo + 1
              i2 = 1
           else
              mi = m
              ni = nh
              i1 = 1
              i2 = ilo + 1
           end if
           call stdlib_cunmqr( side, trans, mi, ni, nh, a( ilo+1, ilo ), lda,tau( ilo ), c( i1, &
                     i2 ), ldc, work, lwork, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cunmhr

     pure subroutine stdlib_zunmhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, lwork, &
     !! ZUNMHR overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! IHI-ILO elementary reflectors, as returned by ZGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(in) :: ihi, ilo, lda, ldc, lwork, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(dp), intent(in) :: tau(*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, lquery
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, nh, ni, nq, nw
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           left = stdlib_lsame( side, 'L' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'C' ) )&
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 .or. ilo>max( 1, nq ) ) then
              info = -5
           else if( ihi<min( ilo, nq ) .or. ihi>nq ) then
              info = -6
           else if( lda<max( 1, nq ) ) then
              info = -8
           else if( ldc<max( 1, m ) ) then
              info = -11
           else if( lwork<nw .and. .not.lquery ) then
              info = -13
           end if
           if( info==0 ) then
              if( left ) then
                 nb = stdlib_ilaenv( 1, 'ZUNMQR', side // trans, nh, n, nh, -1 )
              else
                 nb = stdlib_ilaenv( 1, 'ZUNMQR', side // trans, m, nh, nh, -1 )
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZUNMHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. nh==0 ) then
              work( 1 ) = 1
              return
           end if
           if( left ) then
              mi = nh
              ni = n
              i1 = ilo + 1
              i2 = 1
           else
              mi = m
              ni = nh
              i1 = 1
              i2 = ilo + 1
           end if
           call stdlib_zunmqr( side, trans, mi, ni, nh, a( ilo+1, ilo ), lda,tau( ilo ), c( i1, &
                     i2 ), ldc, work, lwork, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zunmhr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$unmhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, lwork, &
     !! ZUNMHR: overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! IHI-ILO elementary reflectors, as returned by ZGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(in) :: ihi, ilo, lda, ldc, lwork, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*), c(ldc,*)
           complex(${ck}$), intent(in) :: tau(*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, lquery
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, nh, ni, nq, nw
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           left = stdlib_lsame( side, 'L' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'C' ) )&
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 .or. ilo>max( 1, nq ) ) then
              info = -5
           else if( ihi<min( ilo, nq ) .or. ihi>nq ) then
              info = -6
           else if( lda<max( 1, nq ) ) then
              info = -8
           else if( ldc<max( 1, m ) ) then
              info = -11
           else if( lwork<nw .and. .not.lquery ) then
              info = -13
           end if
           if( info==0 ) then
              if( left ) then
                 nb = stdlib_ilaenv( 1, 'ZUNMQR', side // trans, nh, n, nh, -1 )
              else
                 nb = stdlib_ilaenv( 1, 'ZUNMQR', side // trans, m, nh, nh, -1 )
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZUNMHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. nh==0 ) then
              work( 1 ) = 1
              return
           end if
           if( left ) then
              mi = nh
              ni = n
              i1 = ilo + 1
              i2 = 1
           else
              mi = m
              ni = nh
              i1 = 1
              i2 = ilo + 1
           end if
           call stdlib_${ci}$unmqr( side, trans, mi, ni, nh, a( ilo+1, ilo ), lda,tau( ilo ), c( i1, &
                     i2 ), ldc, work, lwork, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$unmhr

#:endif
#:endfor



     pure subroutine stdlib_sgehd2( n, ilo, ihi, a, lda, tau, work, info )
     !! SGEHD2 reduces a real general matrix A to upper Hessenberg form H by
     !! an orthogonal similarity transformation:  Q**T * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(sp) :: aii
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGEHD2', -info )
              return
           end if
           do i = ilo, ihi - 1
              ! compute elementary reflector h(i) to annihilate a(i+2:ihi,i)
              call stdlib_slarfg( ihi-i, a( i+1, i ), a( min( i+2, n ), i ), 1,tau( i ) )
              aii = a( i+1, i )
              a( i+1, i ) = one
              ! apply h(i) to a(1:ihi,i+1:ihi) from the right
              call stdlib_slarf( 'RIGHT', ihi, ihi-i, a( i+1, i ), 1, tau( i ),a( 1, i+1 ), lda, &
                        work )
              ! apply h(i) to a(i+1:ihi,i+1:n) from the left
              call stdlib_slarf( 'LEFT', ihi-i, n-i, a( i+1, i ), 1, tau( i ),a( i+1, i+1 ), lda, &
                        work )
              a( i+1, i ) = aii
           end do
           return
     end subroutine stdlib_sgehd2

     pure subroutine stdlib_dgehd2( n, ilo, ihi, a, lda, tau, work, info )
     !! DGEHD2 reduces a real general matrix A to upper Hessenberg form H by
     !! an orthogonal similarity transformation:  Q**T * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(dp) :: aii
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEHD2', -info )
              return
           end if
           do i = ilo, ihi - 1
              ! compute elementary reflector h(i) to annihilate a(i+2:ihi,i)
              call stdlib_dlarfg( ihi-i, a( i+1, i ), a( min( i+2, n ), i ), 1,tau( i ) )
              aii = a( i+1, i )
              a( i+1, i ) = one
              ! apply h(i) to a(1:ihi,i+1:ihi) from the right
              call stdlib_dlarf( 'RIGHT', ihi, ihi-i, a( i+1, i ), 1, tau( i ),a( 1, i+1 ), lda, &
                        work )
              ! apply h(i) to a(i+1:ihi,i+1:n) from the left
              call stdlib_dlarf( 'LEFT', ihi-i, n-i, a( i+1, i ), 1, tau( i ),a( i+1, i+1 ), lda, &
                        work )
              a( i+1, i ) = aii
           end do
           return
     end subroutine stdlib_dgehd2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$gehd2( n, ilo, ihi, a, lda, tau, work, info )
     !! DGEHD2: reduces a real general matrix A to upper Hessenberg form H by
     !! an orthogonal similarity transformation:  Q**T * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(${rk}$) :: aii
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEHD2', -info )
              return
           end if
           do i = ilo, ihi - 1
              ! compute elementary reflector h(i) to annihilate a(i+2:ihi,i)
              call stdlib_${ri}$larfg( ihi-i, a( i+1, i ), a( min( i+2, n ), i ), 1,tau( i ) )
              aii = a( i+1, i )
              a( i+1, i ) = one
              ! apply h(i) to a(1:ihi,i+1:ihi) from the right
              call stdlib_${ri}$larf( 'RIGHT', ihi, ihi-i, a( i+1, i ), 1, tau( i ),a( 1, i+1 ), lda, &
                        work )
              ! apply h(i) to a(i+1:ihi,i+1:n) from the left
              call stdlib_${ri}$larf( 'LEFT', ihi-i, n-i, a( i+1, i ), 1, tau( i ),a( i+1, i+1 ), lda, &
                        work )
              a( i+1, i ) = aii
           end do
           return
     end subroutine stdlib_${ri}$gehd2

#:endif
#:endfor

     pure subroutine stdlib_cgehd2( n, ilo, ihi, a, lda, tau, work, info )
     !! CGEHD2 reduces a complex general matrix A to upper Hessenberg form H
     !! by a unitary similarity transformation:  Q**H * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           complex(sp) :: alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEHD2', -info )
              return
           end if
           do i = ilo, ihi - 1
              ! compute elementary reflector h(i) to annihilate a(i+2:ihi,i)
              alpha = a( i+1, i )
              call stdlib_clarfg( ihi-i, alpha, a( min( i+2, n ), i ), 1, tau( i ) )
              a( i+1, i ) = cone
              ! apply h(i) to a(1:ihi,i+1:ihi) from the right
              call stdlib_clarf( 'RIGHT', ihi, ihi-i, a( i+1, i ), 1, tau( i ),a( 1, i+1 ), lda, &
                        work )
              ! apply h(i)**h to a(i+1:ihi,i+1:n) from the left
              call stdlib_clarf( 'LEFT', ihi-i, n-i, a( i+1, i ), 1,conjg( tau( i ) ), a( i+1, i+&
                        1 ), lda, work )
              a( i+1, i ) = alpha
           end do
           return
     end subroutine stdlib_cgehd2

     pure subroutine stdlib_zgehd2( n, ilo, ihi, a, lda, tau, work, info )
     !! ZGEHD2 reduces a complex general matrix A to upper Hessenberg form H
     !! by a unitary similarity transformation:  Q**H * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           complex(dp) :: alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEHD2', -info )
              return
           end if
           do i = ilo, ihi - 1
              ! compute elementary reflector h(i) to annihilate a(i+2:ihi,i)
              alpha = a( i+1, i )
              call stdlib_zlarfg( ihi-i, alpha, a( min( i+2, n ), i ), 1, tau( i ) )
              a( i+1, i ) = cone
              ! apply h(i) to a(1:ihi,i+1:ihi) from the right
              call stdlib_zlarf( 'RIGHT', ihi, ihi-i, a( i+1, i ), 1, tau( i ),a( 1, i+1 ), lda, &
                        work )
              ! apply h(i)**h to a(i+1:ihi,i+1:n) from the left
              call stdlib_zlarf( 'LEFT', ihi-i, n-i, a( i+1, i ), 1,conjg( tau( i ) ), a( i+1, i+&
                        1 ), lda, work )
              a( i+1, i ) = alpha
           end do
           return
     end subroutine stdlib_zgehd2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$gehd2( n, ilo, ihi, a, lda, tau, work, info )
     !! ZGEHD2: reduces a complex general matrix A to upper Hessenberg form H
     !! by a unitary similarity transformation:  Q**H * A * Q = H .
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           complex(${ck}$) :: alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEHD2', -info )
              return
           end if
           do i = ilo, ihi - 1
              ! compute elementary reflector h(i) to annihilate a(i+2:ihi,i)
              alpha = a( i+1, i )
              call stdlib_${ci}$larfg( ihi-i, alpha, a( min( i+2, n ), i ), 1, tau( i ) )
              a( i+1, i ) = cone
              ! apply h(i) to a(1:ihi,i+1:ihi) from the right
              call stdlib_${ci}$larf( 'RIGHT', ihi, ihi-i, a( i+1, i ), 1, tau( i ),a( 1, i+1 ), lda, &
                        work )
              ! apply h(i)**h to a(i+1:ihi,i+1:n) from the left
              call stdlib_${ci}$larf( 'LEFT', ihi-i, n-i, a( i+1, i ), 1,conjg( tau( i ) ), a( i+1, i+&
                        1 ), lda, work )
              a( i+1, i ) = alpha
           end do
           return
     end subroutine stdlib_${ci}$gehd2

#:endif
#:endfor





     pure subroutine stdlib_slahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
     !! SLAHR2 reduces the first NB columns of A real general n-BY-(n-k+1)
     !! matrix A so that elements below the k-th subdiagonal are zero. The
     !! reduction is performed by an orthogonal similarity transformation
     !! Q**T * A * Q. The routine returns the matrices V and T which determine
     !! Q as a block reflector I - V*T*V**T, and also the matrix Y = A * V * T.
     !! This is an auxiliary routine called by SGEHRD.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: k, lda, ldt, ldy, n, nb
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: t(ldt,nb), tau(nb), y(ldy,nb)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(sp) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=1 )return
           loop_10: do i = 1, nb
              if( i>1 ) then
                 ! update a(k+1:n,i)
                 ! update i-th column of a - y * v**t
                 call stdlib_sgemv( 'NO TRANSPOSE', n-k, i-1, -one, y(k+1,1), ldy,a( k+i-1, 1 ), &
                           lda, one, a( k+1, i ), 1 )
                 ! apply i - v * t**t * v**t to this column (call it b) from the
                 ! left, using the last column of t as workspace
                 ! let  v = ( v1 )   and   b = ( b1 )   (first i-1 rows)
                          ! ( v2 )             ( b2 )
                 ! where v1 is unit lower triangular
                 ! w := v1**t * b1
                 call stdlib_scopy( i-1, a( k+1, i ), 1, t( 1, nb ), 1 )
                 call stdlib_strmv( 'LOWER', 'TRANSPOSE', 'UNIT',i-1, a( k+1, 1 ),lda, t( 1, nb ),&
                            1 )
                 ! w := w + v2**t * b2
                 call stdlib_sgemv( 'TRANSPOSE', n-k-i+1, i-1,one, a( k+i, 1 ),lda, a( k+i, i ), &
                           1, one, t( 1, nb ), 1 )
                 ! w := t**t * w
                 call stdlib_strmv( 'UPPER', 'TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, nb ), 1 )
                           
                 ! b2 := b2 - v2*w
                 call stdlib_sgemv( 'NO TRANSPOSE', n-k-i+1, i-1, -one,a( k+i, 1 ),lda, t( 1, nb )&
                           , 1, one, a( k+i, i ), 1 )
                 ! b1 := b1 - v1*w
                 call stdlib_strmv( 'LOWER', 'NO TRANSPOSE','UNIT', i-1,a( k+1, 1 ), lda, t( 1, &
                           nb ), 1 )
                 call stdlib_saxpy( i-1, -one, t( 1, nb ), 1, a( k+1, i ), 1 )
                 a( k+i-1, i-1 ) = ei
              end if
              ! generate the elementary reflector h(i) to annihilate
              ! a(k+i+1:n,i)
              call stdlib_slarfg( n-k-i+1, a( k+i, i ), a( min( k+i+1, n ), i ), 1,tau( i ) )
                        
              ei = a( k+i, i )
              a( k+i, i ) = one
              ! compute  y(k+1:n,i)
              call stdlib_sgemv( 'NO TRANSPOSE', n-k, n-k-i+1,one, a( k+1, i+1 ),lda, a( k+i, i ),&
                         1, zero, y( k+1, i ), 1 )
              call stdlib_sgemv( 'TRANSPOSE', n-k-i+1, i-1,one, a( k+i, 1 ), lda,a( k+i, i ), 1, &
                        zero, t( 1, i ), 1 )
              call stdlib_sgemv( 'NO TRANSPOSE', n-k, i-1, -one,y( k+1, 1 ), ldy,t( 1, i ), 1, &
                        one, y( k+1, i ), 1 )
              call stdlib_sscal( n-k, tau( i ), y( k+1, i ), 1 )
              ! compute t(1:i,i)
              call stdlib_sscal( i-1, -tau( i ), t( 1, i ), 1 )
              call stdlib_strmv( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, i ), 1 )
                        
              t( i, i ) = tau( i )
           end do loop_10
           a( k+nb, nb ) = ei
           ! compute y(1:k,1:nb)
           call stdlib_slacpy( 'ALL', k, nb, a( 1, 2 ), lda, y, ldy )
           call stdlib_strmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE','UNIT', k, nb,one, a( k+1, 1 ), &
                     lda, y, ldy )
           if( n>k+nb )call stdlib_sgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', k,nb, n-k-nb, one,a( 1, &
                     2+nb ), lda, a( k+1+nb, 1 ), lda, one, y,ldy )
           call stdlib_strmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE','NON-UNIT', k, nb,one, t, ldt, y, &
                     ldy )
           return
     end subroutine stdlib_slahr2

     pure subroutine stdlib_dlahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
     !! DLAHR2 reduces the first NB columns of A real general n-BY-(n-k+1)
     !! matrix A so that elements below the k-th subdiagonal are zero. The
     !! reduction is performed by an orthogonal similarity transformation
     !! Q**T * A * Q. The routine returns the matrices V and T which determine
     !! Q as a block reflector I - V*T*V**T, and also the matrix Y = A * V * T.
     !! This is an auxiliary routine called by DGEHRD.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: k, lda, ldt, ldy, n, nb
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: t(ldt,nb), tau(nb), y(ldy,nb)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(dp) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=1 )return
           loop_10: do i = 1, nb
              if( i>1 ) then
                 ! update a(k+1:n,i)
                 ! update i-th column of a - y * v**t
                 call stdlib_dgemv( 'NO TRANSPOSE', n-k, i-1, -one, y(k+1,1), ldy,a( k+i-1, 1 ), &
                           lda, one, a( k+1, i ), 1 )
                 ! apply i - v * t**t * v**t to this column (call it b) from the
                 ! left, using the last column of t as workspace
                 ! let  v = ( v1 )   and   b = ( b1 )   (first i-1 rows)
                          ! ( v2 )             ( b2 )
                 ! where v1 is unit lower triangular
                 ! w := v1**t * b1
                 call stdlib_dcopy( i-1, a( k+1, i ), 1, t( 1, nb ), 1 )
                 call stdlib_dtrmv( 'LOWER', 'TRANSPOSE', 'UNIT',i-1, a( k+1, 1 ),lda, t( 1, nb ),&
                            1 )
                 ! w := w + v2**t * b2
                 call stdlib_dgemv( 'TRANSPOSE', n-k-i+1, i-1,one, a( k+i, 1 ),lda, a( k+i, i ), &
                           1, one, t( 1, nb ), 1 )
                 ! w := t**t * w
                 call stdlib_dtrmv( 'UPPER', 'TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, nb ), 1 )
                           
                 ! b2 := b2 - v2*w
                 call stdlib_dgemv( 'NO TRANSPOSE', n-k-i+1, i-1, -one,a( k+i, 1 ),lda, t( 1, nb )&
                           , 1, one, a( k+i, i ), 1 )
                 ! b1 := b1 - v1*w
                 call stdlib_dtrmv( 'LOWER', 'NO TRANSPOSE','UNIT', i-1,a( k+1, 1 ), lda, t( 1, &
                           nb ), 1 )
                 call stdlib_daxpy( i-1, -one, t( 1, nb ), 1, a( k+1, i ), 1 )
                 a( k+i-1, i-1 ) = ei
              end if
              ! generate the elementary reflector h(i) to annihilate
              ! a(k+i+1:n,i)
              call stdlib_dlarfg( n-k-i+1, a( k+i, i ), a( min( k+i+1, n ), i ), 1,tau( i ) )
                        
              ei = a( k+i, i )
              a( k+i, i ) = one
              ! compute  y(k+1:n,i)
              call stdlib_dgemv( 'NO TRANSPOSE', n-k, n-k-i+1,one, a( k+1, i+1 ),lda, a( k+i, i ),&
                         1, zero, y( k+1, i ), 1 )
              call stdlib_dgemv( 'TRANSPOSE', n-k-i+1, i-1,one, a( k+i, 1 ), lda,a( k+i, i ), 1, &
                        zero, t( 1, i ), 1 )
              call stdlib_dgemv( 'NO TRANSPOSE', n-k, i-1, -one,y( k+1, 1 ), ldy,t( 1, i ), 1, &
                        one, y( k+1, i ), 1 )
              call stdlib_dscal( n-k, tau( i ), y( k+1, i ), 1 )
              ! compute t(1:i,i)
              call stdlib_dscal( i-1, -tau( i ), t( 1, i ), 1 )
              call stdlib_dtrmv( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, i ), 1 )
                        
              t( i, i ) = tau( i )
           end do loop_10
           a( k+nb, nb ) = ei
           ! compute y(1:k,1:nb)
           call stdlib_dlacpy( 'ALL', k, nb, a( 1, 2 ), lda, y, ldy )
           call stdlib_dtrmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE','UNIT', k, nb,one, a( k+1, 1 ), &
                     lda, y, ldy )
           if( n>k+nb )call stdlib_dgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', k,nb, n-k-nb, one,a( 1, &
                     2+nb ), lda, a( k+1+nb, 1 ), lda, one, y,ldy )
           call stdlib_dtrmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE','NON-UNIT', k, nb,one, t, ldt, y, &
                     ldy )
           return
     end subroutine stdlib_dlahr2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$lahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
     !! DLAHR2: reduces the first NB columns of A real general n-BY-(n-k+1)
     !! matrix A so that elements below the k-th subdiagonal are zero. The
     !! reduction is performed by an orthogonal similarity transformation
     !! Q**T * A * Q. The routine returns the matrices V and T which determine
     !! Q as a block reflector I - V*T*V**T, and also the matrix Y = A * V * T.
     !! This is an auxiliary routine called by DGEHRD.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: k, lda, ldt, ldy, n, nb
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: t(ldt,nb), tau(nb), y(ldy,nb)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(${rk}$) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=1 )return
           loop_10: do i = 1, nb
              if( i>1 ) then
                 ! update a(k+1:n,i)
                 ! update i-th column of a - y * v**t
                 call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k, i-1, -one, y(k+1,1), ldy,a( k+i-1, 1 ), &
                           lda, one, a( k+1, i ), 1 )
                 ! apply i - v * t**t * v**t to this column (call it b) from the
                 ! left, using the last column of t as workspace
                 ! let  v = ( v1 )   and   b = ( b1 )   (first i-1 rows)
                          ! ( v2 )             ( b2 )
                 ! where v1 is unit lower triangular
                 ! w := v1**t * b1
                 call stdlib_${ri}$copy( i-1, a( k+1, i ), 1, t( 1, nb ), 1 )
                 call stdlib_${ri}$trmv( 'LOWER', 'TRANSPOSE', 'UNIT',i-1, a( k+1, 1 ),lda, t( 1, nb ),&
                            1 )
                 ! w := w + v2**t * b2
                 call stdlib_${ri}$gemv( 'TRANSPOSE', n-k-i+1, i-1,one, a( k+i, 1 ),lda, a( k+i, i ), &
                           1, one, t( 1, nb ), 1 )
                 ! w := t**t * w
                 call stdlib_${ri}$trmv( 'UPPER', 'TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, nb ), 1 )
                           
                 ! b2 := b2 - v2*w
                 call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k-i+1, i-1, -one,a( k+i, 1 ),lda, t( 1, nb )&
                           , 1, one, a( k+i, i ), 1 )
                 ! b1 := b1 - v1*w
                 call stdlib_${ri}$trmv( 'LOWER', 'NO TRANSPOSE','UNIT', i-1,a( k+1, 1 ), lda, t( 1, &
                           nb ), 1 )
                 call stdlib_${ri}$axpy( i-1, -one, t( 1, nb ), 1, a( k+1, i ), 1 )
                 a( k+i-1, i-1 ) = ei
              end if
              ! generate the elementary reflector h(i) to annihilate
              ! a(k+i+1:n,i)
              call stdlib_${ri}$larfg( n-k-i+1, a( k+i, i ), a( min( k+i+1, n ), i ), 1,tau( i ) )
                        
              ei = a( k+i, i )
              a( k+i, i ) = one
              ! compute  y(k+1:n,i)
              call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k, n-k-i+1,one, a( k+1, i+1 ),lda, a( k+i, i ),&
                         1, zero, y( k+1, i ), 1 )
              call stdlib_${ri}$gemv( 'TRANSPOSE', n-k-i+1, i-1,one, a( k+i, 1 ), lda,a( k+i, i ), 1, &
                        zero, t( 1, i ), 1 )
              call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k, i-1, -one,y( k+1, 1 ), ldy,t( 1, i ), 1, &
                        one, y( k+1, i ), 1 )
              call stdlib_${ri}$scal( n-k, tau( i ), y( k+1, i ), 1 )
              ! compute t(1:i,i)
              call stdlib_${ri}$scal( i-1, -tau( i ), t( 1, i ), 1 )
              call stdlib_${ri}$trmv( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, i ), 1 )
                        
              t( i, i ) = tau( i )
           end do loop_10
           a( k+nb, nb ) = ei
           ! compute y(1:k,1:nb)
           call stdlib_${ri}$lacpy( 'ALL', k, nb, a( 1, 2 ), lda, y, ldy )
           call stdlib_${ri}$trmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE','UNIT', k, nb,one, a( k+1, 1 ), &
                     lda, y, ldy )
           if( n>k+nb )call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', k,nb, n-k-nb, one,a( 1, &
                     2+nb ), lda, a( k+1+nb, 1 ), lda, one, y,ldy )
           call stdlib_${ri}$trmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE','NON-UNIT', k, nb,one, t, ldt, y, &
                     ldy )
           return
     end subroutine stdlib_${ri}$lahr2

#:endif
#:endfor

     pure subroutine stdlib_clahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
     !! CLAHR2 reduces the first NB columns of A complex general n-BY-(n-k+1)
     !! matrix A so that elements below the k-th subdiagonal are zero. The
     !! reduction is performed by an unitary similarity transformation
     !! Q**H * A * Q. The routine returns the matrices V and T which determine
     !! Q as a block reflector I - V*T*v**H, and also the matrix Y = A * V * T.
     !! This is an auxiliary routine called by CGEHRD.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: k, lda, ldt, ldy, n, nb
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: t(ldt,nb), tau(nb), y(ldy,nb)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           complex(sp) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=1 )return
           loop_10: do i = 1, nb
              if( i>1 ) then
                 ! update a(k+1:n,i)
                 ! update i-th column of a - y * v**h
                 call stdlib_clacgv( i-1, a( k+i-1, 1 ), lda )
                 call stdlib_cgemv( 'NO TRANSPOSE', n-k, i-1, -cone, y(k+1,1), ldy,a( k+i-1, 1 ), &
                           lda, cone, a( k+1, i ), 1 )
                 call stdlib_clacgv( i-1, a( k+i-1, 1 ), lda )
                 ! apply i - v * t**h * v**h to this column (call it b) from the
                 ! left, using the last column of t as workspace
                 ! let  v = ( v1 )   and   b = ( b1 )   (first i-1 rows)
                          ! ( v2 )             ( b2 )
                 ! where v1 is unit lower triangular
                 ! w := v1**h * b1
                 call stdlib_ccopy( i-1, a( k+1, i ), 1, t( 1, nb ), 1 )
                 call stdlib_ctrmv( 'LOWER', 'CONJUGATE TRANSPOSE', 'UNIT',i-1, a( k+1, 1 ),lda, &
                           t( 1, nb ), 1 )
                 ! w := w + v2**h * b2
                 call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k-i+1, i-1,cone, a( k+i, 1 ),lda, a( &
                           k+i, i ), 1, cone, t( 1, nb ), 1 )
                 ! w := t**h * w
                 call stdlib_ctrmv( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, &
                           nb ), 1 )
                 ! b2 := b2 - v2*w
                 call stdlib_cgemv( 'NO TRANSPOSE', n-k-i+1, i-1, -cone,a( k+i, 1 ),lda, t( 1, nb &
                           ), 1, cone, a( k+i, i ), 1 )
                 ! b1 := b1 - v1*w
                 call stdlib_ctrmv( 'LOWER', 'NO TRANSPOSE','UNIT', i-1,a( k+1, 1 ), lda, t( 1, &
                           nb ), 1 )
                 call stdlib_caxpy( i-1, -cone, t( 1, nb ), 1, a( k+1, i ), 1 )
                 a( k+i-1, i-1 ) = ei
              end if
              ! generate the elementary reflector h(i) to annihilate
              ! a(k+i+1:n,i)
              call stdlib_clarfg( n-k-i+1, a( k+i, i ), a( min( k+i+1, n ), i ), 1,tau( i ) )
                        
              ei = a( k+i, i )
              a( k+i, i ) = cone
              ! compute  y(k+1:n,i)
              call stdlib_cgemv( 'NO TRANSPOSE', n-k, n-k-i+1,cone, a( k+1, i+1 ),lda, a( k+i, i )&
                        , 1, czero, y( k+1, i ), 1 )
              call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k-i+1, i-1,cone, a( k+i, 1 ), lda,a( k+&
                        i, i ), 1, czero, t( 1, i ), 1 )
              call stdlib_cgemv( 'NO TRANSPOSE', n-k, i-1, -cone,y( k+1, 1 ), ldy,t( 1, i ), 1, &
                        cone, y( k+1, i ), 1 )
              call stdlib_cscal( n-k, tau( i ), y( k+1, i ), 1 )
              ! compute t(1:i,i)
              call stdlib_cscal( i-1, -tau( i ), t( 1, i ), 1 )
              call stdlib_ctrmv( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, i ), 1 )
                        
              t( i, i ) = tau( i )
           end do loop_10
           a( k+nb, nb ) = ei
           ! compute y(1:k,1:nb)
           call stdlib_clacpy( 'ALL', k, nb, a( 1, 2 ), lda, y, ldy )
           call stdlib_ctrmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE','UNIT', k, nb,cone, a( k+1, 1 ), &
                     lda, y, ldy )
           if( n>k+nb )call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', k,nb, n-k-nb, cone,a( 1,&
                      2+nb ), lda, a( k+1+nb, 1 ), lda, cone, y,ldy )
           call stdlib_ctrmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE','NON-UNIT', k, nb,cone, t, ldt, y, &
                     ldy )
           return
     end subroutine stdlib_clahr2

     pure subroutine stdlib_zlahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
     !! ZLAHR2 reduces the first NB columns of A complex general n-BY-(n-k+1)
     !! matrix A so that elements below the k-th subdiagonal are zero. The
     !! reduction is performed by an unitary similarity transformation
     !! Q**H * A * Q. The routine returns the matrices V and T which determine
     !! Q as a block reflector I - V*T*V**H, and also the matrix Y = A * V * T.
     !! This is an auxiliary routine called by ZGEHRD.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: k, lda, ldt, ldy, n, nb
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: t(ldt,nb), tau(nb), y(ldy,nb)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           complex(dp) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=1 )return
           loop_10: do i = 1, nb
              if( i>1 ) then
                 ! update a(k+1:n,i)
                 ! update i-th column of a - y * v**h
                 call stdlib_zlacgv( i-1, a( k+i-1, 1 ), lda )
                 call stdlib_zgemv( 'NO TRANSPOSE', n-k, i-1, -cone, y(k+1,1), ldy,a( k+i-1, 1 ), &
                           lda, cone, a( k+1, i ), 1 )
                 call stdlib_zlacgv( i-1, a( k+i-1, 1 ), lda )
                 ! apply i - v * t**h * v**h to this column (call it b) from the
                 ! left, using the last column of t as workspace
                 ! let  v = ( v1 )   and   b = ( b1 )   (first i-1 rows)
                          ! ( v2 )             ( b2 )
                 ! where v1 is unit lower triangular
                 ! w := v1**h * b1
                 call stdlib_zcopy( i-1, a( k+1, i ), 1, t( 1, nb ), 1 )
                 call stdlib_ztrmv( 'LOWER', 'CONJUGATE TRANSPOSE', 'UNIT',i-1, a( k+1, 1 ),lda, &
                           t( 1, nb ), 1 )
                 ! w := w + v2**h * b2
                 call stdlib_zgemv( 'CONJUGATE TRANSPOSE', n-k-i+1, i-1,cone, a( k+i, 1 ),lda, a( &
                           k+i, i ), 1, cone, t( 1, nb ), 1 )
                 ! w := t**h * w
                 call stdlib_ztrmv( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, &
                           nb ), 1 )
                 ! b2 := b2 - v2*w
                 call stdlib_zgemv( 'NO TRANSPOSE', n-k-i+1, i-1, -cone,a( k+i, 1 ),lda, t( 1, nb &
                           ), 1, cone, a( k+i, i ), 1 )
                 ! b1 := b1 - v1*w
                 call stdlib_ztrmv( 'LOWER', 'NO TRANSPOSE','UNIT', i-1,a( k+1, 1 ), lda, t( 1, &
                           nb ), 1 )
                 call stdlib_zaxpy( i-1, -cone, t( 1, nb ), 1, a( k+1, i ), 1 )
                 a( k+i-1, i-1 ) = ei
              end if
              ! generate the elementary reflector h(i) to annihilate
              ! a(k+i+1:n,i)
              call stdlib_zlarfg( n-k-i+1, a( k+i, i ), a( min( k+i+1, n ), i ), 1,tau( i ) )
                        
              ei = a( k+i, i )
              a( k+i, i ) = cone
              ! compute  y(k+1:n,i)
              call stdlib_zgemv( 'NO TRANSPOSE', n-k, n-k-i+1,cone, a( k+1, i+1 ),lda, a( k+i, i )&
                        , 1, czero, y( k+1, i ), 1 )
              call stdlib_zgemv( 'CONJUGATE TRANSPOSE', n-k-i+1, i-1,cone, a( k+i, 1 ), lda,a( k+&
                        i, i ), 1, czero, t( 1, i ), 1 )
              call stdlib_zgemv( 'NO TRANSPOSE', n-k, i-1, -cone,y( k+1, 1 ), ldy,t( 1, i ), 1, &
                        cone, y( k+1, i ), 1 )
              call stdlib_zscal( n-k, tau( i ), y( k+1, i ), 1 )
              ! compute t(1:i,i)
              call stdlib_zscal( i-1, -tau( i ), t( 1, i ), 1 )
              call stdlib_ztrmv( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, i ), 1 )
                        
              t( i, i ) = tau( i )
           end do loop_10
           a( k+nb, nb ) = ei
           ! compute y(1:k,1:nb)
           call stdlib_zlacpy( 'ALL', k, nb, a( 1, 2 ), lda, y, ldy )
           call stdlib_ztrmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE','UNIT', k, nb,cone, a( k+1, 1 ), &
                     lda, y, ldy )
           if( n>k+nb )call stdlib_zgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', k,nb, n-k-nb, cone,a( 1,&
                      2+nb ), lda, a( k+1+nb, 1 ), lda, cone, y,ldy )
           call stdlib_ztrmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE','NON-UNIT', k, nb,cone, t, ldt, y, &
                     ldy )
           return
     end subroutine stdlib_zlahr2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$lahr2( n, k, nb, a, lda, tau, t, ldt, y, ldy )
     !! ZLAHR2: reduces the first NB columns of A complex general n-BY-(n-k+1)
     !! matrix A so that elements below the k-th subdiagonal are zero. The
     !! reduction is performed by an unitary similarity transformation
     !! Q**H * A * Q. The routine returns the matrices V and T which determine
     !! Q as a block reflector I - V*T*V**H, and also the matrix Y = A * V * T.
     !! This is an auxiliary routine called by ZGEHRD.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: k, lda, ldt, ldy, n, nb
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: t(ldt,nb), tau(nb), y(ldy,nb)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           complex(${ck}$) :: ei
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=1 )return
           loop_10: do i = 1, nb
              if( i>1 ) then
                 ! update a(k+1:n,i)
                 ! update i-th column of a - y * v**h
                 call stdlib_${ci}$lacgv( i-1, a( k+i-1, 1 ), lda )
                 call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-k, i-1, -cone, y(k+1,1), ldy,a( k+i-1, 1 ), &
                           lda, cone, a( k+1, i ), 1 )
                 call stdlib_${ci}$lacgv( i-1, a( k+i-1, 1 ), lda )
                 ! apply i - v * t**h * v**h to this column (call it b) from the
                 ! left, using the last column of t as workspace
                 ! let  v = ( v1 )   and   b = ( b1 )   (first i-1 rows)
                          ! ( v2 )             ( b2 )
                 ! where v1 is unit lower triangular
                 ! w := v1**h * b1
                 call stdlib_${ci}$copy( i-1, a( k+1, i ), 1, t( 1, nb ), 1 )
                 call stdlib_${ci}$trmv( 'LOWER', 'CONJUGATE TRANSPOSE', 'UNIT',i-1, a( k+1, 1 ),lda, &
                           t( 1, nb ), 1 )
                 ! w := w + v2**h * b2
                 call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', n-k-i+1, i-1,cone, a( k+i, 1 ),lda, a( &
                           k+i, i ), 1, cone, t( 1, nb ), 1 )
                 ! w := t**h * w
                 call stdlib_${ci}$trmv( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, &
                           nb ), 1 )
                 ! b2 := b2 - v2*w
                 call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-k-i+1, i-1, -cone,a( k+i, 1 ),lda, t( 1, nb &
                           ), 1, cone, a( k+i, i ), 1 )
                 ! b1 := b1 - v1*w
                 call stdlib_${ci}$trmv( 'LOWER', 'NO TRANSPOSE','UNIT', i-1,a( k+1, 1 ), lda, t( 1, &
                           nb ), 1 )
                 call stdlib_${ci}$axpy( i-1, -cone, t( 1, nb ), 1, a( k+1, i ), 1 )
                 a( k+i-1, i-1 ) = ei
              end if
              ! generate the elementary reflector h(i) to annihilate
              ! a(k+i+1:n,i)
              call stdlib_${ci}$larfg( n-k-i+1, a( k+i, i ), a( min( k+i+1, n ), i ), 1,tau( i ) )
                        
              ei = a( k+i, i )
              a( k+i, i ) = cone
              ! compute  y(k+1:n,i)
              call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-k, n-k-i+1,cone, a( k+1, i+1 ),lda, a( k+i, i )&
                        , 1, czero, y( k+1, i ), 1 )
              call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', n-k-i+1, i-1,cone, a( k+i, 1 ), lda,a( k+&
                        i, i ), 1, czero, t( 1, i ), 1 )
              call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-k, i-1, -cone,y( k+1, 1 ), ldy,t( 1, i ), 1, &
                        cone, y( k+1, i ), 1 )
              call stdlib_${ci}$scal( n-k, tau( i ), y( k+1, i ), 1 )
              ! compute t(1:i,i)
              call stdlib_${ci}$scal( i-1, -tau( i ), t( 1, i ), 1 )
              call stdlib_${ci}$trmv( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT',i-1, t, ldt,t( 1, i ), 1 )
                        
              t( i, i ) = tau( i )
           end do loop_10
           a( k+nb, nb ) = ei
           ! compute y(1:k,1:nb)
           call stdlib_${ci}$lacpy( 'ALL', k, nb, a( 1, 2 ), lda, y, ldy )
           call stdlib_${ci}$trmm( 'RIGHT', 'LOWER', 'NO TRANSPOSE','UNIT', k, nb,cone, a( k+1, 1 ), &
                     lda, y, ldy )
           if( n>k+nb )call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', k,nb, n-k-nb, cone,a( 1,&
                      2+nb ), lda, a( k+1+nb, 1 ), lda, cone, y,ldy )
           call stdlib_${ci}$trmm( 'RIGHT', 'UPPER', 'NO TRANSPOSE','NON-UNIT', k, nb,cone, t, ldt, y, &
                     ldy )
           return
     end subroutine stdlib_${ci}$lahr2

#:endif
#:endfor







     pure subroutine stdlib_cunghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! CUNGHR generates a complex unitary matrix Q which is defined as the
     !! product of IHI-ILO elementary reflectors of order N, as returned by
     !! CGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, iinfo, j, lwkopt, nb, nh
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, nh ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              nb = stdlib_ilaenv( 1, 'CUNGQR', ' ', nh, nh, nh, -1 )
              lwkopt = max( 1, nh )*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNGHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           ! shift the vectors which define the elementary reflectors cone
           ! column to the right, and set the first ilo and the last n-ihi
           ! rows and columns to those of the unit matrix
           do j = ihi, ilo + 1, -1
              do i = 1, j - 1
                 a( i, j ) = czero
              end do
              do i = j + 1, ihi
                 a( i, j ) = a( i, j-1 )
              end do
              do i = ihi + 1, n
                 a( i, j ) = czero
              end do
           end do
           do j = 1, ilo
              do i = 1, n
                 a( i, j ) = czero
              end do
              a( j, j ) = cone
           end do
           do j = ihi + 1, n
              do i = 1, n
                 a( i, j ) = czero
              end do
              a( j, j ) = cone
           end do
           if( nh>0 ) then
              ! generate q(ilo+1:ihi,ilo+1:ihi)
              call stdlib_cungqr( nh, nh, nh, a( ilo+1, ilo+1 ), lda, tau( ilo ),work, lwork, &
                        iinfo )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cunghr

     pure subroutine stdlib_zunghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! ZUNGHR generates a complex unitary matrix Q which is defined as the
     !! product of IHI-ILO elementary reflectors of order N, as returned by
     !! ZGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(in) :: tau(*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, iinfo, j, lwkopt, nb, nh
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, nh ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              nb = stdlib_ilaenv( 1, 'ZUNGQR', ' ', nh, nh, nh, -1 )
              lwkopt = max( 1, nh )*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZUNGHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           ! shift the vectors which define the elementary reflectors cone
           ! column to the right, and set the first ilo and the last n-ihi
           ! rows and columns to those of the unit matrix
           do j = ihi, ilo + 1, -1
              do i = 1, j - 1
                 a( i, j ) = czero
              end do
              do i = j + 1, ihi
                 a( i, j ) = a( i, j-1 )
              end do
              do i = ihi + 1, n
                 a( i, j ) = czero
              end do
           end do
           do j = 1, ilo
              do i = 1, n
                 a( i, j ) = czero
              end do
              a( j, j ) = cone
           end do
           do j = ihi + 1, n
              do i = 1, n
                 a( i, j ) = czero
              end do
              a( j, j ) = cone
           end do
           if( nh>0 ) then
              ! generate q(ilo+1:ihi,ilo+1:ihi)
              call stdlib_zungqr( nh, nh, nh, a( ilo+1, ilo+1 ), lda, tau( ilo ),work, lwork, &
                        iinfo )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zunghr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$unghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! ZUNGHR: generates a complex unitary matrix Q which is defined as the
     !! product of IHI-ILO elementary reflectors of order N, as returned by
     !! ZGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(in) :: tau(*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, iinfo, j, lwkopt, nb, nh
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, nh ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              nb = stdlib_ilaenv( 1, 'ZUNGQR', ' ', nh, nh, nh, -1 )
              lwkopt = max( 1, nh )*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZUNGHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           ! shift the vectors which define the elementary reflectors cone
           ! column to the right, and set the first ilo and the last n-ihi
           ! rows and columns to those of the unit matrix
           do j = ihi, ilo + 1, -1
              do i = 1, j - 1
                 a( i, j ) = czero
              end do
              do i = j + 1, ihi
                 a( i, j ) = a( i, j-1 )
              end do
              do i = ihi + 1, n
                 a( i, j ) = czero
              end do
           end do
           do j = 1, ilo
              do i = 1, n
                 a( i, j ) = czero
              end do
              a( j, j ) = cone
           end do
           do j = ihi + 1, n
              do i = 1, n
                 a( i, j ) = czero
              end do
              a( j, j ) = cone
           end do
           if( nh>0 ) then
              ! generate q(ilo+1:ihi,ilo+1:ihi)
              call stdlib_${ci}$ungqr( nh, nh, nh, a( ilo+1, ilo+1 ), lda, tau( ilo ),work, lwork, &
                        iinfo )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$unghr

#:endif
#:endfor



     pure subroutine stdlib_strevc3( side, howmny, select, n, t, ldt, vl, ldvl,vr, ldvr, mm, m, &
     !! STREVC3 computes some or all of the right and/or left eigenvectors of
     !! a real upper quasi-triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a real general matrix:  A = Q*T*Q**T, as computed by SHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**T)*T = w*(y**T)
     !! where y**T denotes the transpose of the vector y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal blocks of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix. If Q is the orthogonal factor that reduces a matrix
     !! A to Schur form T, then Q*X and Q*Y are the matrices of right and
     !! left eigenvectors of A.
     !! This uses a Level 3 BLAS version of the back transformation.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, lwork, mm, n
           ! Array Arguments 
           logical(lk), intent(inout) :: select(*)
           real(sp), intent(in) :: t(ldt,*)
           real(sp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmin = 8
           integer(ilp), parameter :: nbmax = 128
           
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, lquery, over, pair, rightv, somev
           integer(ilp) :: i, ierr, ii, ip, is, j, j1, j2, jnxt, k, ki, iv, maxwrk, nb, &
                     ki2
           real(sp) :: beta, bignum, emax, ovfl, rec, remax, scale, smin, smlnum, ulp, unfl, &
                     vcrit, vmax, wi, wr, xnorm
           ! Intrinsic Functions 
           ! Local Arrays 
           real(sp) :: x(2,2)
           integer(ilp) :: iscomplex(nbmax)
           ! Executable Statements 
           ! decode and test the input parameters
           bothv  = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv  = stdlib_lsame( side, 'L' ) .or. bothv
           allv  = stdlib_lsame( howmny, 'A' )
           over  = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           info = 0
           nb = stdlib_ilaenv( 1, 'STREVC', side // howmny, n, -1, -1, -1 )
           maxwrk = n + 2*n*nb
           work(1) = maxwrk
           lquery = ( lwork==-1 )
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else if( lwork<max( 1, 3*n ) .and. .not.lquery ) then
              info = -14
           else
              ! set m to the number of columns required to store the selected
              ! eigenvectors, standardize the array select if necessary, and
              ! test mm.
              if( somev ) then
                 m = 0
                 pair = .false.
                 do j = 1, n
                    if( pair ) then
                       pair = .false.
                       select( j ) = .false.
                    else
                       if( j<n ) then
                          if( t( j+1, j )==zero ) then
                             if( select( j ) )m = m + 1
                          else
                             pair = .true.
                             if( select( j ) .or. select( j+1 ) ) then
                                select( j ) = .true.
                                m = m + 2
                             end if
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( mm<m ) then
                 info = -11
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STREVC3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! use blocked version of back-transformation if sufficient workspace.
           ! zero-out the workspace to avoid potential nan propagation.
           if( over .and. lwork >= n + 2*n*nbmin ) then
              nb = (lwork - n) / (2*n)
              nb = min( nb, nbmax )
              call stdlib_slaset( 'F', n, 1+2*nb, zero, zero, work, n )
           else
              nb = 1
           end if
           ! set the constants to control overflow.
           unfl = stdlib_slamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_slabad( unfl, ovfl )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           bignum = ( one-ulp ) / smlnum
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           work( 1 ) = zero
           do j = 2, n
              work( j ) = zero
              do i = 1, j - 1
                 work( j ) = work( j ) + abs( t( i, j ) )
              end do
           end do
           ! index ip is used to specify the real or complex eigenvalue:
             ! ip = 0, real eigenvalue,
                  ! 1, first  of conjugate complex pair: (wr,wi)
                 ! -1, second of conjugate complex pair: (wr,wi)
             ! iscomplex array stores ip for each column in current block.
           if( rightv ) then
              ! ============================================================
              ! compute right eigenvectors.
              ! iv is index of column in current block.
              ! for complex right vector, uses iv-1 for real part and iv for complex part.
              ! non-blocked version always uses iv=2;
              ! blocked     version starts with iv=nb, goes down to 1 or 2.
              ! (note the "0-th" column is used for 1-norms computed above.)
              iv = 2
              if( nb>2 ) then
                 iv = nb
              end if
              ip = 0
              is = m
              loop_140: do ki = n, 1, -1
                 if( ip==-1 ) then
                    ! previous iteration (ki+1) was second of conjugate pair,
                    ! so this ki is first of conjugate pair; skip to end of loop
                    ip = 1
                    cycle loop_140
                 else if( ki==1 ) then
                    ! last column, so this ki must be real eigenvalue
                    ip = 0
                 else if( t( ki, ki-1 )==zero ) then
                    ! zero on sub-diagonal, so this ki is real eigenvalue
                    ip = 0
                 else
                    ! non-zero on sub-diagonal, so this ki is second of conjugate pair
                    ip = -1
                 end if
                 if( somev ) then
                    if( ip==0 ) then
                       if( .not.select( ki ) )cycle loop_140
                    else
                       if( .not.select( ki-1 ) )cycle loop_140
                    end if
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki-1 ) ) )*sqrt( abs( t( ki-1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! --------------------------------------------------------
                    ! real right eigenvector
                    work( ki + iv*n ) = one
                    ! form right-hand side.
                    do k = 1, ki - 1
                       work( k + iv*n ) = -t( k, ki )
                    end do
                    ! solve upper quasi-triangular system:
                    ! [ t(1:ki-1,1:ki-1) - wr ]*x = scale*work.
                    jnxt = ki - 1
                    loop_60: do j = ki - 1, 1, -1
                       if( j>jnxt )cycle loop_60
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1   = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_slaln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_sscal( ki, scale, work( 1+iv*n ), 1 )
                                    
                          work( j+iv*n ) = x( 1, 1 )
                          ! update right-hand side
                          call stdlib_saxpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+iv*n ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_slaln2( .false., 2, 1, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+iv*n ), n, wr, zero, x, 2,scale, xnorm, ierr )
                          ! scale x(1,1) and x(2,1) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 2, 1 ) = x( 2, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_sscal( ki, scale, work( 1+iv*n ), 1 )
                                    
                          work( j-1+iv*n ) = x( 1, 1 )
                          work( j  +iv*n ) = x( 2, 1 )
                          ! update right-hand side
                          call stdlib_saxpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+iv*n ), 1 )
                                    
                          call stdlib_saxpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+iv*n ), 1 )
                                    
                       end if
                    end do loop_60
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vr and normalize.
                       call stdlib_scopy( ki, work( 1 + iv*n ), 1, vr( 1, is ), 1 )
                       ii = stdlib_isamax( ki, vr( 1, is ), 1 )
                       remax = one / abs( vr( ii, is ) )
                       call stdlib_sscal( ki, remax, vr( 1, is ), 1 )
                       do k = ki + 1, n
                          vr( k, is ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki>1 )call stdlib_sgemv( 'N', n, ki-1, one, vr, ldvr,work( 1 + iv*n ), &
                                 1, work( ki + iv*n ),vr( 1, ki ), 1 )
                       ii = stdlib_isamax( n, vr( 1, ki ), 1 )
                       remax = one / abs( vr( ii, ki ) )
                       call stdlib_sscal( n, remax, vr( 1, ki ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out below vector
                       do k = ki + 1, n
                          work( k + iv*n ) = zero
                       end do
                       iscomplex( iv ) = ip
                       ! back-transform and normalization is done below
                    end if
                 else
                    ! --------------------------------------------------------
                    ! complex right eigenvector.
                    ! initial solve
                    ! [ ( t(ki-1,ki-1) t(ki-1,ki) ) - (wr + i*wi) ]*x = 0.
                    ! [ ( t(ki,  ki-1) t(ki,  ki) )               ]
                    if( abs( t( ki-1, ki ) )>=abs( t( ki, ki-1 ) ) ) then
                       work( ki-1 + (iv-1)*n ) = one
                       work( ki   + (iv  )*n ) = wi / t( ki-1, ki )
                    else
                       work( ki-1 + (iv-1)*n ) = -wi / t( ki, ki-1 )
                       work( ki   + (iv  )*n ) = one
                    end if
                    work( ki   + (iv-1)*n ) = zero
                    work( ki-1 + (iv  )*n ) = zero
                    ! form right-hand side.
                    do k = 1, ki - 2
                       work( k+(iv-1)*n ) = -work( ki-1+(iv-1)*n )*t(k,ki-1)
                       work( k+(iv  )*n ) = -work( ki  +(iv  )*n )*t(k,ki  )
                    end do
                    ! solve upper quasi-triangular system:
                    ! [ t(1:ki-2,1:ki-2) - (wr+i*wi) ]*x = scale*(work+i*work2)
                    jnxt = ki - 2
                    loop_90: do j = ki - 2, 1, -1
                       if( j>jnxt )cycle loop_90
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1   = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_slaln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+(iv-1)*n ), n,wr, wi, x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) and x(1,2) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 1, 2 ) = x( 1, 2 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_sscal( ki, scale, work( 1+(iv-1)*n ), 1 )
                             call stdlib_sscal( ki, scale, work( 1+(iv  )*n ), 1 )
                          end if
                          work( j+(iv-1)*n ) = x( 1, 1 )
                          work( j+(iv  )*n ) = x( 1, 2 )
                          ! update the right-hand side
                          call stdlib_saxpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+(iv-1)*n ), 1 )
                                    
                          call stdlib_saxpy( j-1, -x( 1, 2 ), t( 1, j ), 1,work( 1+(iv  )*n ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_slaln2( .false., 2, 2, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+(iv-1)*n ), n, wr, wi, x, 2,scale, xnorm, ierr )
                          ! scale x to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                rec = one / xnorm
                                x( 1, 1 ) = x( 1, 1 )*rec
                                x( 1, 2 ) = x( 1, 2 )*rec
                                x( 2, 1 ) = x( 2, 1 )*rec
                                x( 2, 2 ) = x( 2, 2 )*rec
                                scale = scale*rec
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_sscal( ki, scale, work( 1+(iv-1)*n ), 1 )
                             call stdlib_sscal( ki, scale, work( 1+(iv  )*n ), 1 )
                          end if
                          work( j-1+(iv-1)*n ) = x( 1, 1 )
                          work( j  +(iv-1)*n ) = x( 2, 1 )
                          work( j-1+(iv  )*n ) = x( 1, 2 )
                          work( j  +(iv  )*n ) = x( 2, 2 )
                          ! update the right-hand side
                          call stdlib_saxpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+(iv-1)*n   ),&
                                     1 )
                          call stdlib_saxpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+(iv-1)*n   ), &
                                    1 )
                          call stdlib_saxpy( j-2, -x( 1, 2 ), t( 1, j-1 ), 1,work( 1+(iv  )*n ), &
                                    1 )
                          call stdlib_saxpy( j-2, -x( 2, 2 ), t( 1, j ), 1,work( 1+(iv  )*n ), 1 )
                                    
                       end if
                    end do loop_90
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vr and normalize.
                       call stdlib_scopy( ki, work( 1+(iv-1)*n ), 1, vr(1,is-1), 1 )
                       call stdlib_scopy( ki, work( 1+(iv  )*n ), 1, vr(1,is  ), 1 )
                       emax = zero
                       do k = 1, ki
                          emax = max( emax, abs( vr( k, is-1 ) )+abs( vr( k, is   ) ) )
                       end do
                       remax = one / emax
                       call stdlib_sscal( ki, remax, vr( 1, is-1 ), 1 )
                       call stdlib_sscal( ki, remax, vr( 1, is   ), 1 )
                       do k = ki + 1, n
                          vr( k, is-1 ) = zero
                          vr( k, is   ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki>2 ) then
                          call stdlib_sgemv( 'N', n, ki-2, one, vr, ldvr,work( 1    + (iv-1)*n ), &
                                    1,work( ki-1 + (iv-1)*n ), vr(1,ki-1), 1)
                          call stdlib_sgemv( 'N', n, ki-2, one, vr, ldvr,work( 1  + (iv)*n ), 1,&
                                    work( ki + (iv)*n ), vr( 1, ki ), 1 )
                       else
                          call stdlib_sscal( n, work(ki-1+(iv-1)*n), vr(1,ki-1), 1)
                          call stdlib_sscal( n, work(ki  +(iv  )*n), vr(1,ki  ), 1)
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vr( k, ki-1 ) )+abs( vr( k, ki   ) ) )
                       end do
                       remax = one / emax
                       call stdlib_sscal( n, remax, vr( 1, ki-1 ), 1 )
                       call stdlib_sscal( n, remax, vr( 1, ki   ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out below vector
                       do k = ki + 1, n
                          work( k + (iv-1)*n ) = zero
                          work( k + (iv  )*n ) = zero
                       end do
                       iscomplex( iv-1 ) = -ip
                       iscomplex( iv   ) =  ip
                       iv = iv - 1
                       ! back-transform and normalization is done below
                    end if
                 end if
                 if( nb>1 ) then
                    ! --------------------------------------------------------
                    ! blocked version of back-transform
                    ! for complex case, ki2 includes both vectors (ki-1 and ki)
                    if( ip==0 ) then
                       ki2 = ki
                    else
                       ki2 = ki - 1
                    end if
                    ! columns iv:nb of work are valid vectors.
                    ! when the number of vectors stored reaches nb-1 or nb,
                    ! or if this was last vector, do the gemm
                    if( (iv<=2) .or. (ki2==1) ) then
                       call stdlib_sgemm( 'N', 'N', n, nb-iv+1, ki2+nb-iv, one,vr, ldvr,work( 1 + &
                                 (iv)*n    ), n,zero,work( 1 + (nb+iv)*n ), n )
                       ! normalize vectors
                       do k = iv, nb
                          if( iscomplex(k)==0 ) then
                             ! real eigenvector
                             ii = stdlib_isamax( n, work( 1 + (nb+k)*n ), 1 )
                             remax = one / abs( work( ii + (nb+k)*n ) )
                          else if( iscomplex(k)==1 ) then
                             ! first eigenvector of conjugate pair
                             emax = zero
                             do ii = 1, n
                                emax = max( emax,abs( work( ii + (nb+k  )*n ) )+abs( work( ii + (&
                                          nb+k+1)*n ) ) )
                             end do
                             remax = one / emax
                          ! else if iscomplex(k)==-1
                             ! second eigenvector of conjugate pair
                             ! reuse same remax as previous k
                          end if
                          call stdlib_sscal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_slacpy( 'F', n, nb-iv+1,work( 1 + (nb+iv)*n ), n,vr( 1, ki2 ), &
                                 ldvr )
                       iv = nb
                    else
                       iv = iv - 1
                    end if
                 end if ! blocked back-transform
                 is = is - 1
                 if( ip/=0 )is = is - 1
              end do loop_140
           end if
           if( leftv ) then
              ! ============================================================
              ! compute left eigenvectors.
              ! iv is index of column in current block.
              ! for complex left vector, uses iv for real part and iv+1 for complex part.
              ! non-blocked version always uses iv=1;
              ! blocked     version starts with iv=1, goes up to nb-1 or nb.
              ! (note the "0-th" column is used for 1-norms computed above.)
              iv = 1
              ip = 0
              is = 1
              loop_260: do ki = 1, n
                 if( ip==1 ) then
                    ! previous iteration (ki-1) was first of conjugate pair,
                    ! so this ki is second of conjugate pair; skip to end of loop
                    ip = -1
                    cycle loop_260
                 else if( ki==n ) then
                    ! last column, so this ki must be real eigenvalue
                    ip = 0
                 else if( t( ki+1, ki )==zero ) then
                    ! zero on sub-diagonal, so this ki is real eigenvalue
                    ip = 0
                 else
                    ! non-zero on sub-diagonal, so this ki is first of conjugate pair
                    ip = 1
                 end if
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_260
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki+1 ) ) )*sqrt( abs( t( ki+1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! --------------------------------------------------------
                    ! real left eigenvector
                    work( ki + iv*n ) = one
                    ! form right-hand side.
                    do k = ki + 1, n
                       work( k + iv*n ) = -t( ki, k )
                    end do
                    ! solve transposed quasi-triangular system:
                    ! [ t(ki+1:n,ki+1:n) - wr ]**t * x = scale*work
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 1
                    loop_170: do j = ki + 1, n
                       if( j<jnxt )cycle loop_170
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_sscal( n-ki+1, rec, work( ki+iv*n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+iv*n ) = work( j+iv*n ) -stdlib_sdot( j-ki-1, t( ki+1, j ), 1,&
                                    work( ki+1+iv*n ), 1 )
                          ! solve [ t(j,j) - wr ]**t * x = work
                          call stdlib_slaln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_sscal( n-ki+1, scale, work( ki+iv*n ), 1 )
                                    
                          work( j+iv*n ) = x( 1, 1 )
                          vmax = max( abs( work( j+iv*n ) ), vmax )
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_sscal( n-ki+1, rec, work( ki+iv*n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+iv*n ) = work( j+iv*n ) -stdlib_sdot( j-ki-1, t( ki+1, j ), 1,&
                                    work( ki+1+iv*n ), 1 )
                          work( j+1+iv*n ) = work( j+1+iv*n ) -stdlib_sdot( j-ki-1, t( ki+1, j+1 )&
                                    , 1,work( ki+1+iv*n ), 1 )
                          ! solve
                          ! [ t(j,j)-wr   t(j,j+1)      ]**t * x = scale*( work1 )
                          ! [ t(j+1,j)    t(j+1,j+1)-wr ]                ( work2 )
                          call stdlib_slaln2( .true., 2, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_sscal( n-ki+1, scale, work( ki+iv*n ), 1 )
                                    
                          work( j  +iv*n ) = x( 1, 1 )
                          work( j+1+iv*n ) = x( 2, 1 )
                          vmax = max( abs( work( j  +iv*n ) ),abs( work( j+1+iv*n ) ), vmax )
                                    
                          vcrit = bignum / vmax
                       end if
                    end do loop_170
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vl and normalize.
                       call stdlib_scopy( n-ki+1, work( ki + iv*n ), 1,vl( ki, is ), 1 )
                       ii = stdlib_isamax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                       remax = one / abs( vl( ii, is ) )
                       call stdlib_sscal( n-ki+1, remax, vl( ki, is ), 1 )
                       do k = 1, ki - 1
                          vl( k, is ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki<n )call stdlib_sgemv( 'N', n, n-ki, one,vl( 1, ki+1 ), ldvl,work( &
                                 ki+1 + iv*n ), 1,work( ki   + iv*n ), vl( 1, ki ), 1 )
                       ii = stdlib_isamax( n, vl( 1, ki ), 1 )
                       remax = one / abs( vl( ii, ki ) )
                       call stdlib_sscal( n, remax, vl( 1, ki ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out above vector
                       ! could go from ki-nv+1 to ki-1
                       do k = 1, ki - 1
                          work( k + iv*n ) = zero
                       end do
                       iscomplex( iv ) = ip
                       ! back-transform and normalization is done below
                    end if
                 else
                    ! --------------------------------------------------------
                    ! complex left eigenvector.
                    ! initial solve:
                    ! [ ( t(ki,ki)    t(ki,ki+1)  )**t - (wr - i* wi) ]*x = 0.
                    ! [ ( t(ki+1,ki) t(ki+1,ki+1) )                   ]
                    if( abs( t( ki, ki+1 ) )>=abs( t( ki+1, ki ) ) ) then
                       work( ki   + (iv  )*n ) = wi / t( ki, ki+1 )
                       work( ki+1 + (iv+1)*n ) = one
                    else
                       work( ki   + (iv  )*n ) = one
                       work( ki+1 + (iv+1)*n ) = -wi / t( ki+1, ki )
                    end if
                    work( ki+1 + (iv  )*n ) = zero
                    work( ki   + (iv+1)*n ) = zero
                    ! form right-hand side.
                    do k = ki + 2, n
                       work( k+(iv  )*n ) = -work( ki  +(iv  )*n )*t(ki,  k)
                       work( k+(iv+1)*n ) = -work( ki+1+(iv+1)*n )*t(ki+1,k)
                    end do
                    ! solve transposed quasi-triangular system:
                    ! [ t(ki+2:n,ki+2:n)**t - (wr-i*wi) ]*x = work1+i*work2
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 2
                    loop_200: do j = ki + 2, n
                       if( j<jnxt )cycle loop_200
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when
                          ! forming the right-hand side elements.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_sscal( n-ki+1, rec, work(ki+(iv  )*n), 1 )
                             call stdlib_sscal( n-ki+1, rec, work(ki+(iv+1)*n), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+(iv  )*n ) = work( j+(iv)*n ) -stdlib_sdot( j-ki-2, t( ki+2, j )&
                                    , 1,work( ki+2+(iv)*n ), 1 )
                          work( j+(iv+1)*n ) = work( j+(iv+1)*n ) -stdlib_sdot( j-ki-2, t( ki+2, &
                                    j ), 1,work( ki+2+(iv+1)*n ), 1 )
                          ! solve [ t(j,j)-(wr-i*wi) ]*(x11+i*x12)= wk+i*wk2
                          call stdlib_slaln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_sscal( n-ki+1, scale, work(ki+(iv  )*n), 1)
                             call stdlib_sscal( n-ki+1, scale, work(ki+(iv+1)*n), 1)
                          end if
                          work( j+(iv  )*n ) = x( 1, 1 )
                          work( j+(iv+1)*n ) = x( 1, 2 )
                          vmax = max( abs( work( j+(iv  )*n ) ),abs( work( j+(iv+1)*n ) ), vmax )
                                    
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side elements.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_sscal( n-ki+1, rec, work(ki+(iv  )*n), 1 )
                             call stdlib_sscal( n-ki+1, rec, work(ki+(iv+1)*n), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j  +(iv  )*n ) = work( j+(iv)*n ) -stdlib_sdot( j-ki-2, t( ki+2, &
                                    j ), 1,work( ki+2+(iv)*n ), 1 )
                          work( j  +(iv+1)*n ) = work( j+(iv+1)*n ) -stdlib_sdot( j-ki-2, t( ki+2,&
                                     j ), 1,work( ki+2+(iv+1)*n ), 1 )
                          work( j+1+(iv  )*n ) = work( j+1+(iv)*n ) -stdlib_sdot( j-ki-2, t( ki+2,&
                                     j+1 ), 1,work( ki+2+(iv)*n ), 1 )
                          work( j+1+(iv+1)*n ) = work( j+1+(iv+1)*n ) -stdlib_sdot( j-ki-2, t( ki+&
                                    2, j+1 ), 1,work( ki+2+(iv+1)*n ), 1 )
                          ! solve 2-by-2 complex linear equation
                          ! [ (t(j,j)   t(j,j+1)  )**t - (wr-i*wi)*i ]*x = scale*b
                          ! [ (t(j+1,j) t(j+1,j+1))                  ]
                          call stdlib_slaln2( .true., 2, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_sscal( n-ki+1, scale, work(ki+(iv  )*n), 1)
                             call stdlib_sscal( n-ki+1, scale, work(ki+(iv+1)*n), 1)
                          end if
                          work( j  +(iv  )*n ) = x( 1, 1 )
                          work( j  +(iv+1)*n ) = x( 1, 2 )
                          work( j+1+(iv  )*n ) = x( 2, 1 )
                          work( j+1+(iv+1)*n ) = x( 2, 2 )
                          vmax = max( abs( x( 1, 1 ) ), abs( x( 1, 2 ) ),abs( x( 2, 1 ) ), abs( x(&
                                     2, 2 ) ),vmax )
                          vcrit = bignum / vmax
                       end if
                    end do loop_200
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vl and normalize.
                       call stdlib_scopy( n-ki+1, work( ki + (iv  )*n ), 1,vl( ki, is   ), 1 )
                                 
                       call stdlib_scopy( n-ki+1, work( ki + (iv+1)*n ), 1,vl( ki, is+1 ), 1 )
                                 
                       emax = zero
                       do k = ki, n
                          emax = max( emax, abs( vl( k, is   ) )+abs( vl( k, is+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_sscal( n-ki+1, remax, vl( ki, is   ), 1 )
                       call stdlib_sscal( n-ki+1, remax, vl( ki, is+1 ), 1 )
                       do k = 1, ki - 1
                          vl( k, is   ) = zero
                          vl( k, is+1 ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki<n-1 ) then
                          call stdlib_sgemv( 'N', n, n-ki-1, one,vl( 1, ki+2 ), ldvl,work( ki+2 + &
                                    (iv)*n ), 1,work( ki   + (iv)*n ),vl( 1, ki ), 1 )
                          call stdlib_sgemv( 'N', n, n-ki-1, one,vl( 1, ki+2 ), ldvl,work( ki+2 + &
                                    (iv+1)*n ), 1,work( ki+1 + (iv+1)*n ),vl( 1, ki+1 ), 1 )
                       else
                          call stdlib_sscal( n, work(ki+  (iv  )*n), vl(1, ki  ), 1)
                          call stdlib_sscal( n, work(ki+1+(iv+1)*n), vl(1, ki+1), 1)
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vl( k, ki   ) )+abs( vl( k, ki+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_sscal( n, remax, vl( 1, ki   ), 1 )
                       call stdlib_sscal( n, remax, vl( 1, ki+1 ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out above vector
                       ! could go from ki-nv+1 to ki-1
                       do k = 1, ki - 1
                          work( k + (iv  )*n ) = zero
                          work( k + (iv+1)*n ) = zero
                       end do
                       iscomplex( iv   ) =  ip
                       iscomplex( iv+1 ) = -ip
                       iv = iv + 1
                       ! back-transform and normalization is done below
                    end if
                 end if
                 if( nb>1 ) then
                    ! --------------------------------------------------------
                    ! blocked version of back-transform
                    ! for complex case, ki2 includes both vectors (ki and ki+1)
                    if( ip==0 ) then
                       ki2 = ki
                    else
                       ki2 = ki + 1
                    end if
                    ! columns 1:iv of work are valid vectors.
                    ! when the number of vectors stored reaches nb-1 or nb,
                    ! or if this was last vector, do the gemm
                    if( (iv>=nb-1) .or. (ki2==n) ) then
                       call stdlib_sgemm( 'N', 'N', n, iv, n-ki2+iv, one,vl( 1, ki2-iv+1 ), ldvl,&
                                 work( ki2-iv+1 + (1)*n ), n,zero,work( 1 + (nb+1)*n ), n )
                       ! normalize vectors
                       do k = 1, iv
                          if( iscomplex(k)==0) then
                             ! real eigenvector
                             ii = stdlib_isamax( n, work( 1 + (nb+k)*n ), 1 )
                             remax = one / abs( work( ii + (nb+k)*n ) )
                          else if( iscomplex(k)==1) then
                             ! first eigenvector of conjugate pair
                             emax = zero
                             do ii = 1, n
                                emax = max( emax,abs( work( ii + (nb+k  )*n ) )+abs( work( ii + (&
                                          nb+k+1)*n ) ) )
                             end do
                             remax = one / emax
                          ! else if iscomplex(k)==-1
                             ! second eigenvector of conjugate pair
                             ! reuse same remax as previous k
                          end if
                          call stdlib_sscal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_slacpy( 'F', n, iv,work( 1 + (nb+1)*n ), n,vl( 1, ki2-iv+1 ), &
                                 ldvl )
                       iv = 1
                    else
                       iv = iv + 1
                    end if
                 end if ! blocked back-transform
                 is = is + 1
                 if( ip/=0 )is = is + 1
              end do loop_260
           end if
           return
     end subroutine stdlib_strevc3

     pure subroutine stdlib_dtrevc3( side, howmny, select, n, t, ldt, vl, ldvl,vr, ldvr, mm, m, &
     !! DTREVC3 computes some or all of the right and/or left eigenvectors of
     !! a real upper quasi-triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a real general matrix:  A = Q*T*Q**T, as computed by DHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**T)*T = w*(y**T)
     !! where y**T denotes the transpose of the vector y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal blocks of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix. If Q is the orthogonal factor that reduces a matrix
     !! A to Schur form T, then Q*X and Q*Y are the matrices of right and
     !! left eigenvectors of A.
     !! This uses a Level 3 BLAS version of the back transformation.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, lwork, mm, n
           ! Array Arguments 
           logical(lk), intent(inout) :: select(*)
           real(dp), intent(in) :: t(ldt,*)
           real(dp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmin = 8
           integer(ilp), parameter :: nbmax = 128
           
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, lquery, over, pair, rightv, somev
           integer(ilp) :: i, ierr, ii, ip, is, j, j1, j2, jnxt, k, ki, iv, maxwrk, nb, &
                     ki2
           real(dp) :: beta, bignum, emax, ovfl, rec, remax, scale, smin, smlnum, ulp, unfl, &
                     vcrit, vmax, wi, wr, xnorm
           ! Intrinsic Functions 
           ! Local Arrays 
           real(dp) :: x(2,2)
           integer(ilp) :: iscomplex(nbmax)
           ! Executable Statements 
           ! decode and test the input parameters
           bothv  = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv  = stdlib_lsame( side, 'L' ) .or. bothv
           allv  = stdlib_lsame( howmny, 'A' )
           over  = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           info = 0
           nb = stdlib_ilaenv( 1, 'DTREVC', side // howmny, n, -1, -1, -1 )
           maxwrk = n + 2*n*nb
           work(1) = maxwrk
           lquery = ( lwork==-1 )
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else if( lwork<max( 1, 3*n ) .and. .not.lquery ) then
              info = -14
           else
              ! set m to the number of columns required to store the selected
              ! eigenvectors, standardize the array select if necessary, and
              ! test mm.
              if( somev ) then
                 m = 0
                 pair = .false.
                 do j = 1, n
                    if( pair ) then
                       pair = .false.
                       select( j ) = .false.
                    else
                       if( j<n ) then
                          if( t( j+1, j )==zero ) then
                             if( select( j ) )m = m + 1
                          else
                             pair = .true.
                             if( select( j ) .or. select( j+1 ) ) then
                                select( j ) = .true.
                                m = m + 2
                             end if
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( mm<m ) then
                 info = -11
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTREVC3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! use blocked version of back-transformation if sufficient workspace.
           ! zero-out the workspace to avoid potential nan propagation.
           if( over .and. lwork >= n + 2*n*nbmin ) then
              nb = (lwork - n) / (2*n)
              nb = min( nb, nbmax )
              call stdlib_dlaset( 'F', n, 1+2*nb, zero, zero, work, n )
           else
              nb = 1
           end if
           ! set the constants to control overflow.
           unfl = stdlib_dlamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_dlabad( unfl, ovfl )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           bignum = ( one-ulp ) / smlnum
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           work( 1 ) = zero
           do j = 2, n
              work( j ) = zero
              do i = 1, j - 1
                 work( j ) = work( j ) + abs( t( i, j ) )
              end do
           end do
           ! index ip is used to specify the real or complex eigenvalue:
             ! ip = 0, real eigenvalue,
                  ! 1, first  of conjugate complex pair: (wr,wi)
                 ! -1, second of conjugate complex pair: (wr,wi)
             ! iscomplex array stores ip for each column in current block.
           if( rightv ) then
              ! ============================================================
              ! compute right eigenvectors.
              ! iv is index of column in current block.
              ! for complex right vector, uses iv-1 for real part and iv for complex part.
              ! non-blocked version always uses iv=2;
              ! blocked     version starts with iv=nb, goes down to 1 or 2.
              ! (note the "0-th" column is used for 1-norms computed above.)
              iv = 2
              if( nb>2 ) then
                 iv = nb
              end if
              ip = 0
              is = m
              loop_140: do ki = n, 1, -1
                 if( ip==-1 ) then
                    ! previous iteration (ki+1) was second of conjugate pair,
                    ! so this ki is first of conjugate pair; skip to end of loop
                    ip = 1
                    cycle loop_140
                 else if( ki==1 ) then
                    ! last column, so this ki must be real eigenvalue
                    ip = 0
                 else if( t( ki, ki-1 )==zero ) then
                    ! zero on sub-diagonal, so this ki is real eigenvalue
                    ip = 0
                 else
                    ! non-zero on sub-diagonal, so this ki is second of conjugate pair
                    ip = -1
                 end if
                 if( somev ) then
                    if( ip==0 ) then
                       if( .not.select( ki ) )cycle loop_140
                    else
                       if( .not.select( ki-1 ) )cycle loop_140
                    end if
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki-1 ) ) )*sqrt( abs( t( ki-1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! --------------------------------------------------------
                    ! real right eigenvector
                    work( ki + iv*n ) = one
                    ! form right-hand side.
                    do k = 1, ki - 1
                       work( k + iv*n ) = -t( k, ki )
                    end do
                    ! solve upper quasi-triangular system:
                    ! [ t(1:ki-1,1:ki-1) - wr ]*x = scale*work.
                    jnxt = ki - 1
                    loop_60: do j = ki - 1, 1, -1
                       if( j>jnxt )cycle loop_60
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1   = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_dlaln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_dscal( ki, scale, work( 1+iv*n ), 1 )
                                    
                          work( j+iv*n ) = x( 1, 1 )
                          ! update right-hand side
                          call stdlib_daxpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+iv*n ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_dlaln2( .false., 2, 1, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+iv*n ), n, wr, zero, x, 2,scale, xnorm, ierr )
                          ! scale x(1,1) and x(2,1) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 2, 1 ) = x( 2, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_dscal( ki, scale, work( 1+iv*n ), 1 )
                                    
                          work( j-1+iv*n ) = x( 1, 1 )
                          work( j  +iv*n ) = x( 2, 1 )
                          ! update right-hand side
                          call stdlib_daxpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+iv*n ), 1 )
                                    
                          call stdlib_daxpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+iv*n ), 1 )
                                    
                       end if
                    end do loop_60
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vr and normalize.
                       call stdlib_dcopy( ki, work( 1 + iv*n ), 1, vr( 1, is ), 1 )
                       ii = stdlib_idamax( ki, vr( 1, is ), 1 )
                       remax = one / abs( vr( ii, is ) )
                       call stdlib_dscal( ki, remax, vr( 1, is ), 1 )
                       do k = ki + 1, n
                          vr( k, is ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki>1 )call stdlib_dgemv( 'N', n, ki-1, one, vr, ldvr,work( 1 + iv*n ), &
                                 1, work( ki + iv*n ),vr( 1, ki ), 1 )
                       ii = stdlib_idamax( n, vr( 1, ki ), 1 )
                       remax = one / abs( vr( ii, ki ) )
                       call stdlib_dscal( n, remax, vr( 1, ki ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out below vector
                       do k = ki + 1, n
                          work( k + iv*n ) = zero
                       end do
                       iscomplex( iv ) = ip
                       ! back-transform and normalization is done below
                    end if
                 else
                    ! --------------------------------------------------------
                    ! complex right eigenvector.
                    ! initial solve
                    ! [ ( t(ki-1,ki-1) t(ki-1,ki) ) - (wr + i*wi) ]*x = 0.
                    ! [ ( t(ki,  ki-1) t(ki,  ki) )               ]
                    if( abs( t( ki-1, ki ) )>=abs( t( ki, ki-1 ) ) ) then
                       work( ki-1 + (iv-1)*n ) = one
                       work( ki   + (iv  )*n ) = wi / t( ki-1, ki )
                    else
                       work( ki-1 + (iv-1)*n ) = -wi / t( ki, ki-1 )
                       work( ki   + (iv  )*n ) = one
                    end if
                    work( ki   + (iv-1)*n ) = zero
                    work( ki-1 + (iv  )*n ) = zero
                    ! form right-hand side.
                    do k = 1, ki - 2
                       work( k+(iv-1)*n ) = -work( ki-1+(iv-1)*n )*t(k,ki-1)
                       work( k+(iv  )*n ) = -work( ki  +(iv  )*n )*t(k,ki  )
                    end do
                    ! solve upper quasi-triangular system:
                    ! [ t(1:ki-2,1:ki-2) - (wr+i*wi) ]*x = scale*(work+i*work2)
                    jnxt = ki - 2
                    loop_90: do j = ki - 2, 1, -1
                       if( j>jnxt )cycle loop_90
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1   = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_dlaln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+(iv-1)*n ), n,wr, wi, x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) and x(1,2) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 1, 2 ) = x( 1, 2 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_dscal( ki, scale, work( 1+(iv-1)*n ), 1 )
                             call stdlib_dscal( ki, scale, work( 1+(iv  )*n ), 1 )
                          end if
                          work( j+(iv-1)*n ) = x( 1, 1 )
                          work( j+(iv  )*n ) = x( 1, 2 )
                          ! update the right-hand side
                          call stdlib_daxpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+(iv-1)*n ), 1 )
                                    
                          call stdlib_daxpy( j-1, -x( 1, 2 ), t( 1, j ), 1,work( 1+(iv  )*n ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_dlaln2( .false., 2, 2, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+(iv-1)*n ), n, wr, wi, x, 2,scale, xnorm, ierr )
                          ! scale x to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                rec = one / xnorm
                                x( 1, 1 ) = x( 1, 1 )*rec
                                x( 1, 2 ) = x( 1, 2 )*rec
                                x( 2, 1 ) = x( 2, 1 )*rec
                                x( 2, 2 ) = x( 2, 2 )*rec
                                scale = scale*rec
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_dscal( ki, scale, work( 1+(iv-1)*n ), 1 )
                             call stdlib_dscal( ki, scale, work( 1+(iv  )*n ), 1 )
                          end if
                          work( j-1+(iv-1)*n ) = x( 1, 1 )
                          work( j  +(iv-1)*n ) = x( 2, 1 )
                          work( j-1+(iv  )*n ) = x( 1, 2 )
                          work( j  +(iv  )*n ) = x( 2, 2 )
                          ! update the right-hand side
                          call stdlib_daxpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+(iv-1)*n   ),&
                                     1 )
                          call stdlib_daxpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+(iv-1)*n   ), &
                                    1 )
                          call stdlib_daxpy( j-2, -x( 1, 2 ), t( 1, j-1 ), 1,work( 1+(iv  )*n ), &
                                    1 )
                          call stdlib_daxpy( j-2, -x( 2, 2 ), t( 1, j ), 1,work( 1+(iv  )*n ), 1 )
                                    
                       end if
                    end do loop_90
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vr and normalize.
                       call stdlib_dcopy( ki, work( 1+(iv-1)*n ), 1, vr(1,is-1), 1 )
                       call stdlib_dcopy( ki, work( 1+(iv  )*n ), 1, vr(1,is  ), 1 )
                       emax = zero
                       do k = 1, ki
                          emax = max( emax, abs( vr( k, is-1 ) )+abs( vr( k, is   ) ) )
                       end do
                       remax = one / emax
                       call stdlib_dscal( ki, remax, vr( 1, is-1 ), 1 )
                       call stdlib_dscal( ki, remax, vr( 1, is   ), 1 )
                       do k = ki + 1, n
                          vr( k, is-1 ) = zero
                          vr( k, is   ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki>2 ) then
                          call stdlib_dgemv( 'N', n, ki-2, one, vr, ldvr,work( 1    + (iv-1)*n ), &
                                    1,work( ki-1 + (iv-1)*n ), vr(1,ki-1), 1)
                          call stdlib_dgemv( 'N', n, ki-2, one, vr, ldvr,work( 1  + (iv)*n ), 1,&
                                    work( ki + (iv)*n ), vr( 1, ki ), 1 )
                       else
                          call stdlib_dscal( n, work(ki-1+(iv-1)*n), vr(1,ki-1), 1)
                          call stdlib_dscal( n, work(ki  +(iv  )*n), vr(1,ki  ), 1)
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vr( k, ki-1 ) )+abs( vr( k, ki   ) ) )
                       end do
                       remax = one / emax
                       call stdlib_dscal( n, remax, vr( 1, ki-1 ), 1 )
                       call stdlib_dscal( n, remax, vr( 1, ki   ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out below vector
                       do k = ki + 1, n
                          work( k + (iv-1)*n ) = zero
                          work( k + (iv  )*n ) = zero
                       end do
                       iscomplex( iv-1 ) = -ip
                       iscomplex( iv   ) =  ip
                       iv = iv - 1
                       ! back-transform and normalization is done below
                    end if
                 end if
                 if( nb>1 ) then
                    ! --------------------------------------------------------
                    ! blocked version of back-transform
                    ! for complex case, ki2 includes both vectors (ki-1 and ki)
                    if( ip==0 ) then
                       ki2 = ki
                    else
                       ki2 = ki - 1
                    end if
                    ! columns iv:nb of work are valid vectors.
                    ! when the number of vectors stored reaches nb-1 or nb,
                    ! or if this was last vector, do the gemm
                    if( (iv<=2) .or. (ki2==1) ) then
                       call stdlib_dgemm( 'N', 'N', n, nb-iv+1, ki2+nb-iv, one,vr, ldvr,work( 1 + &
                                 (iv)*n    ), n,zero,work( 1 + (nb+iv)*n ), n )
                       ! normalize vectors
                       do k = iv, nb
                          if( iscomplex(k)==0 ) then
                             ! real eigenvector
                             ii = stdlib_idamax( n, work( 1 + (nb+k)*n ), 1 )
                             remax = one / abs( work( ii + (nb+k)*n ) )
                          else if( iscomplex(k)==1 ) then
                             ! first eigenvector of conjugate pair
                             emax = zero
                             do ii = 1, n
                                emax = max( emax,abs( work( ii + (nb+k  )*n ) )+abs( work( ii + (&
                                          nb+k+1)*n ) ) )
                             end do
                             remax = one / emax
                          ! else if iscomplex(k)==-1
                             ! second eigenvector of conjugate pair
                             ! reuse same remax as previous k
                          end if
                          call stdlib_dscal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_dlacpy( 'F', n, nb-iv+1,work( 1 + (nb+iv)*n ), n,vr( 1, ki2 ), &
                                 ldvr )
                       iv = nb
                    else
                       iv = iv - 1
                    end if
                 end if ! blocked back-transform
                 is = is - 1
                 if( ip/=0 )is = is - 1
              end do loop_140
           end if
           if( leftv ) then
              ! ============================================================
              ! compute left eigenvectors.
              ! iv is index of column in current block.
              ! for complex left vector, uses iv for real part and iv+1 for complex part.
              ! non-blocked version always uses iv=1;
              ! blocked     version starts with iv=1, goes up to nb-1 or nb.
              ! (note the "0-th" column is used for 1-norms computed above.)
              iv = 1
              ip = 0
              is = 1
              loop_260: do ki = 1, n
                 if( ip==1 ) then
                    ! previous iteration (ki-1) was first of conjugate pair,
                    ! so this ki is second of conjugate pair; skip to end of loop
                    ip = -1
                    cycle loop_260
                 else if( ki==n ) then
                    ! last column, so this ki must be real eigenvalue
                    ip = 0
                 else if( t( ki+1, ki )==zero ) then
                    ! zero on sub-diagonal, so this ki is real eigenvalue
                    ip = 0
                 else
                    ! non-zero on sub-diagonal, so this ki is first of conjugate pair
                    ip = 1
                 end if
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_260
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki+1 ) ) )*sqrt( abs( t( ki+1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! --------------------------------------------------------
                    ! real left eigenvector
                    work( ki + iv*n ) = one
                    ! form right-hand side.
                    do k = ki + 1, n
                       work( k + iv*n ) = -t( ki, k )
                    end do
                    ! solve transposed quasi-triangular system:
                    ! [ t(ki+1:n,ki+1:n) - wr ]**t * x = scale*work
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 1
                    loop_170: do j = ki + 1, n
                       if( j<jnxt )cycle loop_170
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_dscal( n-ki+1, rec, work( ki+iv*n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+iv*n ) = work( j+iv*n ) -stdlib_ddot( j-ki-1, t( ki+1, j ), 1,&
                                    work( ki+1+iv*n ), 1 )
                          ! solve [ t(j,j) - wr ]**t * x = work
                          call stdlib_dlaln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_dscal( n-ki+1, scale, work( ki+iv*n ), 1 )
                                    
                          work( j+iv*n ) = x( 1, 1 )
                          vmax = max( abs( work( j+iv*n ) ), vmax )
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_dscal( n-ki+1, rec, work( ki+iv*n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+iv*n ) = work( j+iv*n ) -stdlib_ddot( j-ki-1, t( ki+1, j ), 1,&
                                    work( ki+1+iv*n ), 1 )
                          work( j+1+iv*n ) = work( j+1+iv*n ) -stdlib_ddot( j-ki-1, t( ki+1, j+1 )&
                                    , 1,work( ki+1+iv*n ), 1 )
                          ! solve
                          ! [ t(j,j)-wr   t(j,j+1)      ]**t * x = scale*( work1 )
                          ! [ t(j+1,j)    t(j+1,j+1)-wr ]                ( work2 )
                          call stdlib_dlaln2( .true., 2, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_dscal( n-ki+1, scale, work( ki+iv*n ), 1 )
                                    
                          work( j  +iv*n ) = x( 1, 1 )
                          work( j+1+iv*n ) = x( 2, 1 )
                          vmax = max( abs( work( j  +iv*n ) ),abs( work( j+1+iv*n ) ), vmax )
                                    
                          vcrit = bignum / vmax
                       end if
                    end do loop_170
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vl and normalize.
                       call stdlib_dcopy( n-ki+1, work( ki + iv*n ), 1,vl( ki, is ), 1 )
                       ii = stdlib_idamax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                       remax = one / abs( vl( ii, is ) )
                       call stdlib_dscal( n-ki+1, remax, vl( ki, is ), 1 )
                       do k = 1, ki - 1
                          vl( k, is ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki<n )call stdlib_dgemv( 'N', n, n-ki, one,vl( 1, ki+1 ), ldvl,work( &
                                 ki+1 + iv*n ), 1,work( ki   + iv*n ), vl( 1, ki ), 1 )
                       ii = stdlib_idamax( n, vl( 1, ki ), 1 )
                       remax = one / abs( vl( ii, ki ) )
                       call stdlib_dscal( n, remax, vl( 1, ki ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out above vector
                       ! could go from ki-nv+1 to ki-1
                       do k = 1, ki - 1
                          work( k + iv*n ) = zero
                       end do
                       iscomplex( iv ) = ip
                       ! back-transform and normalization is done below
                    end if
                 else
                    ! --------------------------------------------------------
                    ! complex left eigenvector.
                    ! initial solve:
                    ! [ ( t(ki,ki)    t(ki,ki+1)  )**t - (wr - i* wi) ]*x = 0.
                    ! [ ( t(ki+1,ki) t(ki+1,ki+1) )                   ]
                    if( abs( t( ki, ki+1 ) )>=abs( t( ki+1, ki ) ) ) then
                       work( ki   + (iv  )*n ) = wi / t( ki, ki+1 )
                       work( ki+1 + (iv+1)*n ) = one
                    else
                       work( ki   + (iv  )*n ) = one
                       work( ki+1 + (iv+1)*n ) = -wi / t( ki+1, ki )
                    end if
                    work( ki+1 + (iv  )*n ) = zero
                    work( ki   + (iv+1)*n ) = zero
                    ! form right-hand side.
                    do k = ki + 2, n
                       work( k+(iv  )*n ) = -work( ki  +(iv  )*n )*t(ki,  k)
                       work( k+(iv+1)*n ) = -work( ki+1+(iv+1)*n )*t(ki+1,k)
                    end do
                    ! solve transposed quasi-triangular system:
                    ! [ t(ki+2:n,ki+2:n)**t - (wr-i*wi) ]*x = work1+i*work2
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 2
                    loop_200: do j = ki + 2, n
                       if( j<jnxt )cycle loop_200
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when
                          ! forming the right-hand side elements.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_dscal( n-ki+1, rec, work(ki+(iv  )*n), 1 )
                             call stdlib_dscal( n-ki+1, rec, work(ki+(iv+1)*n), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+(iv  )*n ) = work( j+(iv)*n ) -stdlib_ddot( j-ki-2, t( ki+2, j )&
                                    , 1,work( ki+2+(iv)*n ), 1 )
                          work( j+(iv+1)*n ) = work( j+(iv+1)*n ) -stdlib_ddot( j-ki-2, t( ki+2, &
                                    j ), 1,work( ki+2+(iv+1)*n ), 1 )
                          ! solve [ t(j,j)-(wr-i*wi) ]*(x11+i*x12)= wk+i*wk2
                          call stdlib_dlaln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_dscal( n-ki+1, scale, work(ki+(iv  )*n), 1)
                             call stdlib_dscal( n-ki+1, scale, work(ki+(iv+1)*n), 1)
                          end if
                          work( j+(iv  )*n ) = x( 1, 1 )
                          work( j+(iv+1)*n ) = x( 1, 2 )
                          vmax = max( abs( work( j+(iv  )*n ) ),abs( work( j+(iv+1)*n ) ), vmax )
                                    
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side elements.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_dscal( n-ki+1, rec, work(ki+(iv  )*n), 1 )
                             call stdlib_dscal( n-ki+1, rec, work(ki+(iv+1)*n), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j  +(iv  )*n ) = work( j+(iv)*n ) -stdlib_ddot( j-ki-2, t( ki+2, &
                                    j ), 1,work( ki+2+(iv)*n ), 1 )
                          work( j  +(iv+1)*n ) = work( j+(iv+1)*n ) -stdlib_ddot( j-ki-2, t( ki+2,&
                                     j ), 1,work( ki+2+(iv+1)*n ), 1 )
                          work( j+1+(iv  )*n ) = work( j+1+(iv)*n ) -stdlib_ddot( j-ki-2, t( ki+2,&
                                     j+1 ), 1,work( ki+2+(iv)*n ), 1 )
                          work( j+1+(iv+1)*n ) = work( j+1+(iv+1)*n ) -stdlib_ddot( j-ki-2, t( ki+&
                                    2, j+1 ), 1,work( ki+2+(iv+1)*n ), 1 )
                          ! solve 2-by-2 complex linear equation
                          ! [ (t(j,j)   t(j,j+1)  )**t - (wr-i*wi)*i ]*x = scale*b
                          ! [ (t(j+1,j) t(j+1,j+1))                  ]
                          call stdlib_dlaln2( .true., 2, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_dscal( n-ki+1, scale, work(ki+(iv  )*n), 1)
                             call stdlib_dscal( n-ki+1, scale, work(ki+(iv+1)*n), 1)
                          end if
                          work( j  +(iv  )*n ) = x( 1, 1 )
                          work( j  +(iv+1)*n ) = x( 1, 2 )
                          work( j+1+(iv  )*n ) = x( 2, 1 )
                          work( j+1+(iv+1)*n ) = x( 2, 2 )
                          vmax = max( abs( x( 1, 1 ) ), abs( x( 1, 2 ) ),abs( x( 2, 1 ) ), abs( x(&
                                     2, 2 ) ),vmax )
                          vcrit = bignum / vmax
                       end if
                    end do loop_200
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vl and normalize.
                       call stdlib_dcopy( n-ki+1, work( ki + (iv  )*n ), 1,vl( ki, is   ), 1 )
                                 
                       call stdlib_dcopy( n-ki+1, work( ki + (iv+1)*n ), 1,vl( ki, is+1 ), 1 )
                                 
                       emax = zero
                       do k = ki, n
                          emax = max( emax, abs( vl( k, is   ) )+abs( vl( k, is+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_dscal( n-ki+1, remax, vl( ki, is   ), 1 )
                       call stdlib_dscal( n-ki+1, remax, vl( ki, is+1 ), 1 )
                       do k = 1, ki - 1
                          vl( k, is   ) = zero
                          vl( k, is+1 ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki<n-1 ) then
                          call stdlib_dgemv( 'N', n, n-ki-1, one,vl( 1, ki+2 ), ldvl,work( ki+2 + &
                                    (iv)*n ), 1,work( ki   + (iv)*n ),vl( 1, ki ), 1 )
                          call stdlib_dgemv( 'N', n, n-ki-1, one,vl( 1, ki+2 ), ldvl,work( ki+2 + &
                                    (iv+1)*n ), 1,work( ki+1 + (iv+1)*n ),vl( 1, ki+1 ), 1 )
                       else
                          call stdlib_dscal( n, work(ki+  (iv  )*n), vl(1, ki  ), 1)
                          call stdlib_dscal( n, work(ki+1+(iv+1)*n), vl(1, ki+1), 1)
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vl( k, ki   ) )+abs( vl( k, ki+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_dscal( n, remax, vl( 1, ki   ), 1 )
                       call stdlib_dscal( n, remax, vl( 1, ki+1 ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out above vector
                       ! could go from ki-nv+1 to ki-1
                       do k = 1, ki - 1
                          work( k + (iv  )*n ) = zero
                          work( k + (iv+1)*n ) = zero
                       end do
                       iscomplex( iv   ) =  ip
                       iscomplex( iv+1 ) = -ip
                       iv = iv + 1
                       ! back-transform and normalization is done below
                    end if
                 end if
                 if( nb>1 ) then
                    ! --------------------------------------------------------
                    ! blocked version of back-transform
                    ! for complex case, ki2 includes both vectors (ki and ki+1)
                    if( ip==0 ) then
                       ki2 = ki
                    else
                       ki2 = ki + 1
                    end if
                    ! columns 1:iv of work are valid vectors.
                    ! when the number of vectors stored reaches nb-1 or nb,
                    ! or if this was last vector, do the gemm
                    if( (iv>=nb-1) .or. (ki2==n) ) then
                       call stdlib_dgemm( 'N', 'N', n, iv, n-ki2+iv, one,vl( 1, ki2-iv+1 ), ldvl,&
                                 work( ki2-iv+1 + (1)*n ), n,zero,work( 1 + (nb+1)*n ), n )
                       ! normalize vectors
                       do k = 1, iv
                          if( iscomplex(k)==0) then
                             ! real eigenvector
                             ii = stdlib_idamax( n, work( 1 + (nb+k)*n ), 1 )
                             remax = one / abs( work( ii + (nb+k)*n ) )
                          else if( iscomplex(k)==1) then
                             ! first eigenvector of conjugate pair
                             emax = zero
                             do ii = 1, n
                                emax = max( emax,abs( work( ii + (nb+k  )*n ) )+abs( work( ii + (&
                                          nb+k+1)*n ) ) )
                             end do
                             remax = one / emax
                          ! else if iscomplex(k)==-1
                             ! second eigenvector of conjugate pair
                             ! reuse same remax as previous k
                          end if
                          call stdlib_dscal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_dlacpy( 'F', n, iv,work( 1 + (nb+1)*n ), n,vl( 1, ki2-iv+1 ), &
                                 ldvl )
                       iv = 1
                    else
                       iv = iv + 1
                    end if
                 end if ! blocked back-transform
                 is = is + 1
                 if( ip/=0 )is = is + 1
              end do loop_260
           end if
           return
     end subroutine stdlib_dtrevc3

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$trevc3( side, howmny, select, n, t, ldt, vl, ldvl,vr, ldvr, mm, m, &
     !! DTREVC3: computes some or all of the right and/or left eigenvectors of
     !! a real upper quasi-triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a real general matrix:  A = Q*T*Q**T, as computed by DHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**T)*T = w*(y**T)
     !! where y**T denotes the transpose of the vector y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal blocks of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix. If Q is the orthogonal factor that reduces a matrix
     !! A to Schur form T, then Q*X and Q*Y are the matrices of right and
     !! left eigenvectors of A.
     !! This uses a Level 3 BLAS version of the back transformation.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, lwork, mm, n
           ! Array Arguments 
           logical(lk), intent(inout) :: select(*)
           real(${rk}$), intent(in) :: t(ldt,*)
           real(${rk}$), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmin = 8
           integer(ilp), parameter :: nbmax = 128
           
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, lquery, over, pair, rightv, somev
           integer(ilp) :: i, ierr, ii, ip, is, j, j1, j2, jnxt, k, ki, iv, maxwrk, nb, &
                     ki2
           real(${rk}$) :: beta, bignum, emax, ovfl, rec, remax, scale, smin, smlnum, ulp, unfl, &
                     vcrit, vmax, wi, wr, xnorm
           ! Intrinsic Functions 
           ! Local Arrays 
           real(${rk}$) :: x(2,2)
           integer(ilp) :: iscomplex(nbmax)
           ! Executable Statements 
           ! decode and test the input parameters
           bothv  = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv  = stdlib_lsame( side, 'L' ) .or. bothv
           allv  = stdlib_lsame( howmny, 'A' )
           over  = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           info = 0
           nb = stdlib_ilaenv( 1, 'DTREVC', side // howmny, n, -1, -1, -1 )
           maxwrk = n + 2*n*nb
           work(1) = maxwrk
           lquery = ( lwork==-1 )
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else if( lwork<max( 1, 3*n ) .and. .not.lquery ) then
              info = -14
           else
              ! set m to the number of columns required to store the selected
              ! eigenvectors, standardize the array select if necessary, and
              ! test mm.
              if( somev ) then
                 m = 0
                 pair = .false.
                 do j = 1, n
                    if( pair ) then
                       pair = .false.
                       select( j ) = .false.
                    else
                       if( j<n ) then
                          if( t( j+1, j )==zero ) then
                             if( select( j ) )m = m + 1
                          else
                             pair = .true.
                             if( select( j ) .or. select( j+1 ) ) then
                                select( j ) = .true.
                                m = m + 2
                             end if
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( mm<m ) then
                 info = -11
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTREVC3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! use blocked version of back-transformation if sufficient workspace.
           ! zero-out the workspace to avoid potential nan propagation.
           if( over .and. lwork >= n + 2*n*nbmin ) then
              nb = (lwork - n) / (2*n)
              nb = min( nb, nbmax )
              call stdlib_${ri}$laset( 'F', n, 1+2*nb, zero, zero, work, n )
           else
              nb = 1
           end if
           ! set the constants to control overflow.
           unfl = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_${ri}$labad( unfl, ovfl )
           ulp = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           bignum = ( one-ulp ) / smlnum
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           work( 1 ) = zero
           do j = 2, n
              work( j ) = zero
              do i = 1, j - 1
                 work( j ) = work( j ) + abs( t( i, j ) )
              end do
           end do
           ! index ip is used to specify the real or complex eigenvalue:
             ! ip = 0, real eigenvalue,
                  ! 1, first  of conjugate complex pair: (wr,wi)
                 ! -1, second of conjugate complex pair: (wr,wi)
             ! iscomplex array stores ip for each column in current block.
           if( rightv ) then
              ! ============================================================
              ! compute right eigenvectors.
              ! iv is index of column in current block.
              ! for complex right vector, uses iv-1 for real part and iv for complex part.
              ! non-blocked version always uses iv=2;
              ! blocked     version starts with iv=nb, goes down to 1 or 2.
              ! (note the "0-th" column is used for 1-norms computed above.)
              iv = 2
              if( nb>2 ) then
                 iv = nb
              end if
              ip = 0
              is = m
              loop_140: do ki = n, 1, -1
                 if( ip==-1 ) then
                    ! previous iteration (ki+1) was second of conjugate pair,
                    ! so this ki is first of conjugate pair; skip to end of loop
                    ip = 1
                    cycle loop_140
                 else if( ki==1 ) then
                    ! last column, so this ki must be real eigenvalue
                    ip = 0
                 else if( t( ki, ki-1 )==zero ) then
                    ! zero on sub-diagonal, so this ki is real eigenvalue
                    ip = 0
                 else
                    ! non-zero on sub-diagonal, so this ki is second of conjugate pair
                    ip = -1
                 end if
                 if( somev ) then
                    if( ip==0 ) then
                       if( .not.select( ki ) )cycle loop_140
                    else
                       if( .not.select( ki-1 ) )cycle loop_140
                    end if
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki-1 ) ) )*sqrt( abs( t( ki-1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! --------------------------------------------------------
                    ! real right eigenvector
                    work( ki + iv*n ) = one
                    ! form right-hand side.
                    do k = 1, ki - 1
                       work( k + iv*n ) = -t( k, ki )
                    end do
                    ! solve upper quasi-triangular system:
                    ! [ t(1:ki-1,1:ki-1) - wr ]*x = scale*work.
                    jnxt = ki - 1
                    loop_60: do j = ki - 1, 1, -1
                       if( j>jnxt )cycle loop_60
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1   = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_${ri}$laln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( ki, scale, work( 1+iv*n ), 1 )
                                    
                          work( j+iv*n ) = x( 1, 1 )
                          ! update right-hand side
                          call stdlib_${ri}$axpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+iv*n ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_${ri}$laln2( .false., 2, 1, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+iv*n ), n, wr, zero, x, 2,scale, xnorm, ierr )
                          ! scale x(1,1) and x(2,1) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 2, 1 ) = x( 2, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( ki, scale, work( 1+iv*n ), 1 )
                                    
                          work( j-1+iv*n ) = x( 1, 1 )
                          work( j  +iv*n ) = x( 2, 1 )
                          ! update right-hand side
                          call stdlib_${ri}$axpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+iv*n ), 1 )
                                    
                          call stdlib_${ri}$axpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+iv*n ), 1 )
                                    
                       end if
                    end do loop_60
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vr and normalize.
                       call stdlib_${ri}$copy( ki, work( 1 + iv*n ), 1, vr( 1, is ), 1 )
                       ii = stdlib_i${ri}$amax( ki, vr( 1, is ), 1 )
                       remax = one / abs( vr( ii, is ) )
                       call stdlib_${ri}$scal( ki, remax, vr( 1, is ), 1 )
                       do k = ki + 1, n
                          vr( k, is ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki>1 )call stdlib_${ri}$gemv( 'N', n, ki-1, one, vr, ldvr,work( 1 + iv*n ), &
                                 1, work( ki + iv*n ),vr( 1, ki ), 1 )
                       ii = stdlib_i${ri}$amax( n, vr( 1, ki ), 1 )
                       remax = one / abs( vr( ii, ki ) )
                       call stdlib_${ri}$scal( n, remax, vr( 1, ki ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out below vector
                       do k = ki + 1, n
                          work( k + iv*n ) = zero
                       end do
                       iscomplex( iv ) = ip
                       ! back-transform and normalization is done below
                    end if
                 else
                    ! --------------------------------------------------------
                    ! complex right eigenvector.
                    ! initial solve
                    ! [ ( t(ki-1,ki-1) t(ki-1,ki) ) - (wr + i*wi) ]*x = 0.
                    ! [ ( t(ki,  ki-1) t(ki,  ki) )               ]
                    if( abs( t( ki-1, ki ) )>=abs( t( ki, ki-1 ) ) ) then
                       work( ki-1 + (iv-1)*n ) = one
                       work( ki   + (iv  )*n ) = wi / t( ki-1, ki )
                    else
                       work( ki-1 + (iv-1)*n ) = -wi / t( ki, ki-1 )
                       work( ki   + (iv  )*n ) = one
                    end if
                    work( ki   + (iv-1)*n ) = zero
                    work( ki-1 + (iv  )*n ) = zero
                    ! form right-hand side.
                    do k = 1, ki - 2
                       work( k+(iv-1)*n ) = -work( ki-1+(iv-1)*n )*t(k,ki-1)
                       work( k+(iv  )*n ) = -work( ki  +(iv  )*n )*t(k,ki  )
                    end do
                    ! solve upper quasi-triangular system:
                    ! [ t(1:ki-2,1:ki-2) - (wr+i*wi) ]*x = scale*(work+i*work2)
                    jnxt = ki - 2
                    loop_90: do j = ki - 2, 1, -1
                       if( j>jnxt )cycle loop_90
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1   = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_${ri}$laln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+(iv-1)*n ), n,wr, wi, x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) and x(1,2) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 1, 2 ) = x( 1, 2 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( ki, scale, work( 1+(iv-1)*n ), 1 )
                             call stdlib_${ri}$scal( ki, scale, work( 1+(iv  )*n ), 1 )
                          end if
                          work( j+(iv-1)*n ) = x( 1, 1 )
                          work( j+(iv  )*n ) = x( 1, 2 )
                          ! update the right-hand side
                          call stdlib_${ri}$axpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+(iv-1)*n ), 1 )
                                    
                          call stdlib_${ri}$axpy( j-1, -x( 1, 2 ), t( 1, j ), 1,work( 1+(iv  )*n ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_${ri}$laln2( .false., 2, 2, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+(iv-1)*n ), n, wr, wi, x, 2,scale, xnorm, ierr )
                          ! scale x to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                rec = one / xnorm
                                x( 1, 1 ) = x( 1, 1 )*rec
                                x( 1, 2 ) = x( 1, 2 )*rec
                                x( 2, 1 ) = x( 2, 1 )*rec
                                x( 2, 2 ) = x( 2, 2 )*rec
                                scale = scale*rec
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( ki, scale, work( 1+(iv-1)*n ), 1 )
                             call stdlib_${ri}$scal( ki, scale, work( 1+(iv  )*n ), 1 )
                          end if
                          work( j-1+(iv-1)*n ) = x( 1, 1 )
                          work( j  +(iv-1)*n ) = x( 2, 1 )
                          work( j-1+(iv  )*n ) = x( 1, 2 )
                          work( j  +(iv  )*n ) = x( 2, 2 )
                          ! update the right-hand side
                          call stdlib_${ri}$axpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+(iv-1)*n   ),&
                                     1 )
                          call stdlib_${ri}$axpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+(iv-1)*n   ), &
                                    1 )
                          call stdlib_${ri}$axpy( j-2, -x( 1, 2 ), t( 1, j-1 ), 1,work( 1+(iv  )*n ), &
                                    1 )
                          call stdlib_${ri}$axpy( j-2, -x( 2, 2 ), t( 1, j ), 1,work( 1+(iv  )*n ), 1 )
                                    
                       end if
                    end do loop_90
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vr and normalize.
                       call stdlib_${ri}$copy( ki, work( 1+(iv-1)*n ), 1, vr(1,is-1), 1 )
                       call stdlib_${ri}$copy( ki, work( 1+(iv  )*n ), 1, vr(1,is  ), 1 )
                       emax = zero
                       do k = 1, ki
                          emax = max( emax, abs( vr( k, is-1 ) )+abs( vr( k, is   ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( ki, remax, vr( 1, is-1 ), 1 )
                       call stdlib_${ri}$scal( ki, remax, vr( 1, is   ), 1 )
                       do k = ki + 1, n
                          vr( k, is-1 ) = zero
                          vr( k, is   ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki>2 ) then
                          call stdlib_${ri}$gemv( 'N', n, ki-2, one, vr, ldvr,work( 1    + (iv-1)*n ), &
                                    1,work( ki-1 + (iv-1)*n ), vr(1,ki-1), 1)
                          call stdlib_${ri}$gemv( 'N', n, ki-2, one, vr, ldvr,work( 1  + (iv)*n ), 1,&
                                    work( ki + (iv)*n ), vr( 1, ki ), 1 )
                       else
                          call stdlib_${ri}$scal( n, work(ki-1+(iv-1)*n), vr(1,ki-1), 1)
                          call stdlib_${ri}$scal( n, work(ki  +(iv  )*n), vr(1,ki  ), 1)
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vr( k, ki-1 ) )+abs( vr( k, ki   ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( n, remax, vr( 1, ki-1 ), 1 )
                       call stdlib_${ri}$scal( n, remax, vr( 1, ki   ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out below vector
                       do k = ki + 1, n
                          work( k + (iv-1)*n ) = zero
                          work( k + (iv  )*n ) = zero
                       end do
                       iscomplex( iv-1 ) = -ip
                       iscomplex( iv   ) =  ip
                       iv = iv - 1
                       ! back-transform and normalization is done below
                    end if
                 end if
                 if( nb>1 ) then
                    ! --------------------------------------------------------
                    ! blocked version of back-transform
                    ! for complex case, ki2 includes both vectors (ki-1 and ki)
                    if( ip==0 ) then
                       ki2 = ki
                    else
                       ki2 = ki - 1
                    end if
                    ! columns iv:nb of work are valid vectors.
                    ! when the number of vectors stored reaches nb-1 or nb,
                    ! or if this was last vector, do the gemm
                    if( (iv<=2) .or. (ki2==1) ) then
                       call stdlib_${ri}$gemm( 'N', 'N', n, nb-iv+1, ki2+nb-iv, one,vr, ldvr,work( 1 + &
                                 (iv)*n    ), n,zero,work( 1 + (nb+iv)*n ), n )
                       ! normalize vectors
                       do k = iv, nb
                          if( iscomplex(k)==0 ) then
                             ! real eigenvector
                             ii = stdlib_i${ri}$amax( n, work( 1 + (nb+k)*n ), 1 )
                             remax = one / abs( work( ii + (nb+k)*n ) )
                          else if( iscomplex(k)==1 ) then
                             ! first eigenvector of conjugate pair
                             emax = zero
                             do ii = 1, n
                                emax = max( emax,abs( work( ii + (nb+k  )*n ) )+abs( work( ii + (&
                                          nb+k+1)*n ) ) )
                             end do
                             remax = one / emax
                          ! else if iscomplex(k)==-1
                             ! second eigenvector of conjugate pair
                             ! reuse same remax as previous k
                          end if
                          call stdlib_${ri}$scal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_${ri}$lacpy( 'F', n, nb-iv+1,work( 1 + (nb+iv)*n ), n,vr( 1, ki2 ), &
                                 ldvr )
                       iv = nb
                    else
                       iv = iv - 1
                    end if
                 end if ! blocked back-transform
                 is = is - 1
                 if( ip/=0 )is = is - 1
              end do loop_140
           end if
           if( leftv ) then
              ! ============================================================
              ! compute left eigenvectors.
              ! iv is index of column in current block.
              ! for complex left vector, uses iv for real part and iv+1 for complex part.
              ! non-blocked version always uses iv=1;
              ! blocked     version starts with iv=1, goes up to nb-1 or nb.
              ! (note the "0-th" column is used for 1-norms computed above.)
              iv = 1
              ip = 0
              is = 1
              loop_260: do ki = 1, n
                 if( ip==1 ) then
                    ! previous iteration (ki-1) was first of conjugate pair,
                    ! so this ki is second of conjugate pair; skip to end of loop
                    ip = -1
                    cycle loop_260
                 else if( ki==n ) then
                    ! last column, so this ki must be real eigenvalue
                    ip = 0
                 else if( t( ki+1, ki )==zero ) then
                    ! zero on sub-diagonal, so this ki is real eigenvalue
                    ip = 0
                 else
                    ! non-zero on sub-diagonal, so this ki is first of conjugate pair
                    ip = 1
                 end if
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_260
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki+1 ) ) )*sqrt( abs( t( ki+1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! --------------------------------------------------------
                    ! real left eigenvector
                    work( ki + iv*n ) = one
                    ! form right-hand side.
                    do k = ki + 1, n
                       work( k + iv*n ) = -t( ki, k )
                    end do
                    ! solve transposed quasi-triangular system:
                    ! [ t(ki+1:n,ki+1:n) - wr ]**t * x = scale*work
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 1
                    loop_170: do j = ki + 1, n
                       if( j<jnxt )cycle loop_170
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+iv*n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+iv*n ) = work( j+iv*n ) -stdlib_${ri}$dot( j-ki-1, t( ki+1, j ), 1,&
                                    work( ki+1+iv*n ), 1 )
                          ! solve [ t(j,j) - wr ]**t * x = work
                          call stdlib_${ri}$laln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( n-ki+1, scale, work( ki+iv*n ), 1 )
                                    
                          work( j+iv*n ) = x( 1, 1 )
                          vmax = max( abs( work( j+iv*n ) ), vmax )
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+iv*n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+iv*n ) = work( j+iv*n ) -stdlib_${ri}$dot( j-ki-1, t( ki+1, j ), 1,&
                                    work( ki+1+iv*n ), 1 )
                          work( j+1+iv*n ) = work( j+1+iv*n ) -stdlib_${ri}$dot( j-ki-1, t( ki+1, j+1 )&
                                    , 1,work( ki+1+iv*n ), 1 )
                          ! solve
                          ! [ t(j,j)-wr   t(j,j+1)      ]**t * x = scale*( work1 )
                          ! [ t(j+1,j)    t(j+1,j+1)-wr ]                ( work2 )
                          call stdlib_${ri}$laln2( .true., 2, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( n-ki+1, scale, work( ki+iv*n ), 1 )
                                    
                          work( j  +iv*n ) = x( 1, 1 )
                          work( j+1+iv*n ) = x( 2, 1 )
                          vmax = max( abs( work( j  +iv*n ) ),abs( work( j+1+iv*n ) ), vmax )
                                    
                          vcrit = bignum / vmax
                       end if
                    end do loop_170
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vl and normalize.
                       call stdlib_${ri}$copy( n-ki+1, work( ki + iv*n ), 1,vl( ki, is ), 1 )
                       ii = stdlib_i${ri}$amax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                       remax = one / abs( vl( ii, is ) )
                       call stdlib_${ri}$scal( n-ki+1, remax, vl( ki, is ), 1 )
                       do k = 1, ki - 1
                          vl( k, is ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki<n )call stdlib_${ri}$gemv( 'N', n, n-ki, one,vl( 1, ki+1 ), ldvl,work( &
                                 ki+1 + iv*n ), 1,work( ki   + iv*n ), vl( 1, ki ), 1 )
                       ii = stdlib_i${ri}$amax( n, vl( 1, ki ), 1 )
                       remax = one / abs( vl( ii, ki ) )
                       call stdlib_${ri}$scal( n, remax, vl( 1, ki ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out above vector
                       ! could go from ki-nv+1 to ki-1
                       do k = 1, ki - 1
                          work( k + iv*n ) = zero
                       end do
                       iscomplex( iv ) = ip
                       ! back-transform and normalization is done below
                    end if
                 else
                    ! --------------------------------------------------------
                    ! complex left eigenvector.
                    ! initial solve:
                    ! [ ( t(ki,ki)    t(ki,ki+1)  )**t - (wr - i* wi) ]*x = 0.
                    ! [ ( t(ki+1,ki) t(ki+1,ki+1) )                   ]
                    if( abs( t( ki, ki+1 ) )>=abs( t( ki+1, ki ) ) ) then
                       work( ki   + (iv  )*n ) = wi / t( ki, ki+1 )
                       work( ki+1 + (iv+1)*n ) = one
                    else
                       work( ki   + (iv  )*n ) = one
                       work( ki+1 + (iv+1)*n ) = -wi / t( ki+1, ki )
                    end if
                    work( ki+1 + (iv  )*n ) = zero
                    work( ki   + (iv+1)*n ) = zero
                    ! form right-hand side.
                    do k = ki + 2, n
                       work( k+(iv  )*n ) = -work( ki  +(iv  )*n )*t(ki,  k)
                       work( k+(iv+1)*n ) = -work( ki+1+(iv+1)*n )*t(ki+1,k)
                    end do
                    ! solve transposed quasi-triangular system:
                    ! [ t(ki+2:n,ki+2:n)**t - (wr-i*wi) ]*x = work1+i*work2
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 2
                    loop_200: do j = ki + 2, n
                       if( j<jnxt )cycle loop_200
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when
                          ! forming the right-hand side elements.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work(ki+(iv  )*n), 1 )
                             call stdlib_${ri}$scal( n-ki+1, rec, work(ki+(iv+1)*n), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+(iv  )*n ) = work( j+(iv)*n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, j )&
                                    , 1,work( ki+2+(iv)*n ), 1 )
                          work( j+(iv+1)*n ) = work( j+(iv+1)*n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, &
                                    j ), 1,work( ki+2+(iv+1)*n ), 1 )
                          ! solve [ t(j,j)-(wr-i*wi) ]*(x11+i*x12)= wk+i*wk2
                          call stdlib_${ri}$laln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( n-ki+1, scale, work(ki+(iv  )*n), 1)
                             call stdlib_${ri}$scal( n-ki+1, scale, work(ki+(iv+1)*n), 1)
                          end if
                          work( j+(iv  )*n ) = x( 1, 1 )
                          work( j+(iv+1)*n ) = x( 1, 2 )
                          vmax = max( abs( work( j+(iv  )*n ) ),abs( work( j+(iv+1)*n ) ), vmax )
                                    
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side elements.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work(ki+(iv  )*n), 1 )
                             call stdlib_${ri}$scal( n-ki+1, rec, work(ki+(iv+1)*n), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j  +(iv  )*n ) = work( j+(iv)*n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, &
                                    j ), 1,work( ki+2+(iv)*n ), 1 )
                          work( j  +(iv+1)*n ) = work( j+(iv+1)*n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2,&
                                     j ), 1,work( ki+2+(iv+1)*n ), 1 )
                          work( j+1+(iv  )*n ) = work( j+1+(iv)*n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2,&
                                     j+1 ), 1,work( ki+2+(iv)*n ), 1 )
                          work( j+1+(iv+1)*n ) = work( j+1+(iv+1)*n ) -stdlib_${ri}$dot( j-ki-2, t( ki+&
                                    2, j+1 ), 1,work( ki+2+(iv+1)*n ), 1 )
                          ! solve 2-by-2 complex linear equation
                          ! [ (t(j,j)   t(j,j+1)  )**t - (wr-i*wi)*i ]*x = scale*b
                          ! [ (t(j+1,j) t(j+1,j+1))                  ]
                          call stdlib_${ri}$laln2( .true., 2, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+iv*n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( n-ki+1, scale, work(ki+(iv  )*n), 1)
                             call stdlib_${ri}$scal( n-ki+1, scale, work(ki+(iv+1)*n), 1)
                          end if
                          work( j  +(iv  )*n ) = x( 1, 1 )
                          work( j  +(iv+1)*n ) = x( 1, 2 )
                          work( j+1+(iv  )*n ) = x( 2, 1 )
                          work( j+1+(iv+1)*n ) = x( 2, 2 )
                          vmax = max( abs( x( 1, 1 ) ), abs( x( 1, 2 ) ),abs( x( 2, 1 ) ), abs( x(&
                                     2, 2 ) ),vmax )
                          vcrit = bignum / vmax
                       end if
                    end do loop_200
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       ! ------------------------------
                       ! no back-transform: copy x to vl and normalize.
                       call stdlib_${ri}$copy( n-ki+1, work( ki + (iv  )*n ), 1,vl( ki, is   ), 1 )
                                 
                       call stdlib_${ri}$copy( n-ki+1, work( ki + (iv+1)*n ), 1,vl( ki, is+1 ), 1 )
                                 
                       emax = zero
                       do k = ki, n
                          emax = max( emax, abs( vl( k, is   ) )+abs( vl( k, is+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( n-ki+1, remax, vl( ki, is   ), 1 )
                       call stdlib_${ri}$scal( n-ki+1, remax, vl( ki, is+1 ), 1 )
                       do k = 1, ki - 1
                          vl( k, is   ) = zero
                          vl( k, is+1 ) = zero
                       end do
                    else if( nb==1 ) then
                       ! ------------------------------
                       ! version 1: back-transform each vector with gemv, q*x.
                       if( ki<n-1 ) then
                          call stdlib_${ri}$gemv( 'N', n, n-ki-1, one,vl( 1, ki+2 ), ldvl,work( ki+2 + &
                                    (iv)*n ), 1,work( ki   + (iv)*n ),vl( 1, ki ), 1 )
                          call stdlib_${ri}$gemv( 'N', n, n-ki-1, one,vl( 1, ki+2 ), ldvl,work( ki+2 + &
                                    (iv+1)*n ), 1,work( ki+1 + (iv+1)*n ),vl( 1, ki+1 ), 1 )
                       else
                          call stdlib_${ri}$scal( n, work(ki+  (iv  )*n), vl(1, ki  ), 1)
                          call stdlib_${ri}$scal( n, work(ki+1+(iv+1)*n), vl(1, ki+1), 1)
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vl( k, ki   ) )+abs( vl( k, ki+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( n, remax, vl( 1, ki   ), 1 )
                       call stdlib_${ri}$scal( n, remax, vl( 1, ki+1 ), 1 )
                    else
                       ! ------------------------------
                       ! version 2: back-transform block of vectors with gemm
                       ! zero out above vector
                       ! could go from ki-nv+1 to ki-1
                       do k = 1, ki - 1
                          work( k + (iv  )*n ) = zero
                          work( k + (iv+1)*n ) = zero
                       end do
                       iscomplex( iv   ) =  ip
                       iscomplex( iv+1 ) = -ip
                       iv = iv + 1
                       ! back-transform and normalization is done below
                    end if
                 end if
                 if( nb>1 ) then
                    ! --------------------------------------------------------
                    ! blocked version of back-transform
                    ! for complex case, ki2 includes both vectors (ki and ki+1)
                    if( ip==0 ) then
                       ki2 = ki
                    else
                       ki2 = ki + 1
                    end if
                    ! columns 1:iv of work are valid vectors.
                    ! when the number of vectors stored reaches nb-1 or nb,
                    ! or if this was last vector, do the gemm
                    if( (iv>=nb-1) .or. (ki2==n) ) then
                       call stdlib_${ri}$gemm( 'N', 'N', n, iv, n-ki2+iv, one,vl( 1, ki2-iv+1 ), ldvl,&
                                 work( ki2-iv+1 + (1)*n ), n,zero,work( 1 + (nb+1)*n ), n )
                       ! normalize vectors
                       do k = 1, iv
                          if( iscomplex(k)==0) then
                             ! real eigenvector
                             ii = stdlib_i${ri}$amax( n, work( 1 + (nb+k)*n ), 1 )
                             remax = one / abs( work( ii + (nb+k)*n ) )
                          else if( iscomplex(k)==1) then
                             ! first eigenvector of conjugate pair
                             emax = zero
                             do ii = 1, n
                                emax = max( emax,abs( work( ii + (nb+k  )*n ) )+abs( work( ii + (&
                                          nb+k+1)*n ) ) )
                             end do
                             remax = one / emax
                          ! else if iscomplex(k)==-1
                             ! second eigenvector of conjugate pair
                             ! reuse same remax as previous k
                          end if
                          call stdlib_${ri}$scal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_${ri}$lacpy( 'F', n, iv,work( 1 + (nb+1)*n ), n,vl( 1, ki2-iv+1 ), &
                                 ldvl )
                       iv = 1
                    else
                       iv = iv + 1
                    end if
                 end if ! blocked back-transform
                 is = is + 1
                 if( ip/=0 )is = is + 1
              end do loop_260
           end if
           return
     end subroutine stdlib_${ri}$trevc3

#:endif
#:endfor

     pure subroutine stdlib_ctrevc3( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
     !! CTREVC3 computes some or all of the right and/or left eigenvectors of
     !! a complex upper triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a complex general matrix:  A = Q*T*Q**H, as computed by CHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**H)*T = w*(y**H)
     !! where y**H denotes the conjugate transpose of the vector y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix. If Q is the unitary factor that reduces a matrix A to
     !! Schur form T, then Q*X and Q*Y are the matrices of right and left
     !! eigenvectors of A.
     !! This uses a Level 3 BLAS version of the back transformation.
               work, lwork, rwork, lrwork, info)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, lwork, lrwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmin = 8
           integer(ilp), parameter :: nbmax = 128
           
           
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, lquery, over, rightv, somev
           integer(ilp) :: i, ii, is, j, k, ki, iv, maxwrk, nb
           real(sp) :: ovfl, remax, scale, smin, smlnum, ulp, unfl
           complex(sp) :: cdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters
           bothv  = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv  = stdlib_lsame( side, 'L' ) .or. bothv
           allv  = stdlib_lsame( howmny, 'A' )
           over  = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           ! set m to the number of columns required to store the selected
           ! eigenvectors.
           if( somev ) then
              m = 0
              do j = 1, n
                 if( select( j ) )m = m + 1
              end do
           else
              m = n
           end if
           info = 0
           nb = stdlib_ilaenv( 1, 'CTREVC', side // howmny, n, -1, -1, -1 )
           maxwrk = n + 2*n*nb
           work(1) = maxwrk
           rwork(1) = n
           lquery = ( lwork==-1 .or. lrwork==-1 )
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else if( mm<m ) then
              info = -11
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -14
           else if ( lrwork<max( 1, n ) .and. .not.lquery ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTREVC3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! use blocked version of back-transformation if sufficient workspace.
           ! zero-out the workspace to avoid potential nan propagation.
           if( over .and. lwork >= n + 2*n*nbmin ) then
              nb = (lwork - n) / (2*n)
              nb = min( nb, nbmax )
              call stdlib_claset( 'F', n, 1+2*nb, czero, czero, work, n )
           else
              nb = 1
           end if
           ! set the constants to control overflow.
           unfl = stdlib_slamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_slabad( unfl, ovfl )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           ! store the diagonal elements of t in working array work.
           do i = 1, n
              work( i ) = t( i, i )
           end do
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           rwork( 1 ) = zero
           do j = 2, n
              rwork( j ) = stdlib_scasum( j-1, t( 1, j ), 1 )
           end do
           if( rightv ) then
              ! ============================================================
              ! compute right eigenvectors.
              ! iv is index of column in current block.
              ! non-blocked version always uses iv=nb=1;
              ! blocked     version starts with iv=nb, goes down to 1.
              ! (note the "0-th" column is used to store the original diagonal.)
              iv = nb
              is = m
              loop_80: do ki = n, 1, -1
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_80
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 ! --------------------------------------------------------
                 ! complex right eigenvector
                 work( ki + iv*n ) = cone
                 ! form right-hand side.
                 do k = 1, ki - 1
                    work( k + iv*n ) = -t( k, ki )
                 end do
                 ! solve upper triangular system:
                 ! [ t(1:ki-1,1:ki-1) - t(ki,ki) ]*x = scale*work.
                 do k = 1, ki - 1
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki>1 ) then
                    call stdlib_clatrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', 'Y',ki-1, t, ldt, &
                              work( 1 + iv*n ), scale,rwork, info )
                    work( ki + iv*n ) = scale
                 end if
                 ! copy the vector x or q*x to vr and normalize.
                 if( .not.over ) then
                    ! ------------------------------
                    ! no back-transform: copy x to vr and normalize.
                    call stdlib_ccopy( ki, work( 1 + iv*n ), 1, vr( 1, is ), 1 )
                    ii = stdlib_icamax( ki, vr( 1, is ), 1 )
                    remax = one / cabs1( vr( ii, is ) )
                    call stdlib_csscal( ki, remax, vr( 1, is ), 1 )
                    do k = ki + 1, n
                       vr( k, is ) = czero
                    end do
                 else if( nb==1 ) then
                    ! ------------------------------
                    ! version 1: back-transform each vector with gemv, q*x.
                    if( ki>1 )call stdlib_cgemv( 'N', n, ki-1, cone, vr, ldvr,work( 1 + iv*n ), 1,&
                               cmplx( scale,KIND=sp),vr( 1, ki ), 1 )
                    ii = stdlib_icamax( n, vr( 1, ki ), 1 )
                    remax = one / cabs1( vr( ii, ki ) )
                    call stdlib_csscal( n, remax, vr( 1, ki ), 1 )
                 else
                    ! ------------------------------
                    ! version 2: back-transform block of vectors with gemm
                    ! zero out below vector
                    do k = ki + 1, n
                       work( k + iv*n ) = czero
                    end do
                    ! columns iv:nb of work are valid vectors.
                    ! when the number of vectors stored reaches nb,
                    ! or if this was last vector, do the gemm
                    if( (iv==1) .or. (ki==1) ) then
                       call stdlib_cgemm( 'N', 'N', n, nb-iv+1, ki+nb-iv, cone,vr, ldvr,work( 1 + &
                                 (iv)*n    ), n,czero,work( 1 + (nb+iv)*n ), n )
                       ! normalize vectors
                       do k = iv, nb
                          ii = stdlib_icamax( n, work( 1 + (nb+k)*n ), 1 )
                          remax = one / cabs1( work( ii + (nb+k)*n ) )
                          call stdlib_csscal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_clacpy( 'F', n, nb-iv+1,work( 1 + (nb+iv)*n ), n,vr( 1, ki ), &
                                 ldvr )
                       iv = nb
                    else
                       iv = iv - 1
                    end if
                 end if
                 ! restore the original diagonal elements of t.
                 do k = 1, ki - 1
                    t( k, k ) = work( k )
                 end do
                 is = is - 1
              end do loop_80
           end if
           if( leftv ) then
              ! ============================================================
              ! compute left eigenvectors.
              ! iv is index of column in current block.
              ! non-blocked version always uses iv=1;
              ! blocked     version starts with iv=1, goes up to nb.
              ! (note the "0-th" column is used to store the original diagonal.)
              iv = 1
              is = 1
              loop_130: do ki = 1, n
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_130
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 ! --------------------------------------------------------
                 ! complex left eigenvector
                 work( ki + iv*n ) = cone
                 ! form right-hand side.
                 do k = ki + 1, n
                    work( k + iv*n ) = -conjg( t( ki, k ) )
                 end do
                 ! solve conjugate-transposed triangular system:
                 ! [ t(ki+1:n,ki+1:n) - t(ki,ki) ]**h * x = scale*work.
                 do k = ki + 1, n
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki<n ) then
                    call stdlib_clatrs( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT','Y', n-ki, t( &
                              ki+1, ki+1 ), ldt,work( ki+1 + iv*n ), scale, rwork, info )
                    work( ki + iv*n ) = scale
                 end if
                 ! copy the vector x or q*x to vl and normalize.
                 if( .not.over ) then
                    ! ------------------------------
                    ! no back-transform: copy x to vl and normalize.
                    call stdlib_ccopy( n-ki+1, work( ki + iv*n ), 1, vl(ki,is), 1 )
                    ii = stdlib_icamax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                    remax = one / cabs1( vl( ii, is ) )
                    call stdlib_csscal( n-ki+1, remax, vl( ki, is ), 1 )
                    do k = 1, ki - 1
                       vl( k, is ) = czero
                    end do
                 else if( nb==1 ) then
                    ! ------------------------------
                    ! version 1: back-transform each vector with gemv, q*x.
                    if( ki<n )call stdlib_cgemv( 'N', n, n-ki, cone, vl( 1, ki+1 ), ldvl,work( ki+&
                              1 + iv*n ), 1, cmplx( scale,KIND=sp),vl( 1, ki ), 1 )
                    ii = stdlib_icamax( n, vl( 1, ki ), 1 )
                    remax = one / cabs1( vl( ii, ki ) )
                    call stdlib_csscal( n, remax, vl( 1, ki ), 1 )
                 else
                    ! ------------------------------
                    ! version 2: back-transform block of vectors with gemm
                    ! zero out above vector
                    ! could go from ki-nv+1 to ki-1
                    do k = 1, ki - 1
                       work( k + iv*n ) = czero
                    end do
                    ! columns 1:iv of work are valid vectors.
                    ! when the number of vectors stored reaches nb,
                    ! or if this was last vector, do the gemm
                    if( (iv==nb) .or. (ki==n) ) then
                       call stdlib_cgemm( 'N', 'N', n, iv, n-ki+iv, cone,vl( 1, ki-iv+1 ), ldvl,&
                                 work( ki-iv+1 + (1)*n ), n,czero,work( 1 + (nb+1)*n ), n )
                       ! normalize vectors
                       do k = 1, iv
                          ii = stdlib_icamax( n, work( 1 + (nb+k)*n ), 1 )
                          remax = one / cabs1( work( ii + (nb+k)*n ) )
                          call stdlib_csscal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_clacpy( 'F', n, iv,work( 1 + (nb+1)*n ), n,vl( 1, ki-iv+1 ), &
                                 ldvl )
                       iv = 1
                    else
                       iv = iv + 1
                    end if
                 end if
                 ! restore the original diagonal elements of t.
                 do k = ki + 1, n
                    t( k, k ) = work( k )
                 end do
                 is = is + 1
              end do loop_130
           end if
           return
     end subroutine stdlib_ctrevc3

     pure subroutine stdlib_ztrevc3( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
     !! ZTREVC3 computes some or all of the right and/or left eigenvectors of
     !! a complex upper triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a complex general matrix:  A = Q*T*Q**H, as computed by ZHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**H)*T = w*(y**H)
     !! where y**H denotes the conjugate transpose of the vector y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix. If Q is the unitary factor that reduces a matrix A to
     !! Schur form T, then Q*X and Q*Y are the matrices of right and left
     !! eigenvectors of A.
     !! This uses a Level 3 BLAS version of the back transformation.
               work, lwork, rwork, lrwork, info)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, lwork, lrwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmin = 8
           integer(ilp), parameter :: nbmax = 128
           
           
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, lquery, over, rightv, somev
           integer(ilp) :: i, ii, is, j, k, ki, iv, maxwrk, nb
           real(dp) :: ovfl, remax, scale, smin, smlnum, ulp, unfl
           complex(dp) :: cdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters
           bothv  = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv  = stdlib_lsame( side, 'L' ) .or. bothv
           allv  = stdlib_lsame( howmny, 'A' )
           over  = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           ! set m to the number of columns required to store the selected
           ! eigenvectors.
           if( somev ) then
              m = 0
              do j = 1, n
                 if( select( j ) )m = m + 1
              end do
           else
              m = n
           end if
           info = 0
           nb = stdlib_ilaenv( 1, 'ZTREVC', side // howmny, n, -1, -1, -1 )
           maxwrk = n + 2*n*nb
           work(1) = maxwrk
           rwork(1) = n
           lquery = ( lwork==-1 .or. lrwork==-1 )
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else if( mm<m ) then
              info = -11
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -14
           else if ( lrwork<max( 1, n ) .and. .not.lquery ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTREVC3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! use blocked version of back-transformation if sufficient workspace.
           ! zero-out the workspace to avoid potential nan propagation.
           if( over .and. lwork >= n + 2*n*nbmin ) then
              nb = (lwork - n) / (2*n)
              nb = min( nb, nbmax )
              call stdlib_zlaset( 'F', n, 1+2*nb, czero, czero, work, n )
           else
              nb = 1
           end if
           ! set the constants to control overflow.
           unfl = stdlib_dlamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_dlabad( unfl, ovfl )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           ! store the diagonal elements of t in working array work.
           do i = 1, n
              work( i ) = t( i, i )
           end do
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           rwork( 1 ) = zero
           do j = 2, n
              rwork( j ) = stdlib_dzasum( j-1, t( 1, j ), 1 )
           end do
           if( rightv ) then
              ! ============================================================
              ! compute right eigenvectors.
              ! iv is index of column in current block.
              ! non-blocked version always uses iv=nb=1;
              ! blocked     version starts with iv=nb, goes down to 1.
              ! (note the "0-th" column is used to store the original diagonal.)
              iv = nb
              is = m
              loop_80: do ki = n, 1, -1
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_80
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 ! --------------------------------------------------------
                 ! complex right eigenvector
                 work( ki + iv*n ) = cone
                 ! form right-hand side.
                 do k = 1, ki - 1
                    work( k + iv*n ) = -t( k, ki )
                 end do
                 ! solve upper triangular system:
                 ! [ t(1:ki-1,1:ki-1) - t(ki,ki) ]*x = scale*work.
                 do k = 1, ki - 1
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki>1 ) then
                    call stdlib_zlatrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', 'Y',ki-1, t, ldt, &
                              work( 1 + iv*n ), scale,rwork, info )
                    work( ki + iv*n ) = scale
                 end if
                 ! copy the vector x or q*x to vr and normalize.
                 if( .not.over ) then
                    ! ------------------------------
                    ! no back-transform: copy x to vr and normalize.
                    call stdlib_zcopy( ki, work( 1 + iv*n ), 1, vr( 1, is ), 1 )
                    ii = stdlib_izamax( ki, vr( 1, is ), 1 )
                    remax = one / cabs1( vr( ii, is ) )
                    call stdlib_zdscal( ki, remax, vr( 1, is ), 1 )
                    do k = ki + 1, n
                       vr( k, is ) = czero
                    end do
                 else if( nb==1 ) then
                    ! ------------------------------
                    ! version 1: back-transform each vector with gemv, q*x.
                    if( ki>1 )call stdlib_zgemv( 'N', n, ki-1, cone, vr, ldvr,work( 1 + iv*n ), 1,&
                               cmplx( scale,KIND=dp),vr( 1, ki ), 1 )
                    ii = stdlib_izamax( n, vr( 1, ki ), 1 )
                    remax = one / cabs1( vr( ii, ki ) )
                    call stdlib_zdscal( n, remax, vr( 1, ki ), 1 )
                 else
                    ! ------------------------------
                    ! version 2: back-transform block of vectors with gemm
                    ! zero out below vector
                    do k = ki + 1, n
                       work( k + iv*n ) = czero
                    end do
                    ! columns iv:nb of work are valid vectors.
                    ! when the number of vectors stored reaches nb,
                    ! or if this was last vector, do the gemm
                    if( (iv==1) .or. (ki==1) ) then
                       call stdlib_zgemm( 'N', 'N', n, nb-iv+1, ki+nb-iv, cone,vr, ldvr,work( 1 + &
                                 (iv)*n    ), n,czero,work( 1 + (nb+iv)*n ), n )
                       ! normalize vectors
                       do k = iv, nb
                          ii = stdlib_izamax( n, work( 1 + (nb+k)*n ), 1 )
                          remax = one / cabs1( work( ii + (nb+k)*n ) )
                          call stdlib_zdscal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_zlacpy( 'F', n, nb-iv+1,work( 1 + (nb+iv)*n ), n,vr( 1, ki ), &
                                 ldvr )
                       iv = nb
                    else
                       iv = iv - 1
                    end if
                 end if
                 ! restore the original diagonal elements of t.
                 do k = 1, ki - 1
                    t( k, k ) = work( k )
                 end do
                 is = is - 1
              end do loop_80
           end if
           if( leftv ) then
              ! ============================================================
              ! compute left eigenvectors.
              ! iv is index of column in current block.
              ! non-blocked version always uses iv=1;
              ! blocked     version starts with iv=1, goes up to nb.
              ! (note the "0-th" column is used to store the original diagonal.)
              iv = 1
              is = 1
              loop_130: do ki = 1, n
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_130
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 ! --------------------------------------------------------
                 ! complex left eigenvector
                 work( ki + iv*n ) = cone
                 ! form right-hand side.
                 do k = ki + 1, n
                    work( k + iv*n ) = -conjg( t( ki, k ) )
                 end do
                 ! solve conjugate-transposed triangular system:
                 ! [ t(ki+1:n,ki+1:n) - t(ki,ki) ]**h * x = scale*work.
                 do k = ki + 1, n
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki<n ) then
                    call stdlib_zlatrs( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT','Y', n-ki, t( &
                              ki+1, ki+1 ), ldt,work( ki+1 + iv*n ), scale, rwork, info )
                    work( ki + iv*n ) = scale
                 end if
                 ! copy the vector x or q*x to vl and normalize.
                 if( .not.over ) then
                    ! ------------------------------
                    ! no back-transform: copy x to vl and normalize.
                    call stdlib_zcopy( n-ki+1, work( ki + iv*n ), 1, vl(ki,is), 1 )
                    ii = stdlib_izamax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                    remax = one / cabs1( vl( ii, is ) )
                    call stdlib_zdscal( n-ki+1, remax, vl( ki, is ), 1 )
                    do k = 1, ki - 1
                       vl( k, is ) = czero
                    end do
                 else if( nb==1 ) then
                    ! ------------------------------
                    ! version 1: back-transform each vector with gemv, q*x.
                    if( ki<n )call stdlib_zgemv( 'N', n, n-ki, cone, vl( 1, ki+1 ), ldvl,work( ki+&
                              1 + iv*n ), 1, cmplx( scale,KIND=dp),vl( 1, ki ), 1 )
                    ii = stdlib_izamax( n, vl( 1, ki ), 1 )
                    remax = one / cabs1( vl( ii, ki ) )
                    call stdlib_zdscal( n, remax, vl( 1, ki ), 1 )
                 else
                    ! ------------------------------
                    ! version 2: back-transform block of vectors with gemm
                    ! zero out above vector
                    ! could go from ki-nv+1 to ki-1
                    do k = 1, ki - 1
                       work( k + iv*n ) = czero
                    end do
                    ! columns 1:iv of work are valid vectors.
                    ! when the number of vectors stored reaches nb,
                    ! or if this was last vector, do the gemm
                    if( (iv==nb) .or. (ki==n) ) then
                       call stdlib_zgemm( 'N', 'N', n, iv, n-ki+iv, cone,vl( 1, ki-iv+1 ), ldvl,&
                                 work( ki-iv+1 + (1)*n ), n,czero,work( 1 + (nb+1)*n ), n )
                       ! normalize vectors
                       do k = 1, iv
                          ii = stdlib_izamax( n, work( 1 + (nb+k)*n ), 1 )
                          remax = one / cabs1( work( ii + (nb+k)*n ) )
                          call stdlib_zdscal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_zlacpy( 'F', n, iv,work( 1 + (nb+1)*n ), n,vl( 1, ki-iv+1 ), &
                                 ldvl )
                       iv = 1
                    else
                       iv = iv + 1
                    end if
                 end if
                 ! restore the original diagonal elements of t.
                 do k = ki + 1, n
                    t( k, k ) = work( k )
                 end do
                 is = is + 1
              end do loop_130
           end if
           return
     end subroutine stdlib_ztrevc3

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$trevc3( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
     !! ZTREVC3: computes some or all of the right and/or left eigenvectors of
     !! a complex upper triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a complex general matrix:  A = Q*T*Q**H, as computed by ZHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**H)*T = w*(y**H)
     !! where y**H denotes the conjugate transpose of the vector y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix. If Q is the unitary factor that reduces a matrix A to
     !! Schur form T, then Q*X and Q*Y are the matrices of right and left
     !! eigenvectors of A.
     !! This uses a Level 3 BLAS version of the back transformation.
               work, lwork, rwork, lrwork, info)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, lwork, lrwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: nbmin = 8
           integer(ilp), parameter :: nbmax = 128
           
           
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, lquery, over, rightv, somev
           integer(ilp) :: i, ii, is, j, k, ki, iv, maxwrk, nb
           real(${ck}$) :: ovfl, remax, scale, smin, smlnum, ulp, unfl
           complex(${ck}$) :: cdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters
           bothv  = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv  = stdlib_lsame( side, 'L' ) .or. bothv
           allv  = stdlib_lsame( howmny, 'A' )
           over  = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           ! set m to the number of columns required to store the selected
           ! eigenvectors.
           if( somev ) then
              m = 0
              do j = 1, n
                 if( select( j ) )m = m + 1
              end do
           else
              m = n
           end if
           info = 0
           nb = stdlib_ilaenv( 1, 'ZTREVC', side // howmny, n, -1, -1, -1 )
           maxwrk = n + 2*n*nb
           work(1) = maxwrk
           rwork(1) = n
           lquery = ( lwork==-1 .or. lrwork==-1 )
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else if( mm<m ) then
              info = -11
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -14
           else if ( lrwork<max( 1, n ) .and. .not.lquery ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTREVC3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! use blocked version of back-transformation if sufficient workspace.
           ! zero-out the workspace to avoid potential nan propagation.
           if( over .and. lwork >= n + 2*n*nbmin ) then
              nb = (lwork - n) / (2*n)
              nb = min( nb, nbmax )
              call stdlib_${ci}$laset( 'F', n, 1+2*nb, czero, czero, work, n )
           else
              nb = 1
           end if
           ! set the constants to control overflow.
           unfl = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_${c2ri(ci)}$labad( unfl, ovfl )
           ulp = stdlib_${c2ri(ci)}$lamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           ! store the diagonal elements of t in working array work.
           do i = 1, n
              work( i ) = t( i, i )
           end do
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           rwork( 1 ) = zero
           do j = 2, n
              rwork( j ) = stdlib_${c2ri(ci)}$zasum( j-1, t( 1, j ), 1 )
           end do
           if( rightv ) then
              ! ============================================================
              ! compute right eigenvectors.
              ! iv is index of column in current block.
              ! non-blocked version always uses iv=nb=1;
              ! blocked     version starts with iv=nb, goes down to 1.
              ! (note the "0-th" column is used to store the original diagonal.)
              iv = nb
              is = m
              loop_80: do ki = n, 1, -1
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_80
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 ! --------------------------------------------------------
                 ! complex right eigenvector
                 work( ki + iv*n ) = cone
                 ! form right-hand side.
                 do k = 1, ki - 1
                    work( k + iv*n ) = -t( k, ki )
                 end do
                 ! solve upper triangular system:
                 ! [ t(1:ki-1,1:ki-1) - t(ki,ki) ]*x = scale*work.
                 do k = 1, ki - 1
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki>1 ) then
                    call stdlib_${ci}$latrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', 'Y',ki-1, t, ldt, &
                              work( 1 + iv*n ), scale,rwork, info )
                    work( ki + iv*n ) = scale
                 end if
                 ! copy the vector x or q*x to vr and normalize.
                 if( .not.over ) then
                    ! ------------------------------
                    ! no back-transform: copy x to vr and normalize.
                    call stdlib_${ci}$copy( ki, work( 1 + iv*n ), 1, vr( 1, is ), 1 )
                    ii = stdlib_i${ci}$amax( ki, vr( 1, is ), 1 )
                    remax = one / cabs1( vr( ii, is ) )
                    call stdlib_${ci}$dscal( ki, remax, vr( 1, is ), 1 )
                    do k = ki + 1, n
                       vr( k, is ) = czero
                    end do
                 else if( nb==1 ) then
                    ! ------------------------------
                    ! version 1: back-transform each vector with gemv, q*x.
                    if( ki>1 )call stdlib_${ci}$gemv( 'N', n, ki-1, cone, vr, ldvr,work( 1 + iv*n ), 1,&
                               cmplx( scale,KIND=${ck}$),vr( 1, ki ), 1 )
                    ii = stdlib_i${ci}$amax( n, vr( 1, ki ), 1 )
                    remax = one / cabs1( vr( ii, ki ) )
                    call stdlib_${ci}$dscal( n, remax, vr( 1, ki ), 1 )
                 else
                    ! ------------------------------
                    ! version 2: back-transform block of vectors with gemm
                    ! zero out below vector
                    do k = ki + 1, n
                       work( k + iv*n ) = czero
                    end do
                    ! columns iv:nb of work are valid vectors.
                    ! when the number of vectors stored reaches nb,
                    ! or if this was last vector, do the gemm
                    if( (iv==1) .or. (ki==1) ) then
                       call stdlib_${ci}$gemm( 'N', 'N', n, nb-iv+1, ki+nb-iv, cone,vr, ldvr,work( 1 + &
                                 (iv)*n    ), n,czero,work( 1 + (nb+iv)*n ), n )
                       ! normalize vectors
                       do k = iv, nb
                          ii = stdlib_i${ci}$amax( n, work( 1 + (nb+k)*n ), 1 )
                          remax = one / cabs1( work( ii + (nb+k)*n ) )
                          call stdlib_${ci}$dscal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_${ci}$lacpy( 'F', n, nb-iv+1,work( 1 + (nb+iv)*n ), n,vr( 1, ki ), &
                                 ldvr )
                       iv = nb
                    else
                       iv = iv - 1
                    end if
                 end if
                 ! restore the original diagonal elements of t.
                 do k = 1, ki - 1
                    t( k, k ) = work( k )
                 end do
                 is = is - 1
              end do loop_80
           end if
           if( leftv ) then
              ! ============================================================
              ! compute left eigenvectors.
              ! iv is index of column in current block.
              ! non-blocked version always uses iv=1;
              ! blocked     version starts with iv=1, goes up to nb.
              ! (note the "0-th" column is used to store the original diagonal.)
              iv = 1
              is = 1
              loop_130: do ki = 1, n
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_130
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 ! --------------------------------------------------------
                 ! complex left eigenvector
                 work( ki + iv*n ) = cone
                 ! form right-hand side.
                 do k = ki + 1, n
                    work( k + iv*n ) = -conjg( t( ki, k ) )
                 end do
                 ! solve conjugate-transposed triangular system:
                 ! [ t(ki+1:n,ki+1:n) - t(ki,ki) ]**h * x = scale*work.
                 do k = ki + 1, n
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki<n ) then
                    call stdlib_${ci}$latrs( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT','Y', n-ki, t( &
                              ki+1, ki+1 ), ldt,work( ki+1 + iv*n ), scale, rwork, info )
                    work( ki + iv*n ) = scale
                 end if
                 ! copy the vector x or q*x to vl and normalize.
                 if( .not.over ) then
                    ! ------------------------------
                    ! no back-transform: copy x to vl and normalize.
                    call stdlib_${ci}$copy( n-ki+1, work( ki + iv*n ), 1, vl(ki,is), 1 )
                    ii = stdlib_i${ci}$amax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                    remax = one / cabs1( vl( ii, is ) )
                    call stdlib_${ci}$dscal( n-ki+1, remax, vl( ki, is ), 1 )
                    do k = 1, ki - 1
                       vl( k, is ) = czero
                    end do
                 else if( nb==1 ) then
                    ! ------------------------------
                    ! version 1: back-transform each vector with gemv, q*x.
                    if( ki<n )call stdlib_${ci}$gemv( 'N', n, n-ki, cone, vl( 1, ki+1 ), ldvl,work( ki+&
                              1 + iv*n ), 1, cmplx( scale,KIND=${ck}$),vl( 1, ki ), 1 )
                    ii = stdlib_i${ci}$amax( n, vl( 1, ki ), 1 )
                    remax = one / cabs1( vl( ii, ki ) )
                    call stdlib_${ci}$dscal( n, remax, vl( 1, ki ), 1 )
                 else
                    ! ------------------------------
                    ! version 2: back-transform block of vectors with gemm
                    ! zero out above vector
                    ! could go from ki-nv+1 to ki-1
                    do k = 1, ki - 1
                       work( k + iv*n ) = czero
                    end do
                    ! columns 1:iv of work are valid vectors.
                    ! when the number of vectors stored reaches nb,
                    ! or if this was last vector, do the gemm
                    if( (iv==nb) .or. (ki==n) ) then
                       call stdlib_${ci}$gemm( 'N', 'N', n, iv, n-ki+iv, cone,vl( 1, ki-iv+1 ), ldvl,&
                                 work( ki-iv+1 + (1)*n ), n,czero,work( 1 + (nb+1)*n ), n )
                       ! normalize vectors
                       do k = 1, iv
                          ii = stdlib_i${ci}$amax( n, work( 1 + (nb+k)*n ), 1 )
                          remax = one / cabs1( work( ii + (nb+k)*n ) )
                          call stdlib_${ci}$dscal( n, remax, work( 1 + (nb+k)*n ), 1 )
                       end do
                       call stdlib_${ci}$lacpy( 'F', n, iv,work( 1 + (nb+1)*n ), n,vl( 1, ki-iv+1 ), &
                                 ldvl )
                       iv = 1
                    else
                       iv = iv + 1
                    end if
                 end if
                 ! restore the original diagonal elements of t.
                 do k = ki + 1, n
                    t( k, k ) = work( k )
                 end do
                 is = is + 1
              end do loop_130
           end if
           return
     end subroutine stdlib_${ci}$trevc3

#:endif
#:endfor





     pure subroutine stdlib_claqz3( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_desired, alpha,&
     !! CLAQZ3 Executes a single multishift QZ sweep
                beta, a, lda, b, ldb,q, ldq, z, ldz, qc, ldqc, zc, ldzc, work,lwork, info )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! function arguments
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(ilp), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,nshifts, &
                     nblock_desired, ldqc, ldzc
           complex(sp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq, * ),z( ldz, * ), qc( &
                     ldqc, * ), zc( ldzc, * ), work( * ),alpha( * ), beta( * )
           integer(ilp), intent( out ) :: info
           
           
           ! local scalars
           integer(ilp) :: i, j, ns, istartm, istopm, sheight, swidth, k, np, istartb, istopb, &
                     ishift, nblock, npos
           real(sp) :: safmin, safmax, c, scale
           complex(sp) :: temp, temp2, temp3, s
           info = 0
           if ( nblock_desired < nshifts+1 ) then
              info = -8
           end if
           if ( lwork ==-1 ) then
              ! workspace query, quick return
              work( 1 ) = n*nblock_desired
              return
           else if ( lwork < n*nblock_desired ) then
              info = -25
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLAQZ3', -info )
              return
           end if
           ! executable statements
           ! get machine constants
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_slabad( safmin, safmax )
           if ( ilo >= ihi ) then
              return
           end if
           if ( ilschur ) then
              istartm = 1
              istopm = n
           else
              istartm = ilo
              istopm = ihi
           end if
           ns = nshifts
           npos = max( nblock_desired-ns, 1 )
           ! the following block introduces the shifts and chases
           ! them down one by one just enough to make space for
           ! the other shifts. the near-the-diagonal block is
           ! of size (ns+1) x ns.
           call stdlib_claset( 'FULL', ns+1, ns+1, czero, cone, qc, ldqc )
           call stdlib_claset( 'FULL', ns, ns, czero, cone, zc, ldzc )
           do i = 1, ns
              ! introduce the shift
              scale = sqrt( abs( alpha( i ) ) ) * sqrt( abs( beta( i ) ) )
              if( scale >= safmin .and. scale <= safmax ) then
                 alpha( i ) = alpha( i )/scale
                 beta( i ) = beta( i )/scale
              end if
              temp2 = beta( i )*a( ilo, ilo )-alpha( i )*b( ilo, ilo )
              temp3 = beta( i )*a( ilo+1, ilo )
              if ( abs( temp2 ) > safmax .or.abs( temp3 ) > safmax ) then
                 temp2 = cone
                 temp3 = czero
              end if
              call stdlib_clartg( temp2, temp3, c, s, temp )
              call stdlib_crot( ns, a( ilo, ilo ), lda, a( ilo+1, ilo ), lda, c,s )
              call stdlib_crot( ns, b( ilo, ilo ), ldb, b( ilo+1, ilo ), ldb, c,s )
              call stdlib_crot( ns+1, qc( 1, 1 ), 1, qc( 1, 2 ), 1, c, conjg( s ) )
              ! chase the shift down
              do j = 1, ns-i
                 call stdlib_claqz1( .true., .true., j, 1, ns, ihi-ilo+1, a( ilo,ilo ), lda, b( &
                           ilo, ilo ), ldb, ns+1, 1, qc,ldqc, ns, 1, zc, ldzc )
              end do
           end do
           ! update the rest of the pencil
           ! update a(ilo:ilo+ns,ilo+ns:istopm) and b(ilo:ilo+ns,ilo+ns:istopm)
           ! from the left with qc(1:ns+1,1:ns+1)'
           sheight = ns+1
           swidth = istopm-( ilo+ns )+1
           if ( swidth > 0 ) then
              call stdlib_cgemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,a( ilo, ilo+&
                        ns ), lda, czero, work, sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, a( ilo,ilo+ns ), lda )
                        
              call stdlib_cgemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,b( ilo, ilo+&
                        ns ), ldb, czero, work, sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, b( ilo,ilo+ns ), ldb )
                        
           end if
           if ( ilq ) then
             call stdlib_cgemm( 'N', 'N', n, sheight, sheight, cone, q( 1, ilo ),ldq, qc, ldqc, &
                       czero, work, n )
              call stdlib_clacpy( 'ALL', n, sheight, work, n, q( 1, ilo ), ldq )
           end if
           ! update a(istartm:ilo-1,ilo:ilo+ns-1) and b(istartm:ilo-1,ilo:ilo+ns-1)
           ! from the right with zc(1:ns,1:ns)
           sheight = ilo-1-istartm+1
           swidth = ns
           if ( sheight > 0 ) then
              call stdlib_cgemm( 'N', 'N', sheight, swidth, swidth, cone,a( istartm, ilo ), lda, &
                        zc, ldzc, czero, work,sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ilo ), lda )
                        
              call stdlib_cgemm( 'N', 'N', sheight, swidth, swidth, cone,b( istartm, ilo ), ldb, &
                        zc, ldzc, czero, work,sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ilo ), ldb )
                        
           end if
           if ( ilz ) then
              call stdlib_cgemm( 'N', 'N', n, swidth, swidth, cone, z( 1, ilo ),ldz, zc, ldzc, &
                        czero, work, n )
              call stdlib_clacpy( 'ALL', n, swidth, work, n, z( 1, ilo ), ldz )
           end if
           ! the following block chases the shifts down to the bottom
           ! right block. if possible, a shift is moved down npos
           ! positions at a time
           k = ilo
           do while ( k < ihi-ns )
              np = min( ihi-ns-k, npos )
              ! size of the near-the-diagonal block
              nblock = ns+np
              ! istartb points to the first row we will be updating
              istartb = k+1
              ! istopb points to the last column we will be updating
              istopb = k+nblock-1
              call stdlib_claset( 'FULL', ns+np, ns+np, czero, cone, qc, ldqc )
              call stdlib_claset( 'FULL', ns+np, ns+np, czero, cone, zc, ldzc )
              ! near the diagonal shift chase
              do i = ns-1, 0, -1
                 do j = 0, np-1
                    ! move down the block with index k+i+j, updating
                    ! the (ns+np x ns+np) block:
                    ! (k:k+ns+np,k:k+ns+np-1)
                    call stdlib_claqz1( .true., .true., k+i+j, istartb, istopb, ihi,a, lda, b, &
                              ldb, nblock, k+1, qc, ldqc,nblock, k, zc, ldzc )
                 end do
              end do
              ! update rest of the pencil
              ! update a(k+1:k+ns+np, k+ns+np:istopm) and
              ! b(k+1:k+ns+np, k+ns+np:istopm)
              ! from the left with qc(1:ns+np,1:ns+np)'
              sheight = ns+np
              swidth = istopm-( k+ns+np )+1
              if ( swidth > 0 ) then
                 call stdlib_cgemm( 'C', 'N', sheight, swidth, sheight, cone, qc,ldqc, a( k+1, k+&
                           ns+np ), lda, czero, work,sheight )
                 call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, a( k+1,k+ns+np ), lda &
                           )
                 call stdlib_cgemm( 'C', 'N', sheight, swidth, sheight, cone, qc,ldqc, b( k+1, k+&
                           ns+np ), ldb, czero, work,sheight )
                 call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, b( k+1,k+ns+np ), ldb &
                           )
              end if
              if ( ilq ) then
                 call stdlib_cgemm( 'N', 'N', n, nblock, nblock, cone, q( 1, k+1 ),ldq, qc, ldqc, &
                           czero, work, n )
                 call stdlib_clacpy( 'ALL', n, nblock, work, n, q( 1, k+1 ), ldq )
              end if
              ! update a(istartm:k,k:k+ns+npos-1) and b(istartm:k,k:k+ns+npos-1)
              ! from the right with zc(1:ns+np,1:ns+np)
              sheight = k-istartm+1
              swidth = nblock
              if ( sheight > 0 ) then
                 call stdlib_cgemm( 'N', 'N', sheight, swidth, swidth, cone,a( istartm, k ), lda, &
                           zc, ldzc, czero, work,sheight )
                 call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight,a( istartm, k ), lda )
                           
                 call stdlib_cgemm( 'N', 'N', sheight, swidth, swidth, cone,b( istartm, k ), ldb, &
                           zc, ldzc, czero, work,sheight )
                 call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight,b( istartm, k ), ldb )
                           
              end if
              if ( ilz ) then
                 call stdlib_cgemm( 'N', 'N', n, nblock, nblock, cone, z( 1, k ),ldz, zc, ldzc, &
                           czero, work, n )
                 call stdlib_clacpy( 'ALL', n, nblock, work, n, z( 1, k ), ldz )
              end if
              k = k+np
           end do
           ! the following block removes the shifts from the bottom right corner
           ! one by one. updates are initially applied to a(ihi-ns+1:ihi,ihi-ns:ihi).
           call stdlib_claset( 'FULL', ns, ns, czero, cone, qc, ldqc )
           call stdlib_claset( 'FULL', ns+1, ns+1, czero, cone, zc, ldzc )
           ! istartb points to the first row we will be updating
           istartb = ihi-ns+1
           ! istopb points to the last column we will be updating
           istopb = ihi
           do i = 1, ns
              ! chase the shift down to the bottom right corner
              do ishift = ihi-i, ihi-1
                 call stdlib_claqz1( .true., .true., ishift, istartb, istopb, ihi,a, lda, b, ldb, &
                           ns, ihi-ns+1, qc, ldqc, ns+1,ihi-ns, zc, ldzc )
              end do
           end do
           ! update rest of the pencil
           ! update a(ihi-ns+1:ihi, ihi+1:istopm)
           ! from the left with qc(1:ns,1:ns)'
           sheight = ns
           swidth = istopm-( ihi+1 )+1
           if ( swidth > 0 ) then
              call stdlib_cgemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,a( ihi-ns+1, &
                        ihi+1 ), lda, czero, work, sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight,a( ihi-ns+1, ihi+1 ), lda &
                        )
              call stdlib_cgemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,b( ihi-ns+1, &
                        ihi+1 ), ldb, czero, work, sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight,b( ihi-ns+1, ihi+1 ), ldb &
                        )
           end if
           if ( ilq ) then
              call stdlib_cgemm( 'N', 'N', n, ns, ns, cone, q( 1, ihi-ns+1 ), ldq,qc, ldqc, czero,&
                         work, n )
              call stdlib_clacpy( 'ALL', n, ns, work, n, q( 1, ihi-ns+1 ), ldq )
           end if
           ! update a(istartm:ihi-ns,ihi-ns:ihi)
           ! from the right with zc(1:ns+1,1:ns+1)
           sheight = ihi-ns-istartm+1
           swidth = ns+1
           if ( sheight > 0 ) then
              call stdlib_cgemm( 'N', 'N', sheight, swidth, swidth, cone,a( istartm, ihi-ns ), &
                        lda, zc, ldzc, czero, work,sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ihi-ns ), lda &
                        )
              call stdlib_cgemm( 'N', 'N', sheight, swidth, swidth, cone,b( istartm, ihi-ns ), &
                        ldb, zc, ldzc, czero, work,sheight )
              call stdlib_clacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ihi-ns ), ldb &
                        )
           end if
           if ( ilz ) then
              call stdlib_cgemm( 'N', 'N', n, ns+1, ns+1, cone, z( 1, ihi-ns ), ldz,zc, ldzc, &
                        czero, work, n )
              call stdlib_clacpy( 'ALL', n, ns+1, work, n, z( 1, ihi-ns ), ldz )
           end if
     end subroutine stdlib_claqz3

     pure subroutine stdlib_zlaqz3( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_desired, alpha,&
     !! ZLAQZ3 Executes a single multishift QZ sweep
                beta, a, lda, b, ldb,q, ldq, z, ldz, qc, ldqc, zc, ldzc, work,lwork, info )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! function arguments
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(ilp), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,nshifts, &
                     nblock_desired, ldqc, ldzc
           complex(dp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq,* ), z( ldz, * ), qc( &
                     ldqc, * ), zc( ldzc, * ), work( * ),alpha( * ), beta( * )
           integer(ilp), intent( out ) :: info
           
           
           ! local scalars
           integer(ilp) :: i, j, ns, istartm, istopm, sheight, swidth, k, np, istartb, istopb, &
                     ishift, nblock, npos
           real(dp) :: safmin, safmax, c, scale
           complex(dp) :: temp, temp2, temp3, s
           info = 0
           if ( nblock_desired < nshifts+1 ) then
              info = -8
           end if
           if ( lwork ==-1 ) then
              ! workspace query, quick return
              work( 1 ) = n*nblock_desired
              return
           else if ( lwork < n*nblock_desired ) then
              info = -25
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZLAQZ3', -info )
              return
           end if
           ! executable statements
           ! get machine constants
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_dlabad( safmin, safmax )
           if ( ilo >= ihi ) then
              return
           end if
           if ( ilschur ) then
              istartm = 1
              istopm = n
           else
              istartm = ilo
              istopm = ihi
           end if
           ns = nshifts
           npos = max( nblock_desired-ns, 1 )
           ! the following block introduces the shifts and chases
           ! them down one by one just enough to make space for
           ! the other shifts. the near-the-diagonal block is
           ! of size (ns+1) x ns.
           call stdlib_zlaset( 'FULL', ns+1, ns+1, czero, cone, qc, ldqc )
           call stdlib_zlaset( 'FULL', ns, ns, czero, cone, zc, ldzc )
           do i = 1, ns
              ! introduce the shift
              scale = sqrt( abs( alpha( i ) ) ) * sqrt( abs( beta( i ) ) )
              if( scale >= safmin .and. scale <= safmax ) then
                 alpha( i ) = alpha( i )/scale
                 beta( i ) = beta( i )/scale
              end if
              temp2 = beta( i )*a( ilo, ilo )-alpha( i )*b( ilo, ilo )
              temp3 = beta( i )*a( ilo+1, ilo )
              if ( abs( temp2 ) > safmax .or.abs( temp3 ) > safmax ) then
                 temp2 = cone
                 temp3 = czero
              end if
              call stdlib_zlartg( temp2, temp3, c, s, temp )
              call stdlib_zrot( ns, a( ilo, ilo ), lda, a( ilo+1, ilo ), lda, c,s )
              call stdlib_zrot( ns, b( ilo, ilo ), ldb, b( ilo+1, ilo ), ldb, c,s )
              call stdlib_zrot( ns+1, qc( 1, 1 ), 1, qc( 1, 2 ), 1, c,conjg( s ) )
              ! chase the shift down
              do j = 1, ns-i
                 call stdlib_zlaqz1( .true., .true., j, 1, ns, ihi-ilo+1, a( ilo,ilo ), lda, b( &
                           ilo, ilo ), ldb, ns+1, 1, qc,ldqc, ns, 1, zc, ldzc )
              end do
           end do
           ! update the rest of the pencil
           ! update a(ilo:ilo+ns,ilo+ns:istopm) and b(ilo:ilo+ns,ilo+ns:istopm)
           ! from the left with qc(1:ns+1,1:ns+1)'
           sheight = ns+1
           swidth = istopm-( ilo+ns )+1
           if ( swidth > 0 ) then
              call stdlib_zgemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,a( ilo, ilo+&
                        ns ), lda, czero, work, sheight )
              call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight, a( ilo,ilo+ns ), lda )
                        
              call stdlib_zgemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,b( ilo, ilo+&
                        ns ), ldb, czero, work, sheight )
              call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight, b( ilo,ilo+ns ), ldb )
                        
           end if
           if ( ilq ) then
              call stdlib_zgemm( 'N', 'N', n, sheight, sheight, cone, q( 1, ilo ),ldq, qc, ldqc, &
                        czero, work, n )
              call stdlib_zlacpy( 'ALL', n, sheight, work, n, q( 1, ilo ), ldq )
           end if
           ! update a(istartm:ilo-1,ilo:ilo+ns-1) and b(istartm:ilo-1,ilo:ilo+ns-1)
           ! from the right with zc(1:ns,1:ns)
           sheight = ilo-1-istartm+1
           swidth = ns
           if ( sheight > 0 ) then
              call stdlib_zgemm( 'N', 'N', sheight, swidth, swidth, cone,a( istartm, ilo ), lda, &
                        zc, ldzc, czero, work,sheight )
              call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ilo ), lda )
                        
              call stdlib_zgemm( 'N', 'N', sheight, swidth, swidth, cone,b( istartm, ilo ), ldb, &
                        zc, ldzc, czero, work,sheight )
              call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ilo ), ldb )
                        
           end if
           if ( ilz ) then
              call stdlib_zgemm( 'N', 'N', n, swidth, swidth, cone, z( 1, ilo ),ldz, zc, ldzc, &
                        czero, work, n )
              call stdlib_zlacpy( 'ALL', n, swidth, work, n, z( 1, ilo ), ldz )
           end if
           ! the following block chases the shifts down to the bottom
           ! right block. if possible, a shift is moved down npos
           ! positions at a time
           k = ilo
           do while ( k < ihi-ns )
              np = min( ihi-ns-k, npos )
              ! size of the near-the-diagonal block
              nblock = ns+np
              ! istartb points to the first row we will be updating
              istartb = k+1
              ! istopb points to the last column we will be updating
              istopb = k+nblock-1
              call stdlib_zlaset( 'FULL', ns+np, ns+np, czero, cone, qc, ldqc )
              call stdlib_zlaset( 'FULL', ns+np, ns+np, czero, cone, zc, ldzc )
              ! near the diagonal shift chase
              do i = ns-1, 0, -1
                 do j = 0, np-1
                    ! move down the block with index k+i+j, updating
                    ! the (ns+np x ns+np) block:
                    ! (k:k+ns+np,k:k+ns+np-1)
                    call stdlib_zlaqz1( .true., .true., k+i+j, istartb, istopb, ihi,a, lda, b, &
                              ldb, nblock, k+1, qc, ldqc,nblock, k, zc, ldzc )
                 end do
              end do
              ! update rest of the pencil
              ! update a(k+1:k+ns+np, k+ns+np:istopm) and
              ! b(k+1:k+ns+np, k+ns+np:istopm)
              ! from the left with qc(1:ns+np,1:ns+np)'
              sheight = ns+np
              swidth = istopm-( k+ns+np )+1
              if ( swidth > 0 ) then
                 call stdlib_zgemm( 'C', 'N', sheight, swidth, sheight, cone, qc,ldqc, a( k+1, k+&
                           ns+np ), lda, czero, work,sheight )
                 call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight, a( k+1,k+ns+np ), lda &
                           )
                 call stdlib_zgemm( 'C', 'N', sheight, swidth, sheight, cone, qc,ldqc, b( k+1, k+&
                           ns+np ), ldb, czero, work,sheight )
                 call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight, b( k+1,k+ns+np ), ldb &
                           )
              end if
              if ( ilq ) then
                 call stdlib_zgemm( 'N', 'N', n, nblock, nblock, cone, q( 1, k+1 ),ldq, qc, ldqc, &
                           czero, work, n )
                 call stdlib_zlacpy( 'ALL', n, nblock, work, n, q( 1, k+1 ), ldq )
              end if
              ! update a(istartm:k,k:k+ns+npos-1) and b(istartm:k,k:k+ns+npos-1)
              ! from the right with zc(1:ns+np,1:ns+np)
              sheight = k-istartm+1
              swidth = nblock
              if ( sheight > 0 ) then
                 call stdlib_zgemm( 'N', 'N', sheight, swidth, swidth, cone,a( istartm, k ), lda, &
                           zc, ldzc, czero, work,sheight )
                 call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight,a( istartm, k ), lda )
                           
                 call stdlib_zgemm( 'N', 'N', sheight, swidth, swidth, cone,b( istartm, k ), ldb, &
                           zc, ldzc, czero, work,sheight )
                 call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight,b( istartm, k ), ldb )
                           
              end if
              if ( ilz ) then
                 call stdlib_zgemm( 'N', 'N', n, nblock, nblock, cone, z( 1, k ),ldz, zc, ldzc, &
                           czero, work, n )
                 call stdlib_zlacpy( 'ALL', n, nblock, work, n, z( 1, k ), ldz )
              end if
              k = k+np
           end do
           ! the following block removes the shifts from the bottom right corner
           ! one by one. updates are initially applied to a(ihi-ns+1:ihi,ihi-ns:ihi).
           call stdlib_zlaset( 'FULL', ns, ns, czero, cone, qc, ldqc )
           call stdlib_zlaset( 'FULL', ns+1, ns+1, czero, cone, zc, ldzc )
           ! istartb points to the first row we will be updating
           istartb = ihi-ns+1
           ! istopb points to the last column we will be updating
           istopb = ihi
           do i = 1, ns
              ! chase the shift down to the bottom right corner
              do ishift = ihi-i, ihi-1
                 call stdlib_zlaqz1( .true., .true., ishift, istartb, istopb, ihi,a, lda, b, ldb, &
                           ns, ihi-ns+1, qc, ldqc, ns+1,ihi-ns, zc, ldzc )
              end do
           end do
           ! update rest of the pencil
           ! update a(ihi-ns+1:ihi, ihi+1:istopm)
           ! from the left with qc(1:ns,1:ns)'
           sheight = ns
           swidth = istopm-( ihi+1 )+1
           if ( swidth > 0 ) then
              call stdlib_zgemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,a( ihi-ns+1, &
                        ihi+1 ), lda, czero, work, sheight )
              call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight,a( ihi-ns+1, ihi+1 ), lda &
                        )
              call stdlib_zgemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,b( ihi-ns+1, &
                        ihi+1 ), ldb, czero, work, sheight )
              call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight,b( ihi-ns+1, ihi+1 ), ldb &
                        )
           end if
           if ( ilq ) then
              call stdlib_zgemm( 'N', 'N', n, ns, ns, cone, q( 1, ihi-ns+1 ), ldq,qc, ldqc, czero,&
                         work, n )
              call stdlib_zlacpy( 'ALL', n, ns, work, n, q( 1, ihi-ns+1 ), ldq )
           end if
           ! update a(istartm:ihi-ns,ihi-ns:ihi)
           ! from the right with zc(1:ns+1,1:ns+1)
           sheight = ihi-ns-istartm+1
           swidth = ns+1
           if ( sheight > 0 ) then
              call stdlib_zgemm( 'N', 'N', sheight, swidth, swidth, cone,a( istartm, ihi-ns ), &
                        lda, zc, ldzc, czero, work,sheight )
              call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ihi-ns ), lda &
                        )
              call stdlib_zgemm( 'N', 'N', sheight, swidth, swidth, cone,b( istartm, ihi-ns ), &
                        ldb, zc, ldzc, czero, work,sheight )
              call stdlib_zlacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ihi-ns ), ldb &
                        )
           end if
           if ( ilz ) then
              call stdlib_zgemm( 'N', 'N', n, ns+1, ns+1, cone, z( 1, ihi-ns ), ldz,zc, ldzc, &
                        czero, work, n )
              call stdlib_zlacpy( 'ALL', n, ns+1, work, n, z( 1, ihi-ns ), ldz )
           end if
     end subroutine stdlib_zlaqz3

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$laqz3( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_qesired, alpha,&
     !! ZLAQZ3: Executes a single multishift QZ sweep
                beta, a, lda, b, ldb,q, ldq, z, ldz, qc, ldqc, zc, ldzc, work,lwork, info )
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! function arguments
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(ilp), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,nshifts, &
                     nblock_qesired, ldqc, ldzc
           complex(${ck}$), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq,* ), z( ldz, * ), qc( &
                     ldqc, * ), zc( ldzc, * ), work( * ),alpha( * ), beta( * )
           integer(ilp), intent( out ) :: info
           
           
           ! local scalars
           integer(ilp) :: i, j, ns, istartm, istopm, sheight, swidth, k, np, istartb, istopb, &
                     ishift, nblock, npos
           real(${ck}$) :: safmin, safmax, c, scale
           complex(${ck}$) :: temp, temp2, temp3, s
           info = 0
           if ( nblock_qesired < nshifts+1 ) then
              info = -8
           end if
           if ( lwork ==-1 ) then
              ! workspace query, quick return
              work( 1 ) = n*nblock_qesired
              return
           else if ( lwork < n*nblock_qesired ) then
              info = -25
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZLAQZ3', -info )
              return
           end if
           ! executable statements
           ! get machine constants
           safmin = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           call stdlib_${c2ri(ci)}$labad( safmin, safmax )
           if ( ilo >= ihi ) then
              return
           end if
           if ( ilschur ) then
              istartm = 1
              istopm = n
           else
              istartm = ilo
              istopm = ihi
           end if
           ns = nshifts
           npos = max( nblock_qesired-ns, 1 )
           ! the following block introduces the shifts and chases
           ! them down one by one just enough to make space for
           ! the other shifts. the near-the-diagonal block is
           ! of size (ns+1) x ns.
           call stdlib_${ci}$laset( 'FULL', ns+1, ns+1, czero, cone, qc, ldqc )
           call stdlib_${ci}$laset( 'FULL', ns, ns, czero, cone, zc, ldzc )
           do i = 1, ns
              ! introduce the shift
              scale = sqrt( abs( alpha( i ) ) ) * sqrt( abs( beta( i ) ) )
              if( scale >= safmin .and. scale <= safmax ) then
                 alpha( i ) = alpha( i )/scale
                 beta( i ) = beta( i )/scale
              end if
              temp2 = beta( i )*a( ilo, ilo )-alpha( i )*b( ilo, ilo )
              temp3 = beta( i )*a( ilo+1, ilo )
              if ( abs( temp2 ) > safmax .or.abs( temp3 ) > safmax ) then
                 temp2 = cone
                 temp3 = czero
              end if
              call stdlib_${ci}$lartg( temp2, temp3, c, s, temp )
              call stdlib_${ci}$rot( ns, a( ilo, ilo ), lda, a( ilo+1, ilo ), lda, c,s )
              call stdlib_${ci}$rot( ns, b( ilo, ilo ), ldb, b( ilo+1, ilo ), ldb, c,s )
              call stdlib_${ci}$rot( ns+1, qc( 1, 1 ), 1, qc( 1, 2 ), 1, c,conjg( s ) )
              ! chase the shift down
              do j = 1, ns-i
                 call stdlib_${ci}$laqz1( .true., .true., j, 1, ns, ihi-ilo+1, a( ilo,ilo ), lda, b( &
                           ilo, ilo ), ldb, ns+1, 1, qc,ldqc, ns, 1, zc, ldzc )
              end do
           end do
           ! update the rest of the pencil
           ! update a(ilo:ilo+ns,ilo+ns:istopm) and b(ilo:ilo+ns,ilo+ns:istopm)
           ! from the left with qc(1:ns+1,1:ns+1)'
           sheight = ns+1
           swidth = istopm-( ilo+ns )+1
           if ( swidth > 0 ) then
              call stdlib_${ci}$gemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,a( ilo, ilo+&
                        ns ), lda, czero, work, sheight )
              call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight, a( ilo,ilo+ns ), lda )
                        
              call stdlib_${ci}$gemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,b( ilo, ilo+&
                        ns ), ldb, czero, work, sheight )
              call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight, b( ilo,ilo+ns ), ldb )
                        
           end if
           if ( ilq ) then
              call stdlib_${ci}$gemm( 'N', 'N', n, sheight, sheight, cone, q( 1, ilo ),ldq, qc, ldqc, &
                        czero, work, n )
              call stdlib_${ci}$lacpy( 'ALL', n, sheight, work, n, q( 1, ilo ), ldq )
           end if
           ! update a(istartm:ilo-1,ilo:ilo+ns-1) and b(istartm:ilo-1,ilo:ilo+ns-1)
           ! from the right with zc(1:ns,1:ns)
           sheight = ilo-1-istartm+1
           swidth = ns
           if ( sheight > 0 ) then
              call stdlib_${ci}$gemm( 'N', 'N', sheight, swidth, swidth, cone,a( istartm, ilo ), lda, &
                        zc, ldzc, czero, work,sheight )
              call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ilo ), lda )
                        
              call stdlib_${ci}$gemm( 'N', 'N', sheight, swidth, swidth, cone,b( istartm, ilo ), ldb, &
                        zc, ldzc, czero, work,sheight )
              call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ilo ), ldb )
                        
           end if
           if ( ilz ) then
              call stdlib_${ci}$gemm( 'N', 'N', n, swidth, swidth, cone, z( 1, ilo ),ldz, zc, ldzc, &
                        czero, work, n )
              call stdlib_${ci}$lacpy( 'ALL', n, swidth, work, n, z( 1, ilo ), ldz )
           end if
           ! the following block chases the shifts down to the bottom
           ! right block. if possible, a shift is moved down npos
           ! positions at a time
           k = ilo
           do while ( k < ihi-ns )
              np = min( ihi-ns-k, npos )
              ! size of the near-the-diagonal block
              nblock = ns+np
              ! istartb points to the first row we will be updating
              istartb = k+1
              ! istopb points to the last column we will be updating
              istopb = k+nblock-1
              call stdlib_${ci}$laset( 'FULL', ns+np, ns+np, czero, cone, qc, ldqc )
              call stdlib_${ci}$laset( 'FULL', ns+np, ns+np, czero, cone, zc, ldzc )
              ! near the diagonal shift chase
              do i = ns-1, 0, -1
                 do j = 0, np-1
                    ! move down the block with index k+i+j, updating
                    ! the (ns+np x ns+np) block:
                    ! (k:k+ns+np,k:k+ns+np-1)
                    call stdlib_${ci}$laqz1( .true., .true., k+i+j, istartb, istopb, ihi,a, lda, b, &
                              ldb, nblock, k+1, qc, ldqc,nblock, k, zc, ldzc )
                 end do
              end do
              ! update rest of the pencil
              ! update a(k+1:k+ns+np, k+ns+np:istopm) and
              ! b(k+1:k+ns+np, k+ns+np:istopm)
              ! from the left with qc(1:ns+np,1:ns+np)'
              sheight = ns+np
              swidth = istopm-( k+ns+np )+1
              if ( swidth > 0 ) then
                 call stdlib_${ci}$gemm( 'C', 'N', sheight, swidth, sheight, cone, qc,ldqc, a( k+1, k+&
                           ns+np ), lda, czero, work,sheight )
                 call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight, a( k+1,k+ns+np ), lda &
                           )
                 call stdlib_${ci}$gemm( 'C', 'N', sheight, swidth, sheight, cone, qc,ldqc, b( k+1, k+&
                           ns+np ), ldb, czero, work,sheight )
                 call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight, b( k+1,k+ns+np ), ldb &
                           )
              end if
              if ( ilq ) then
                 call stdlib_${ci}$gemm( 'N', 'N', n, nblock, nblock, cone, q( 1, k+1 ),ldq, qc, ldqc, &
                           czero, work, n )
                 call stdlib_${ci}$lacpy( 'ALL', n, nblock, work, n, q( 1, k+1 ), ldq )
              end if
              ! update a(istartm:k,k:k+ns+npos-1) and b(istartm:k,k:k+ns+npos-1)
              ! from the right with zc(1:ns+np,1:ns+np)
              sheight = k-istartm+1
              swidth = nblock
              if ( sheight > 0 ) then
                 call stdlib_${ci}$gemm( 'N', 'N', sheight, swidth, swidth, cone,a( istartm, k ), lda, &
                           zc, ldzc, czero, work,sheight )
                 call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight,a( istartm, k ), lda )
                           
                 call stdlib_${ci}$gemm( 'N', 'N', sheight, swidth, swidth, cone,b( istartm, k ), ldb, &
                           zc, ldzc, czero, work,sheight )
                 call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight,b( istartm, k ), ldb )
                           
              end if
              if ( ilz ) then
                 call stdlib_${ci}$gemm( 'N', 'N', n, nblock, nblock, cone, z( 1, k ),ldz, zc, ldzc, &
                           czero, work, n )
                 call stdlib_${ci}$lacpy( 'ALL', n, nblock, work, n, z( 1, k ), ldz )
              end if
              k = k+np
           end do
           ! the following block removes the shifts from the bottom right corner
           ! one by one. updates are initially applied to a(ihi-ns+1:ihi,ihi-ns:ihi).
           call stdlib_${ci}$laset( 'FULL', ns, ns, czero, cone, qc, ldqc )
           call stdlib_${ci}$laset( 'FULL', ns+1, ns+1, czero, cone, zc, ldzc )
           ! istartb points to the first row we will be updating
           istartb = ihi-ns+1
           ! istopb points to the last column we will be updating
           istopb = ihi
           do i = 1, ns
              ! chase the shift down to the bottom right corner
              do ishift = ihi-i, ihi-1
                 call stdlib_${ci}$laqz1( .true., .true., ishift, istartb, istopb, ihi,a, lda, b, ldb, &
                           ns, ihi-ns+1, qc, ldqc, ns+1,ihi-ns, zc, ldzc )
              end do
           end do
           ! update rest of the pencil
           ! update a(ihi-ns+1:ihi, ihi+1:istopm)
           ! from the left with qc(1:ns,1:ns)'
           sheight = ns
           swidth = istopm-( ihi+1 )+1
           if ( swidth > 0 ) then
              call stdlib_${ci}$gemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,a( ihi-ns+1, &
                        ihi+1 ), lda, czero, work, sheight )
              call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight,a( ihi-ns+1, ihi+1 ), lda &
                        )
              call stdlib_${ci}$gemm( 'C', 'N', sheight, swidth, sheight, cone, qc, ldqc,b( ihi-ns+1, &
                        ihi+1 ), ldb, czero, work, sheight )
              call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight,b( ihi-ns+1, ihi+1 ), ldb &
                        )
           end if
           if ( ilq ) then
              call stdlib_${ci}$gemm( 'N', 'N', n, ns, ns, cone, q( 1, ihi-ns+1 ), ldq,qc, ldqc, czero,&
                         work, n )
              call stdlib_${ci}$lacpy( 'ALL', n, ns, work, n, q( 1, ihi-ns+1 ), ldq )
           end if
           ! update a(istartm:ihi-ns,ihi-ns:ihi)
           ! from the right with zc(1:ns+1,1:ns+1)
           sheight = ihi-ns-istartm+1
           swidth = ns+1
           if ( sheight > 0 ) then
              call stdlib_${ci}$gemm( 'N', 'N', sheight, swidth, swidth, cone,a( istartm, ihi-ns ), &
                        lda, zc, ldzc, czero, work,sheight )
              call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ihi-ns ), lda &
                        )
              call stdlib_${ci}$gemm( 'N', 'N', sheight, swidth, swidth, cone,b( istartm, ihi-ns ), &
                        ldb, zc, ldzc, czero, work,sheight )
              call stdlib_${ci}$lacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ihi-ns ), ldb &
                        )
           end if
           if ( ilz ) then
              call stdlib_${ci}$gemm( 'N', 'N', n, ns+1, ns+1, cone, z( 1, ihi-ns ), ldz,zc, ldzc, &
                        czero, work, n )
              call stdlib_${ci}$lacpy( 'ALL', n, ns+1, work, n, z( 1, ihi-ns ), ldz )
           end if
     end subroutine stdlib_${ci}$laqz3

#:endif
#:endfor



     pure subroutine stdlib_slaln2( ltrans, na, nw, smin, ca, a, lda, d1, d2, b,ldb, wr, wi, x, &
     !! SLALN2 solves a system of the form  (ca A - w D ) X = s B
     !! or (ca A**T - w D) X = s B   with possible scaling ("s") and
     !! perturbation of A.  (A**T means A-transpose.)
     !! A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
     !! real diagonal matrix, w is a real or complex value, and X and B are
     !! NA x 1 matrices -- real if w is real, complex if w is complex.  NA
     !! may be 1 or 2.
     !! If w is complex, X and B are represented as NA x 2 matrices,
     !! the first column of each being the real part and the second
     !! being the imaginary part.
     !! "s" is a scaling factor (<= 1), computed by SLALN2, which is
     !! so chosen that X can be computed without overflow.  X is further
     !! scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
     !! than overflow.
     !! If both singular values of (ca A - w D) are less than SMIN,
     !! SMIN*identity will be used instead of (ca A - w D).  If only one
     !! singular value is less than SMIN, one element of (ca A - w D) will be
     !! perturbed enough to make the smallest singular value roughly SMIN.
     !! If both singular values are at least SMIN, (ca A - w D) will not be
     !! perturbed.  In any case, the perturbation will be at most some small
     !! multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
     !! are computed by infinity-norm approximations, and thus will only be
     !! correct to a factor of 2 or so.
     !! Note: all input quantities are assumed to be smaller than overflow
     !! by a reasonable factor.  (See BIGNUM.)
               ldx, scale, xnorm, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: ltrans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldx, na, nw
           real(sp), intent(in) :: ca, d1, d2, smin, wi, wr
           real(sp), intent(out) :: scale, xnorm
           ! Array Arguments 
           real(sp), intent(in) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: x(ldx,*)
       ! =====================================================================
           
           
           ! Local Scalars 
           integer(ilp) :: icmax, j
           real(sp) :: bbnd, bi1, bi2, bignum, bnorm, br1, br2, ci21, ci22, cmax, cnorm, cr21, &
           cr22, csi, csr, li21, lr21, smini, smlnum, temp, u22abs, ui11, ui11r, ui12, ui12s, &
                     ui22, ur11, ur11r, ur12, ur12s, ur22, xi1, xi2, xr1, xr2
           ! Local Arrays 
           logical(lk) :: cswap(4), rswap(4)
           integer(ilp) :: ipivot(4,4)
           real(sp) :: ci(2,2), civ(4), cr(2,2), crv(4)
           ! Intrinsic Functions 
           ! Equivalences 
           equivalence        ( ci( 1, 1 ), civ( 1 ) ),( cr( 1, 1 ), crv( 1 ) )
           ! Data Statements 
           cswap = [.false.,.false.,.true.,.true.]
           rswap = [.false.,.true.,.false.,.true.]
           ipivot = reshape([1,2,3,4,2,1,4,3,3,4,1,2,4,3,2,1],[4,4])
           ! Executable Statements 
           ! compute bignum
           smlnum = two*stdlib_slamch( 'SAFE MINIMUM' )
           bignum = one / smlnum
           smini = max( smin, smlnum )
           ! don't check for input errors
           info = 0
           ! standard initializations
           scale = one
           if( na==1 ) then
              ! 1 x 1  (i.e., scalar) system   c x = b
              if( nw==1 ) then
                 ! real 1x1 system.
                 ! c = ca a - w d
                 csr = ca*a( 1, 1 ) - wr*d1
                 cnorm = abs( csr )
                 ! if | c | < smini, use c = smini
                 if( cnorm<smini ) then
                    csr = smini
                    cnorm = smini
                    info = 1
                 end if
                 ! check scaling for  x = b / c
                 bnorm = abs( b( 1, 1 ) )
                 if( cnorm<one .and. bnorm>one ) then
                    if( bnorm>bignum*cnorm )scale = one / bnorm
                 end if
                 ! compute x
                 x( 1, 1 ) = ( b( 1, 1 )*scale ) / csr
                 xnorm = abs( x( 1, 1 ) )
              else
                 ! complex 1x1 system (w is complex)
                 ! c = ca a - w d
                 csr = ca*a( 1, 1 ) - wr*d1
                 csi = -wi*d1
                 cnorm = abs( csr ) + abs( csi )
                 ! if | c | < smini, use c = smini
                 if( cnorm<smini ) then
                    csr = smini
                    csi = zero
                    cnorm = smini
                    info = 1
                 end if
                 ! check scaling for  x = b / c
                 bnorm = abs( b( 1, 1 ) ) + abs( b( 1, 2 ) )
                 if( cnorm<one .and. bnorm>one ) then
                    if( bnorm>bignum*cnorm )scale = one / bnorm
                 end if
                 ! compute x
                 call stdlib_sladiv( scale*b( 1, 1 ), scale*b( 1, 2 ), csr, csi,x( 1, 1 ), x( 1, &
                           2 ) )
                 xnorm = abs( x( 1, 1 ) ) + abs( x( 1, 2 ) )
              end if
           else
              ! 2x2 system
              ! compute the realpart of  c = ca a - w d  (or  ca a**t - w d,KIND=sp)
              cr( 1, 1 ) = ca*a( 1, 1 ) - wr*d1
              cr( 2, 2 ) = ca*a( 2, 2 ) - wr*d2
              if( ltrans ) then
                 cr( 1, 2 ) = ca*a( 2, 1 )
                 cr( 2, 1 ) = ca*a( 1, 2 )
              else
                 cr( 2, 1 ) = ca*a( 2, 1 )
                 cr( 1, 2 ) = ca*a( 1, 2 )
              end if
              if( nw==1 ) then
                 ! real2x2 system  (w is real,KIND=sp)
                 ! find the largest element in c
                 cmax = zero
                 icmax = 0
                 do j = 1, 4
                    if( abs( crv( j ) )>cmax ) then
                       cmax = abs( crv( j ) )
                       icmax = j
                    end if
                 end do
                 ! if norm(c) < smini, use smini*identity.
                 if( cmax<smini ) then
                    bnorm = max( abs( b( 1, 1 ) ), abs( b( 2, 1 ) ) )
                    if( smini<one .and. bnorm>one ) then
                       if( bnorm>bignum*smini )scale = one / bnorm
                    end if
                    temp = scale / smini
                    x( 1, 1 ) = temp*b( 1, 1 )
                    x( 2, 1 ) = temp*b( 2, 1 )
                    xnorm = temp*bnorm
                    info = 1
                    return
                 end if
                 ! gaussian elimination with complete pivoting.
                 ur11 = crv( icmax )
                 cr21 = crv( ipivot( 2, icmax ) )
                 ur12 = crv( ipivot( 3, icmax ) )
                 cr22 = crv( ipivot( 4, icmax ) )
                 ur11r = one / ur11
                 lr21 = ur11r*cr21
                 ur22 = cr22 - ur12*lr21
                 ! if smaller pivot < smini, use smini
                 if( abs( ur22 )<smini ) then
                    ur22 = smini
                    info = 1
                 end if
                 if( rswap( icmax ) ) then
                    br1 = b( 2, 1 )
                    br2 = b( 1, 1 )
                 else
                    br1 = b( 1, 1 )
                    br2 = b( 2, 1 )
                 end if
                 br2 = br2 - lr21*br1
                 bbnd = max( abs( br1*( ur22*ur11r ) ), abs( br2 ) )
                 if( bbnd>one .and. abs( ur22 )<one ) then
                    if( bbnd>=bignum*abs( ur22 ) )scale = one / bbnd
                 end if
                 xr2 = ( br2*scale ) / ur22
                 xr1 = ( scale*br1 )*ur11r - xr2*( ur11r*ur12 )
                 if( cswap( icmax ) ) then
                    x( 1, 1 ) = xr2
                    x( 2, 1 ) = xr1
                 else
                    x( 1, 1 ) = xr1
                    x( 2, 1 ) = xr2
                 end if
                 xnorm = max( abs( xr1 ), abs( xr2 ) )
                 ! further scaling if  norm(a) norm(x) > overflow
                 if( xnorm>one .and. cmax>one ) then
                    if( xnorm>bignum / cmax ) then
                       temp = cmax / bignum
                       x( 1, 1 ) = temp*x( 1, 1 )
                       x( 2, 1 ) = temp*x( 2, 1 )
                       xnorm = temp*xnorm
                       scale = temp*scale
                    end if
                 end if
              else
                 ! complex 2x2 system  (w is complex)
                 ! find the largest element in c
                 ci( 1, 1 ) = -wi*d1
                 ci( 2, 1 ) = zero
                 ci( 1, 2 ) = zero
                 ci( 2, 2 ) = -wi*d2
                 cmax = zero
                 icmax = 0
                 do j = 1, 4
                    if( abs( crv( j ) )+abs( civ( j ) )>cmax ) then
                       cmax = abs( crv( j ) ) + abs( civ( j ) )
                       icmax = j
                    end if
                 end do
                 ! if norm(c) < smini, use smini*identity.
                 if( cmax<smini ) then
                    bnorm = max( abs( b( 1, 1 ) )+abs( b( 1, 2 ) ),abs( b( 2, 1 ) )+abs( b( 2, 2 )&
                               ) )
                    if( smini<one .and. bnorm>one ) then
                       if( bnorm>bignum*smini )scale = one / bnorm
                    end if
                    temp = scale / smini
                    x( 1, 1 ) = temp*b( 1, 1 )
                    x( 2, 1 ) = temp*b( 2, 1 )
                    x( 1, 2 ) = temp*b( 1, 2 )
                    x( 2, 2 ) = temp*b( 2, 2 )
                    xnorm = temp*bnorm
                    info = 1
                    return
                 end if
                 ! gaussian elimination with complete pivoting.
                 ur11 = crv( icmax )
                 ui11 = civ( icmax )
                 cr21 = crv( ipivot( 2, icmax ) )
                 ci21 = civ( ipivot( 2, icmax ) )
                 ur12 = crv( ipivot( 3, icmax ) )
                 ui12 = civ( ipivot( 3, icmax ) )
                 cr22 = crv( ipivot( 4, icmax ) )
                 ci22 = civ( ipivot( 4, icmax ) )
                 if( icmax==1 .or. icmax==4 ) then
                    ! code when off-diagonals of pivoted c are real
                    if( abs( ur11 )>abs( ui11 ) ) then
                       temp = ui11 / ur11
                       ur11r = one / ( ur11*( one+temp**2 ) )
                       ui11r = -temp*ur11r
                    else
                       temp = ur11 / ui11
                       ui11r = -one / ( ui11*( one+temp**2 ) )
                       ur11r = -temp*ui11r
                    end if
                    lr21 = cr21*ur11r
                    li21 = cr21*ui11r
                    ur12s = ur12*ur11r
                    ui12s = ur12*ui11r
                    ur22 = cr22 - ur12*lr21
                    ui22 = ci22 - ur12*li21
                 else
                    ! code when diagonals of pivoted c are real
                    ur11r = one / ur11
                    ui11r = zero
                    lr21 = cr21*ur11r
                    li21 = ci21*ur11r
                    ur12s = ur12*ur11r
                    ui12s = ui12*ur11r
                    ur22 = cr22 - ur12*lr21 + ui12*li21
                    ui22 = -ur12*li21 - ui12*lr21
                 end if
                 u22abs = abs( ur22 ) + abs( ui22 )
                 ! if smaller pivot < smini, use smini
                 if( u22abs<smini ) then
                    ur22 = smini
                    ui22 = zero
                    info = 1
                 end if
                 if( rswap( icmax ) ) then
                    br2 = b( 1, 1 )
                    br1 = b( 2, 1 )
                    bi2 = b( 1, 2 )
                    bi1 = b( 2, 2 )
                 else
                    br1 = b( 1, 1 )
                    br2 = b( 2, 1 )
                    bi1 = b( 1, 2 )
                    bi2 = b( 2, 2 )
                 end if
                 br2 = br2 - lr21*br1 + li21*bi1
                 bi2 = bi2 - li21*br1 - lr21*bi1
                 bbnd = max( ( abs( br1 )+abs( bi1 ) )*( u22abs*( abs( ur11r )+abs( ui11r ) ) ),&
                           abs( br2 )+abs( bi2 ) )
                 if( bbnd>one .and. u22abs<one ) then
                    if( bbnd>=bignum*u22abs ) then
                       scale = one / bbnd
                       br1 = scale*br1
                       bi1 = scale*bi1
                       br2 = scale*br2
                       bi2 = scale*bi2
                    end if
                 end if
                 call stdlib_sladiv( br2, bi2, ur22, ui22, xr2, xi2 )
                 xr1 = ur11r*br1 - ui11r*bi1 - ur12s*xr2 + ui12s*xi2
                 xi1 = ui11r*br1 + ur11r*bi1 - ui12s*xr2 - ur12s*xi2
                 if( cswap( icmax ) ) then
                    x( 1, 1 ) = xr2
                    x( 2, 1 ) = xr1
                    x( 1, 2 ) = xi2
                    x( 2, 2 ) = xi1
                 else
                    x( 1, 1 ) = xr1
                    x( 2, 1 ) = xr2
                    x( 1, 2 ) = xi1
                    x( 2, 2 ) = xi2
                 end if
                 xnorm = max( abs( xr1 )+abs( xi1 ), abs( xr2 )+abs( xi2 ) )
                 ! further scaling if  norm(a) norm(x) > overflow
                 if( xnorm>one .and. cmax>one ) then
                    if( xnorm>bignum / cmax ) then
                       temp = cmax / bignum
                       x( 1, 1 ) = temp*x( 1, 1 )
                       x( 2, 1 ) = temp*x( 2, 1 )
                       x( 1, 2 ) = temp*x( 1, 2 )
                       x( 2, 2 ) = temp*x( 2, 2 )
                       xnorm = temp*xnorm
                       scale = temp*scale
                    end if
                 end if
              end if
           end if
           return
     end subroutine stdlib_slaln2

     pure subroutine stdlib_dlaln2( ltrans, na, nw, smin, ca, a, lda, d1, d2, b,ldb, wr, wi, x, &
     !! DLALN2 solves a system of the form  (ca A - w D ) X = s B
     !! or (ca A**T - w D) X = s B   with possible scaling ("s") and
     !! perturbation of A.  (A**T means A-transpose.)
     !! A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
     !! real diagonal matrix, w is a real or complex value, and X and B are
     !! NA x 1 matrices -- real if w is real, complex if w is complex.  NA
     !! may be 1 or 2.
     !! If w is complex, X and B are represented as NA x 2 matrices,
     !! the first column of each being the real part and the second
     !! being the imaginary part.
     !! "s" is a scaling factor (<= 1), computed by DLALN2, which is
     !! so chosen that X can be computed without overflow.  X is further
     !! scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
     !! than overflow.
     !! If both singular values of (ca A - w D) are less than SMIN,
     !! SMIN*identity will be used instead of (ca A - w D).  If only one
     !! singular value is less than SMIN, one element of (ca A - w D) will be
     !! perturbed enough to make the smallest singular value roughly SMIN.
     !! If both singular values are at least SMIN, (ca A - w D) will not be
     !! perturbed.  In any case, the perturbation will be at most some small
     !! multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
     !! are computed by infinity-norm approximations, and thus will only be
     !! correct to a factor of 2 or so.
     !! Note: all input quantities are assumed to be smaller than overflow
     !! by a reasonable factor.  (See BIGNUM.)
               ldx, scale, xnorm, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: ltrans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldx, na, nw
           real(dp), intent(in) :: ca, d1, d2, smin, wi, wr
           real(dp), intent(out) :: scale, xnorm
           ! Array Arguments 
           real(dp), intent(in) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: x(ldx,*)
       ! =====================================================================
           
           
           ! Local Scalars 
           integer(ilp) :: icmax, j
           real(dp) :: bbnd, bi1, bi2, bignum, bnorm, br1, br2, ci21, ci22, cmax, cnorm, cr21, &
           cr22, csi, csr, li21, lr21, smini, smlnum, temp, u22abs, ui11, ui11r, ui12, ui12s, &
                     ui22, ur11, ur11r, ur12, ur12s, ur22, xi1, xi2, xr1, xr2
           ! Local Arrays 
           logical(lk) :: rswap(4), zswap(4)
           integer(ilp) :: ipivot(4,4)
           real(dp) :: ci(2,2), civ(4), cr(2,2), crv(4)
           ! Intrinsic Functions 
           ! Equivalences 
           equivalence        ( ci( 1, 1 ), civ( 1 ) ),( cr( 1, 1 ), crv( 1 ) )
           ! Data Statements 
           zswap = [.false.,.false.,.true.,.true.]
           rswap = [.false.,.true.,.false.,.true.]
           ipivot = reshape([1,2,3,4,2,1,4,3,3,4,1,2,4,3,2,1],[4,4])
           ! Executable Statements 
           ! compute bignum
           smlnum = two*stdlib_dlamch( 'SAFE MINIMUM' )
           bignum = one / smlnum
           smini = max( smin, smlnum )
           ! don't check for input errors
           info = 0
           ! standard initializations
           scale = one
           if( na==1 ) then
              ! 1 x 1  (i.e., scalar) system   c x = b
              if( nw==1 ) then
                 ! real 1x1 system.
                 ! c = ca a - w d
                 csr = ca*a( 1, 1 ) - wr*d1
                 cnorm = abs( csr )
                 ! if | c | < smini, use c = smini
                 if( cnorm<smini ) then
                    csr = smini
                    cnorm = smini
                    info = 1
                 end if
                 ! check scaling for  x = b / c
                 bnorm = abs( b( 1, 1 ) )
                 if( cnorm<one .and. bnorm>one ) then
                    if( bnorm>bignum*cnorm )scale = one / bnorm
                 end if
                 ! compute x
                 x( 1, 1 ) = ( b( 1, 1 )*scale ) / csr
                 xnorm = abs( x( 1, 1 ) )
              else
                 ! complex 1x1 system (w is complex)
                 ! c = ca a - w d
                 csr = ca*a( 1, 1 ) - wr*d1
                 csi = -wi*d1
                 cnorm = abs( csr ) + abs( csi )
                 ! if | c | < smini, use c = smini
                 if( cnorm<smini ) then
                    csr = smini
                    csi = zero
                    cnorm = smini
                    info = 1
                 end if
                 ! check scaling for  x = b / c
                 bnorm = abs( b( 1, 1 ) ) + abs( b( 1, 2 ) )
                 if( cnorm<one .and. bnorm>one ) then
                    if( bnorm>bignum*cnorm )scale = one / bnorm
                 end if
                 ! compute x
                 call stdlib_dladiv( scale*b( 1, 1 ), scale*b( 1, 2 ), csr, csi,x( 1, 1 ), x( 1, &
                           2 ) )
                 xnorm = abs( x( 1, 1 ) ) + abs( x( 1, 2 ) )
              end if
           else
              ! 2x2 system
              ! compute the realpart of  c = ca a - w d  (or  ca a**t - w d,KIND=dp)
              cr( 1, 1 ) = ca*a( 1, 1 ) - wr*d1
              cr( 2, 2 ) = ca*a( 2, 2 ) - wr*d2
              if( ltrans ) then
                 cr( 1, 2 ) = ca*a( 2, 1 )
                 cr( 2, 1 ) = ca*a( 1, 2 )
              else
                 cr( 2, 1 ) = ca*a( 2, 1 )
                 cr( 1, 2 ) = ca*a( 1, 2 )
              end if
              if( nw==1 ) then
                 ! real2x2 system  (w is real,KIND=dp)
                 ! find the largest element in c
                 cmax = zero
                 icmax = 0
                 do j = 1, 4
                    if( abs( crv( j ) )>cmax ) then
                       cmax = abs( crv( j ) )
                       icmax = j
                    end if
                 end do
                 ! if norm(c) < smini, use smini*identity.
                 if( cmax<smini ) then
                    bnorm = max( abs( b( 1, 1 ) ), abs( b( 2, 1 ) ) )
                    if( smini<one .and. bnorm>one ) then
                       if( bnorm>bignum*smini )scale = one / bnorm
                    end if
                    temp = scale / smini
                    x( 1, 1 ) = temp*b( 1, 1 )
                    x( 2, 1 ) = temp*b( 2, 1 )
                    xnorm = temp*bnorm
                    info = 1
                    return
                 end if
                 ! gaussian elimination with complete pivoting.
                 ur11 = crv( icmax )
                 cr21 = crv( ipivot( 2, icmax ) )
                 ur12 = crv( ipivot( 3, icmax ) )
                 cr22 = crv( ipivot( 4, icmax ) )
                 ur11r = one / ur11
                 lr21 = ur11r*cr21
                 ur22 = cr22 - ur12*lr21
                 ! if smaller pivot < smini, use smini
                 if( abs( ur22 )<smini ) then
                    ur22 = smini
                    info = 1
                 end if
                 if( rswap( icmax ) ) then
                    br1 = b( 2, 1 )
                    br2 = b( 1, 1 )
                 else
                    br1 = b( 1, 1 )
                    br2 = b( 2, 1 )
                 end if
                 br2 = br2 - lr21*br1
                 bbnd = max( abs( br1*( ur22*ur11r ) ), abs( br2 ) )
                 if( bbnd>one .and. abs( ur22 )<one ) then
                    if( bbnd>=bignum*abs( ur22 ) )scale = one / bbnd
                 end if
                 xr2 = ( br2*scale ) / ur22
                 xr1 = ( scale*br1 )*ur11r - xr2*( ur11r*ur12 )
                 if( zswap( icmax ) ) then
                    x( 1, 1 ) = xr2
                    x( 2, 1 ) = xr1
                 else
                    x( 1, 1 ) = xr1
                    x( 2, 1 ) = xr2
                 end if
                 xnorm = max( abs( xr1 ), abs( xr2 ) )
                 ! further scaling if  norm(a) norm(x) > overflow
                 if( xnorm>one .and. cmax>one ) then
                    if( xnorm>bignum / cmax ) then
                       temp = cmax / bignum
                       x( 1, 1 ) = temp*x( 1, 1 )
                       x( 2, 1 ) = temp*x( 2, 1 )
                       xnorm = temp*xnorm
                       scale = temp*scale
                    end if
                 end if
              else
                 ! complex 2x2 system  (w is complex)
                 ! find the largest element in c
                 ci( 1, 1 ) = -wi*d1
                 ci( 2, 1 ) = zero
                 ci( 1, 2 ) = zero
                 ci( 2, 2 ) = -wi*d2
                 cmax = zero
                 icmax = 0
                 do j = 1, 4
                    if( abs( crv( j ) )+abs( civ( j ) )>cmax ) then
                       cmax = abs( crv( j ) ) + abs( civ( j ) )
                       icmax = j
                    end if
                 end do
                 ! if norm(c) < smini, use smini*identity.
                 if( cmax<smini ) then
                    bnorm = max( abs( b( 1, 1 ) )+abs( b( 1, 2 ) ),abs( b( 2, 1 ) )+abs( b( 2, 2 )&
                               ) )
                    if( smini<one .and. bnorm>one ) then
                       if( bnorm>bignum*smini )scale = one / bnorm
                    end if
                    temp = scale / smini
                    x( 1, 1 ) = temp*b( 1, 1 )
                    x( 2, 1 ) = temp*b( 2, 1 )
                    x( 1, 2 ) = temp*b( 1, 2 )
                    x( 2, 2 ) = temp*b( 2, 2 )
                    xnorm = temp*bnorm
                    info = 1
                    return
                 end if
                 ! gaussian elimination with complete pivoting.
                 ur11 = crv( icmax )
                 ui11 = civ( icmax )
                 cr21 = crv( ipivot( 2, icmax ) )
                 ci21 = civ( ipivot( 2, icmax ) )
                 ur12 = crv( ipivot( 3, icmax ) )
                 ui12 = civ( ipivot( 3, icmax ) )
                 cr22 = crv( ipivot( 4, icmax ) )
                 ci22 = civ( ipivot( 4, icmax ) )
                 if( icmax==1 .or. icmax==4 ) then
                    ! code when off-diagonals of pivoted c are real
                    if( abs( ur11 )>abs( ui11 ) ) then
                       temp = ui11 / ur11
                       ur11r = one / ( ur11*( one+temp**2 ) )
                       ui11r = -temp*ur11r
                    else
                       temp = ur11 / ui11
                       ui11r = -one / ( ui11*( one+temp**2 ) )
                       ur11r = -temp*ui11r
                    end if
                    lr21 = cr21*ur11r
                    li21 = cr21*ui11r
                    ur12s = ur12*ur11r
                    ui12s = ur12*ui11r
                    ur22 = cr22 - ur12*lr21
                    ui22 = ci22 - ur12*li21
                 else
                    ! code when diagonals of pivoted c are real
                    ur11r = one / ur11
                    ui11r = zero
                    lr21 = cr21*ur11r
                    li21 = ci21*ur11r
                    ur12s = ur12*ur11r
                    ui12s = ui12*ur11r
                    ur22 = cr22 - ur12*lr21 + ui12*li21
                    ui22 = -ur12*li21 - ui12*lr21
                 end if
                 u22abs = abs( ur22 ) + abs( ui22 )
                 ! if smaller pivot < smini, use smini
                 if( u22abs<smini ) then
                    ur22 = smini
                    ui22 = zero
                    info = 1
                 end if
                 if( rswap( icmax ) ) then
                    br2 = b( 1, 1 )
                    br1 = b( 2, 1 )
                    bi2 = b( 1, 2 )
                    bi1 = b( 2, 2 )
                 else
                    br1 = b( 1, 1 )
                    br2 = b( 2, 1 )
                    bi1 = b( 1, 2 )
                    bi2 = b( 2, 2 )
                 end if
                 br2 = br2 - lr21*br1 + li21*bi1
                 bi2 = bi2 - li21*br1 - lr21*bi1
                 bbnd = max( ( abs( br1 )+abs( bi1 ) )*( u22abs*( abs( ur11r )+abs( ui11r ) ) ),&
                           abs( br2 )+abs( bi2 ) )
                 if( bbnd>one .and. u22abs<one ) then
                    if( bbnd>=bignum*u22abs ) then
                       scale = one / bbnd
                       br1 = scale*br1
                       bi1 = scale*bi1
                       br2 = scale*br2
                       bi2 = scale*bi2
                    end if
                 end if
                 call stdlib_dladiv( br2, bi2, ur22, ui22, xr2, xi2 )
                 xr1 = ur11r*br1 - ui11r*bi1 - ur12s*xr2 + ui12s*xi2
                 xi1 = ui11r*br1 + ur11r*bi1 - ui12s*xr2 - ur12s*xi2
                 if( zswap( icmax ) ) then
                    x( 1, 1 ) = xr2
                    x( 2, 1 ) = xr1
                    x( 1, 2 ) = xi2
                    x( 2, 2 ) = xi1
                 else
                    x( 1, 1 ) = xr1
                    x( 2, 1 ) = xr2
                    x( 1, 2 ) = xi1
                    x( 2, 2 ) = xi2
                 end if
                 xnorm = max( abs( xr1 )+abs( xi1 ), abs( xr2 )+abs( xi2 ) )
                 ! further scaling if  norm(a) norm(x) > overflow
                 if( xnorm>one .and. cmax>one ) then
                    if( xnorm>bignum / cmax ) then
                       temp = cmax / bignum
                       x( 1, 1 ) = temp*x( 1, 1 )
                       x( 2, 1 ) = temp*x( 2, 1 )
                       x( 1, 2 ) = temp*x( 1, 2 )
                       x( 2, 2 ) = temp*x( 2, 2 )
                       xnorm = temp*xnorm
                       scale = temp*scale
                    end if
                 end if
              end if
           end if
           return
     end subroutine stdlib_dlaln2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$laln2( ltrans, na, nw, smin, ca, a, lda, d1, d2, b,ldb, wr, wi, x, &
     !! DLALN2: solves a system of the form  (ca A - w D ) X = s B
     !! or (ca A**T - w D) X = s B   with possible scaling ("s") and
     !! perturbation of A.  (A**T means A-transpose.)
     !! A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
     !! real diagonal matrix, w is a real or complex value, and X and B are
     !! NA x 1 matrices -- real if w is real, complex if w is complex.  NA
     !! may be 1 or 2.
     !! If w is complex, X and B are represented as NA x 2 matrices,
     !! the first column of each being the real part and the second
     !! being the imaginary part.
     !! "s" is a scaling factor (<= 1), computed by DLALN2, which is
     !! so chosen that X can be computed without overflow.  X is further
     !! scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
     !! than overflow.
     !! If both singular values of (ca A - w D) are less than SMIN,
     !! SMIN*identity will be used instead of (ca A - w D).  If only one
     !! singular value is less than SMIN, one element of (ca A - w D) will be
     !! perturbed enough to make the smallest singular value roughly SMIN.
     !! If both singular values are at least SMIN, (ca A - w D) will not be
     !! perturbed.  In any case, the perturbation will be at most some small
     !! multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
     !! are computed by infinity-norm approximations, and thus will only be
     !! correct to a factor of 2 or so.
     !! Note: all input quantities are assumed to be smaller than overflow
     !! by a reasonable factor.  (See BIGNUM.)
               ldx, scale, xnorm, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: ltrans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldx, na, nw
           real(${rk}$), intent(in) :: ca, d1, d2, smin, wi, wr
           real(${rk}$), intent(out) :: scale, xnorm
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: x(ldx,*)
       ! =====================================================================
           
           
           ! Local Scalars 
           integer(ilp) :: icmax, j
           real(${rk}$) :: bbnd, bi1, bi2, bignum, bnorm, br1, br2, ci21, ci22, cmax, cnorm, cr21, &
           cr22, csi, csr, li21, lr21, smini, smlnum, temp, u22abs, ui11, ui11r, ui12, ui12s, &
                     ui22, ur11, ur11r, ur12, ur12s, ur22, xi1, xi2, xr1, xr2
           ! Local Arrays 
           logical(lk) :: rswap(4), zswap(4)
           integer(ilp) :: ipivot(4,4)
           real(${rk}$) :: ci(2,2), civ(4), cr(2,2), crv(4)
           ! Intrinsic Functions 
           ! Equivalences 
           equivalence        ( ci( 1, 1 ), civ( 1 ) ),( cr( 1, 1 ), crv( 1 ) )
           ! Data Statements 
           zswap = [.false.,.false.,.true.,.true.]
           rswap = [.false.,.true.,.false.,.true.]
           ipivot = reshape([1,2,3,4,2,1,4,3,3,4,1,2,4,3,2,1],[4,4])
           ! Executable Statements 
           ! compute bignum
           smlnum = two*stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           bignum = one / smlnum
           smini = max( smin, smlnum )
           ! don't check for input errors
           info = 0
           ! standard initializations
           scale = one
           if( na==1 ) then
              ! 1 x 1  (i.e., scalar) system   c x = b
              if( nw==1 ) then
                 ! real 1x1 system.
                 ! c = ca a - w d
                 csr = ca*a( 1, 1 ) - wr*d1
                 cnorm = abs( csr )
                 ! if | c | < smini, use c = smini
                 if( cnorm<smini ) then
                    csr = smini
                    cnorm = smini
                    info = 1
                 end if
                 ! check scaling for  x = b / c
                 bnorm = abs( b( 1, 1 ) )
                 if( cnorm<one .and. bnorm>one ) then
                    if( bnorm>bignum*cnorm )scale = one / bnorm
                 end if
                 ! compute x
                 x( 1, 1 ) = ( b( 1, 1 )*scale ) / csr
                 xnorm = abs( x( 1, 1 ) )
              else
                 ! complex 1x1 system (w is complex)
                 ! c = ca a - w d
                 csr = ca*a( 1, 1 ) - wr*d1
                 csi = -wi*d1
                 cnorm = abs( csr ) + abs( csi )
                 ! if | c | < smini, use c = smini
                 if( cnorm<smini ) then
                    csr = smini
                    csi = zero
                    cnorm = smini
                    info = 1
                 end if
                 ! check scaling for  x = b / c
                 bnorm = abs( b( 1, 1 ) ) + abs( b( 1, 2 ) )
                 if( cnorm<one .and. bnorm>one ) then
                    if( bnorm>bignum*cnorm )scale = one / bnorm
                 end if
                 ! compute x
                 call stdlib_${ri}$ladiv( scale*b( 1, 1 ), scale*b( 1, 2 ), csr, csi,x( 1, 1 ), x( 1, &
                           2 ) )
                 xnorm = abs( x( 1, 1 ) ) + abs( x( 1, 2 ) )
              end if
           else
              ! 2x2 system
              ! compute the realpart of  c = ca a - w d  (or  ca a**t - w d,KIND=${rk}$)
              cr( 1, 1 ) = ca*a( 1, 1 ) - wr*d1
              cr( 2, 2 ) = ca*a( 2, 2 ) - wr*d2
              if( ltrans ) then
                 cr( 1, 2 ) = ca*a( 2, 1 )
                 cr( 2, 1 ) = ca*a( 1, 2 )
              else
                 cr( 2, 1 ) = ca*a( 2, 1 )
                 cr( 1, 2 ) = ca*a( 1, 2 )
              end if
              if( nw==1 ) then
                 ! real2x2 system  (w is real,KIND=${rk}$)
                 ! find the largest element in c
                 cmax = zero
                 icmax = 0
                 do j = 1, 4
                    if( abs( crv( j ) )>cmax ) then
                       cmax = abs( crv( j ) )
                       icmax = j
                    end if
                 end do
                 ! if norm(c) < smini, use smini*identity.
                 if( cmax<smini ) then
                    bnorm = max( abs( b( 1, 1 ) ), abs( b( 2, 1 ) ) )
                    if( smini<one .and. bnorm>one ) then
                       if( bnorm>bignum*smini )scale = one / bnorm
                    end if
                    temp = scale / smini
                    x( 1, 1 ) = temp*b( 1, 1 )
                    x( 2, 1 ) = temp*b( 2, 1 )
                    xnorm = temp*bnorm
                    info = 1
                    return
                 end if
                 ! gaussian elimination with complete pivoting.
                 ur11 = crv( icmax )
                 cr21 = crv( ipivot( 2, icmax ) )
                 ur12 = crv( ipivot( 3, icmax ) )
                 cr22 = crv( ipivot( 4, icmax ) )
                 ur11r = one / ur11
                 lr21 = ur11r*cr21
                 ur22 = cr22 - ur12*lr21
                 ! if smaller pivot < smini, use smini
                 if( abs( ur22 )<smini ) then
                    ur22 = smini
                    info = 1
                 end if
                 if( rswap( icmax ) ) then
                    br1 = b( 2, 1 )
                    br2 = b( 1, 1 )
                 else
                    br1 = b( 1, 1 )
                    br2 = b( 2, 1 )
                 end if
                 br2 = br2 - lr21*br1
                 bbnd = max( abs( br1*( ur22*ur11r ) ), abs( br2 ) )
                 if( bbnd>one .and. abs( ur22 )<one ) then
                    if( bbnd>=bignum*abs( ur22 ) )scale = one / bbnd
                 end if
                 xr2 = ( br2*scale ) / ur22
                 xr1 = ( scale*br1 )*ur11r - xr2*( ur11r*ur12 )
                 if( zswap( icmax ) ) then
                    x( 1, 1 ) = xr2
                    x( 2, 1 ) = xr1
                 else
                    x( 1, 1 ) = xr1
                    x( 2, 1 ) = xr2
                 end if
                 xnorm = max( abs( xr1 ), abs( xr2 ) )
                 ! further scaling if  norm(a) norm(x) > overflow
                 if( xnorm>one .and. cmax>one ) then
                    if( xnorm>bignum / cmax ) then
                       temp = cmax / bignum
                       x( 1, 1 ) = temp*x( 1, 1 )
                       x( 2, 1 ) = temp*x( 2, 1 )
                       xnorm = temp*xnorm
                       scale = temp*scale
                    end if
                 end if
              else
                 ! complex 2x2 system  (w is complex)
                 ! find the largest element in c
                 ci( 1, 1 ) = -wi*d1
                 ci( 2, 1 ) = zero
                 ci( 1, 2 ) = zero
                 ci( 2, 2 ) = -wi*d2
                 cmax = zero
                 icmax = 0
                 do j = 1, 4
                    if( abs( crv( j ) )+abs( civ( j ) )>cmax ) then
                       cmax = abs( crv( j ) ) + abs( civ( j ) )
                       icmax = j
                    end if
                 end do
                 ! if norm(c) < smini, use smini*identity.
                 if( cmax<smini ) then
                    bnorm = max( abs( b( 1, 1 ) )+abs( b( 1, 2 ) ),abs( b( 2, 1 ) )+abs( b( 2, 2 )&
                               ) )
                    if( smini<one .and. bnorm>one ) then
                       if( bnorm>bignum*smini )scale = one / bnorm
                    end if
                    temp = scale / smini
                    x( 1, 1 ) = temp*b( 1, 1 )
                    x( 2, 1 ) = temp*b( 2, 1 )
                    x( 1, 2 ) = temp*b( 1, 2 )
                    x( 2, 2 ) = temp*b( 2, 2 )
                    xnorm = temp*bnorm
                    info = 1
                    return
                 end if
                 ! gaussian elimination with complete pivoting.
                 ur11 = crv( icmax )
                 ui11 = civ( icmax )
                 cr21 = crv( ipivot( 2, icmax ) )
                 ci21 = civ( ipivot( 2, icmax ) )
                 ur12 = crv( ipivot( 3, icmax ) )
                 ui12 = civ( ipivot( 3, icmax ) )
                 cr22 = crv( ipivot( 4, icmax ) )
                 ci22 = civ( ipivot( 4, icmax ) )
                 if( icmax==1 .or. icmax==4 ) then
                    ! code when off-diagonals of pivoted c are real
                    if( abs( ur11 )>abs( ui11 ) ) then
                       temp = ui11 / ur11
                       ur11r = one / ( ur11*( one+temp**2 ) )
                       ui11r = -temp*ur11r
                    else
                       temp = ur11 / ui11
                       ui11r = -one / ( ui11*( one+temp**2 ) )
                       ur11r = -temp*ui11r
                    end if
                    lr21 = cr21*ur11r
                    li21 = cr21*ui11r
                    ur12s = ur12*ur11r
                    ui12s = ur12*ui11r
                    ur22 = cr22 - ur12*lr21
                    ui22 = ci22 - ur12*li21
                 else
                    ! code when diagonals of pivoted c are real
                    ur11r = one / ur11
                    ui11r = zero
                    lr21 = cr21*ur11r
                    li21 = ci21*ur11r
                    ur12s = ur12*ur11r
                    ui12s = ui12*ur11r
                    ur22 = cr22 - ur12*lr21 + ui12*li21
                    ui22 = -ur12*li21 - ui12*lr21
                 end if
                 u22abs = abs( ur22 ) + abs( ui22 )
                 ! if smaller pivot < smini, use smini
                 if( u22abs<smini ) then
                    ur22 = smini
                    ui22 = zero
                    info = 1
                 end if
                 if( rswap( icmax ) ) then
                    br2 = b( 1, 1 )
                    br1 = b( 2, 1 )
                    bi2 = b( 1, 2 )
                    bi1 = b( 2, 2 )
                 else
                    br1 = b( 1, 1 )
                    br2 = b( 2, 1 )
                    bi1 = b( 1, 2 )
                    bi2 = b( 2, 2 )
                 end if
                 br2 = br2 - lr21*br1 + li21*bi1
                 bi2 = bi2 - li21*br1 - lr21*bi1
                 bbnd = max( ( abs( br1 )+abs( bi1 ) )*( u22abs*( abs( ur11r )+abs( ui11r ) ) ),&
                           abs( br2 )+abs( bi2 ) )
                 if( bbnd>one .and. u22abs<one ) then
                    if( bbnd>=bignum*u22abs ) then
                       scale = one / bbnd
                       br1 = scale*br1
                       bi1 = scale*bi1
                       br2 = scale*br2
                       bi2 = scale*bi2
                    end if
                 end if
                 call stdlib_${ri}$ladiv( br2, bi2, ur22, ui22, xr2, xi2 )
                 xr1 = ur11r*br1 - ui11r*bi1 - ur12s*xr2 + ui12s*xi2
                 xi1 = ui11r*br1 + ur11r*bi1 - ui12s*xr2 - ur12s*xi2
                 if( zswap( icmax ) ) then
                    x( 1, 1 ) = xr2
                    x( 2, 1 ) = xr1
                    x( 1, 2 ) = xi2
                    x( 2, 2 ) = xi1
                 else
                    x( 1, 1 ) = xr1
                    x( 2, 1 ) = xr2
                    x( 1, 2 ) = xi1
                    x( 2, 2 ) = xi2
                 end if
                 xnorm = max( abs( xr1 )+abs( xi1 ), abs( xr2 )+abs( xi2 ) )
                 ! further scaling if  norm(a) norm(x) > overflow
                 if( xnorm>one .and. cmax>one ) then
                    if( xnorm>bignum / cmax ) then
                       temp = cmax / bignum
                       x( 1, 1 ) = temp*x( 1, 1 )
                       x( 2, 1 ) = temp*x( 2, 1 )
                       x( 1, 2 ) = temp*x( 1, 2 )
                       x( 2, 2 ) = temp*x( 2, 2 )
                       xnorm = temp*xnorm
                       scale = temp*scale
                    end if
                 end if
              end if
           end if
           return
     end subroutine stdlib_${ri}$laln2

#:endif
#:endfor





     pure subroutine stdlib_sgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
     !! SGEBAK forms the right or left eigenvectors of a real general matrix
     !! by backward transformation on the computed eigenvectors of the
     !! balanced matrix output by SGEBAL.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(inout) :: v(ldv,*)
           real(sp), intent(in) :: scale(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, ii, k
           real(sp) :: s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( m<0 ) then
              info = -7
           else if( ldv<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGEBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 do i = ilo, ihi
                    s = scale( i )
                    call stdlib_sscal( m, s, v( i, 1 ), ldv )
                 end do
              end if
              if( leftv ) then
                 do i = ilo, ihi
                    s = one / scale( i )
                    call stdlib_sscal( m, s, v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           ! for  i = ilo-1 step -1 until 1,
                    ! ihi+1 step 1 until n do --
                    30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 loop_40: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_40
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_40
                    call stdlib_sswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
              end if
              if( leftv ) then
                 loop_50: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_50
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_50
                    call stdlib_sswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_50
              end if
           end if
           return
     end subroutine stdlib_sgebak

     pure subroutine stdlib_dgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
     !! DGEBAK forms the right or left eigenvectors of a real general matrix
     !! by backward transformation on the computed eigenvectors of the
     !! balanced matrix output by DGEBAL.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(in) :: scale(*)
           real(dp), intent(inout) :: v(ldv,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, ii, k
           real(dp) :: s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( m<0 ) then
              info = -7
           else if( ldv<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 do i = ilo, ihi
                    s = scale( i )
                    call stdlib_dscal( m, s, v( i, 1 ), ldv )
                 end do
              end if
              if( leftv ) then
                 do i = ilo, ihi
                    s = one / scale( i )
                    call stdlib_dscal( m, s, v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           ! for  i = ilo-1 step -1 until 1,
                    ! ihi+1 step 1 until n do --
                    30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 loop_40: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_40
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_40
                    call stdlib_dswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
              end if
              if( leftv ) then
                 loop_50: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_50
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_50
                    call stdlib_dswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_50
              end if
           end if
           return
     end subroutine stdlib_dgebak

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$gebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
     !! DGEBAK: forms the right or left eigenvectors of a real general matrix
     !! by backward transformation on the computed eigenvectors of the
     !! balanced matrix output by DGEBAL.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(in) :: scale(*)
           real(${rk}$), intent(inout) :: v(ldv,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, ii, k
           real(${rk}$) :: s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( m<0 ) then
              info = -7
           else if( ldv<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 do i = ilo, ihi
                    s = scale( i )
                    call stdlib_${ri}$scal( m, s, v( i, 1 ), ldv )
                 end do
              end if
              if( leftv ) then
                 do i = ilo, ihi
                    s = one / scale( i )
                    call stdlib_${ri}$scal( m, s, v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           ! for  i = ilo-1 step -1 until 1,
                    ! ihi+1 step 1 until n do --
                    30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 loop_40: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_40
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_40
                    call stdlib_${ri}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
              end if
              if( leftv ) then
                 loop_50: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_50
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_50
                    call stdlib_${ri}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_50
              end if
           end if
           return
     end subroutine stdlib_${ri}$gebak

#:endif
#:endfor

     pure subroutine stdlib_cgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
     !! CGEBAK forms the right or left eigenvectors of a complex general
     !! matrix by backward transformation on the computed eigenvectors of the
     !! balanced matrix output by CGEBAL.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(in) :: scale(*)
           complex(sp), intent(inout) :: v(ldv,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, ii, k
           real(sp) :: s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( m<0 ) then
              info = -7
           else if( ldv<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 do i = ilo, ihi
                    s = scale( i )
                    call stdlib_csscal( m, s, v( i, 1 ), ldv )
                 end do
              end if
              if( leftv ) then
                 do i = ilo, ihi
                    s = one / scale( i )
                    call stdlib_csscal( m, s, v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           ! for  i = ilo-1 step -1 until 1,
                    ! ihi+1 step 1 until n do --
                    30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 loop_40: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_40
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_40
                    call stdlib_cswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
              end if
              if( leftv ) then
                 loop_50: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_50
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_50
                    call stdlib_cswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_50
              end if
           end if
           return
     end subroutine stdlib_cgebak

     pure subroutine stdlib_zgebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
     !! ZGEBAK forms the right or left eigenvectors of a complex general
     !! matrix by backward transformation on the computed eigenvectors of the
     !! balanced matrix output by ZGEBAL.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(in) :: scale(*)
           complex(dp), intent(inout) :: v(ldv,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, ii, k
           real(dp) :: s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( m<0 ) then
              info = -7
           else if( ldv<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 do i = ilo, ihi
                    s = scale( i )
                    call stdlib_zdscal( m, s, v( i, 1 ), ldv )
                 end do
              end if
              if( leftv ) then
                 do i = ilo, ihi
                    s = one / scale( i )
                    call stdlib_zdscal( m, s, v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           ! for  i = ilo-1 step -1 until 1,
                    ! ihi+1 step 1 until n do --
                    30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 loop_40: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_40
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_40
                    call stdlib_zswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
              end if
              if( leftv ) then
                 loop_50: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_50
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_50
                    call stdlib_zswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_50
              end if
           end if
           return
     end subroutine stdlib_zgebak

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$gebak( job, side, n, ilo, ihi, scale, m, v, ldv,info )
     !! ZGEBAK: forms the right or left eigenvectors of a complex general
     !! matrix by backward transformation on the computed eigenvectors of the
     !! balanced matrix output by ZGEBAL.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${ck}$), intent(in) :: scale(*)
           complex(${ck}$), intent(inout) :: v(ldv,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, ii, k
           real(${ck}$) :: s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( m<0 ) then
              info = -7
           else if( ldv<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 do i = ilo, ihi
                    s = scale( i )
                    call stdlib_${ci}$dscal( m, s, v( i, 1 ), ldv )
                 end do
              end if
              if( leftv ) then
                 do i = ilo, ihi
                    s = one / scale( i )
                    call stdlib_${ci}$dscal( m, s, v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           ! for  i = ilo-1 step -1 until 1,
                    ! ihi+1 step 1 until n do --
                    30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              if( rightv ) then
                 loop_40: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_40
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_40
                    call stdlib_${ci}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
              end if
              if( leftv ) then
                 loop_50: do ii = 1, n
                    i = ii
                    if( i>=ilo .and. i<=ihi )cycle loop_50
                    if( i<ilo )i = ilo - ii
                    k = scale( i )
                    if( k==i )cycle loop_50
                    call stdlib_${ci}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_50
              end if
           end if
           return
     end subroutine stdlib_${ci}$gebak

#:endif
#:endfor







     pure subroutine stdlib_slanv2( a, b, c, d, rt1r, rt1i, rt2r, rt2i, cs, sn )
     !! SLANV2 computes the Schur factorization of a real 2-by-2 nonsymmetric
     !! matrix in standard form:
     !! [ A  B ] = [ CS -SN ] [ AA  BB ] [ CS  SN ]
     !! [ C  D ]   [ SN  CS ] [ CC  DD ] [-SN  CS ]
     !! where either
     !! 1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or
     !! 2) AA = DD and BB*CC < 0, so that AA + or - sqrt(BB*CC) are complex
     !! conjugate eigenvalues.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(sp), intent(inout) :: a, b, c, d
           real(sp), intent(out) :: cs, rt1i, rt1r, rt2i, rt2r, sn
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: multpl = 4.0e+0_sp
           
           
           ! Local Scalars 
           real(sp) :: aa, bb, bcmax, bcmis, cc, cs1, dd, eps, p, sab, sac, scale, sigma, sn1, &
                     tau, temp, z, safmin, safmn2, safmx2
           integer(ilp) :: count
           ! Intrinsic Functions 
           ! Executable Statements 
           safmin = stdlib_slamch( 'S' )
           eps = stdlib_slamch( 'P' )
           safmn2 = stdlib_slamch( 'B' )**int( log( safmin / eps ) /log( stdlib_slamch( 'B' ) ) / &
                     two,KIND=ilp)
           safmx2 = one / safmn2
           if( c==zero ) then
              cs = one
              sn = zero
           else if( b==zero ) then
              ! swap rows and columns
              cs = zero
              sn = one
              temp = d
              d = a
              a = temp
              b = -c
              c = zero
           else if( (a-d)==zero .and. sign( one, b )/=sign( one, c ) ) then
              cs = one
              sn = zero
           else
              temp = a - d
              p = half*temp
              bcmax = max( abs( b ), abs( c ) )
              bcmis = min( abs( b ), abs( c ) )*sign( one, b )*sign( one, c )
              scale = max( abs( p ), bcmax )
              z = ( p / scale )*p + ( bcmax / scale )*bcmis
              ! if z is of the order of the machine accuracy, postpone the
              ! decision on the nature of eigenvalues
              if( z>=multpl*eps ) then
                 ! real eigenvalues. compute a and d.
                 z = p + sign( sqrt( scale )*sqrt( z ), p )
                 a = d + z
                 d = d - ( bcmax / z )*bcmis
                 ! compute b and the rotation matrix
                 tau = stdlib_slapy2( c, z )
                 cs = z / tau
                 sn = c / tau
                 b = b - c
                 c = zero
              else
                 ! complex eigenvalues, or real(almost,KIND=sp) equal eigenvalues.
                 ! make diagonal elements equal.
                 count = 0
                 sigma = b + c
                 10 continue
                 count = count + 1
                 scale = max( abs(temp), abs(sigma) )
                 if( scale>=safmx2 ) then
                    sigma = sigma * safmn2
                    temp = temp * safmn2
                    if (count <= 20)goto 10
                 end if
                 if( scale<=safmn2 ) then
                    sigma = sigma * safmx2
                    temp = temp * safmx2
                    if (count <= 20)goto 10
                 end if
                 p = half*temp
                 tau = stdlib_slapy2( sigma, temp )
                 cs = sqrt( half*( one+abs( sigma ) / tau ) )
                 sn = -( p / ( tau*cs ) )*sign( one, sigma )
                 ! compute [ aa  bb ] = [ a  b ] [ cs -sn ]
                         ! [ cc  dd ]   [ c  d ] [ sn  cs ]
                 aa = a*cs + b*sn
                 bb = -a*sn + b*cs
                 cc = c*cs + d*sn
                 dd = -c*sn + d*cs
                 ! compute [ a  b ] = [ cs  sn ] [ aa  bb ]
                         ! [ c  d ]   [-sn  cs ] [ cc  dd ]
                 a = aa*cs + cc*sn
                 b = bb*cs + dd*sn
                 c = -aa*sn + cc*cs
                 d = -bb*sn + dd*cs
                 temp = half*( a+d )
                 a = temp
                 d = temp
                 if( c/=zero ) then
                    if( b/=zero ) then
                       if( sign( one, b )==sign( one, c ) ) then
                          ! real eigenvalues: reduce to upper triangular form
                          sab = sqrt( abs( b ) )
                          sac = sqrt( abs( c ) )
                          p = sign( sab*sac, c )
                          tau = one / sqrt( abs( b+c ) )
                          a = temp + p
                          d = temp - p
                          b = b - c
                          c = zero
                          cs1 = sab*tau
                          sn1 = sac*tau
                          temp = cs*cs1 - sn*sn1
                          sn = cs*sn1 + sn*cs1
                          cs = temp
                       end if
                    else
                       b = -c
                       c = zero
                       temp = cs
                       cs = -sn
                       sn = temp
                    end if
                 end if
              end if
           end if
           ! store eigenvalues in (rt1r,rt1i) and (rt2r,rt2i).
           rt1r = a
           rt2r = d
           if( c==zero ) then
              rt1i = zero
              rt2i = zero
           else
              rt1i = sqrt( abs( b ) )*sqrt( abs( c ) )
              rt2i = -rt1i
           end if
           return
     end subroutine stdlib_slanv2

     pure subroutine stdlib_dlanv2( a, b, c, d, rt1r, rt1i, rt2r, rt2i, cs, sn )
     !! DLANV2 computes the Schur factorization of a real 2-by-2 nonsymmetric
     !! matrix in standard form:
     !! [ A  B ] = [ CS -SN ] [ AA  BB ] [ CS  SN ]
     !! [ C  D ]   [ SN  CS ] [ CC  DD ] [-SN  CS ]
     !! where either
     !! 1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or
     !! 2) AA = DD and BB*CC < 0, so that AA + or - sqrt(BB*CC) are complex
     !! conjugate eigenvalues.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(dp), intent(inout) :: a, b, c, d
           real(dp), intent(out) :: cs, rt1i, rt1r, rt2i, rt2r, sn
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: multpl = 4.0e+0_dp
           
           
           ! Local Scalars 
           real(dp) :: aa, bb, bcmax, bcmis, cc, cs1, dd, eps, p, sab, sac, scale, sigma, sn1, &
                     tau, temp, z, safmin, safmn2, safmx2
           integer(ilp) :: count
           ! Intrinsic Functions 
           ! Executable Statements 
           safmin = stdlib_dlamch( 'S' )
           eps = stdlib_dlamch( 'P' )
           safmn2 = stdlib_dlamch( 'B' )**int( log( safmin / eps ) /log( stdlib_dlamch( 'B' ) ) / &
                     two,KIND=ilp)
           safmx2 = one / safmn2
           if( c==zero ) then
              cs = one
              sn = zero
           else if( b==zero ) then
              ! swap rows and columns
              cs = zero
              sn = one
              temp = d
              d = a
              a = temp
              b = -c
              c = zero
           else if( ( a-d )==zero .and. sign( one, b )/=sign( one, c ) )then
              cs = one
              sn = zero
           else
              temp = a - d
              p = half*temp
              bcmax = max( abs( b ), abs( c ) )
              bcmis = min( abs( b ), abs( c ) )*sign( one, b )*sign( one, c )
              scale = max( abs( p ), bcmax )
              z = ( p / scale )*p + ( bcmax / scale )*bcmis
              ! if z is of the order of the machine accuracy, postpone the
              ! decision on the nature of eigenvalues
              if( z>=multpl*eps ) then
                 ! real eigenvalues. compute a and d.
                 z = p + sign( sqrt( scale )*sqrt( z ), p )
                 a = d + z
                 d = d - ( bcmax / z )*bcmis
                 ! compute b and the rotation matrix
                 tau = stdlib_dlapy2( c, z )
                 cs = z / tau
                 sn = c / tau
                 b = b - c
                 c = zero
              else
                 ! complex eigenvalues, or real(almost,KIND=dp) equal eigenvalues.
                 ! make diagonal elements equal.
                 count = 0
                 sigma = b + c
                 10 continue
                 count = count + 1
                 scale = max( abs(temp), abs(sigma) )
                 if( scale>=safmx2 ) then
                    sigma = sigma * safmn2
                    temp = temp * safmn2
                    if (count <= 20)goto 10
                 end if
                 if( scale<=safmn2 ) then
                    sigma = sigma * safmx2
                    temp = temp * safmx2
                    if (count <= 20)goto 10
                 end if
                 p = half*temp
                 tau = stdlib_dlapy2( sigma, temp )
                 cs = sqrt( half*( one+abs( sigma ) / tau ) )
                 sn = -( p / ( tau*cs ) )*sign( one, sigma )
                 ! compute [ aa  bb ] = [ a  b ] [ cs -sn ]
                         ! [ cc  dd ]   [ c  d ] [ sn  cs ]
                 aa = a*cs + b*sn
                 bb = -a*sn + b*cs
                 cc = c*cs + d*sn
                 dd = -c*sn + d*cs
                 ! compute [ a  b ] = [ cs  sn ] [ aa  bb ]
                         ! [ c  d ]   [-sn  cs ] [ cc  dd ]
                 a = aa*cs + cc*sn
                 b = bb*cs + dd*sn
                 c = -aa*sn + cc*cs
                 d = -bb*sn + dd*cs
                 temp = half*( a+d )
                 a = temp
                 d = temp
                 if( c/=zero ) then
                    if( b/=zero ) then
                       if( sign( one, b )==sign( one, c ) ) then
                          ! real eigenvalues: reduce to upper triangular form
                          sab = sqrt( abs( b ) )
                          sac = sqrt( abs( c ) )
                          p = sign( sab*sac, c )
                          tau = one / sqrt( abs( b+c ) )
                          a = temp + p
                          d = temp - p
                          b = b - c
                          c = zero
                          cs1 = sab*tau
                          sn1 = sac*tau
                          temp = cs*cs1 - sn*sn1
                          sn = cs*sn1 + sn*cs1
                          cs = temp
                       end if
                    else
                       b = -c
                       c = zero
                       temp = cs
                       cs = -sn
                       sn = temp
                    end if
                 end if
              end if
           end if
           ! store eigenvalues in (rt1r,rt1i) and (rt2r,rt2i).
           rt1r = a
           rt2r = d
           if( c==zero ) then
              rt1i = zero
              rt2i = zero
           else
              rt1i = sqrt( abs( b ) )*sqrt( abs( c ) )
              rt2i = -rt1i
           end if
           return
     end subroutine stdlib_dlanv2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$lanv2( a, b, c, d, rt1r, rt1i, rt2r, rt2i, cs, sn )
     !! DLANV2: computes the Schur factorization of a real 2-by-2 nonsymmetric
     !! matrix in standard form:
     !! [ A  B ] = [ CS -SN ] [ AA  BB ] [ CS  SN ]
     !! [ C  D ]   [ SN  CS ] [ CC  DD ] [-SN  CS ]
     !! where either
     !! 1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or
     !! 2) AA = DD and BB*CC < 0, so that AA + or - sqrt(BB*CC) are complex
     !! conjugate eigenvalues.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(${rk}$), intent(inout) :: a, b, c, d
           real(${rk}$), intent(out) :: cs, rt1i, rt1r, rt2i, rt2r, sn
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: multpl = 4.0e+0_${rk}$
           
           
           ! Local Scalars 
           real(${rk}$) :: aa, bb, bcmax, bcmis, cc, cs1, dd, eps, p, sab, sac, scale, sigma, sn1, &
                     tau, temp, z, safmin, safmn2, safmx2
           integer(ilp) :: count
           ! Intrinsic Functions 
           ! Executable Statements 
           safmin = stdlib_${ri}$lamch( 'S' )
           eps = stdlib_${ri}$lamch( 'P' )
           safmn2 = stdlib_${ri}$lamch( 'B' )**int( log( safmin / eps ) /log( stdlib_${ri}$lamch( 'B' ) ) / &
                     two,KIND=ilp)
           safmx2 = one / safmn2
           if( c==zero ) then
              cs = one
              sn = zero
           else if( b==zero ) then
              ! swap rows and columns
              cs = zero
              sn = one
              temp = d
              d = a
              a = temp
              b = -c
              c = zero
           else if( ( a-d )==zero .and. sign( one, b )/=sign( one, c ) )then
              cs = one
              sn = zero
           else
              temp = a - d
              p = half*temp
              bcmax = max( abs( b ), abs( c ) )
              bcmis = min( abs( b ), abs( c ) )*sign( one, b )*sign( one, c )
              scale = max( abs( p ), bcmax )
              z = ( p / scale )*p + ( bcmax / scale )*bcmis
              ! if z is of the order of the machine accuracy, postpone the
              ! decision on the nature of eigenvalues
              if( z>=multpl*eps ) then
                 ! real eigenvalues. compute a and d.
                 z = p + sign( sqrt( scale )*sqrt( z ), p )
                 a = d + z
                 d = d - ( bcmax / z )*bcmis
                 ! compute b and the rotation matrix
                 tau = stdlib_${ri}$lapy2( c, z )
                 cs = z / tau
                 sn = c / tau
                 b = b - c
                 c = zero
              else
                 ! complex eigenvalues, or real(almost,KIND=${rk}$) equal eigenvalues.
                 ! make diagonal elements equal.
                 count = 0
                 sigma = b + c
                 10 continue
                 count = count + 1
                 scale = max( abs(temp), abs(sigma) )
                 if( scale>=safmx2 ) then
                    sigma = sigma * safmn2
                    temp = temp * safmn2
                    if (count <= 20)goto 10
                 end if
                 if( scale<=safmn2 ) then
                    sigma = sigma * safmx2
                    temp = temp * safmx2
                    if (count <= 20)goto 10
                 end if
                 p = half*temp
                 tau = stdlib_${ri}$lapy2( sigma, temp )
                 cs = sqrt( half*( one+abs( sigma ) / tau ) )
                 sn = -( p / ( tau*cs ) )*sign( one, sigma )
                 ! compute [ aa  bb ] = [ a  b ] [ cs -sn ]
                         ! [ cc  dd ]   [ c  d ] [ sn  cs ]
                 aa = a*cs + b*sn
                 bb = -a*sn + b*cs
                 cc = c*cs + d*sn
                 dd = -c*sn + d*cs
                 ! compute [ a  b ] = [ cs  sn ] [ aa  bb ]
                         ! [ c  d ]   [-sn  cs ] [ cc  dd ]
                 a = aa*cs + cc*sn
                 b = bb*cs + dd*sn
                 c = -aa*sn + cc*cs
                 d = -bb*sn + dd*cs
                 temp = half*( a+d )
                 a = temp
                 d = temp
                 if( c/=zero ) then
                    if( b/=zero ) then
                       if( sign( one, b )==sign( one, c ) ) then
                          ! real eigenvalues: reduce to upper triangular form
                          sab = sqrt( abs( b ) )
                          sac = sqrt( abs( c ) )
                          p = sign( sab*sac, c )
                          tau = one / sqrt( abs( b+c ) )
                          a = temp + p
                          d = temp - p
                          b = b - c
                          c = zero
                          cs1 = sab*tau
                          sn1 = sac*tau
                          temp = cs*cs1 - sn*sn1
                          sn = cs*sn1 + sn*cs1
                          cs = temp
                       end if
                    else
                       b = -c
                       c = zero
                       temp = cs
                       cs = -sn
                       sn = temp
                    end if
                 end if
              end if
           end if
           ! store eigenvalues in (rt1r,rt1i) and (rt2r,rt2i).
           rt1r = a
           rt2r = d
           if( c==zero ) then
              rt1i = zero
              rt2i = zero
           else
              rt1i = sqrt( abs( b ) )*sqrt( abs( c ) )
              rt2i = -rt1i
           end if
           return
     end subroutine stdlib_${ri}$lanv2

#:endif
#:endfor





     pure subroutine stdlib_chseqr( job, compz, n, ilo, ihi, h, ldh, w, z, ldz,work, lwork, info )
     !! CHSEQR computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**H, where T is an upper triangular matrix (the
     !! Schur form), and Z is the unitary matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input unitary
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*T*(QZ)**H.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           character, intent(in) :: compz, job
           ! Array Arguments 
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: w(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: nl = 49
           real(sp), parameter :: rzero = 0.0_sp
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_clahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== nl allocates some local workspace to help small matrices
           ! .    through a rare stdlib_clahqr failure.  nl > ntiny = 15 is
           ! .    required and nl <= nmin = stdlib_ilaenv(ispec=12,...) is recom-
           ! .    mended.  (the default value of nmin is 75.)  using nl = 49
           ! .    allows up to six simultaneous shifts and a 16-by-16
           ! .    deflation window.  ====
           
           
           
           ! Local Arrays 
           complex(sp) :: hl(nl,nl), workl(nl)
           ! Local Scalars 
           integer(ilp) :: kbot, nmin
           logical(lk) :: initz, lquery, wantt, wantz
           ! Intrinsic Functions 
           ! Executable Statements 
           ! ==== decode and check the input parameters. ====
           wantt = stdlib_lsame( job, 'S' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           work( 1 ) = cmplx( real( max( 1, n ),KIND=sp), rzero,KIND=sp)
           lquery = lwork==-1
           info = 0
           if( .not.stdlib_lsame( job, 'E' ) .and. .not.wantt ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( ldh<max( 1, n ) ) then
              info = -7
           else if( ldz<1 .or. ( wantz .and. ldz<max( 1, n ) ) ) then
              info = -10
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -12
           end if
           if( info/=0 ) then
              ! ==== quick return in case of invalid argument. ====
              call stdlib_xerbla( 'CHSEQR', -info )
              return
           else if( n==0 ) then
              ! ==== quick return in case n = 0; nothing to do. ====
              return
           else if( lquery ) then
              ! ==== quick return in case of a workspace query ====
              call stdlib_claqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, ilo, ihi, z,ldz, work, &
                        lwork, info )
              ! ==== ensure reported workspace size is backward-compatible with
              ! .    previous lapack versions. ====
              work( 1 ) = cmplx( max( real( work( 1 ),KIND=sp), real( max( 1,n ),KIND=sp) ), &
                        rzero,KIND=sp)
              return
           else
              ! ==== copy eigenvalues isolated by stdlib_cgebal ====
              if( ilo>1 )call stdlib_ccopy( ilo-1, h, ldh+1, w, 1 )
              if( ihi<n )call stdlib_ccopy( n-ihi, h( ihi+1, ihi+1 ), ldh+1, w( ihi+1 ), 1 )
                        
              ! ==== initialize z, if requested ====
              if( initz )call stdlib_claset( 'A', n, n, czero, cone, z, ldz )
              ! ==== quick return if possible ====
              if( ilo==ihi ) then
                 w( ilo ) = h( ilo, ilo )
                 return
              end if
              ! ==== stdlib_clahqr/stdlib_claqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'CHSEQR', job( : 1 ) // compz( : 1 ), n,ilo, ihi, lwork )
                        
              nmin = max( ntiny, nmin )
              ! ==== stdlib_claqr0 for big matrices; stdlib_clahqr for small ones ====
              if( n>nmin ) then
                 call stdlib_claqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, ilo, ihi,z, ldz, work, &
                           lwork, info )
              else
                 ! ==== small matrix ====
                 call stdlib_clahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, ilo, ihi,z, ldz, info )
                           
                 if( info>0 ) then
                    ! ==== a rare stdlib_clahqr failure!  stdlib_claqr0 sometimes succeeds
                    ! .    when stdlib_clahqr fails. ====
                    kbot = info
                    if( n>=nl ) then
                       ! ==== larger matrices have enough subdiagonal scratch
                       ! .    space to call stdlib_claqr0 directly. ====
                       call stdlib_claqr0( wantt, wantz, n, ilo, kbot, h, ldh, w,ilo, ihi, z, ldz,&
                                  work, lwork, info )
                    else
                       ! ==== tiny matrices don't have enough subdiagonal
                       ! .    scratch space to benefit from stdlib_claqr0.  hence,
                       ! .    tiny matrices must be copied into a larger
                       ! .    array before calling stdlib_claqr0. ====
                       call stdlib_clacpy( 'A', n, n, h, ldh, hl, nl )
                       hl( n+1, n ) = czero
                       call stdlib_claset( 'A', nl, nl-n, czero, czero, hl( 1, n+1 ),nl )
                       call stdlib_claqr0( wantt, wantz, nl, ilo, kbot, hl, nl, w,ilo, ihi, z, &
                                 ldz, workl, nl, info )
                       if( wantt .or. info/=0 )call stdlib_clacpy( 'A', n, n, hl, nl, h, ldh )
                                 
                    end if
                 end if
              end if
              ! ==== clear out the trash, if necessary. ====
              if( ( wantt .or. info/=0 ) .and. n>2 )call stdlib_claset( 'L', n-2, n-2, czero, &
                        czero, h( 3, 1 ), ldh )
              ! ==== ensure reported workspace size is backward-compatible with
              ! .    previous lapack versions. ====
              work( 1 ) = cmplx( max( real( max( 1, n ),KIND=sp),real( work( 1 ),KIND=sp) ), &
                        rzero,KIND=sp)
           end if
     end subroutine stdlib_chseqr

     pure subroutine stdlib_zhseqr( job, compz, n, ilo, ihi, h, ldh, w, z, ldz,work, lwork, info )
     !! ZHSEQR computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**H, where T is an upper triangular matrix (the
     !! Schur form), and Z is the unitary matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input unitary
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*T*(QZ)**H.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           character, intent(in) :: compz, job
           ! Array Arguments 
           complex(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(dp), intent(out) :: w(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: nl = 49
           real(dp), parameter :: rzero = 0.0_dp
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_zlahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== nl allocates some local workspace to help small matrices
           ! .    through a rare stdlib_zlahqr failure.  nl > ntiny = 15 is
           ! .    required and nl <= nmin = stdlib_ilaenv(ispec=12,...) is recom-
           ! .    mended.  (the default value of nmin is 75.)  using nl = 49
           ! .    allows up to six simultaneous shifts and a 16-by-16
           ! .    deflation window.  ====
           
           
           
           ! Local Arrays 
           complex(dp) :: hl(nl,nl), workl(nl)
           ! Local Scalars 
           integer(ilp) :: kbot, nmin
           logical(lk) :: initz, lquery, wantt, wantz
           ! Intrinsic Functions 
           ! Executable Statements 
           ! ==== decode and check the input parameters. ====
           wantt = stdlib_lsame( job, 'S' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           work( 1 ) = cmplx( real( max( 1, n ),KIND=dp), rzero,KIND=dp)
           lquery = lwork==-1
           info = 0
           if( .not.stdlib_lsame( job, 'E' ) .and. .not.wantt ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( ldh<max( 1, n ) ) then
              info = -7
           else if( ldz<1 .or. ( wantz .and. ldz<max( 1, n ) ) ) then
              info = -10
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -12
           end if
           if( info/=0 ) then
              ! ==== quick return in case of invalid argument. ====
              call stdlib_xerbla( 'ZHSEQR', -info )
              return
           else if( n==0 ) then
              ! ==== quick return in case n = 0; nothing to do. ====
              return
           else if( lquery ) then
              ! ==== quick return in case of a workspace query ====
              call stdlib_zlaqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, ilo, ihi, z,ldz, work, &
                        lwork, info )
              ! ==== ensure reported workspace size is backward-compatible with
              ! .    previous lapack versions. ====
              work( 1 ) = cmplx( max( real( work( 1 ),KIND=dp), real( max( 1,n ),KIND=dp) ), &
                        rzero,KIND=dp)
              return
           else
              ! ==== copy eigenvalues isolated by stdlib_zgebal ====
              if( ilo>1 )call stdlib_zcopy( ilo-1, h, ldh+1, w, 1 )
              if( ihi<n )call stdlib_zcopy( n-ihi, h( ihi+1, ihi+1 ), ldh+1, w( ihi+1 ), 1 )
                        
              ! ==== initialize z, if requested ====
              if( initz )call stdlib_zlaset( 'A', n, n, czero, cone, z, ldz )
              ! ==== quick return if possible ====
              if( ilo==ihi ) then
                 w( ilo ) = h( ilo, ilo )
                 return
              end if
              ! ==== stdlib_zlahqr/stdlib_zlaqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'ZHSEQR', job( : 1 ) // compz( : 1 ), n,ilo, ihi, lwork )
                        
              nmin = max( ntiny, nmin )
              ! ==== stdlib_zlaqr0 for big matrices; stdlib_zlahqr for small ones ====
              if( n>nmin ) then
                 call stdlib_zlaqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, ilo, ihi,z, ldz, work, &
                           lwork, info )
              else
                 ! ==== small matrix ====
                 call stdlib_zlahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, ilo, ihi,z, ldz, info )
                           
                 if( info>0 ) then
                    ! ==== a rare stdlib_zlahqr failure!  stdlib_zlaqr0 sometimes succeeds
                    ! .    when stdlib_zlahqr fails. ====
                    kbot = info
                    if( n>=nl ) then
                       ! ==== larger matrices have enough subdiagonal scratch
                       ! .    space to call stdlib_zlaqr0 directly. ====
                       call stdlib_zlaqr0( wantt, wantz, n, ilo, kbot, h, ldh, w,ilo, ihi, z, ldz,&
                                  work, lwork, info )
                    else
                       ! ==== tiny matrices don't have enough subdiagonal
                       ! .    scratch space to benefit from stdlib_zlaqr0.  hence,
                       ! .    tiny matrices must be copied into a larger
                       ! .    array before calling stdlib_zlaqr0. ====
                       call stdlib_zlacpy( 'A', n, n, h, ldh, hl, nl )
                       hl( n+1, n ) = czero
                       call stdlib_zlaset( 'A', nl, nl-n, czero, czero, hl( 1, n+1 ),nl )
                       call stdlib_zlaqr0( wantt, wantz, nl, ilo, kbot, hl, nl, w,ilo, ihi, z, &
                                 ldz, workl, nl, info )
                       if( wantt .or. info/=0 )call stdlib_zlacpy( 'A', n, n, hl, nl, h, ldh )
                                 
                    end if
                 end if
              end if
              ! ==== clear out the trash, if necessary. ====
              if( ( wantt .or. info/=0 ) .and. n>2 )call stdlib_zlaset( 'L', n-2, n-2, czero, &
                        czero, h( 3, 1 ), ldh )
              ! ==== ensure reported workspace size is backward-compatible with
              ! .    previous lapack versions. ====
              work( 1 ) = cmplx( max( real( max( 1, n ),KIND=dp),real( work( 1 ),KIND=dp) ), &
                        rzero,KIND=dp)
           end if
     end subroutine stdlib_zhseqr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$hseqr( job, compz, n, ilo, ihi, h, ldh, w, z, ldz,work, lwork, info )
     !! ZHSEQR: computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**H, where T is an upper triangular matrix (the
     !! Schur form), and Z is the unitary matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input unitary
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*T*(QZ)**H.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           character, intent(in) :: compz, job
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(${ck}$), intent(out) :: w(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: nl = 49
           real(${ck}$), parameter :: rzero = 0.0_${ck}$
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_${ci}$lahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== nl allocates some local workspace to help small matrices
           ! .    through a rare stdlib_${ci}$lahqr failure.  nl > ntiny = 15 is
           ! .    required and nl <= nmin = stdlib_ilaenv(ispec=12,...) is recom-
           ! .    mended.  (the default value of nmin is 75.)  using nl = 49
           ! .    allows up to six simultaneous shifts and a 16-by-16
           ! .    deflation window.  ====
           
           
           
           ! Local Arrays 
           complex(${ck}$) :: hl(nl,nl), workl(nl)
           ! Local Scalars 
           integer(ilp) :: kbot, nmin
           logical(lk) :: initz, lquery, wantt, wantz
           ! Intrinsic Functions 
           ! Executable Statements 
           ! ==== decode and check the input parameters. ====
           wantt = stdlib_lsame( job, 'S' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           work( 1 ) = cmplx( real( max( 1, n ),KIND=${ck}$), rzero,KIND=${ck}$)
           lquery = lwork==-1
           info = 0
           if( .not.stdlib_lsame( job, 'E' ) .and. .not.wantt ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -4
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -5
           else if( ldh<max( 1, n ) ) then
              info = -7
           else if( ldz<1 .or. ( wantz .and. ldz<max( 1, n ) ) ) then
              info = -10
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -12
           end if
           if( info/=0 ) then
              ! ==== quick return in case of invalid argument. ====
              call stdlib_xerbla( 'ZHSEQR', -info )
              return
           else if( n==0 ) then
              ! ==== quick return in case n = 0; nothing to do. ====
              return
           else if( lquery ) then
              ! ==== quick return in case of a workspace query ====
              call stdlib_${ci}$laqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, ilo, ihi, z,ldz, work, &
                        lwork, info )
              ! ==== ensure reported workspace size is backward-compatible with
              ! .    previous lapack versions. ====
              work( 1 ) = cmplx( max( real( work( 1 ),KIND=${ck}$), real( max( 1,n ),KIND=${ck}$) ), &
                        rzero,KIND=${ck}$)
              return
           else
              ! ==== copy eigenvalues isolated by stdlib_${ci}$gebal ====
              if( ilo>1 )call stdlib_${ci}$copy( ilo-1, h, ldh+1, w, 1 )
              if( ihi<n )call stdlib_${ci}$copy( n-ihi, h( ihi+1, ihi+1 ), ldh+1, w( ihi+1 ), 1 )
                        
              ! ==== initialize z, if requested ====
              if( initz )call stdlib_${ci}$laset( 'A', n, n, czero, cone, z, ldz )
              ! ==== quick return if possible ====
              if( ilo==ihi ) then
                 w( ilo ) = h( ilo, ilo )
                 return
              end if
              ! ==== stdlib_${ci}$lahqr/stdlib_${ci}$laqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'ZHSEQR', job( : 1 ) // compz( : 1 ), n,ilo, ihi, lwork )
                        
              nmin = max( ntiny, nmin )
              ! ==== stdlib_${ci}$laqr0 for big matrices; stdlib_${ci}$lahqr for small ones ====
              if( n>nmin ) then
                 call stdlib_${ci}$laqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, ilo, ihi,z, ldz, work, &
                           lwork, info )
              else
                 ! ==== small matrix ====
                 call stdlib_${ci}$lahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, ilo, ihi,z, ldz, info )
                           
                 if( info>0 ) then
                    ! ==== a rare stdlib_${ci}$lahqr failure!  stdlib_${ci}$laqr0 sometimes succeeds
                    ! .    when stdlib_${ci}$lahqr fails. ====
                    kbot = info
                    if( n>=nl ) then
                       ! ==== larger matrices have enough subdiagonal scratch
                       ! .    space to call stdlib_${ci}$laqr0 directly. ====
                       call stdlib_${ci}$laqr0( wantt, wantz, n, ilo, kbot, h, ldh, w,ilo, ihi, z, ldz,&
                                  work, lwork, info )
                    else
                       ! ==== tiny matrices don't have enough subdiagonal
                       ! .    scratch space to benefit from stdlib_${ci}$laqr0.  hence,
                       ! .    tiny matrices must be copied into a larger
                       ! .    array before calling stdlib_${ci}$laqr0. ====
                       call stdlib_${ci}$lacpy( 'A', n, n, h, ldh, hl, nl )
                       hl( n+1, n ) = czero
                       call stdlib_${ci}$laset( 'A', nl, nl-n, czero, czero, hl( 1, n+1 ),nl )
                       call stdlib_${ci}$laqr0( wantt, wantz, nl, ilo, kbot, hl, nl, w,ilo, ihi, z, &
                                 ldz, workl, nl, info )
                       if( wantt .or. info/=0 )call stdlib_${ci}$lacpy( 'A', n, n, hl, nl, h, ldh )
                                 
                    end if
                 end if
              end if
              ! ==== clear out the trash, if necessary. ====
              if( ( wantt .or. info/=0 ) .and. n>2 )call stdlib_${ci}$laset( 'L', n-2, n-2, czero, &
                        czero, h( 3, 1 ), ldh )
              ! ==== ensure reported workspace size is backward-compatible with
              ! .    previous lapack versions. ====
              work( 1 ) = cmplx( max( real( max( 1, n ),KIND=${ck}$),real( work( 1 ),KIND=${ck}$) ), &
                        rzero,KIND=${ck}$)
           end if
     end subroutine stdlib_${ci}$hseqr

#:endif
#:endfor



     pure subroutine stdlib_slaein( rightv, noinit, n, h, ldh, wr, wi, vr, vi, b,ldb, work, eps3, &
     !! SLAEIN uses inverse iteration to find a right or left eigenvector
     !! corresponding to the eigenvalue (WR,WI) of a real upper Hessenberg
     !! matrix H.
               smlnum, bignum, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: noinit, rightv
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldh, n
           real(sp), intent(in) :: bignum, eps3, smlnum, wi, wr
           ! Array Arguments 
           real(sp), intent(out) :: b(ldb,*), work(*)
           real(sp), intent(in) :: h(ldh,*)
           real(sp), intent(inout) :: vi(*), vr(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: tenth = 1.0e-1_sp
           
           ! Local Scalars 
           character :: normin, trans
           integer(ilp) :: i, i1, i2, i3, ierr, its, j
           real(sp) :: absbii, absbjj, ei, ej, growto, norm, nrmsml, rec, rootn, scale, temp, &
                     vcrit, vmax, vnorm, w, w1, x, xi, xr, y
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! growto is the threshold used in the acceptance test for an
           ! eigenvector.
           rootn = sqrt( real( n,KIND=sp) )
           growto = tenth / rootn
           nrmsml = max( one, eps3*rootn )*smlnum
           ! form b = h - (wr,wi)*i (except that the subdiagonal elements and
           ! the imaginary parts of the diagonal elements are not stored).
           do j = 1, n
              do i = 1, j - 1
                 b( i, j ) = h( i, j )
              end do
              b( j, j ) = h( j, j ) - wr
           end do
           if( wi==zero ) then
              ! real eigenvalue.
              if( noinit ) then
                 ! set initial vector.
                 do i = 1, n
                    vr( i ) = eps3
                 end do
              else
                 ! scale supplied initial vector.
                 vnorm = stdlib_snrm2( n, vr, 1 )
                 call stdlib_sscal( n, ( eps3*rootn ) / max( vnorm, nrmsml ), vr,1 )
              end if
              if( rightv ) then
                 ! lu decomposition with partial pivoting of b, replacing zero
                 ! pivots by eps3.
                 do i = 1, n - 1
                    ei = h( i+1, i )
                    if( abs( b( i, i ) )<abs( ei ) ) then
                       ! interchange rows and eliminate.
                       x = b( i, i ) / ei
                       b( i, i ) = ei
                       do j = i + 1, n
                          temp = b( i+1, j )
                          b( i+1, j ) = b( i, j ) - x*temp
                          b( i, j ) = temp
                       end do
                    else
                       ! eliminate without interchange.
                       if( b( i, i )==zero )b( i, i ) = eps3
                       x = ei / b( i, i )
                       if( x/=zero ) then
                          do j = i + 1, n
                             b( i+1, j ) = b( i+1, j ) - x*b( i, j )
                          end do
                       end if
                    end if
                 end do
                 if( b( n, n )==zero )b( n, n ) = eps3
                 trans = 'N'
              else
                 ! ul decomposition with partial pivoting of b, replacing zero
                 ! pivots by eps3.
                 do j = n, 2, -1
                    ej = h( j, j-1 )
                    if( abs( b( j, j ) )<abs( ej ) ) then
                       ! interchange columns and eliminate.
                       x = b( j, j ) / ej
                       b( j, j ) = ej
                       do i = 1, j - 1
                          temp = b( i, j-1 )
                          b( i, j-1 ) = b( i, j ) - x*temp
                          b( i, j ) = temp
                       end do
                    else
                       ! eliminate without interchange.
                       if( b( j, j )==zero )b( j, j ) = eps3
                       x = ej / b( j, j )
                       if( x/=zero ) then
                          do i = 1, j - 1
                             b( i, j-1 ) = b( i, j-1 ) - x*b( i, j )
                          end do
                       end if
                    end if
                 end do
                 if( b( 1, 1 )==zero )b( 1, 1 ) = eps3
                 trans = 'T'
              end if
              normin = 'N'
              do its = 1, n
                 ! solve u*x = scale*v for a right eigenvector
                   ! or u**t*x = scale*v for a left eigenvector,
                 ! overwriting x on v.
                 call stdlib_slatrs( 'UPPER', trans, 'NONUNIT', normin, n, b, ldb,vr, scale, work,&
                            ierr )
                 normin = 'Y'
                 ! test for sufficient growth in the norm of v.
                 vnorm = stdlib_sasum( n, vr, 1 )
                 if( vnorm>=growto*scale )go to 120
                 ! choose new orthogonal starting vector and try again.
                 temp = eps3 / ( rootn+one )
                 vr( 1 ) = eps3
                 do i = 2, n
                    vr( i ) = temp
                 end do
                 vr( n-its+1 ) = vr( n-its+1 ) - eps3*rootn
              end do
              ! failure to find eigenvector in n iterations.
              info = 1
              120 continue
              ! normalize eigenvector.
              i = stdlib_isamax( n, vr, 1 )
              call stdlib_sscal( n, one / abs( vr( i ) ), vr, 1 )
           else
              ! complex eigenvalue.
              if( noinit ) then
                 ! set initial vector.
                 do i = 1, n
                    vr( i ) = eps3
                    vi( i ) = zero
                 end do
              else
                 ! scale supplied initial vector.
                 norm = stdlib_slapy2( stdlib_snrm2( n, vr, 1 ), stdlib_snrm2( n, vi, 1 ) )
                           
                 rec = ( eps3*rootn ) / max( norm, nrmsml )
                 call stdlib_sscal( n, rec, vr, 1 )
                 call stdlib_sscal( n, rec, vi, 1 )
              end if
              if( rightv ) then
                 ! lu decomposition with partial pivoting of b, replacing zero
                 ! pivots by eps3.
                 ! the imaginary part of the (i,j)-th element of u is stored in
                 ! b(j+1,i).
                 b( 2, 1 ) = -wi
                 do i = 2, n
                    b( i+1, 1 ) = zero
                 end do
                 loop_170: do i = 1, n - 1
                    absbii = stdlib_slapy2( b( i, i ), b( i+1, i ) )
                    ei = h( i+1, i )
                    if( absbii<abs( ei ) ) then
                       ! interchange rows and eliminate.
                       xr = b( i, i ) / ei
                       xi = b( i+1, i ) / ei
                       b( i, i ) = ei
                       b( i+1, i ) = zero
                       do j = i + 1, n
                          temp = b( i+1, j )
                          b( i+1, j ) = b( i, j ) - xr*temp
                          b( j+1, i+1 ) = b( j+1, i ) - xi*temp
                          b( i, j ) = temp
                          b( j+1, i ) = zero
                       end do
                       b( i+2, i ) = -wi
                       b( i+1, i+1 ) = b( i+1, i+1 ) - xi*wi
                       b( i+2, i+1 ) = b( i+2, i+1 ) + xr*wi
                    else
                       ! eliminate without interchanging rows.
                       if( absbii==zero ) then
                          b( i, i ) = eps3
                          b( i+1, i ) = zero
                          absbii = eps3
                       end if
                       ei = ( ei / absbii ) / absbii
                       xr = b( i, i )*ei
                       xi = -b( i+1, i )*ei
                       do j = i + 1, n
                          b( i+1, j ) = b( i+1, j ) - xr*b( i, j ) +xi*b( j+1, i )
                          b( j+1, i+1 ) = -xr*b( j+1, i ) - xi*b( i, j )
                       end do
                       b( i+2, i+1 ) = b( i+2, i+1 ) - wi
                    end if
                    ! compute 1-norm of offdiagonal elements of i-th row.
                    work( i ) = stdlib_sasum( n-i, b( i, i+1 ), ldb ) +stdlib_sasum( n-i, b( i+2, &
                              i ), 1 )
                 end do loop_170
                 if( b( n, n )==zero .and. b( n+1, n )==zero )b( n, n ) = eps3
                 work( n ) = zero
                 i1 = n
                 i2 = 1
                 i3 = -1
              else
                 ! ul decomposition with partial pivoting of conjg(b),
                 ! replacing zero pivots by eps3.
                 ! the imaginary part of the (i,j)-th element of u is stored in
                 ! b(j+1,i).
                 b( n+1, n ) = wi
                 do j = 1, n - 1
                    b( n+1, j ) = zero
                 end do
                 loop_210: do j = n, 2, -1
                    ej = h( j, j-1 )
                    absbjj = stdlib_slapy2( b( j, j ), b( j+1, j ) )
                    if( absbjj<abs( ej ) ) then
                       ! interchange columns and eliminate
                       xr = b( j, j ) / ej
                       xi = b( j+1, j ) / ej
                       b( j, j ) = ej
                       b( j+1, j ) = zero
                       do i = 1, j - 1
                          temp = b( i, j-1 )
                          b( i, j-1 ) = b( i, j ) - xr*temp
                          b( j, i ) = b( j+1, i ) - xi*temp
                          b( i, j ) = temp
                          b( j+1, i ) = zero
                       end do
                       b( j+1, j-1 ) = wi
                       b( j-1, j-1 ) = b( j-1, j-1 ) + xi*wi
                       b( j, j-1 ) = b( j, j-1 ) - xr*wi
                    else
                       ! eliminate without interchange.
                       if( absbjj==zero ) then
                          b( j, j ) = eps3
                          b( j+1, j ) = zero
                          absbjj = eps3
                       end if
                       ej = ( ej / absbjj ) / absbjj
                       xr = b( j, j )*ej
                       xi = -b( j+1, j )*ej
                       do i = 1, j - 1
                          b( i, j-1 ) = b( i, j-1 ) - xr*b( i, j ) +xi*b( j+1, i )
                          b( j, i ) = -xr*b( j+1, i ) - xi*b( i, j )
                       end do
                       b( j, j-1 ) = b( j, j-1 ) + wi
                    end if
                    ! compute 1-norm of offdiagonal elements of j-th column.
                    work( j ) = stdlib_sasum( j-1, b( 1, j ), 1 ) +stdlib_sasum( j-1, b( j+1, 1 ),&
                               ldb )
                 end do loop_210
                 if( b( 1, 1 )==zero .and. b( 2, 1 )==zero )b( 1, 1 ) = eps3
                 work( 1 ) = zero
                 i1 = 1
                 i2 = n
                 i3 = 1
              end if
              loop_270: do its = 1, n
                 scale = one
                 vmax = one
                 vcrit = bignum
                 ! solve u*(xr,xi) = scale*(vr,vi) for a right eigenvector,
                   ! or u**t*(xr,xi) = scale*(vr,vi) for a left eigenvector,
                 ! overwriting (xr,xi) on (vr,vi).
                 loop_250: do i = i1, i2, i3
                    if( work( i )>vcrit ) then
                       rec = one / vmax
                       call stdlib_sscal( n, rec, vr, 1 )
                       call stdlib_sscal( n, rec, vi, 1 )
                       scale = scale*rec
                       vmax = one
                       vcrit = bignum
                    end if
                    xr = vr( i )
                    xi = vi( i )
                    if( rightv ) then
                       do j = i + 1, n
                          xr = xr - b( i, j )*vr( j ) + b( j+1, i )*vi( j )
                          xi = xi - b( i, j )*vi( j ) - b( j+1, i )*vr( j )
                       end do
                    else
                       do j = 1, i - 1
                          xr = xr - b( j, i )*vr( j ) + b( i+1, j )*vi( j )
                          xi = xi - b( j, i )*vi( j ) - b( i+1, j )*vr( j )
                       end do
                    end if
                    w = abs( b( i, i ) ) + abs( b( i+1, i ) )
                    if( w>smlnum ) then
                       if( w<one ) then
                          w1 = abs( xr ) + abs( xi )
                          if( w1>w*bignum ) then
                             rec = one / w1
                             call stdlib_sscal( n, rec, vr, 1 )
                             call stdlib_sscal( n, rec, vi, 1 )
                             xr = vr( i )
                             xi = vi( i )
                             scale = scale*rec
                             vmax = vmax*rec
                          end if
                       end if
                       ! divide by diagonal element of b.
                       call stdlib_sladiv( xr, xi, b( i, i ), b( i+1, i ), vr( i ),vi( i ) )
                                 
                       vmax = max( abs( vr( i ) )+abs( vi( i ) ), vmax )
                       vcrit = bignum / vmax
                    else
                       do j = 1, n
                          vr( j ) = zero
                          vi( j ) = zero
                       end do
                       vr( i ) = one
                       vi( i ) = one
                       scale = zero
                       vmax = one
                       vcrit = bignum
                    end if
                 end do loop_250
                 ! test for sufficient growth in the norm of (vr,vi).
                 vnorm = stdlib_sasum( n, vr, 1 ) + stdlib_sasum( n, vi, 1 )
                 if( vnorm>=growto*scale )go to 280
                 ! choose a new orthogonal starting vector and try again.
                 y = eps3 / ( rootn+one )
                 vr( 1 ) = eps3
                 vi( 1 ) = zero
                 do i = 2, n
                    vr( i ) = y
                    vi( i ) = zero
                 end do
                 vr( n-its+1 ) = vr( n-its+1 ) - eps3*rootn
              end do loop_270
              ! failure to find eigenvector in n iterations
              info = 1
              280 continue
              ! normalize eigenvector.
              vnorm = zero
              do i = 1, n
                 vnorm = max( vnorm, abs( vr( i ) )+abs( vi( i ) ) )
              end do
              call stdlib_sscal( n, one / vnorm, vr, 1 )
              call stdlib_sscal( n, one / vnorm, vi, 1 )
           end if
           return
     end subroutine stdlib_slaein

     pure subroutine stdlib_dlaein( rightv, noinit, n, h, ldh, wr, wi, vr, vi, b,ldb, work, eps3, &
     !! DLAEIN uses inverse iteration to find a right or left eigenvector
     !! corresponding to the eigenvalue (WR,WI) of a real upper Hessenberg
     !! matrix H.
               smlnum, bignum, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: noinit, rightv
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldh, n
           real(dp), intent(in) :: bignum, eps3, smlnum, wi, wr
           ! Array Arguments 
           real(dp), intent(out) :: b(ldb,*), work(*)
           real(dp), intent(in) :: h(ldh,*)
           real(dp), intent(inout) :: vi(*), vr(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: tenth = 1.0e-1_dp
           
           ! Local Scalars 
           character :: normin, trans
           integer(ilp) :: i, i1, i2, i3, ierr, its, j
           real(dp) :: absbii, absbjj, ei, ej, growto, norm, nrmsml, rec, rootn, scale, temp, &
                     vcrit, vmax, vnorm, w, w1, x, xi, xr, y
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! growto is the threshold used in the acceptance test for an
           ! eigenvector.
           rootn = sqrt( real( n,KIND=dp) )
           growto = tenth / rootn
           nrmsml = max( one, eps3*rootn )*smlnum
           ! form b = h - (wr,wi)*i (except that the subdiagonal elements and
           ! the imaginary parts of the diagonal elements are not stored).
           do j = 1, n
              do i = 1, j - 1
                 b( i, j ) = h( i, j )
              end do
              b( j, j ) = h( j, j ) - wr
           end do
           if( wi==zero ) then
              ! real eigenvalue.
              if( noinit ) then
                 ! set initial vector.
                 do i = 1, n
                    vr( i ) = eps3
                 end do
              else
                 ! scale supplied initial vector.
                 vnorm = stdlib_dnrm2( n, vr, 1 )
                 call stdlib_dscal( n, ( eps3*rootn ) / max( vnorm, nrmsml ), vr,1 )
              end if
              if( rightv ) then
                 ! lu decomposition with partial pivoting of b, replacing zero
                 ! pivots by eps3.
                 do i = 1, n - 1
                    ei = h( i+1, i )
                    if( abs( b( i, i ) )<abs( ei ) ) then
                       ! interchange rows and eliminate.
                       x = b( i, i ) / ei
                       b( i, i ) = ei
                       do j = i + 1, n
                          temp = b( i+1, j )
                          b( i+1, j ) = b( i, j ) - x*temp
                          b( i, j ) = temp
                       end do
                    else
                       ! eliminate without interchange.
                       if( b( i, i )==zero )b( i, i ) = eps3
                       x = ei / b( i, i )
                       if( x/=zero ) then
                          do j = i + 1, n
                             b( i+1, j ) = b( i+1, j ) - x*b( i, j )
                          end do
                       end if
                    end if
                 end do
                 if( b( n, n )==zero )b( n, n ) = eps3
                 trans = 'N'
              else
                 ! ul decomposition with partial pivoting of b, replacing zero
                 ! pivots by eps3.
                 do j = n, 2, -1
                    ej = h( j, j-1 )
                    if( abs( b( j, j ) )<abs( ej ) ) then
                       ! interchange columns and eliminate.
                       x = b( j, j ) / ej
                       b( j, j ) = ej
                       do i = 1, j - 1
                          temp = b( i, j-1 )
                          b( i, j-1 ) = b( i, j ) - x*temp
                          b( i, j ) = temp
                       end do
                    else
                       ! eliminate without interchange.
                       if( b( j, j )==zero )b( j, j ) = eps3
                       x = ej / b( j, j )
                       if( x/=zero ) then
                          do i = 1, j - 1
                             b( i, j-1 ) = b( i, j-1 ) - x*b( i, j )
                          end do
                       end if
                    end if
                 end do
                 if( b( 1, 1 )==zero )b( 1, 1 ) = eps3
                 trans = 'T'
              end if
              normin = 'N'
              do its = 1, n
                 ! solve u*x = scale*v for a right eigenvector
                   ! or u**t*x = scale*v for a left eigenvector,
                 ! overwriting x on v.
                 call stdlib_dlatrs( 'UPPER', trans, 'NONUNIT', normin, n, b, ldb,vr, scale, work,&
                            ierr )
                 normin = 'Y'
                 ! test for sufficient growth in the norm of v.
                 vnorm = stdlib_dasum( n, vr, 1 )
                 if( vnorm>=growto*scale )go to 120
                 ! choose new orthogonal starting vector and try again.
                 temp = eps3 / ( rootn+one )
                 vr( 1 ) = eps3
                 do i = 2, n
                    vr( i ) = temp
                 end do
                 vr( n-its+1 ) = vr( n-its+1 ) - eps3*rootn
              end do
              ! failure to find eigenvector in n iterations.
              info = 1
              120 continue
              ! normalize eigenvector.
              i = stdlib_idamax( n, vr, 1 )
              call stdlib_dscal( n, one / abs( vr( i ) ), vr, 1 )
           else
              ! complex eigenvalue.
              if( noinit ) then
                 ! set initial vector.
                 do i = 1, n
                    vr( i ) = eps3
                    vi( i ) = zero
                 end do
              else
                 ! scale supplied initial vector.
                 norm = stdlib_dlapy2( stdlib_dnrm2( n, vr, 1 ), stdlib_dnrm2( n, vi, 1 ) )
                           
                 rec = ( eps3*rootn ) / max( norm, nrmsml )
                 call stdlib_dscal( n, rec, vr, 1 )
                 call stdlib_dscal( n, rec, vi, 1 )
              end if
              if( rightv ) then
                 ! lu decomposition with partial pivoting of b, replacing zero
                 ! pivots by eps3.
                 ! the imaginary part of the (i,j)-th element of u is stored in
                 ! b(j+1,i).
                 b( 2, 1 ) = -wi
                 do i = 2, n
                    b( i+1, 1 ) = zero
                 end do
                 loop_170: do i = 1, n - 1
                    absbii = stdlib_dlapy2( b( i, i ), b( i+1, i ) )
                    ei = h( i+1, i )
                    if( absbii<abs( ei ) ) then
                       ! interchange rows and eliminate.
                       xr = b( i, i ) / ei
                       xi = b( i+1, i ) / ei
                       b( i, i ) = ei
                       b( i+1, i ) = zero
                       do j = i + 1, n
                          temp = b( i+1, j )
                          b( i+1, j ) = b( i, j ) - xr*temp
                          b( j+1, i+1 ) = b( j+1, i ) - xi*temp
                          b( i, j ) = temp
                          b( j+1, i ) = zero
                       end do
                       b( i+2, i ) = -wi
                       b( i+1, i+1 ) = b( i+1, i+1 ) - xi*wi
                       b( i+2, i+1 ) = b( i+2, i+1 ) + xr*wi
                    else
                       ! eliminate without interchanging rows.
                       if( absbii==zero ) then
                          b( i, i ) = eps3
                          b( i+1, i ) = zero
                          absbii = eps3
                       end if
                       ei = ( ei / absbii ) / absbii
                       xr = b( i, i )*ei
                       xi = -b( i+1, i )*ei
                       do j = i + 1, n
                          b( i+1, j ) = b( i+1, j ) - xr*b( i, j ) +xi*b( j+1, i )
                          b( j+1, i+1 ) = -xr*b( j+1, i ) - xi*b( i, j )
                       end do
                       b( i+2, i+1 ) = b( i+2, i+1 ) - wi
                    end if
                    ! compute 1-norm of offdiagonal elements of i-th row.
                    work( i ) = stdlib_dasum( n-i, b( i, i+1 ), ldb ) +stdlib_dasum( n-i, b( i+2, &
                              i ), 1 )
                 end do loop_170
                 if( b( n, n )==zero .and. b( n+1, n )==zero )b( n, n ) = eps3
                 work( n ) = zero
                 i1 = n
                 i2 = 1
                 i3 = -1
              else
                 ! ul decomposition with partial pivoting of conjg(b),
                 ! replacing zero pivots by eps3.
                 ! the imaginary part of the (i,j)-th element of u is stored in
                 ! b(j+1,i).
                 b( n+1, n ) = wi
                 do j = 1, n - 1
                    b( n+1, j ) = zero
                 end do
                 loop_210: do j = n, 2, -1
                    ej = h( j, j-1 )
                    absbjj = stdlib_dlapy2( b( j, j ), b( j+1, j ) )
                    if( absbjj<abs( ej ) ) then
                       ! interchange columns and eliminate
                       xr = b( j, j ) / ej
                       xi = b( j+1, j ) / ej
                       b( j, j ) = ej
                       b( j+1, j ) = zero
                       do i = 1, j - 1
                          temp = b( i, j-1 )
                          b( i, j-1 ) = b( i, j ) - xr*temp
                          b( j, i ) = b( j+1, i ) - xi*temp
                          b( i, j ) = temp
                          b( j+1, i ) = zero
                       end do
                       b( j+1, j-1 ) = wi
                       b( j-1, j-1 ) = b( j-1, j-1 ) + xi*wi
                       b( j, j-1 ) = b( j, j-1 ) - xr*wi
                    else
                       ! eliminate without interchange.
                       if( absbjj==zero ) then
                          b( j, j ) = eps3
                          b( j+1, j ) = zero
                          absbjj = eps3
                       end if
                       ej = ( ej / absbjj ) / absbjj
                       xr = b( j, j )*ej
                       xi = -b( j+1, j )*ej
                       do i = 1, j - 1
                          b( i, j-1 ) = b( i, j-1 ) - xr*b( i, j ) +xi*b( j+1, i )
                          b( j, i ) = -xr*b( j+1, i ) - xi*b( i, j )
                       end do
                       b( j, j-1 ) = b( j, j-1 ) + wi
                    end if
                    ! compute 1-norm of offdiagonal elements of j-th column.
                    work( j ) = stdlib_dasum( j-1, b( 1, j ), 1 ) +stdlib_dasum( j-1, b( j+1, 1 ),&
                               ldb )
                 end do loop_210
                 if( b( 1, 1 )==zero .and. b( 2, 1 )==zero )b( 1, 1 ) = eps3
                 work( 1 ) = zero
                 i1 = 1
                 i2 = n
                 i3 = 1
              end if
              loop_270: do its = 1, n
                 scale = one
                 vmax = one
                 vcrit = bignum
                 ! solve u*(xr,xi) = scale*(vr,vi) for a right eigenvector,
                   ! or u**t*(xr,xi) = scale*(vr,vi) for a left eigenvector,
                 ! overwriting (xr,xi) on (vr,vi).
                 loop_250: do i = i1, i2, i3
                    if( work( i )>vcrit ) then
                       rec = one / vmax
                       call stdlib_dscal( n, rec, vr, 1 )
                       call stdlib_dscal( n, rec, vi, 1 )
                       scale = scale*rec
                       vmax = one
                       vcrit = bignum
                    end if
                    xr = vr( i )
                    xi = vi( i )
                    if( rightv ) then
                       do j = i + 1, n
                          xr = xr - b( i, j )*vr( j ) + b( j+1, i )*vi( j )
                          xi = xi - b( i, j )*vi( j ) - b( j+1, i )*vr( j )
                       end do
                    else
                       do j = 1, i - 1
                          xr = xr - b( j, i )*vr( j ) + b( i+1, j )*vi( j )
                          xi = xi - b( j, i )*vi( j ) - b( i+1, j )*vr( j )
                       end do
                    end if
                    w = abs( b( i, i ) ) + abs( b( i+1, i ) )
                    if( w>smlnum ) then
                       if( w<one ) then
                          w1 = abs( xr ) + abs( xi )
                          if( w1>w*bignum ) then
                             rec = one / w1
                             call stdlib_dscal( n, rec, vr, 1 )
                             call stdlib_dscal( n, rec, vi, 1 )
                             xr = vr( i )
                             xi = vi( i )
                             scale = scale*rec
                             vmax = vmax*rec
                          end if
                       end if
                       ! divide by diagonal element of b.
                       call stdlib_dladiv( xr, xi, b( i, i ), b( i+1, i ), vr( i ),vi( i ) )
                                 
                       vmax = max( abs( vr( i ) )+abs( vi( i ) ), vmax )
                       vcrit = bignum / vmax
                    else
                       do j = 1, n
                          vr( j ) = zero
                          vi( j ) = zero
                       end do
                       vr( i ) = one
                       vi( i ) = one
                       scale = zero
                       vmax = one
                       vcrit = bignum
                    end if
                 end do loop_250
                 ! test for sufficient growth in the norm of (vr,vi).
                 vnorm = stdlib_dasum( n, vr, 1 ) + stdlib_dasum( n, vi, 1 )
                 if( vnorm>=growto*scale )go to 280
                 ! choose a new orthogonal starting vector and try again.
                 y = eps3 / ( rootn+one )
                 vr( 1 ) = eps3
                 vi( 1 ) = zero
                 do i = 2, n
                    vr( i ) = y
                    vi( i ) = zero
                 end do
                 vr( n-its+1 ) = vr( n-its+1 ) - eps3*rootn
              end do loop_270
              ! failure to find eigenvector in n iterations
              info = 1
              280 continue
              ! normalize eigenvector.
              vnorm = zero
              do i = 1, n
                 vnorm = max( vnorm, abs( vr( i ) )+abs( vi( i ) ) )
              end do
              call stdlib_dscal( n, one / vnorm, vr, 1 )
              call stdlib_dscal( n, one / vnorm, vi, 1 )
           end if
           return
     end subroutine stdlib_dlaein

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$laein( rightv, noinit, n, h, ldh, wr, wi, vr, vi, b,ldb, work, eps3, &
     !! DLAEIN: uses inverse iteration to find a right or left eigenvector
     !! corresponding to the eigenvalue (WR,WI) of a real upper Hessenberg
     !! matrix H.
               smlnum, bignum, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: noinit, rightv
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldh, n
           real(${rk}$), intent(in) :: bignum, eps3, smlnum, wi, wr
           ! Array Arguments 
           real(${rk}$), intent(out) :: b(ldb,*), work(*)
           real(${rk}$), intent(in) :: h(ldh,*)
           real(${rk}$), intent(inout) :: vi(*), vr(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: tenth = 1.0e-1_${rk}$
           
           ! Local Scalars 
           character :: normin, trans
           integer(ilp) :: i, i1, i2, i3, ierr, its, j
           real(${rk}$) :: absbii, absbjj, ei, ej, growto, norm, nrmsml, rec, rootn, scale, temp, &
                     vcrit, vmax, vnorm, w, w1, x, xi, xr, y
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! growto is the threshold used in the acceptance test for an
           ! eigenvector.
           rootn = sqrt( real( n,KIND=${rk}$) )
           growto = tenth / rootn
           nrmsml = max( one, eps3*rootn )*smlnum
           ! form b = h - (wr,wi)*i (except that the subdiagonal elements and
           ! the imaginary parts of the diagonal elements are not stored).
           do j = 1, n
              do i = 1, j - 1
                 b( i, j ) = h( i, j )
              end do
              b( j, j ) = h( j, j ) - wr
           end do
           if( wi==zero ) then
              ! real eigenvalue.
              if( noinit ) then
                 ! set initial vector.
                 do i = 1, n
                    vr( i ) = eps3
                 end do
              else
                 ! scale supplied initial vector.
                 vnorm = stdlib_${ri}$nrm2( n, vr, 1 )
                 call stdlib_${ri}$scal( n, ( eps3*rootn ) / max( vnorm, nrmsml ), vr,1 )
              end if
              if( rightv ) then
                 ! lu decomposition with partial pivoting of b, replacing zero
                 ! pivots by eps3.
                 do i = 1, n - 1
                    ei = h( i+1, i )
                    if( abs( b( i, i ) )<abs( ei ) ) then
                       ! interchange rows and eliminate.
                       x = b( i, i ) / ei
                       b( i, i ) = ei
                       do j = i + 1, n
                          temp = b( i+1, j )
                          b( i+1, j ) = b( i, j ) - x*temp
                          b( i, j ) = temp
                       end do
                    else
                       ! eliminate without interchange.
                       if( b( i, i )==zero )b( i, i ) = eps3
                       x = ei / b( i, i )
                       if( x/=zero ) then
                          do j = i + 1, n
                             b( i+1, j ) = b( i+1, j ) - x*b( i, j )
                          end do
                       end if
                    end if
                 end do
                 if( b( n, n )==zero )b( n, n ) = eps3
                 trans = 'N'
              else
                 ! ul decomposition with partial pivoting of b, replacing zero
                 ! pivots by eps3.
                 do j = n, 2, -1
                    ej = h( j, j-1 )
                    if( abs( b( j, j ) )<abs( ej ) ) then
                       ! interchange columns and eliminate.
                       x = b( j, j ) / ej
                       b( j, j ) = ej
                       do i = 1, j - 1
                          temp = b( i, j-1 )
                          b( i, j-1 ) = b( i, j ) - x*temp
                          b( i, j ) = temp
                       end do
                    else
                       ! eliminate without interchange.
                       if( b( j, j )==zero )b( j, j ) = eps3
                       x = ej / b( j, j )
                       if( x/=zero ) then
                          do i = 1, j - 1
                             b( i, j-1 ) = b( i, j-1 ) - x*b( i, j )
                          end do
                       end if
                    end if
                 end do
                 if( b( 1, 1 )==zero )b( 1, 1 ) = eps3
                 trans = 'T'
              end if
              normin = 'N'
              do its = 1, n
                 ! solve u*x = scale*v for a right eigenvector
                   ! or u**t*x = scale*v for a left eigenvector,
                 ! overwriting x on v.
                 call stdlib_${ri}$latrs( 'UPPER', trans, 'NONUNIT', normin, n, b, ldb,vr, scale, work,&
                            ierr )
                 normin = 'Y'
                 ! test for sufficient growth in the norm of v.
                 vnorm = stdlib_${ri}$asum( n, vr, 1 )
                 if( vnorm>=growto*scale )go to 120
                 ! choose new orthogonal starting vector and try again.
                 temp = eps3 / ( rootn+one )
                 vr( 1 ) = eps3
                 do i = 2, n
                    vr( i ) = temp
                 end do
                 vr( n-its+1 ) = vr( n-its+1 ) - eps3*rootn
              end do
              ! failure to find eigenvector in n iterations.
              info = 1
              120 continue
              ! normalize eigenvector.
              i = stdlib_i${ri}$amax( n, vr, 1 )
              call stdlib_${ri}$scal( n, one / abs( vr( i ) ), vr, 1 )
           else
              ! complex eigenvalue.
              if( noinit ) then
                 ! set initial vector.
                 do i = 1, n
                    vr( i ) = eps3
                    vi( i ) = zero
                 end do
              else
                 ! scale supplied initial vector.
                 norm = stdlib_${ri}$lapy2( stdlib_${ri}$nrm2( n, vr, 1 ), stdlib_${ri}$nrm2( n, vi, 1 ) )
                           
                 rec = ( eps3*rootn ) / max( norm, nrmsml )
                 call stdlib_${ri}$scal( n, rec, vr, 1 )
                 call stdlib_${ri}$scal( n, rec, vi, 1 )
              end if
              if( rightv ) then
                 ! lu decomposition with partial pivoting of b, replacing zero
                 ! pivots by eps3.
                 ! the imaginary part of the (i,j)-th element of u is stored in
                 ! b(j+1,i).
                 b( 2, 1 ) = -wi
                 do i = 2, n
                    b( i+1, 1 ) = zero
                 end do
                 loop_170: do i = 1, n - 1
                    absbii = stdlib_${ri}$lapy2( b( i, i ), b( i+1, i ) )
                    ei = h( i+1, i )
                    if( absbii<abs( ei ) ) then
                       ! interchange rows and eliminate.
                       xr = b( i, i ) / ei
                       xi = b( i+1, i ) / ei
                       b( i, i ) = ei
                       b( i+1, i ) = zero
                       do j = i + 1, n
                          temp = b( i+1, j )
                          b( i+1, j ) = b( i, j ) - xr*temp
                          b( j+1, i+1 ) = b( j+1, i ) - xi*temp
                          b( i, j ) = temp
                          b( j+1, i ) = zero
                       end do
                       b( i+2, i ) = -wi
                       b( i+1, i+1 ) = b( i+1, i+1 ) - xi*wi
                       b( i+2, i+1 ) = b( i+2, i+1 ) + xr*wi
                    else
                       ! eliminate without interchanging rows.
                       if( absbii==zero ) then
                          b( i, i ) = eps3
                          b( i+1, i ) = zero
                          absbii = eps3
                       end if
                       ei = ( ei / absbii ) / absbii
                       xr = b( i, i )*ei
                       xi = -b( i+1, i )*ei
                       do j = i + 1, n
                          b( i+1, j ) = b( i+1, j ) - xr*b( i, j ) +xi*b( j+1, i )
                          b( j+1, i+1 ) = -xr*b( j+1, i ) - xi*b( i, j )
                       end do
                       b( i+2, i+1 ) = b( i+2, i+1 ) - wi
                    end if
                    ! compute 1-norm of offdiagonal elements of i-th row.
                    work( i ) = stdlib_${ri}$asum( n-i, b( i, i+1 ), ldb ) +stdlib_${ri}$asum( n-i, b( i+2, &
                              i ), 1 )
                 end do loop_170
                 if( b( n, n )==zero .and. b( n+1, n )==zero )b( n, n ) = eps3
                 work( n ) = zero
                 i1 = n
                 i2 = 1
                 i3 = -1
              else
                 ! ul decomposition with partial pivoting of conjg(b),
                 ! replacing zero pivots by eps3.
                 ! the imaginary part of the (i,j)-th element of u is stored in
                 ! b(j+1,i).
                 b( n+1, n ) = wi
                 do j = 1, n - 1
                    b( n+1, j ) = zero
                 end do
                 loop_210: do j = n, 2, -1
                    ej = h( j, j-1 )
                    absbjj = stdlib_${ri}$lapy2( b( j, j ), b( j+1, j ) )
                    if( absbjj<abs( ej ) ) then
                       ! interchange columns and eliminate
                       xr = b( j, j ) / ej
                       xi = b( j+1, j ) / ej
                       b( j, j ) = ej
                       b( j+1, j ) = zero
                       do i = 1, j - 1
                          temp = b( i, j-1 )
                          b( i, j-1 ) = b( i, j ) - xr*temp
                          b( j, i ) = b( j+1, i ) - xi*temp
                          b( i, j ) = temp
                          b( j+1, i ) = zero
                       end do
                       b( j+1, j-1 ) = wi
                       b( j-1, j-1 ) = b( j-1, j-1 ) + xi*wi
                       b( j, j-1 ) = b( j, j-1 ) - xr*wi
                    else
                       ! eliminate without interchange.
                       if( absbjj==zero ) then
                          b( j, j ) = eps3
                          b( j+1, j ) = zero
                          absbjj = eps3
                       end if
                       ej = ( ej / absbjj ) / absbjj
                       xr = b( j, j )*ej
                       xi = -b( j+1, j )*ej
                       do i = 1, j - 1
                          b( i, j-1 ) = b( i, j-1 ) - xr*b( i, j ) +xi*b( j+1, i )
                          b( j, i ) = -xr*b( j+1, i ) - xi*b( i, j )
                       end do
                       b( j, j-1 ) = b( j, j-1 ) + wi
                    end if
                    ! compute 1-norm of offdiagonal elements of j-th column.
                    work( j ) = stdlib_${ri}$asum( j-1, b( 1, j ), 1 ) +stdlib_${ri}$asum( j-1, b( j+1, 1 ),&
                               ldb )
                 end do loop_210
                 if( b( 1, 1 )==zero .and. b( 2, 1 )==zero )b( 1, 1 ) = eps3
                 work( 1 ) = zero
                 i1 = 1
                 i2 = n
                 i3 = 1
              end if
              loop_270: do its = 1, n
                 scale = one
                 vmax = one
                 vcrit = bignum
                 ! solve u*(xr,xi) = scale*(vr,vi) for a right eigenvector,
                   ! or u**t*(xr,xi) = scale*(vr,vi) for a left eigenvector,
                 ! overwriting (xr,xi) on (vr,vi).
                 loop_250: do i = i1, i2, i3
                    if( work( i )>vcrit ) then
                       rec = one / vmax
                       call stdlib_${ri}$scal( n, rec, vr, 1 )
                       call stdlib_${ri}$scal( n, rec, vi, 1 )
                       scale = scale*rec
                       vmax = one
                       vcrit = bignum
                    end if
                    xr = vr( i )
                    xi = vi( i )
                    if( rightv ) then
                       do j = i + 1, n
                          xr = xr - b( i, j )*vr( j ) + b( j+1, i )*vi( j )
                          xi = xi - b( i, j )*vi( j ) - b( j+1, i )*vr( j )
                       end do
                    else
                       do j = 1, i - 1
                          xr = xr - b( j, i )*vr( j ) + b( i+1, j )*vi( j )
                          xi = xi - b( j, i )*vi( j ) - b( i+1, j )*vr( j )
                       end do
                    end if
                    w = abs( b( i, i ) ) + abs( b( i+1, i ) )
                    if( w>smlnum ) then
                       if( w<one ) then
                          w1 = abs( xr ) + abs( xi )
                          if( w1>w*bignum ) then
                             rec = one / w1
                             call stdlib_${ri}$scal( n, rec, vr, 1 )
                             call stdlib_${ri}$scal( n, rec, vi, 1 )
                             xr = vr( i )
                             xi = vi( i )
                             scale = scale*rec
                             vmax = vmax*rec
                          end if
                       end if
                       ! divide by diagonal element of b.
                       call stdlib_${ri}$ladiv( xr, xi, b( i, i ), b( i+1, i ), vr( i ),vi( i ) )
                                 
                       vmax = max( abs( vr( i ) )+abs( vi( i ) ), vmax )
                       vcrit = bignum / vmax
                    else
                       do j = 1, n
                          vr( j ) = zero
                          vi( j ) = zero
                       end do
                       vr( i ) = one
                       vi( i ) = one
                       scale = zero
                       vmax = one
                       vcrit = bignum
                    end if
                 end do loop_250
                 ! test for sufficient growth in the norm of (vr,vi).
                 vnorm = stdlib_${ri}$asum( n, vr, 1 ) + stdlib_${ri}$asum( n, vi, 1 )
                 if( vnorm>=growto*scale )go to 280
                 ! choose a new orthogonal starting vector and try again.
                 y = eps3 / ( rootn+one )
                 vr( 1 ) = eps3
                 vi( 1 ) = zero
                 do i = 2, n
                    vr( i ) = y
                    vi( i ) = zero
                 end do
                 vr( n-its+1 ) = vr( n-its+1 ) - eps3*rootn
              end do loop_270
              ! failure to find eigenvector in n iterations
              info = 1
              280 continue
              ! normalize eigenvector.
              vnorm = zero
              do i = 1, n
                 vnorm = max( vnorm, abs( vr( i ) )+abs( vi( i ) ) )
              end do
              call stdlib_${ri}$scal( n, one / vnorm, vr, 1 )
              call stdlib_${ri}$scal( n, one / vnorm, vi, 1 )
           end if
           return
     end subroutine stdlib_${ri}$laein

#:endif
#:endfor

     pure subroutine stdlib_claein( rightv, noinit, n, h, ldh, w, v, b, ldb, rwork,eps3, smlnum, &
     !! CLAEIN uses inverse iteration to find a right or left eigenvector
     !! corresponding to the eigenvalue W of a complex upper Hessenberg
     !! matrix H.
               info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: noinit, rightv
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldh, n
           real(sp), intent(in) :: eps3, smlnum
           complex(sp), intent(in) :: w
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(out) :: b(ldb,*)
           complex(sp), intent(in) :: h(ldh,*)
           complex(sp), intent(inout) :: v(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: tenth = 1.0e-1_sp
           
           
           ! Local Scalars 
           character :: normin, trans
           integer(ilp) :: i, ierr, its, j
           real(sp) :: growto, nrmsml, rootn, rtemp, scale, vnorm
           complex(sp) :: cdum, ei, ej, temp, x
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! growto is the threshold used in the acceptance test for an
           ! eigenvector.
           rootn = sqrt( real( n,KIND=sp) )
           growto = tenth / rootn
           nrmsml = max( one, eps3*rootn )*smlnum
           ! form b = h - w*i (except that the subdiagonal elements are not
           ! stored).
           do j = 1, n
              do i = 1, j - 1
                 b( i, j ) = h( i, j )
              end do
              b( j, j ) = h( j, j ) - w
           end do
           if( noinit ) then
              ! initialize v.
              do i = 1, n
                 v( i ) = eps3
              end do
           else
              ! scale supplied initial vector.
              vnorm = stdlib_scnrm2( n, v, 1 )
              call stdlib_csscal( n, ( eps3*rootn ) / max( vnorm, nrmsml ), v, 1 )
           end if
           if( rightv ) then
              ! lu decomposition with partial pivoting of b, replacing czero
              ! pivots by eps3.
              do i = 1, n - 1
                 ei = h( i+1, i )
                 if( cabs1( b( i, i ) )<cabs1( ei ) ) then
                    ! interchange rows and eliminate.
                    x = stdlib_cladiv( b( i, i ), ei )
                    b( i, i ) = ei
                    do j = i + 1, n
                       temp = b( i+1, j )
                       b( i+1, j ) = b( i, j ) - x*temp
                       b( i, j ) = temp
                    end do
                 else
                    ! eliminate without interchange.
                    if( b( i, i )==czero )b( i, i ) = eps3
                    x = stdlib_cladiv( ei, b( i, i ) )
                    if( x/=czero ) then
                       do j = i + 1, n
                          b( i+1, j ) = b( i+1, j ) - x*b( i, j )
                       end do
                    end if
                 end if
              end do
              if( b( n, n )==czero )b( n, n ) = eps3
              trans = 'N'
           else
              ! ul decomposition with partial pivoting of b, replacing czero
              ! pivots by eps3.
              do j = n, 2, -1
                 ej = h( j, j-1 )
                 if( cabs1( b( j, j ) )<cabs1( ej ) ) then
                    ! interchange columns and eliminate.
                    x = stdlib_cladiv( b( j, j ), ej )
                    b( j, j ) = ej
                    do i = 1, j - 1
                       temp = b( i, j-1 )
                       b( i, j-1 ) = b( i, j ) - x*temp
                       b( i, j ) = temp
                    end do
                 else
                    ! eliminate without interchange.
                    if( b( j, j )==czero )b( j, j ) = eps3
                    x = stdlib_cladiv( ej, b( j, j ) )
                    if( x/=czero ) then
                       do i = 1, j - 1
                          b( i, j-1 ) = b( i, j-1 ) - x*b( i, j )
                       end do
                    end if
                 end if
              end do
              if( b( 1, 1 )==czero )b( 1, 1 ) = eps3
              trans = 'C'
           end if
           normin = 'N'
           do its = 1, n
              ! solve u*x = scale*v for a right eigenvector
                ! or u**h *x = scale*v for a left eigenvector,
              ! overwriting x on v.
              call stdlib_clatrs( 'UPPER', trans, 'NONUNIT', normin, n, b, ldb, v,scale, rwork, &
                        ierr )
              normin = 'Y'
              ! test for sufficient growth in the norm of v.
              vnorm = stdlib_scasum( n, v, 1 )
              if( vnorm>=growto*scale )go to 120
              ! choose new orthogonal starting vector and try again.
              rtemp = eps3 / ( rootn+one )
              v( 1 ) = eps3
              do i = 2, n
                 v( i ) = rtemp
              end do
              v( n-its+1 ) = v( n-its+1 ) - eps3*rootn
           end do
           ! failure to find eigenvector in n iterations.
           info = 1
           120 continue
           ! normalize eigenvector.
           i = stdlib_icamax( n, v, 1 )
           call stdlib_csscal( n, one / cabs1( v( i ) ), v, 1 )
           return
     end subroutine stdlib_claein

     pure subroutine stdlib_zlaein( rightv, noinit, n, h, ldh, w, v, b, ldb, rwork,eps3, smlnum, &
     !! ZLAEIN uses inverse iteration to find a right or left eigenvector
     !! corresponding to the eigenvalue W of a complex upper Hessenberg
     !! matrix H.
               info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: noinit, rightv
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldh, n
           real(dp), intent(in) :: eps3, smlnum
           complex(dp), intent(in) :: w
           ! Array Arguments 
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(out) :: b(ldb,*)
           complex(dp), intent(in) :: h(ldh,*)
           complex(dp), intent(inout) :: v(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: tenth = 1.0e-1_dp
           
           
           ! Local Scalars 
           character :: normin, trans
           integer(ilp) :: i, ierr, its, j
           real(dp) :: growto, nrmsml, rootn, rtemp, scale, vnorm
           complex(dp) :: cdum, ei, ej, temp, x
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! growto is the threshold used in the acceptance test for an
           ! eigenvector.
           rootn = sqrt( real( n,KIND=dp) )
           growto = tenth / rootn
           nrmsml = max( one, eps3*rootn )*smlnum
           ! form b = h - w*i (except that the subdiagonal elements are not
           ! stored).
           do j = 1, n
              do i = 1, j - 1
                 b( i, j ) = h( i, j )
              end do
              b( j, j ) = h( j, j ) - w
           end do
           if( noinit ) then
              ! initialize v.
              do i = 1, n
                 v( i ) = eps3
              end do
           else
              ! scale supplied initial vector.
              vnorm = stdlib_dznrm2( n, v, 1 )
              call stdlib_zdscal( n, ( eps3*rootn ) / max( vnorm, nrmsml ), v, 1 )
           end if
           if( rightv ) then
              ! lu decomposition with partial pivoting of b, replacing czero
              ! pivots by eps3.
              do i = 1, n - 1
                 ei = h( i+1, i )
                 if( cabs1( b( i, i ) )<cabs1( ei ) ) then
                    ! interchange rows and eliminate.
                    x = stdlib_zladiv( b( i, i ), ei )
                    b( i, i ) = ei
                    do j = i + 1, n
                       temp = b( i+1, j )
                       b( i+1, j ) = b( i, j ) - x*temp
                       b( i, j ) = temp
                    end do
                 else
                    ! eliminate without interchange.
                    if( b( i, i )==czero )b( i, i ) = eps3
                    x = stdlib_zladiv( ei, b( i, i ) )
                    if( x/=czero ) then
                       do j = i + 1, n
                          b( i+1, j ) = b( i+1, j ) - x*b( i, j )
                       end do
                    end if
                 end if
              end do
              if( b( n, n )==czero )b( n, n ) = eps3
              trans = 'N'
           else
              ! ul decomposition with partial pivoting of b, replacing czero
              ! pivots by eps3.
              do j = n, 2, -1
                 ej = h( j, j-1 )
                 if( cabs1( b( j, j ) )<cabs1( ej ) ) then
                    ! interchange columns and eliminate.
                    x = stdlib_zladiv( b( j, j ), ej )
                    b( j, j ) = ej
                    do i = 1, j - 1
                       temp = b( i, j-1 )
                       b( i, j-1 ) = b( i, j ) - x*temp
                       b( i, j ) = temp
                    end do
                 else
                    ! eliminate without interchange.
                    if( b( j, j )==czero )b( j, j ) = eps3
                    x = stdlib_zladiv( ej, b( j, j ) )
                    if( x/=czero ) then
                       do i = 1, j - 1
                          b( i, j-1 ) = b( i, j-1 ) - x*b( i, j )
                       end do
                    end if
                 end if
              end do
              if( b( 1, 1 )==czero )b( 1, 1 ) = eps3
              trans = 'C'
           end if
           normin = 'N'
           do its = 1, n
              ! solve u*x = scale*v for a right eigenvector
                ! or u**h *x = scale*v for a left eigenvector,
              ! overwriting x on v.
              call stdlib_zlatrs( 'UPPER', trans, 'NONUNIT', normin, n, b, ldb, v,scale, rwork, &
                        ierr )
              normin = 'Y'
              ! test for sufficient growth in the norm of v.
              vnorm = stdlib_dzasum( n, v, 1 )
              if( vnorm>=growto*scale )go to 120
              ! choose new orthogonal starting vector and try again.
              rtemp = eps3 / ( rootn+one )
              v( 1 ) = eps3
              do i = 2, n
                 v( i ) = rtemp
              end do
              v( n-its+1 ) = v( n-its+1 ) - eps3*rootn
           end do
           ! failure to find eigenvector in n iterations.
           info = 1
           120 continue
           ! normalize eigenvector.
           i = stdlib_izamax( n, v, 1 )
           call stdlib_zdscal( n, one / cabs1( v( i ) ), v, 1 )
           return
     end subroutine stdlib_zlaein

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$laein( rightv, noinit, n, h, ldh, w, v, b, ldb, rwork,eps3, smlnum, &
     !! ZLAEIN: uses inverse iteration to find a right or left eigenvector
     !! corresponding to the eigenvalue W of a complex upper Hessenberg
     !! matrix H.
               info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: noinit, rightv
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldh, n
           real(${ck}$), intent(in) :: eps3, smlnum
           complex(${ck}$), intent(in) :: w
           ! Array Arguments 
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(out) :: b(ldb,*)
           complex(${ck}$), intent(in) :: h(ldh,*)
           complex(${ck}$), intent(inout) :: v(*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: tenth = 1.0e-1_${ck}$
           
           
           ! Local Scalars 
           character :: normin, trans
           integer(ilp) :: i, ierr, its, j
           real(${ck}$) :: growto, nrmsml, rootn, rtemp, scale, vnorm
           complex(${ck}$) :: cdum, ei, ej, temp, x
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! growto is the threshold used in the acceptance test for an
           ! eigenvector.
           rootn = sqrt( real( n,KIND=${ck}$) )
           growto = tenth / rootn
           nrmsml = max( one, eps3*rootn )*smlnum
           ! form b = h - w*i (except that the subdiagonal elements are not
           ! stored).
           do j = 1, n
              do i = 1, j - 1
                 b( i, j ) = h( i, j )
              end do
              b( j, j ) = h( j, j ) - w
           end do
           if( noinit ) then
              ! initialize v.
              do i = 1, n
                 v( i ) = eps3
              end do
           else
              ! scale supplied initial vector.
              vnorm = stdlib_${c2ri(ci)}$znrm2( n, v, 1 )
              call stdlib_${ci}$dscal( n, ( eps3*rootn ) / max( vnorm, nrmsml ), v, 1 )
           end if
           if( rightv ) then
              ! lu decomposition with partial pivoting of b, replacing czero
              ! pivots by eps3.
              do i = 1, n - 1
                 ei = h( i+1, i )
                 if( cabs1( b( i, i ) )<cabs1( ei ) ) then
                    ! interchange rows and eliminate.
                    x = stdlib_${ci}$ladiv( b( i, i ), ei )
                    b( i, i ) = ei
                    do j = i + 1, n
                       temp = b( i+1, j )
                       b( i+1, j ) = b( i, j ) - x*temp
                       b( i, j ) = temp
                    end do
                 else
                    ! eliminate without interchange.
                    if( b( i, i )==czero )b( i, i ) = eps3
                    x = stdlib_${ci}$ladiv( ei, b( i, i ) )
                    if( x/=czero ) then
                       do j = i + 1, n
                          b( i+1, j ) = b( i+1, j ) - x*b( i, j )
                       end do
                    end if
                 end if
              end do
              if( b( n, n )==czero )b( n, n ) = eps3
              trans = 'N'
           else
              ! ul decomposition with partial pivoting of b, replacing czero
              ! pivots by eps3.
              do j = n, 2, -1
                 ej = h( j, j-1 )
                 if( cabs1( b( j, j ) )<cabs1( ej ) ) then
                    ! interchange columns and eliminate.
                    x = stdlib_${ci}$ladiv( b( j, j ), ej )
                    b( j, j ) = ej
                    do i = 1, j - 1
                       temp = b( i, j-1 )
                       b( i, j-1 ) = b( i, j ) - x*temp
                       b( i, j ) = temp
                    end do
                 else
                    ! eliminate without interchange.
                    if( b( j, j )==czero )b( j, j ) = eps3
                    x = stdlib_${ci}$ladiv( ej, b( j, j ) )
                    if( x/=czero ) then
                       do i = 1, j - 1
                          b( i, j-1 ) = b( i, j-1 ) - x*b( i, j )
                       end do
                    end if
                 end if
              end do
              if( b( 1, 1 )==czero )b( 1, 1 ) = eps3
              trans = 'C'
           end if
           normin = 'N'
           do its = 1, n
              ! solve u*x = scale*v for a right eigenvector
                ! or u**h *x = scale*v for a left eigenvector,
              ! overwriting x on v.
              call stdlib_${ci}$latrs( 'UPPER', trans, 'NONUNIT', normin, n, b, ldb, v,scale, rwork, &
                        ierr )
              normin = 'Y'
              ! test for sufficient growth in the norm of v.
              vnorm = stdlib_${c2ri(ci)}$zasum( n, v, 1 )
              if( vnorm>=growto*scale )go to 120
              ! choose new orthogonal starting vector and try again.
              rtemp = eps3 / ( rootn+one )
              v( 1 ) = eps3
              do i = 2, n
                 v( i ) = rtemp
              end do
              v( n-its+1 ) = v( n-its+1 ) - eps3*rootn
           end do
           ! failure to find eigenvector in n iterations.
           info = 1
           120 continue
           ! normalize eigenvector.
           i = stdlib_i${ci}$amax( n, v, 1 )
           call stdlib_${ci}$dscal( n, one / cabs1( v( i ) ), v, 1 )
           return
     end subroutine stdlib_${ci}$laein

#:endif
#:endfor



     pure subroutine stdlib_sgebal( job, n, a, lda, ilo, ihi, scale, info )
     !! SGEBAL balances a general real matrix A.  This involves, first,
     !! permuting A by a similarity transformation to isolate eigenvalues
     !! in the first 1 to ILO-1 and last IHI+1 to N elements on the
     !! diagonal; and second, applying a diagonal similarity transformation
     !! to rows and columns ILO to IHI to make the rows and columns as
     !! close in norm as possible.  Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrix, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: scale(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sclfac = 2.0e+0_sp
           real(sp), parameter :: factor = 0.95e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: noconv
           integer(ilp) :: i, ica, iexc, ira, j, k, l, m
           real(sp) :: c, ca, f, g, r, ra, s, sfmax1, sfmax2, sfmin1, sfmin2
           ! Intrinsic Functions 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGEBAL', -info )
              return
           end if
           k = 1
           l = n
           if( n==0 )go to 210
           if( stdlib_lsame( job, 'N' ) ) then
              do i = 1, n
                 scale( i ) = one
              end do
              go to 210
           end if
           if( stdlib_lsame( job, 'S' ) )go to 120
           ! permutation to isolate eigenvalues if possible
           go to 50
           ! row and column exchange.
           20 continue
           scale( m ) = j
           if( j==m )go to 30
           call stdlib_sswap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_sswap( n-k+1, a( j, k ), lda, a( m, k ), lda )
           30 continue
           go to ( 40, 80 )iexc
           ! search for rows isolating an eigenvalue and push them down.
           40 continue
           if( l==1 )go to 210
           l = l - 1
           50 continue
           loop_70: do j = l, 1, -1
              loop_60: do i = 1, l
                 if( i==j )cycle loop_60
                 if( a( j, i )/=zero )cycle loop_70
              end do loop_60
              m = l
              iexc = 1
              go to 20
           end do loop_70
           go to 90
           ! search for columns isolating an eigenvalue and push them left.
           80 continue
           k = k + 1
           90 continue
           loop_110: do j = k, l
              loop_100: do i = k, l
                 if( i==j )cycle loop_100
                 if( a( i, j )/=zero )cycle loop_110
              end do loop_100
              m = k
              iexc = 2
              go to 20
           end do loop_110
           120 continue
           do i = k, l
              scale( i ) = one
           end do
           if( stdlib_lsame( job, 'P' ) )go to 210
           ! balance the submatrix in rows k to l.
           ! iterative loop for norm reduction
           sfmin1 = stdlib_slamch( 'S' ) / stdlib_slamch( 'P' )
           sfmax1 = one / sfmin1
           sfmin2 = sfmin1*sclfac
           sfmax2 = one / sfmin2
           140 continue
           noconv = .false.
           loop_200: do i = k, l
              c = stdlib_snrm2( l-k+1, a( k, i ), 1 )
              r = stdlib_snrm2( l-k+1, a( i, k ), lda )
              ica = stdlib_isamax( l, a( 1, i ), 1 )
              ca = abs( a( ica, i ) )
              ira = stdlib_isamax( n-k+1, a( i, k ), lda )
              ra = abs( a( i, ira+k-1 ) )
              ! guard against zero c or r due to underflow.
              if( c==zero .or. r==zero )cycle loop_200
              g = r / sclfac
              f = one
              s = c + r
              160 continue
              if( c>=g .or. max( f, c, ca )>=sfmax2 .or.min( r, g, ra )<=sfmin2 )go to 170
              f = f*sclfac
              c = c*sclfac
              ca = ca*sclfac
              r = r / sclfac
              g = g / sclfac
              ra = ra / sclfac
              go to 160
              170 continue
              g = c / sclfac
              180 continue
              if( g<r .or. max( r, ra )>=sfmax2 .or.min( f, c, g, ca )<=sfmin2 )go to 190
                 if( stdlib_sisnan( c+f+ca+r+g+ra ) ) then
                 ! exit if nan to avoid infinite loop
                 info = -3
                 call stdlib_xerbla( 'SGEBAL', -info )
                 return
              end if
              f = f / sclfac
              c = c / sclfac
              g = g / sclfac
              ca = ca / sclfac
              r = r*sclfac
              ra = ra*sclfac
              go to 180
              ! now balance.
              190 continue
              if( ( c+r )>=factor*s )cycle loop_200
              if( f<one .and. scale( i )<one ) then
                 if( f*scale( i )<=sfmin1 )cycle loop_200
              end if
              if( f>one .and. scale( i )>one ) then
                 if( scale( i )>=sfmax1 / f )cycle loop_200
              end if
              g = one / f
              scale( i ) = scale( i )*f
              noconv = .true.
              call stdlib_sscal( n-k+1, g, a( i, k ), lda )
              call stdlib_sscal( l, f, a( 1, i ), 1 )
           end do loop_200
           if( noconv )go to 140
           210 continue
           ilo = k
           ihi = l
           return
     end subroutine stdlib_sgebal

     pure subroutine stdlib_dgebal( job, n, a, lda, ilo, ihi, scale, info )
     !! DGEBAL balances a general real matrix A.  This involves, first,
     !! permuting A by a similarity transformation to isolate eigenvalues
     !! in the first 1 to ILO-1 and last IHI+1 to N elements on the
     !! diagonal; and second, applying a diagonal similarity transformation
     !! to rows and columns ILO to IHI to make the rows and columns as
     !! close in norm as possible.  Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrix, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: scale(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sclfac = 2.0e+0_dp
           real(dp), parameter :: factor = 0.95e+0_dp
           
           
           
           ! Local Scalars 
           logical(lk) :: noconv
           integer(ilp) :: i, ica, iexc, ira, j, k, l, m
           real(dp) :: c, ca, f, g, r, ra, s, sfmax1, sfmax2, sfmin1, sfmin2
           ! Intrinsic Functions 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEBAL', -info )
              return
           end if
           k = 1
           l = n
           if( n==0 )go to 210
           if( stdlib_lsame( job, 'N' ) ) then
              do i = 1, n
                 scale( i ) = one
              end do
              go to 210
           end if
           if( stdlib_lsame( job, 'S' ) )go to 120
           ! permutation to isolate eigenvalues if possible
           go to 50
           ! row and column exchange.
           20 continue
           scale( m ) = j
           if( j==m )go to 30
           call stdlib_dswap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_dswap( n-k+1, a( j, k ), lda, a( m, k ), lda )
           30 continue
           go to ( 40, 80 )iexc
           ! search for rows isolating an eigenvalue and push them down.
           40 continue
           if( l==1 )go to 210
           l = l - 1
           50 continue
           loop_70: do j = l, 1, -1
              loop_60: do i = 1, l
                 if( i==j )cycle loop_60
                 if( a( j, i )/=zero )cycle loop_70
              end do loop_60
              m = l
              iexc = 1
              go to 20
           end do loop_70
           go to 90
           ! search for columns isolating an eigenvalue and push them left.
           80 continue
           k = k + 1
           90 continue
           loop_110: do j = k, l
              loop_100: do i = k, l
                 if( i==j )cycle loop_100
                 if( a( i, j )/=zero )cycle loop_110
              end do loop_100
              m = k
              iexc = 2
              go to 20
           end do loop_110
           120 continue
           do i = k, l
              scale( i ) = one
           end do
           if( stdlib_lsame( job, 'P' ) )go to 210
           ! balance the submatrix in rows k to l.
           ! iterative loop for norm reduction
           sfmin1 = stdlib_dlamch( 'S' ) / stdlib_dlamch( 'P' )
           sfmax1 = one / sfmin1
           sfmin2 = sfmin1*sclfac
           sfmax2 = one / sfmin2
           140 continue
           noconv = .false.
           loop_200: do i = k, l
              c = stdlib_dnrm2( l-k+1, a( k, i ), 1 )
              r = stdlib_dnrm2( l-k+1, a( i, k ), lda )
              ica = stdlib_idamax( l, a( 1, i ), 1 )
              ca = abs( a( ica, i ) )
              ira = stdlib_idamax( n-k+1, a( i, k ), lda )
              ra = abs( a( i, ira+k-1 ) )
              ! guard against zero c or r due to underflow.
              if( c==zero .or. r==zero )cycle loop_200
              g = r / sclfac
              f = one
              s = c + r
              160 continue
              if( c>=g .or. max( f, c, ca )>=sfmax2 .or.min( r, g, ra )<=sfmin2 )go to 170
                 if( stdlib_disnan( c+f+ca+r+g+ra ) ) then
                 ! exit if nan to avoid infinite loop
                 info = -3
                 call stdlib_xerbla( 'DGEBAL', -info )
                 return
              end if
              f = f*sclfac
              c = c*sclfac
              ca = ca*sclfac
              r = r / sclfac
              g = g / sclfac
              ra = ra / sclfac
              go to 160
              170 continue
              g = c / sclfac
              180 continue
              if( g<r .or. max( r, ra )>=sfmax2 .or.min( f, c, g, ca )<=sfmin2 )go to 190
              f = f / sclfac
              c = c / sclfac
              g = g / sclfac
              ca = ca / sclfac
              r = r*sclfac
              ra = ra*sclfac
              go to 180
              ! now balance.
              190 continue
              if( ( c+r )>=factor*s )cycle loop_200
              if( f<one .and. scale( i )<one ) then
                 if( f*scale( i )<=sfmin1 )cycle loop_200
              end if
              if( f>one .and. scale( i )>one ) then
                 if( scale( i )>=sfmax1 / f )cycle loop_200
              end if
              g = one / f
              scale( i ) = scale( i )*f
              noconv = .true.
              call stdlib_dscal( n-k+1, g, a( i, k ), lda )
              call stdlib_dscal( l, f, a( 1, i ), 1 )
           end do loop_200
           if( noconv )go to 140
           210 continue
           ilo = k
           ihi = l
           return
     end subroutine stdlib_dgebal

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$gebal( job, n, a, lda, ilo, ihi, scale, info )
     !! DGEBAL: balances a general real matrix A.  This involves, first,
     !! permuting A by a similarity transformation to isolate eigenvalues
     !! in the first 1 to ILO-1 and last IHI+1 to N elements on the
     !! diagonal; and second, applying a diagonal similarity transformation
     !! to rows and columns ILO to IHI to make the rows and columns as
     !! close in norm as possible.  Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrix, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: scale(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: sclfac = 2.0e+0_${rk}$
           real(${rk}$), parameter :: factor = 0.95e+0_${rk}$
           
           
           
           ! Local Scalars 
           logical(lk) :: noconv
           integer(ilp) :: i, ica, iexc, ira, j, k, l, m
           real(${rk}$) :: c, ca, f, g, r, ra, s, sfmax1, sfmax2, sfmin1, sfmin2
           ! Intrinsic Functions 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGEBAL', -info )
              return
           end if
           k = 1
           l = n
           if( n==0 )go to 210
           if( stdlib_lsame( job, 'N' ) ) then
              do i = 1, n
                 scale( i ) = one
              end do
              go to 210
           end if
           if( stdlib_lsame( job, 'S' ) )go to 120
           ! permutation to isolate eigenvalues if possible
           go to 50
           ! row and column exchange.
           20 continue
           scale( m ) = j
           if( j==m )go to 30
           call stdlib_${ri}$swap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_${ri}$swap( n-k+1, a( j, k ), lda, a( m, k ), lda )
           30 continue
           go to ( 40, 80 )iexc
           ! search for rows isolating an eigenvalue and push them down.
           40 continue
           if( l==1 )go to 210
           l = l - 1
           50 continue
           loop_70: do j = l, 1, -1
              loop_60: do i = 1, l
                 if( i==j )cycle loop_60
                 if( a( j, i )/=zero )cycle loop_70
              end do loop_60
              m = l
              iexc = 1
              go to 20
           end do loop_70
           go to 90
           ! search for columns isolating an eigenvalue and push them left.
           80 continue
           k = k + 1
           90 continue
           loop_110: do j = k, l
              loop_100: do i = k, l
                 if( i==j )cycle loop_100
                 if( a( i, j )/=zero )cycle loop_110
              end do loop_100
              m = k
              iexc = 2
              go to 20
           end do loop_110
           120 continue
           do i = k, l
              scale( i ) = one
           end do
           if( stdlib_lsame( job, 'P' ) )go to 210
           ! balance the submatrix in rows k to l.
           ! iterative loop for norm reduction
           sfmin1 = stdlib_${ri}$lamch( 'S' ) / stdlib_${ri}$lamch( 'P' )
           sfmax1 = one / sfmin1
           sfmin2 = sfmin1*sclfac
           sfmax2 = one / sfmin2
           140 continue
           noconv = .false.
           loop_200: do i = k, l
              c = stdlib_${ri}$nrm2( l-k+1, a( k, i ), 1 )
              r = stdlib_${ri}$nrm2( l-k+1, a( i, k ), lda )
              ica = stdlib_i${ri}$amax( l, a( 1, i ), 1 )
              ca = abs( a( ica, i ) )
              ira = stdlib_i${ri}$amax( n-k+1, a( i, k ), lda )
              ra = abs( a( i, ira+k-1 ) )
              ! guard against zero c or r due to underflow.
              if( c==zero .or. r==zero )cycle loop_200
              g = r / sclfac
              f = one
              s = c + r
              160 continue
              if( c>=g .or. max( f, c, ca )>=sfmax2 .or.min( r, g, ra )<=sfmin2 )go to 170
                 if( stdlib_${ri}$isnan( c+f+ca+r+g+ra ) ) then
                 ! exit if nan to avoid infinite loop
                 info = -3
                 call stdlib_xerbla( 'DGEBAL', -info )
                 return
              end if
              f = f*sclfac
              c = c*sclfac
              ca = ca*sclfac
              r = r / sclfac
              g = g / sclfac
              ra = ra / sclfac
              go to 160
              170 continue
              g = c / sclfac
              180 continue
              if( g<r .or. max( r, ra )>=sfmax2 .or.min( f, c, g, ca )<=sfmin2 )go to 190
              f = f / sclfac
              c = c / sclfac
              g = g / sclfac
              ca = ca / sclfac
              r = r*sclfac
              ra = ra*sclfac
              go to 180
              ! now balance.
              190 continue
              if( ( c+r )>=factor*s )cycle loop_200
              if( f<one .and. scale( i )<one ) then
                 if( f*scale( i )<=sfmin1 )cycle loop_200
              end if
              if( f>one .and. scale( i )>one ) then
                 if( scale( i )>=sfmax1 / f )cycle loop_200
              end if
              g = one / f
              scale( i ) = scale( i )*f
              noconv = .true.
              call stdlib_${ri}$scal( n-k+1, g, a( i, k ), lda )
              call stdlib_${ri}$scal( l, f, a( 1, i ), 1 )
           end do loop_200
           if( noconv )go to 140
           210 continue
           ilo = k
           ihi = l
           return
     end subroutine stdlib_${ri}$gebal

#:endif
#:endfor

     pure subroutine stdlib_cgebal( job, n, a, lda, ilo, ihi, scale, info )
     !! CGEBAL balances a general complex matrix A.  This involves, first,
     !! permuting A by a similarity transformation to isolate eigenvalues
     !! in the first 1 to ILO-1 and last IHI+1 to N elements on the
     !! diagonal; and second, applying a diagonal similarity transformation
     !! to rows and columns ILO to IHI to make the rows and columns as
     !! close in norm as possible.  Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrix, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(sp), intent(out) :: scale(*)
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sclfac = 2.0e+0_sp
           real(sp), parameter :: factor = 0.95e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: noconv
           integer(ilp) :: i, ica, iexc, ira, j, k, l, m
           real(sp) :: c, ca, f, g, r, ra, s, sfmax1, sfmax2, sfmin1, sfmin2
           ! Intrinsic Functions 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGEBAL', -info )
              return
           end if
           k = 1
           l = n
           if( n==0 )go to 210
           if( stdlib_lsame( job, 'N' ) ) then
              do i = 1, n
                 scale( i ) = one
              end do
              go to 210
           end if
           if( stdlib_lsame( job, 'S' ) )go to 120
           ! permutation to isolate eigenvalues if possible
           go to 50
           ! row and column exchange.
           20 continue
           scale( m ) = j
           if( j==m )go to 30
           call stdlib_cswap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_cswap( n-k+1, a( j, k ), lda, a( m, k ), lda )
           30 continue
           go to ( 40, 80 )iexc
           ! search for rows isolating an eigenvalue and push them down.
           40 continue
           if( l==1 )go to 210
           l = l - 1
           50 continue
           loop_70: do j = l, 1, -1
              loop_60: do i = 1, l
                 if( i==j )cycle loop_60
                 if( real( a( j, i ),KIND=sp)/=zero .or. aimag( a( j, i ) )/=zero )cycle &
                           loop_70
              end do loop_60
              m = l
              iexc = 1
              go to 20
           end do loop_70
           go to 90
           ! search for columns isolating an eigenvalue and push them left.
           80 continue
           k = k + 1
           90 continue
           loop_110: do j = k, l
              loop_100: do i = k, l
                 if( i==j )cycle loop_100
                 if( real( a( i, j ),KIND=sp)/=zero .or. aimag( a( i, j ) )/=zero )cycle &
                           loop_110
              end do loop_100
              m = k
              iexc = 2
              go to 20
           end do loop_110
           120 continue
           do i = k, l
              scale( i ) = one
           end do
           if( stdlib_lsame( job, 'P' ) )go to 210
           ! balance the submatrix in rows k to l.
           ! iterative loop for norm reduction
           sfmin1 = stdlib_slamch( 'S' ) / stdlib_slamch( 'P' )
           sfmax1 = one / sfmin1
           sfmin2 = sfmin1*sclfac
           sfmax2 = one / sfmin2
           140 continue
           noconv = .false.
           loop_200: do i = k, l
              c = stdlib_scnrm2( l-k+1, a( k, i ), 1 )
              r = stdlib_scnrm2( l-k+1, a( i , k ), lda )
              ica = stdlib_icamax( l, a( 1, i ), 1 )
              ca = abs( a( ica, i ) )
              ira = stdlib_icamax( n-k+1, a( i, k ), lda )
              ra = abs( a( i, ira+k-1 ) )
              ! guard against zero c or r due to underflow.
              if( c==zero .or. r==zero )cycle loop_200
              g = r / sclfac
              f = one
              s = c + r
              160 continue
              if( c>=g .or. max( f, c, ca )>=sfmax2 .or.min( r, g, ra )<=sfmin2 )go to 170
                 if( stdlib_sisnan( c+f+ca+r+g+ra ) ) then
                 ! exit if nan to avoid infinite loop
                 info = -3
                 call stdlib_xerbla( 'CGEBAL', -info )
                 return
              end if
              f = f*sclfac
              c = c*sclfac
              ca = ca*sclfac
              r = r / sclfac
              g = g / sclfac
              ra = ra / sclfac
              go to 160
              170 continue
              g = c / sclfac
              180 continue
              if( g<r .or. max( r, ra )>=sfmax2 .or.min( f, c, g, ca )<=sfmin2 )go to 190
              f = f / sclfac
              c = c / sclfac
              g = g / sclfac
              ca = ca / sclfac
              r = r*sclfac
              ra = ra*sclfac
              go to 180
              ! now balance.
              190 continue
              if( ( c+r )>=factor*s )cycle loop_200
              if( f<one .and. scale( i )<one ) then
                 if( f*scale( i )<=sfmin1 )cycle loop_200
              end if
              if( f>one .and. scale( i )>one ) then
                 if( scale( i )>=sfmax1 / f )cycle loop_200
              end if
              g = one / f
              scale( i ) = scale( i )*f
              noconv = .true.
              call stdlib_csscal( n-k+1, g, a( i, k ), lda )
              call stdlib_csscal( l, f, a( 1, i ), 1 )
           end do loop_200
           if( noconv )go to 140
           210 continue
           ilo = k
           ihi = l
           return
     end subroutine stdlib_cgebal

     pure subroutine stdlib_zgebal( job, n, a, lda, ilo, ihi, scale, info )
     !! ZGEBAL balances a general complex matrix A.  This involves, first,
     !! permuting A by a similarity transformation to isolate eigenvalues
     !! in the first 1 to ILO-1 and last IHI+1 to N elements on the
     !! diagonal; and second, applying a diagonal similarity transformation
     !! to rows and columns ILO to IHI to make the rows and columns as
     !! close in norm as possible.  Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrix, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(dp), intent(out) :: scale(*)
           complex(dp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sclfac = 2.0e+0_dp
           real(dp), parameter :: factor = 0.95e+0_dp
           
           
           
           ! Local Scalars 
           logical(lk) :: noconv
           integer(ilp) :: i, ica, iexc, ira, j, k, l, m
           real(dp) :: c, ca, f, g, r, ra, s, sfmax1, sfmax2, sfmin1, sfmin2
           ! Intrinsic Functions 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEBAL', -info )
              return
           end if
           k = 1
           l = n
           if( n==0 )go to 210
           if( stdlib_lsame( job, 'N' ) ) then
              do i = 1, n
                 scale( i ) = one
              end do
              go to 210
           end if
           if( stdlib_lsame( job, 'S' ) )go to 120
           ! permutation to isolate eigenvalues if possible
           go to 50
           ! row and column exchange.
           20 continue
           scale( m ) = j
           if( j==m )go to 30
           call stdlib_zswap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_zswap( n-k+1, a( j, k ), lda, a( m, k ), lda )
           30 continue
           go to ( 40, 80 )iexc
           ! search for rows isolating an eigenvalue and push them down.
           40 continue
           if( l==1 )go to 210
           l = l - 1
           50 continue
           loop_70: do j = l, 1, -1
              loop_60: do i = 1, l
                 if( i==j )cycle loop_60
                 if( real( a( j, i ),KIND=dp)/=zero .or. aimag( a( j, i ) )/=zero )cycle &
                           loop_70
              end do loop_60
              m = l
              iexc = 1
              go to 20
           end do loop_70
           go to 90
           ! search for columns isolating an eigenvalue and push them left.
           80 continue
           k = k + 1
           90 continue
           loop_110: do j = k, l
              loop_100: do i = k, l
                 if( i==j )cycle loop_100
                 if( real( a( i, j ),KIND=dp)/=zero .or. aimag( a( i, j ) )/=zero )cycle &
                           loop_110
              end do loop_100
              m = k
              iexc = 2
              go to 20
           end do loop_110
           120 continue
           do i = k, l
              scale( i ) = one
           end do
           if( stdlib_lsame( job, 'P' ) )go to 210
           ! balance the submatrix in rows k to l.
           ! iterative loop for norm reduction
           sfmin1 = stdlib_dlamch( 'S' ) / stdlib_dlamch( 'P' )
           sfmax1 = one / sfmin1
           sfmin2 = sfmin1*sclfac
           sfmax2 = one / sfmin2
           140 continue
           noconv = .false.
           loop_200: do i = k, l
              c = stdlib_dznrm2( l-k+1, a( k, i ), 1 )
              r = stdlib_dznrm2( l-k+1, a( i, k ), lda )
              ica = stdlib_izamax( l, a( 1, i ), 1 )
              ca = abs( a( ica, i ) )
              ira = stdlib_izamax( n-k+1, a( i, k ), lda )
              ra = abs( a( i, ira+k-1 ) )
              ! guard against zero c or r due to underflow.
              if( c==zero .or. r==zero )cycle loop_200
              g = r / sclfac
              f = one
              s = c + r
              160 continue
              if( c>=g .or. max( f, c, ca )>=sfmax2 .or.min( r, g, ra )<=sfmin2 )go to 170
                 if( stdlib_disnan( c+f+ca+r+g+ra ) ) then
                 ! exit if nan to avoid infinite loop
                 info = -3
                 call stdlib_xerbla( 'ZGEBAL', -info )
                 return
              end if
              f = f*sclfac
              c = c*sclfac
              ca = ca*sclfac
              r = r / sclfac
              g = g / sclfac
              ra = ra / sclfac
              go to 160
              170 continue
              g = c / sclfac
              180 continue
              if( g<r .or. max( r, ra )>=sfmax2 .or.min( f, c, g, ca )<=sfmin2 )go to 190
              f = f / sclfac
              c = c / sclfac
              g = g / sclfac
              ca = ca / sclfac
              r = r*sclfac
              ra = ra*sclfac
              go to 180
              ! now balance.
              190 continue
              if( ( c+r )>=factor*s )cycle loop_200
              if( f<one .and. scale( i )<one ) then
                 if( f*scale( i )<=sfmin1 )cycle loop_200
              end if
              if( f>one .and. scale( i )>one ) then
                 if( scale( i )>=sfmax1 / f )cycle loop_200
              end if
              g = one / f
              scale( i ) = scale( i )*f
              noconv = .true.
              call stdlib_zdscal( n-k+1, g, a( i, k ), lda )
              call stdlib_zdscal( l, f, a( 1, i ), 1 )
           end do loop_200
           if( noconv )go to 140
           210 continue
           ilo = k
           ihi = l
           return
     end subroutine stdlib_zgebal

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$gebal( job, n, a, lda, ilo, ihi, scale, info )
     !! ZGEBAL: balances a general complex matrix A.  This involves, first,
     !! permuting A by a similarity transformation to isolate eigenvalues
     !! in the first 1 to ILO-1 and last IHI+1 to N elements on the
     !! diagonal; and second, applying a diagonal similarity transformation
     !! to rows and columns ILO to IHI to make the rows and columns as
     !! close in norm as possible.  Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrix, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(${ck}$), intent(out) :: scale(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: sclfac = 2.0e+0_${ck}$
           real(${ck}$), parameter :: factor = 0.95e+0_${ck}$
           
           
           
           ! Local Scalars 
           logical(lk) :: noconv
           integer(ilp) :: i, ica, iexc, ira, j, k, l, m
           real(${ck}$) :: c, ca, f, g, r, ra, s, sfmax1, sfmax2, sfmin1, sfmin2
           ! Intrinsic Functions 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGEBAL', -info )
              return
           end if
           k = 1
           l = n
           if( n==0 )go to 210
           if( stdlib_lsame( job, 'N' ) ) then
              do i = 1, n
                 scale( i ) = one
              end do
              go to 210
           end if
           if( stdlib_lsame( job, 'S' ) )go to 120
           ! permutation to isolate eigenvalues if possible
           go to 50
           ! row and column exchange.
           20 continue
           scale( m ) = j
           if( j==m )go to 30
           call stdlib_${ci}$swap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_${ci}$swap( n-k+1, a( j, k ), lda, a( m, k ), lda )
           30 continue
           go to ( 40, 80 )iexc
           ! search for rows isolating an eigenvalue and push them down.
           40 continue
           if( l==1 )go to 210
           l = l - 1
           50 continue
           loop_70: do j = l, 1, -1
              loop_60: do i = 1, l
                 if( i==j )cycle loop_60
                 if( real( a( j, i ),KIND=${ck}$)/=zero .or. aimag( a( j, i ) )/=zero )cycle &
                           loop_70
              end do loop_60
              m = l
              iexc = 1
              go to 20
           end do loop_70
           go to 90
           ! search for columns isolating an eigenvalue and push them left.
           80 continue
           k = k + 1
           90 continue
           loop_110: do j = k, l
              loop_100: do i = k, l
                 if( i==j )cycle loop_100
                 if( real( a( i, j ),KIND=${ck}$)/=zero .or. aimag( a( i, j ) )/=zero )cycle &
                           loop_110
              end do loop_100
              m = k
              iexc = 2
              go to 20
           end do loop_110
           120 continue
           do i = k, l
              scale( i ) = one
           end do
           if( stdlib_lsame( job, 'P' ) )go to 210
           ! balance the submatrix in rows k to l.
           ! iterative loop for norm reduction
           sfmin1 = stdlib_${c2ri(ci)}$lamch( 'S' ) / stdlib_${c2ri(ci)}$lamch( 'P' )
           sfmax1 = one / sfmin1
           sfmin2 = sfmin1*sclfac
           sfmax2 = one / sfmin2
           140 continue
           noconv = .false.
           loop_200: do i = k, l
              c = stdlib_${c2ri(ci)}$znrm2( l-k+1, a( k, i ), 1 )
              r = stdlib_${c2ri(ci)}$znrm2( l-k+1, a( i, k ), lda )
              ica = stdlib_i${ci}$amax( l, a( 1, i ), 1 )
              ca = abs( a( ica, i ) )
              ira = stdlib_i${ci}$amax( n-k+1, a( i, k ), lda )
              ra = abs( a( i, ira+k-1 ) )
              ! guard against zero c or r due to underflow.
              if( c==zero .or. r==zero )cycle loop_200
              g = r / sclfac
              f = one
              s = c + r
              160 continue
              if( c>=g .or. max( f, c, ca )>=sfmax2 .or.min( r, g, ra )<=sfmin2 )go to 170
                 if( stdlib_${c2ri(ci)}$isnan( c+f+ca+r+g+ra ) ) then
                 ! exit if nan to avoid infinite loop
                 info = -3
                 call stdlib_xerbla( 'ZGEBAL', -info )
                 return
              end if
              f = f*sclfac
              c = c*sclfac
              ca = ca*sclfac
              r = r / sclfac
              g = g / sclfac
              ra = ra / sclfac
              go to 160
              170 continue
              g = c / sclfac
              180 continue
              if( g<r .or. max( r, ra )>=sfmax2 .or.min( f, c, g, ca )<=sfmin2 )go to 190
              f = f / sclfac
              c = c / sclfac
              g = g / sclfac
              ca = ca / sclfac
              r = r*sclfac
              ra = ra*sclfac
              go to 180
              ! now balance.
              190 continue
              if( ( c+r )>=factor*s )cycle loop_200
              if( f<one .and. scale( i )<one ) then
                 if( f*scale( i )<=sfmin1 )cycle loop_200
              end if
              if( f>one .and. scale( i )>one ) then
                 if( scale( i )>=sfmax1 / f )cycle loop_200
              end if
              g = one / f
              scale( i ) = scale( i )*f
              noconv = .true.
              call stdlib_${ci}$dscal( n-k+1, g, a( i, k ), lda )
              call stdlib_${ci}$dscal( l, f, a( 1, i ), 1 )
           end do loop_200
           if( noconv )go to 140
           210 continue
           ilo = k
           ihi = l
           return
     end subroutine stdlib_${ci}$gebal

#:endif
#:endfor



     pure subroutine stdlib_claqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, work, lwork, info )
     !! CLAQR0 computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**H, where T is an upper triangular matrix (the
     !! Schur form), and Z is the unitary matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input unitary
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
                
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: w(*), work(*)
        ! ================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: kexnw = 5
           integer(ilp), parameter :: kexsh = 6
           real(sp), parameter :: wilk1 = 0.75_sp
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_clahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== exceptional deflation windows:  try to cure rare
           ! .    slow convergence by varying the size of the
           ! .    deflation window after kexnw iterations. ====
           
           ! ==== exceptional shifts: try to cure rare slow convergence
           ! .    with ad-hoc exceptional shifts every kexsh iterations.
           ! .    ====
           
           ! ==== the constant wilk1 is used to form the exceptional
           ! .    shifts. ====
           
           
           
           ! Local Scalars 
           complex(sp) :: aa, bb, cc, cdum, dd, det, rtdisc, swap, tr2
           real(sp) :: s
           integer(ilp) :: i, inf, it, itmax, k, kacc22, kbot, kdu, ks, kt, ktop, ku, kv, kwh, &
           kwtop, kwv, ld, ls, lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns, nsmax, nsr, nve, nw,&
                      nwmax, nwr, nwupbd
           logical(lk) :: sorted
           character :: jbcmpz*2
           ! Local Arrays 
           complex(sp) :: zdum(1,1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! ==== quick return for n = 0: nothing to do. ====
           if( n==0 ) then
              work( 1 ) = cone
              return
           end if
           if( n<=ntiny ) then
              ! ==== tiny matrices must use stdlib_clahqr. ====
              lwkopt = 1
              if( lwork/=-1 )call stdlib_clahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, &
                        z, ldz, info )
           else
              ! ==== use small bulge multi-shift qr with aggressive early
              ! .    deflation on larger-than-tiny matrices. ====
              ! ==== hope for the best. ====
              info = 0
              ! ==== set up job flags for stdlib_ilaenv. ====
              if( wantt ) then
                 jbcmpz( 1: 1 ) = 'S'
              else
                 jbcmpz( 1: 1 ) = 'E'
              end if
              if( wantz ) then
                 jbcmpz( 2: 2 ) = 'V'
              else
                 jbcmpz( 2: 2 ) = 'N'
              end if
              ! ==== nwr = recommended deflation window size.  at this
              ! .    point,  n > ntiny = 15, so there is enough
              ! .    subdiagonal workspace for nwr>=2 as required.
              ! .    (in fact, there is enough subdiagonal space for
              ! .    nwr>=4.) ====
              nwr = stdlib_ilaenv( 13, 'CLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nwr = max( 2, nwr )
              nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
              ! ==== nsr = recommended number of simultaneous shifts.
              ! .    at this point n > ntiny = 15, so there is at
              ! .    enough subdiagonal workspace for nsr to be even
              ! .    and greater than or equal to two as required. ====
              nsr = stdlib_ilaenv( 15, 'CLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nsr = min( nsr, ( n-3 ) / 6, ihi-ilo )
              nsr = max( 2, nsr-mod( nsr, 2 ) )
              ! ==== estimate optimal workspace ====
              ! ==== workspace query call to stdlib_claqr3 ====
              call stdlib_claqr3( wantt, wantz, n, ilo, ihi, nwr+1, h, ldh, iloz,ihiz, z, ldz, ls,&
                         ld, w, h, ldh, n, h, ldh, n, h,ldh, work, -1 )
              ! ==== optimal workspace = max(stdlib_claqr5, stdlib_claqr3) ====
              lwkopt = max( 3*nsr / 2, int( work( 1 ),KIND=ilp) )
              ! ==== quick return in case of workspace query. ====
              if( lwork==-1 ) then
                 work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
                 return
              end if
              ! ==== stdlib_clahqr/stdlib_claqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'CLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nmin = max( ntiny, nmin )
              ! ==== nibble crossover point ====
              nibble = stdlib_ilaenv( 14, 'CLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nibble = max( 0, nibble )
              ! ==== accumulate reflections during ttswp?  use block
              ! .    2-by-2 structure during matrix-matrix multiply? ====
              kacc22 = stdlib_ilaenv( 16, 'CLAQR0', jbcmpz, n, ilo, ihi, lwork )
              kacc22 = max( 0, kacc22 )
              kacc22 = min( 2, kacc22 )
              ! ==== nwmax = the largest possible deflation window for
              ! .    which there is sufficient workspace. ====
              nwmax = min( ( n-1 ) / 3, lwork / 2 )
              nw = nwmax
              ! ==== nsmax = the largest number of simultaneous shifts
              ! .    for which there is sufficient workspace. ====
              nsmax = min( ( n-3 ) / 6, 2*lwork / 3 )
              nsmax = nsmax - mod( nsmax, 2 )
              ! ==== ndfl: an iteration count restarted at deflation. ====
              ndfl = 1
              ! ==== itmax = iteration limit ====
              itmax = max( 30, 2*kexsh )*max( 10, ( ihi-ilo+1 ) )
              ! ==== last row and column in the active block ====
              kbot = ihi
              ! ==== main loop ====
              loop_70: do it = 1, itmax
                 ! ==== done when kbot falls below ilo ====
                 if( kbot<ilo )go to 80
                 ! ==== locate active block ====
                 do k = kbot, ilo + 1, -1
                    if( h( k, k-1 )==czero )go to 20
                 end do
                 k = ilo
                 20 continue
                 ktop = k
                 ! ==== select deflation window size:
                 ! .    typical case:
                 ! .      if possible and advisable, nibble the entire
                 ! .      active block.  if not, use size min(nwr,nwmax)
                 ! .      or min(nwr+1,nwmax) depending upon which has
                 ! .      the smaller corresponding subdiagonal entry
                 ! .      (a heuristic).
                 ! .    exceptional case:
                 ! .      if there have been no deflations in kexnw or
                 ! .      more iterations, then vary the deflation window
                 ! .      size.   at first, because, larger windows are,
                 ! .      in general, more powerful than smaller ones,
                 ! .      rapidly increase the window to the maximum possible.
                 ! .      then, gradually reduce the window size. ====
                 nh = kbot - ktop + 1
                 nwupbd = min( nh, nwmax )
                 if( ndfl<kexnw ) then
                    nw = min( nwupbd, nwr )
                 else
                    nw = min( nwupbd, 2*nw )
                 end if
                 if( nw<nwmax ) then
                    if( nw>=nh-1 ) then
                       nw = nh
                    else
                       kwtop = kbot - nw + 1
                       if( cabs1( h( kwtop, kwtop-1 ) )>cabs1( h( kwtop-1, kwtop-2 ) ) )nw = nw + &
                                 1
                    end if
                 end if
                 if( ndfl<kexnw ) then
                    ndec = -1
                 else if( ndec>=0 .or. nw>=nwupbd ) then
                    ndec = ndec + 1
                    if( nw-ndec<2 )ndec = 0
                    nw = nw - ndec
                 end if
                 ! ==== aggressive early deflation:
                 ! .    split workspace under the subdiagonal into
                 ! .      - an nw-by-nw work array v in the lower
                 ! .        left-hand-corner,
                 ! .      - an nw-by-at-least-nw-but-more-is-better
                 ! .        (nw-by-nho) horizontal work array along
                 ! .        the bottom edge,
                 ! .      - an at-least-nw-but-more-is-better (nhv-by-nw)
                 ! .        vertical work array along the left-hand-edge.
                 ! .        ====
                 kv = n - nw + 1
                 kt = nw + 1
                 nho = ( n-nw-1 ) - kt + 1
                 kwv = nw + 2
                 nve = ( n-nw ) - kwv + 1
                 ! ==== aggressive early deflation ====
                 call stdlib_claqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
                 ls, ld, w, h( kv, 1 ), ldh, nho,h( kv, kt ), ldh, nve, h( kwv, 1 ), ldh, work,&
                           lwork )
                 ! ==== adjust kbot accounting for new deflations. ====
                 kbot = kbot - ld
                 ! ==== ks points to the shifts. ====
                 ks = kbot - ls + 1
                 ! ==== skip an expensive qr sweep if there is a (partly
                 ! .    heuristic) reason to expect that many eigenvalues
                 ! .    will deflate without it.  here, the qr sweep is
                 ! .    skipped if many eigenvalues have just been deflated
                 ! .    or if the remaining active block is small.
                 if( ( ld==0 ) .or. ( ( 100*ld<=nw*nibble ) .and. ( kbot-ktop+1>min( nmin, nwmax )&
                            ) ) ) then
                    ! ==== ns = nominal number of simultaneous shifts.
                    ! .    this may be lowered (slightly) if stdlib_claqr3
                    ! .    did not provide that many shifts. ====
                    ns = min( nsmax, nsr, max( 2, kbot-ktop ) )
                    ns = ns - mod( ns, 2 )
                    ! ==== if there have been no deflations
                    ! .    in a multiple of kexsh iterations,
                    ! .    then try exceptional shifts.
                    ! .    otherwise use shifts provided by
                    ! .    stdlib_claqr3 above or from the eigenvalues
                    ! .    of a trailing principal submatrix. ====
                    if( mod( ndfl, kexsh )==0 ) then
                       ks = kbot - ns + 1
                       do i = kbot, ks + 1, -2
                          w( i ) = h( i, i ) + wilk1*cabs1( h( i, i-1 ) )
                          w( i-1 ) = w( i )
                       end do
                    else
                       ! ==== got ns/2 or fewer shifts? use stdlib_claqr4 or
                       ! .    stdlib_clahqr on a trailing principal submatrix to
                       ! .    get more. (since ns<=nsmax<=(n-3)/6,
                       ! .    there is enough space below the subdiagonal
                       ! .    to fit an ns-by-ns scratch array.) ====
                       if( kbot-ks+1<=ns / 2 ) then
                          ks = kbot - ns + 1
                          kt = n - ns + 1
                          call stdlib_clacpy( 'A', ns, ns, h( ks, ks ), ldh,h( kt, 1 ), ldh )
                                    
                          if( ns>nmin ) then
                             call stdlib_claqr4( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, w( &
                                       ks ), 1, 1,zdum, 1, work, lwork, inf )
                          else
                             call stdlib_clahqr( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, w( &
                                       ks ), 1, 1,zdum, 1, inf )
                          end if
                          ks = ks + inf
                          ! ==== in case of a rare qr failure use
                          ! .    eigenvalues of the trailing 2-by-2
                          ! .    principal submatrix.  scale to avoid
                          ! .    overflows, underflows and subnormals.
                          ! .    (the scale factor s can not be czero,
                          ! .    because h(kbot,kbot-1) is nonzero.) ====
                          if( ks>=kbot ) then
                             s = cabs1( h( kbot-1, kbot-1 ) ) +cabs1( h( kbot, kbot-1 ) ) +cabs1( &
                                       h( kbot-1, kbot ) ) +cabs1( h( kbot, kbot ) )
                             aa = h( kbot-1, kbot-1 ) / s
                             cc = h( kbot, kbot-1 ) / s
                             bb = h( kbot-1, kbot ) / s
                             dd = h( kbot, kbot ) / s
                             tr2 = ( aa+dd ) / two
                             det = ( aa-tr2 )*( dd-tr2 ) - bb*cc
                             rtdisc = sqrt( -det )
                             w( kbot-1 ) = ( tr2+rtdisc )*s
                             w( kbot ) = ( tr2-rtdisc )*s
                             ks = kbot - 1
                          end if
                       end if
                       if( kbot-ks+1>ns ) then
                          ! ==== sort the shifts (helps a little) ====
                          sorted = .false.
                          do k = kbot, ks + 1, -1
                             if( sorted )go to 60
                             sorted = .true.
                             do i = ks, k - 1
                                if( cabs1( w( i ) )<cabs1( w( i+1 ) ) )then
                                   sorted = .false.
                                   swap = w( i )
                                   w( i ) = w( i+1 )
                                   w( i+1 ) = swap
                                end if
                             end do
                          end do
                          60 continue
                       end if
                    end if
                    ! ==== if there are only two shifts, then use
                    ! .    only cone.  ====
                    if( kbot-ks+1==2 ) then
                       if( cabs1( w( kbot )-h( kbot, kbot ) )<cabs1( w( kbot-1 )-h( kbot, kbot ) )&
                                  ) then
                          w( kbot-1 ) = w( kbot )
                       else
                          w( kbot ) = w( kbot-1 )
                       end if
                    end if
                    ! ==== use up to ns of the the smallest magnitude
                    ! .    shifts.  if there aren't ns shifts available,
                    ! .    then use them all, possibly dropping cone to
                    ! .    make the number of shifts even. ====
                    ns = min( ns, kbot-ks+1 )
                    ns = ns - mod( ns, 2 )
                    ks = kbot - ns + 1
                    ! ==== small-bulge multi-shift qr sweep:
                    ! .    split workspace under the subdiagonal into
                    ! .    - a kdu-by-kdu work array u in the lower
                    ! .      left-hand-corner,
                    ! .    - a kdu-by-at-least-kdu-but-more-is-better
                    ! .      (kdu-by-nho) horizontal work array wh along
                    ! .      the bottom edge,
                    ! .    - and an at-least-kdu-but-more-is-better-by-kdu
                    ! .      (nve-by-kdu) vertical work wv arrow along
                    ! .      the left-hand-edge. ====
                    kdu = 2*ns
                    ku = n - kdu + 1
                    kwh = kdu + 1
                    nho = ( n-kdu+1-4 ) - ( kdu+1 ) + 1
                    kwv = kdu + 4
                    nve = n - kdu - kwv + 1
                    ! ==== small-bulge multi-shift qr sweep ====
                    call stdlib_claqr5( wantt, wantz, kacc22, n, ktop, kbot, ns,w( ks ), h, ldh, &
                    iloz, ihiz, z, ldz, work,3, h( ku, 1 ), ldh, nve, h( kwv, 1 ), ldh,nho, h( ku,&
                               kwh ), ldh )
                 end if
                 ! ==== note progress (or the lack of it). ====
                 if( ld>0 ) then
                    ndfl = 1
                 else
                    ndfl = ndfl + 1
                 end if
                 ! ==== end of main loop ====
              end do loop_70
              ! ==== iteration limit exceeded.  set info to show where
              ! .    the problem occurred and exit. ====
              info = kbot
              80 continue
           end if
           ! ==== return the optimal value of lwork. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
     end subroutine stdlib_claqr0

     pure subroutine stdlib_zlaqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, work,lwork, info )
     !! ZLAQR0 computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**H, where T is an upper triangular matrix (the
     !! Schur form), and Z is the unitary matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input unitary
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
                
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(dp), intent(out) :: w(*), work(*)
        ! ================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: kexnw = 5
           integer(ilp), parameter :: kexsh = 6
           real(dp), parameter :: wilk1 = 0.75_dp
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_zlahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== exceptional deflation windows:  try to cure rare
           ! .    slow convergence by varying the size of the
           ! .    deflation window after kexnw iterations. ====
           
           ! ==== exceptional shifts: try to cure rare slow convergence
           ! .    with ad-hoc exceptional shifts every kexsh iterations.
           ! .    ====
           
           ! ==== the constant wilk1 is used to form the exceptional
           ! .    shifts. ====
           
           
           
           ! Local Scalars 
           complex(dp) :: aa, bb, cc, cdum, dd, det, rtdisc, swap, tr2
           real(dp) :: s
           integer(ilp) :: i, inf, it, itmax, k, kacc22, kbot, kdu, ks, kt, ktop, ku, kv, kwh, &
           kwtop, kwv, ld, ls, lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns, nsmax, nsr, nve, nw,&
                      nwmax, nwr, nwupbd
           logical(lk) :: sorted
           character :: jbcmpz*2
           ! Local Arrays 
           complex(dp) :: zdum(1,1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! ==== quick return for n = 0: nothing to do. ====
           if( n==0 ) then
              work( 1 ) = cone
              return
           end if
           if( n<=ntiny ) then
              ! ==== tiny matrices must use stdlib_zlahqr. ====
              lwkopt = 1
              if( lwork/=-1 )call stdlib_zlahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, &
                        z, ldz, info )
           else
              ! ==== use small bulge multi-shift qr with aggressive early
              ! .    deflation on larger-than-tiny matrices. ====
              ! ==== hope for the best. ====
              info = 0
              ! ==== set up job flags for stdlib_ilaenv. ====
              if( wantt ) then
                 jbcmpz( 1: 1 ) = 'S'
              else
                 jbcmpz( 1: 1 ) = 'E'
              end if
              if( wantz ) then
                 jbcmpz( 2: 2 ) = 'V'
              else
                 jbcmpz( 2: 2 ) = 'N'
              end if
              ! ==== nwr = recommended deflation window size.  at this
              ! .    point,  n > ntiny = 15, so there is enough
              ! .    subdiagonal workspace for nwr>=2 as required.
              ! .    (in fact, there is enough subdiagonal space for
              ! .    nwr>=4.) ====
              nwr = stdlib_ilaenv( 13, 'ZLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nwr = max( 2, nwr )
              nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
              ! ==== nsr = recommended number of simultaneous shifts.
              ! .    at this point n > ntiny = 15, so there is at
              ! .    enough subdiagonal workspace for nsr to be even
              ! .    and greater than or equal to two as required. ====
              nsr = stdlib_ilaenv( 15, 'ZLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nsr = min( nsr, ( n-3 ) / 6, ihi-ilo )
              nsr = max( 2, nsr-mod( nsr, 2 ) )
              ! ==== estimate optimal workspace ====
              ! ==== workspace query call to stdlib_zlaqr3 ====
              call stdlib_zlaqr3( wantt, wantz, n, ilo, ihi, nwr+1, h, ldh, iloz,ihiz, z, ldz, ls,&
                         ld, w, h, ldh, n, h, ldh, n, h,ldh, work, -1 )
              ! ==== optimal workspace = max(stdlib_zlaqr5, stdlib_zlaqr3) ====
              lwkopt = max( 3*nsr / 2, int( work( 1 ),KIND=ilp) )
              ! ==== quick return in case of workspace query. ====
              if( lwork==-1 ) then
                 work( 1 ) = cmplx( lwkopt, 0,KIND=dp)
                 return
              end if
              ! ==== stdlib_zlahqr/stdlib_zlaqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'ZLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nmin = max( ntiny, nmin )
              ! ==== nibble crossover point ====
              nibble = stdlib_ilaenv( 14, 'ZLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nibble = max( 0, nibble )
              ! ==== accumulate reflections during ttswp?  use block
              ! .    2-by-2 structure during matrix-matrix multiply? ====
              kacc22 = stdlib_ilaenv( 16, 'ZLAQR0', jbcmpz, n, ilo, ihi, lwork )
              kacc22 = max( 0, kacc22 )
              kacc22 = min( 2, kacc22 )
              ! ==== nwmax = the largest possible deflation window for
              ! .    which there is sufficient workspace. ====
              nwmax = min( ( n-1 ) / 3, lwork / 2 )
              nw = nwmax
              ! ==== nsmax = the largest number of simultaneous shifts
              ! .    for which there is sufficient workspace. ====
              nsmax = min( ( n-3 ) / 6, 2*lwork / 3 )
              nsmax = nsmax - mod( nsmax, 2 )
              ! ==== ndfl: an iteration count restarted at deflation. ====
              ndfl = 1
              ! ==== itmax = iteration limit ====
              itmax = max( 30, 2*kexsh )*max( 10, ( ihi-ilo+1 ) )
              ! ==== last row and column in the active block ====
              kbot = ihi
              ! ==== main loop ====
              loop_70: do it = 1, itmax
                 ! ==== done when kbot falls below ilo ====
                 if( kbot<ilo )go to 80
                 ! ==== locate active block ====
                 do k = kbot, ilo + 1, -1
                    if( h( k, k-1 )==czero )go to 20
                 end do
                 k = ilo
                 20 continue
                 ktop = k
                 ! ==== select deflation window size:
                 ! .    typical case:
                 ! .      if possible and advisable, nibble the entire
                 ! .      active block.  if not, use size min(nwr,nwmax)
                 ! .      or min(nwr+1,nwmax) depending upon which has
                 ! .      the smaller corresponding subdiagonal entry
                 ! .      (a heuristic).
                 ! .    exceptional case:
                 ! .      if there have been no deflations in kexnw or
                 ! .      more iterations, then vary the deflation window
                 ! .      size.   at first, because, larger windows are,
                 ! .      in general, more powerful than smaller ones,
                 ! .      rapidly increase the window to the maximum possible.
                 ! .      then, gradually reduce the window size. ====
                 nh = kbot - ktop + 1
                 nwupbd = min( nh, nwmax )
                 if( ndfl<kexnw ) then
                    nw = min( nwupbd, nwr )
                 else
                    nw = min( nwupbd, 2*nw )
                 end if
                 if( nw<nwmax ) then
                    if( nw>=nh-1 ) then
                       nw = nh
                    else
                       kwtop = kbot - nw + 1
                       if( cabs1( h( kwtop, kwtop-1 ) )>cabs1( h( kwtop-1, kwtop-2 ) ) )nw = nw + &
                                 1
                    end if
                 end if
                 if( ndfl<kexnw ) then
                    ndec = -1
                 else if( ndec>=0 .or. nw>=nwupbd ) then
                    ndec = ndec + 1
                    if( nw-ndec<2 )ndec = 0
                    nw = nw - ndec
                 end if
                 ! ==== aggressive early deflation:
                 ! .    split workspace under the subdiagonal into
                 ! .      - an nw-by-nw work array v in the lower
                 ! .        left-hand-corner,
                 ! .      - an nw-by-at-least-nw-but-more-is-better
                 ! .        (nw-by-nho) horizontal work array along
                 ! .        the bottom edge,
                 ! .      - an at-least-nw-but-more-is-better (nhv-by-nw)
                 ! .        vertical work array along the left-hand-edge.
                 ! .        ====
                 kv = n - nw + 1
                 kt = nw + 1
                 nho = ( n-nw-1 ) - kt + 1
                 kwv = nw + 2
                 nve = ( n-nw ) - kwv + 1
                 ! ==== aggressive early deflation ====
                 call stdlib_zlaqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
                 ls, ld, w, h( kv, 1 ), ldh, nho,h( kv, kt ), ldh, nve, h( kwv, 1 ), ldh, work,&
                           lwork )
                 ! ==== adjust kbot accounting for new deflations. ====
                 kbot = kbot - ld
                 ! ==== ks points to the shifts. ====
                 ks = kbot - ls + 1
                 ! ==== skip an expensive qr sweep if there is a (partly
                 ! .    heuristic) reason to expect that many eigenvalues
                 ! .    will deflate without it.  here, the qr sweep is
                 ! .    skipped if many eigenvalues have just been deflated
                 ! .    or if the remaining active block is small.
                 if( ( ld==0 ) .or. ( ( 100*ld<=nw*nibble ) .and. ( kbot-ktop+1>min( nmin, nwmax )&
                            ) ) ) then
                    ! ==== ns = nominal number of simultaneous shifts.
                    ! .    this may be lowered (slightly) if stdlib_zlaqr3
                    ! .    did not provide that many shifts. ====
                    ns = min( nsmax, nsr, max( 2, kbot-ktop ) )
                    ns = ns - mod( ns, 2 )
                    ! ==== if there have been no deflations
                    ! .    in a multiple of kexsh iterations,
                    ! .    then try exceptional shifts.
                    ! .    otherwise use shifts provided by
                    ! .    stdlib_zlaqr3 above or from the eigenvalues
                    ! .    of a trailing principal submatrix. ====
                    if( mod( ndfl, kexsh )==0 ) then
                       ks = kbot - ns + 1
                       do i = kbot, ks + 1, -2
                          w( i ) = h( i, i ) + wilk1*cabs1( h( i, i-1 ) )
                          w( i-1 ) = w( i )
                       end do
                    else
                       ! ==== got ns/2 or fewer shifts? use stdlib_zlaqr4 or
                       ! .    stdlib_zlahqr on a trailing principal submatrix to
                       ! .    get more. (since ns<=nsmax<=(n-3)/6,
                       ! .    there is enough space below the subdiagonal
                       ! .    to fit an ns-by-ns scratch array.) ====
                       if( kbot-ks+1<=ns / 2 ) then
                          ks = kbot - ns + 1
                          kt = n - ns + 1
                          call stdlib_zlacpy( 'A', ns, ns, h( ks, ks ), ldh,h( kt, 1 ), ldh )
                                    
                          if( ns>nmin ) then
                             call stdlib_zlaqr4( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, w( &
                                       ks ), 1, 1,zdum, 1, work, lwork, inf )
                          else
                             call stdlib_zlahqr( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, w( &
                                       ks ), 1, 1,zdum, 1, inf )
                          end if
                          ks = ks + inf
                          ! ==== in case of a rare qr failure use
                          ! .    eigenvalues of the trailing 2-by-2
                          ! .    principal submatrix.  scale to avoid
                          ! .    overflows, underflows and subnormals.
                          ! .    (the scale factor s can not be czero,
                          ! .    because h(kbot,kbot-1) is nonzero.) ====
                          if( ks>=kbot ) then
                             s = cabs1( h( kbot-1, kbot-1 ) ) +cabs1( h( kbot, kbot-1 ) ) +cabs1( &
                                       h( kbot-1, kbot ) ) +cabs1( h( kbot, kbot ) )
                             aa = h( kbot-1, kbot-1 ) / s
                             cc = h( kbot, kbot-1 ) / s
                             bb = h( kbot-1, kbot ) / s
                             dd = h( kbot, kbot ) / s
                             tr2 = ( aa+dd ) / two
                             det = ( aa-tr2 )*( dd-tr2 ) - bb*cc
                             rtdisc = sqrt( -det )
                             w( kbot-1 ) = ( tr2+rtdisc )*s
                             w( kbot ) = ( tr2-rtdisc )*s
                             ks = kbot - 1
                          end if
                       end if
                       if( kbot-ks+1>ns ) then
                          ! ==== sort the shifts (helps a little) ====
                          sorted = .false.
                          do k = kbot, ks + 1, -1
                             if( sorted )go to 60
                             sorted = .true.
                             do i = ks, k - 1
                                if( cabs1( w( i ) )<cabs1( w( i+1 ) ) )then
                                   sorted = .false.
                                   swap = w( i )
                                   w( i ) = w( i+1 )
                                   w( i+1 ) = swap
                                end if
                             end do
                          end do
                          60 continue
                       end if
                    end if
                    ! ==== if there are only two shifts, then use
                    ! .    only cone.  ====
                    if( kbot-ks+1==2 ) then
                       if( cabs1( w( kbot )-h( kbot, kbot ) )<cabs1( w( kbot-1 )-h( kbot, kbot ) )&
                                  ) then
                          w( kbot-1 ) = w( kbot )
                       else
                          w( kbot ) = w( kbot-1 )
                       end if
                    end if
                    ! ==== use up to ns of the the smallest magnitude
                    ! .    shifts.  if there aren't ns shifts available,
                    ! .    then use them all, possibly dropping cone to
                    ! .    make the number of shifts even. ====
                    ns = min( ns, kbot-ks+1 )
                    ns = ns - mod( ns, 2 )
                    ks = kbot - ns + 1
                    ! ==== small-bulge multi-shift qr sweep:
                    ! .    split workspace under the subdiagonal into
                    ! .    - a kdu-by-kdu work array u in the lower
                    ! .      left-hand-corner,
                    ! .    - a kdu-by-at-least-kdu-but-more-is-better
                    ! .      (kdu-by-nho) horizontal work array wh along
                    ! .      the bottom edge,
                    ! .    - and an at-least-kdu-but-more-is-better-by-kdu
                    ! .      (nve-by-kdu) vertical work wv arrow along
                    ! .      the left-hand-edge. ====
                    kdu = 2*ns
                    ku = n - kdu + 1
                    kwh = kdu + 1
                    nho = ( n-kdu+1-4 ) - ( kdu+1 ) + 1
                    kwv = kdu + 4
                    nve = n - kdu - kwv + 1
                    ! ==== small-bulge multi-shift qr sweep ====
                    call stdlib_zlaqr5( wantt, wantz, kacc22, n, ktop, kbot, ns,w( ks ), h, ldh, &
                    iloz, ihiz, z, ldz, work,3, h( ku, 1 ), ldh, nve, h( kwv, 1 ), ldh,nho, h( ku,&
                               kwh ), ldh )
                 end if
                 ! ==== note progress (or the lack of it). ====
                 if( ld>0 ) then
                    ndfl = 1
                 else
                    ndfl = ndfl + 1
                 end if
                 ! ==== end of main loop ====
              end do loop_70
              ! ==== iteration limit exceeded.  set info to show where
              ! .    the problem occurred and exit. ====
              info = kbot
              80 continue
           end if
           ! ==== return the optimal value of lwork. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=dp)
     end subroutine stdlib_zlaqr0

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$laqr0( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, z, ldz, work, lwork, info )
     !! ZLAQR0: computes the eigenvalues of a Hessenberg matrix H
     !! and, optionally, the matrices T and Z from the Schur decomposition
     !! H = Z T Z**H, where T is an upper triangular matrix (the
     !! Schur form), and Z is the unitary matrix of Schur vectors.
     !! Optionally Z may be postmultiplied into an input unitary
     !! matrix Q so that this routine can give the Schur factorization
     !! of a matrix A which has been reduced to the Hessenberg form H
     !! by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
                
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ihiz, ilo, iloz, ldh, ldz, lwork, n
           integer(ilp), intent(out) :: info
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(${ck}$), intent(out) :: w(*), work(*)
        ! ================================================================
           ! Parameters 
           integer(ilp), parameter :: ntiny = 15
           integer(ilp), parameter :: kexnw = 5
           integer(ilp), parameter :: kexsh = 6
           real(${ck}$), parameter :: wilk1 = 0.75_${ck}$
           ! ==== matrices of order ntiny or smaller must be processed by
           ! .    stdlib_${ci}$lahqr because of insufficient subdiagonal scratch space.
           ! .    (this is a hard limit.) ====
           
           ! ==== exceptional deflation windows:  try to cure rare
           ! .    slow convergence by varying the size of the
           ! .    deflation window after kexnw iterations. ====
           
           ! ==== exceptional shifts: try to cure rare slow convergence
           ! .    with ad-hoc exceptional shifts every kexsh iterations.
           ! .    ====
           
           ! ==== the constant wilk1 is used to form the exceptional
           ! .    shifts. ====
           
           
           
           ! Local Scalars 
           complex(${ck}$) :: aa, bb, cc, cdum, dd, det, rtdisc, swap, tr2
           real(${ck}$) :: s
           integer(ilp) :: i, inf, it, itmax, k, kacc22, kbot, kdu, ks, kt, ktop, ku, kv, kwh, &
           kwtop, kwv, ld, ls, lwkopt, ndec, ndfl, nh, nho, nibble, nmin, ns, nsmax, nsr, nve, nw,&
                      nwmax, nwr, nwupbd
           logical(lk) :: sorted
           character :: jbcmpz*2
           ! Local Arrays 
           complex(${ck}$) :: zdum(1,1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           info = 0
           ! ==== quick return for n = 0: nothing to do. ====
           if( n==0 ) then
              work( 1 ) = cone
              return
           end if
           if( n<=ntiny ) then
              ! ==== tiny matrices must use stdlib_${ci}$lahqr. ====
              lwkopt = 1
              if( lwork/=-1 )call stdlib_${ci}$lahqr( wantt, wantz, n, ilo, ihi, h, ldh, w, iloz,ihiz, &
                        z, ldz, info )
           else
              ! ==== use small bulge multi-shift qr with aggressive early
              ! .    deflation on larger-than-tiny matrices. ====
              ! ==== hope for the best. ====
              info = 0
              ! ==== set up job flags for stdlib_ilaenv. ====
              if( wantt ) then
                 jbcmpz( 1: 1 ) = 'S'
              else
                 jbcmpz( 1: 1 ) = 'E'
              end if
              if( wantz ) then
                 jbcmpz( 2: 2 ) = 'V'
              else
                 jbcmpz( 2: 2 ) = 'N'
              end if
              ! ==== nwr = recommended deflation window size.  at this
              ! .    point,  n > ntiny = 15, so there is enough
              ! .    subdiagonal workspace for nwr>=2 as required.
              ! .    (in fact, there is enough subdiagonal space for
              ! .    nwr>=4.) ====
              nwr = stdlib_ilaenv( 13, 'ZLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nwr = max( 2, nwr )
              nwr = min( ihi-ilo+1, ( n-1 ) / 3, nwr )
              ! ==== nsr = recommended number of simultaneous shifts.
              ! .    at this point n > ntiny = 15, so there is at
              ! .    enough subdiagonal workspace for nsr to be even
              ! .    and greater than or equal to two as required. ====
              nsr = stdlib_ilaenv( 15, 'ZLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nsr = min( nsr, ( n-3 ) / 6, ihi-ilo )
              nsr = max( 2, nsr-mod( nsr, 2 ) )
              ! ==== estimate optimal workspace ====
              ! ==== workspace query call to stdlib_${ci}$laqr3 ====
              call stdlib_${ci}$laqr3( wantt, wantz, n, ilo, ihi, nwr+1, h, ldh, iloz,ihiz, z, ldz, ls,&
                         ld, w, h, ldh, n, h, ldh, n, h,ldh, work, -1 )
              ! ==== optimal workspace = max(stdlib_${ci}$laqr5, stdlib_${ci}$laqr3) ====
              lwkopt = max( 3*nsr / 2, int( work( 1 ),KIND=ilp) )
              ! ==== quick return in case of workspace query. ====
              if( lwork==-1 ) then
                 work( 1 ) = cmplx( lwkopt, 0,KIND=${ck}$)
                 return
              end if
              ! ==== stdlib_${ci}$lahqr/stdlib_${ci}$laqr0 crossover point ====
              nmin = stdlib_ilaenv( 12, 'ZLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nmin = max( ntiny, nmin )
              ! ==== nibble crossover point ====
              nibble = stdlib_ilaenv( 14, 'ZLAQR0', jbcmpz, n, ilo, ihi, lwork )
              nibble = max( 0, nibble )
              ! ==== accumulate reflections during ttswp?  use block
              ! .    2-by-2 structure during matrix-matrix multiply? ====
              kacc22 = stdlib_ilaenv( 16, 'ZLAQR0', jbcmpz, n, ilo, ihi, lwork )
              kacc22 = max( 0, kacc22 )
              kacc22 = min( 2, kacc22 )
              ! ==== nwmax = the largest possible deflation window for
              ! .    which there is sufficient workspace. ====
              nwmax = min( ( n-1 ) / 3, lwork / 2 )
              nw = nwmax
              ! ==== nsmax = the largest number of simultaneous shifts
              ! .    for which there is sufficient workspace. ====
              nsmax = min( ( n-3 ) / 6, 2*lwork / 3 )
              nsmax = nsmax - mod( nsmax, 2 )
              ! ==== ndfl: an iteration count restarted at deflation. ====
              ndfl = 1
              ! ==== itmax = iteration limit ====
              itmax = max( 30, 2*kexsh )*max( 10, ( ihi-ilo+1 ) )
              ! ==== last row and column in the active block ====
              kbot = ihi
              ! ==== main loop ====
              loop_70: do it = 1, itmax
                 ! ==== done when kbot falls below ilo ====
                 if( kbot<ilo )go to 80
                 ! ==== locate active block ====
                 do k = kbot, ilo + 1, -1
                    if( h( k, k-1 )==czero )go to 20
                 end do
                 k = ilo
                 20 continue
                 ktop = k
                 ! ==== select deflation window size:
                 ! .    typical case:
                 ! .      if possible and advisable, nibble the entire
                 ! .      active block.  if not, use size min(nwr,nwmax)
                 ! .      or min(nwr+1,nwmax) depending upon which has
                 ! .      the smaller corresponding subdiagonal entry
                 ! .      (a heuristic).
                 ! .    exceptional case:
                 ! .      if there have been no deflations in kexnw or
                 ! .      more iterations, then vary the deflation window
                 ! .      size.   at first, because, larger windows are,
                 ! .      in general, more powerful than smaller ones,
                 ! .      rapidly increase the window to the maximum possible.
                 ! .      then, gradually reduce the window size. ====
                 nh = kbot - ktop + 1
                 nwupbd = min( nh, nwmax )
                 if( ndfl<kexnw ) then
                    nw = min( nwupbd, nwr )
                 else
                    nw = min( nwupbd, 2*nw )
                 end if
                 if( nw<nwmax ) then
                    if( nw>=nh-1 ) then
                       nw = nh
                    else
                       kwtop = kbot - nw + 1
                       if( cabs1( h( kwtop, kwtop-1 ) )>cabs1( h( kwtop-1, kwtop-2 ) ) )nw = nw + &
                                 1
                    end if
                 end if
                 if( ndfl<kexnw ) then
                    ndec = -1
                 else if( ndec>=0 .or. nw>=nwupbd ) then
                    ndec = ndec + 1
                    if( nw-ndec<2 )ndec = 0
                    nw = nw - ndec
                 end if
                 ! ==== aggressive early deflation:
                 ! .    split workspace under the subdiagonal into
                 ! .      - an nw-by-nw work array v in the lower
                 ! .        left-hand-corner,
                 ! .      - an nw-by-at-least-nw-but-more-is-better
                 ! .        (nw-by-nho) horizontal work array along
                 ! .        the bottom edge,
                 ! .      - an at-least-nw-but-more-is-better (nhv-by-nw)
                 ! .        vertical work array along the left-hand-edge.
                 ! .        ====
                 kv = n - nw + 1
                 kt = nw + 1
                 nho = ( n-nw-1 ) - kt + 1
                 kwv = nw + 2
                 nve = ( n-nw ) - kwv + 1
                 ! ==== aggressive early deflation ====
                 call stdlib_${ci}$laqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
                 ls, ld, w, h( kv, 1 ), ldh, nho,h( kv, kt ), ldh, nve, h( kwv, 1 ), ldh, work,&
                           lwork )
                 ! ==== adjust kbot accounting for new deflations. ====
                 kbot = kbot - ld
                 ! ==== ks points to the shifts. ====
                 ks = kbot - ls + 1
                 ! ==== skip an expensive qr sweep if there is a (partly
                 ! .    heuristic) reason to expect that many eigenvalues
                 ! .    will deflate without it.  here, the qr sweep is
                 ! .    skipped if many eigenvalues have just been deflated
                 ! .    or if the remaining active block is small.
                 if( ( ld==0 ) .or. ( ( 100*ld<=nw*nibble ) .and. ( kbot-ktop+1>min( nmin, nwmax )&
                            ) ) ) then
                    ! ==== ns = nominal number of simultaneous shifts.
                    ! .    this may be lowered (slightly) if stdlib_${ci}$laqr3
                    ! .    did not provide that many shifts. ====
                    ns = min( nsmax, nsr, max( 2, kbot-ktop ) )
                    ns = ns - mod( ns, 2 )
                    ! ==== if there have been no deflations
                    ! .    in a multiple of kexsh iterations,
                    ! .    then try exceptional shifts.
                    ! .    otherwise use shifts provided by
                    ! .    stdlib_${ci}$laqr3 above or from the eigenvalues
                    ! .    of a trailing principal submatrix. ====
                    if( mod( ndfl, kexsh )==0 ) then
                       ks = kbot - ns + 1
                       do i = kbot, ks + 1, -2
                          w( i ) = h( i, i ) + wilk1*cabs1( h( i, i-1 ) )
                          w( i-1 ) = w( i )
                       end do
                    else
                       ! ==== got ns/2 or fewer shifts? use stdlib_${ci}$laqr4 or
                       ! .    stdlib_${ci}$lahqr on a trailing principal submatrix to
                       ! .    get more. (since ns<=nsmax<=(n-3)/6,
                       ! .    there is enough space below the subdiagonal
                       ! .    to fit an ns-by-ns scratch array.) ====
                       if( kbot-ks+1<=ns / 2 ) then
                          ks = kbot - ns + 1
                          kt = n - ns + 1
                          call stdlib_${ci}$lacpy( 'A', ns, ns, h( ks, ks ), ldh,h( kt, 1 ), ldh )
                                    
                          if( ns>nmin ) then
                             call stdlib_${ci}$laqr4( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, w( &
                                       ks ), 1, 1,zdum, 1, work, lwork, inf )
                          else
                             call stdlib_${ci}$lahqr( .false., .false., ns, 1, ns,h( kt, 1 ), ldh, w( &
                                       ks ), 1, 1,zdum, 1, inf )
                          end if
                          ks = ks + inf
                          ! ==== in case of a rare qr failure use
                          ! .    eigenvalues of the trailing 2-by-2
                          ! .    principal submatrix.  scale to avoid
                          ! .    overflows, underflows and subnormals.
                          ! .    (the scale factor s can not be czero,
                          ! .    because h(kbot,kbot-1) is nonzero.) ====
                          if( ks>=kbot ) then
                             s = cabs1( h( kbot-1, kbot-1 ) ) +cabs1( h( kbot, kbot-1 ) ) +cabs1( &
                                       h( kbot-1, kbot ) ) +cabs1( h( kbot, kbot ) )
                             aa = h( kbot-1, kbot-1 ) / s
                             cc = h( kbot, kbot-1 ) / s
                             bb = h( kbot-1, kbot ) / s
                             dd = h( kbot, kbot ) / s
                             tr2 = ( aa+dd ) / two
                             det = ( aa-tr2 )*( dd-tr2 ) - bb*cc
                             rtdisc = sqrt( -det )
                             w( kbot-1 ) = ( tr2+rtdisc )*s
                             w( kbot ) = ( tr2-rtdisc )*s
                             ks = kbot - 1
                          end if
                       end if
                       if( kbot-ks+1>ns ) then
                          ! ==== sort the shifts (helps a little) ====
                          sorted = .false.
                          do k = kbot, ks + 1, -1
                             if( sorted )go to 60
                             sorted = .true.
                             do i = ks, k - 1
                                if( cabs1( w( i ) )<cabs1( w( i+1 ) ) )then
                                   sorted = .false.
                                   swap = w( i )
                                   w( i ) = w( i+1 )
                                   w( i+1 ) = swap
                                end if
                             end do
                          end do
                          60 continue
                       end if
                    end if
                    ! ==== if there are only two shifts, then use
                    ! .    only cone.  ====
                    if( kbot-ks+1==2 ) then
                       if( cabs1( w( kbot )-h( kbot, kbot ) )<cabs1( w( kbot-1 )-h( kbot, kbot ) )&
                                  ) then
                          w( kbot-1 ) = w( kbot )
                       else
                          w( kbot ) = w( kbot-1 )
                       end if
                    end if
                    ! ==== use up to ns of the the smallest magnitude
                    ! .    shifts.  if there aren't ns shifts available,
                    ! .    then use them all, possibly dropping cone to
                    ! .    make the number of shifts even. ====
                    ns = min( ns, kbot-ks+1 )
                    ns = ns - mod( ns, 2 )
                    ks = kbot - ns + 1
                    ! ==== small-bulge multi-shift qr sweep:
                    ! .    split workspace under the subdiagonal into
                    ! .    - a kdu-by-kdu work array u in the lower
                    ! .      left-hand-corner,
                    ! .    - a kdu-by-at-least-kdu-but-more-is-better
                    ! .      (kdu-by-nho) horizontal work array wh along
                    ! .      the bottom edge,
                    ! .    - and an at-least-kdu-but-more-is-better-by-kdu
                    ! .      (nve-by-kdu) vertical work wv arrow along
                    ! .      the left-hand-edge. ====
                    kdu = 2*ns
                    ku = n - kdu + 1
                    kwh = kdu + 1
                    nho = ( n-kdu+1-4 ) - ( kdu+1 ) + 1
                    kwv = kdu + 4
                    nve = n - kdu - kwv + 1
                    ! ==== small-bulge multi-shift qr sweep ====
                    call stdlib_${ci}$laqr5( wantt, wantz, kacc22, n, ktop, kbot, ns,w( ks ), h, ldh, &
                    iloz, ihiz, z, ldz, work,3, h( ku, 1 ), ldh, nve, h( kwv, 1 ), ldh,nho, h( ku,&
                               kwh ), ldh )
                 end if
                 ! ==== note progress (or the lack of it). ====
                 if( ld>0 ) then
                    ndfl = 1
                 else
                    ndfl = ndfl + 1
                 end if
                 ! ==== end of main loop ====
              end do loop_70
              ! ==== iteration limit exceeded.  set info to show where
              ! .    the problem occurred and exit. ====
              info = kbot
              80 continue
           end if
           ! ==== return the optimal value of lwork. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=${ck}$)
     end subroutine stdlib_${ci}$laqr0

#:endif
#:endfor







     pure subroutine stdlib_slaqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts,sr, si, h, ldh, &
     !! SLAQR5 , called by SLAQR0, performs a
     !! single small-bulge multi-shift QR sweep.
               iloz, ihiz, z, ldz, v, ldv, u,ldu, nv, wv, ldwv, nh, wh, ldwh )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv, ldwh, ldwv, &
                     ldz, n, nh, nshfts, nv
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(sp), intent(inout) :: h(ldh,*), si(*), sr(*), z(ldz,*)
           real(sp), intent(out) :: u(ldu,*), v(ldv,*), wh(ldwh,*), wv(ldwv,*)
        ! ================================================================
           
           ! Local Scalars 
           real(sp) :: alpha, beta, h11, h12, h21, h22, refsum, safmax, safmin, scl, smlnum, swap,&
                      tst1, tst2, ulp
           integer(ilp) :: i, i2, i4, incol, j, jbot, jcol, jlen, jrow, jtop, k, k1, kdu, kms, &
                     krcol, m, m22, mbot, mtop, nbmps, ndcol, ns, nu
           logical(lk) :: accum, bmp22
           ! Intrinsic Functions 
           ! Local Arrays 
           real(sp) :: vt(3)
           ! Executable Statements 
           ! ==== if there are no shifts, then there is nothing to do. ====
           if( nshfts<2 )return
           ! ==== if the active block is empty or 1-by-1, then there
           ! .    is nothing to do. ====
           if( ktop>=kbot )return
           ! ==== shuffle shifts into pairs of real shifts and pairs
           ! .    of complex conjugate shifts assuming complex
           ! .    conjugate shifts are already adjacent to one
           ! .    another. ====
           do i = 1, nshfts - 2, 2
              if( si( i )/=-si( i+1 ) ) then
                 swap = sr( i )
                 sr( i ) = sr( i+1 )
                 sr( i+1 ) = sr( i+2 )
                 sr( i+2 ) = swap
                 swap = si( i )
                 si( i ) = si( i+1 )
                 si( i+1 ) = si( i+2 )
                 si( i+2 ) = swap
              end if
           end do
           ! ==== nshfts is supposed to be even, but if it is odd,
           ! .    then simply reduce it by one.  the shuffle above
           ! .    ensures that the dropped shift is real and that
           ! .    the remaining shifts are paired. ====
           ns = nshfts - mod( nshfts, 2 )
           ! ==== machine constants for deflation ====
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = one / safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=sp) / ulp )
           ! ==== use accumulated reflections to update far-from-diagonal
           ! .    entries ? ====
           accum = ( kacc22==1 ) .or. ( kacc22==2 )
           ! ==== clear trash ====
           if( ktop+2<=kbot )h( ktop+2, ktop ) = zero
           ! ==== nbmps = number of 2-shift bulges in the chain ====
           nbmps = ns / 2
           ! ==== kdu = width of slab ====
           kdu = 4*nbmps
           ! ==== create and chase chains of nbmps bulges ====
           loop_180: do incol = ktop - 2*nbmps + 1, kbot - 2, 2*nbmps
              ! jtop = index from which updates from the right start.
              if( accum ) then
                 jtop = max( ktop, incol )
              else if( wantt ) then
                 jtop = 1
              else
                 jtop = ktop
              end if
              ndcol = incol + kdu
              if( accum )call stdlib_slaset( 'ALL', kdu, kdu, zero, one, u, ldu )
              ! ==== near-the-diagonal bulge chase.  the following loop
              ! .    performs the near-the-diagonal part of a small bulge
              ! .    multi-shift qr sweep.  each 4*nbmps column diagonal
              ! .    chunk extends from column incol to column ndcol
              ! .    (including both column incol and column ndcol). the
              ! .    following loop chases a 2*nbmps+1 column long chain of
              ! .    nbmps bulges 2*nbmps-1 columns to the right.  (incol
              ! .    may be less than ktop and and ndcol may be greater than
              ! .    kbot indicating phantom columns from which to chase
              ! .    bulges before they are actually introduced or to which
              ! .    to chase bulges beyond column kbot.)  ====
              loop_145: do krcol = incol, min( incol+2*nbmps-1, kbot-2 )
                 ! ==== bulges number mtop to mbot are active double implicit
                 ! .    shift bulges.  there may or may not also be small
                 ! .    2-by-2 bulge, if there is room.  the inactive bulges
                 ! .    (if any) must wait until the active bulges have moved
                 ! .    down the diagonal to make room.  the phantom matrix
                 ! .    paradigm described above helps keep track.  ====
                 mtop = max( 1, ( ktop-krcol ) / 2+1 )
                 mbot = min( nbmps, ( kbot-krcol-1 ) / 2 )
                 m22 = mbot + 1
                 bmp22 = ( mbot<nbmps ) .and. ( krcol+2*( m22-1 ) )==( kbot-2 )
                 ! ==== generate reflections to chase the chain right
                 ! .    one column.  (the minimum value of k is ktop-1.) ====
                 if ( bmp22 ) then
                    ! ==== special case: 2-by-2 reflection at bottom treated
                    ! .    separately ====
                    k = krcol + 2*( m22-1 )
                    if( k==ktop-1 ) then
                       call stdlib_slaqr1( 2, h( k+1, k+1 ), ldh, sr( 2*m22-1 ),si( 2*m22-1 ), sr(&
                                  2*m22 ), si( 2*m22 ),v( 1, m22 ) )
                       beta = v( 1, m22 )
                       call stdlib_slarfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                    else
                       beta = h( k+1, k )
                       v( 2, m22 ) = h( k+2, k )
                       call stdlib_slarfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                       h( k+1, k ) = beta
                       h( k+2, k ) = zero
                    end if
                    ! ==== perform update from right within
                    ! .    computational window. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m22 )*( h( j, k+1 )+v( 2, m22 )*h( j, k+2 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) - refsum*v( 2, m22 )
                    end do
                    ! ==== perform update from left within
                    ! .    computational window. ====
                    if( accum ) then
                       jbot = min( ndcol, kbot )
                    else if( wantt ) then
                       jbot = n
                    else
                       jbot = kbot
                    end if
                    do j = k+1, jbot
                       refsum = v( 1, m22 )*( h( k+1, j )+v( 2, m22 )*h( k+2, j ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m22 )
                    end do
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is zero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k>=ktop ) then
                       if( h( k+1, k )/=zero ) then
                          tst1 = abs( h( k, k ) ) + abs( h( k+1, k+1 ) )
                          if( tst1==zero ) then
                             if( k>=ktop+1 )tst1 = tst1 + abs( h( k, k-1 ) )
                             if( k>=ktop+2 )tst1 = tst1 + abs( h( k, k-2 ) )
                             if( k>=ktop+3 )tst1 = tst1 + abs( h( k, k-3 ) )
                             if( k<=kbot-2 )tst1 = tst1 + abs( h( k+2, k+1 ) )
                             if( k<=kbot-3 )tst1 = tst1 + abs( h( k+3, k+1 ) )
                             if( k<=kbot-4 )tst1 = tst1 + abs( h( k+4, k+1 ) )
                          end if
                          if( abs( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) )then
                             h12 = max( abs( h( k+1, k ) ),abs( h( k, k+1 ) ) )
                             h21 = min( abs( h( k+1, k ) ),abs( h( k, k+1 ) ) )
                             h11 = max( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             h22 = min( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             scl = h11 + h12
                             tst2 = h22*( h11 / scl )
                             if( tst2==zero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) ) &
                                       then
                                h( k+1, k ) = zero
                             end if
                          end if
                       end if
                    end if
                    ! ==== accumulate orthogonal transformations. ====
                    if( accum ) then
                       kms = k - incol
                       do j = max( 1, ktop-incol ), kdu
                          refsum = v( 1, m22 )*( u( j, kms+1 )+v( 2, m22 )*u( j, kms+2 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) - refsum*v( 2, m22 )
                       end do
                    else if( wantz ) then
                       do j = iloz, ihiz
                          refsum = v( 1, m22 )*( z( j, k+1 )+v( 2, m22 )*z( j, k+2 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) - refsum*v( 2, m22 )
                       end do
                    end if
                 end if
                 ! ==== normal case: chain of 3-by-3 reflections ====
                 loop_80: do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    if( k==ktop-1 ) then
                       call stdlib_slaqr1( 3, h( ktop, ktop ), ldh, sr( 2*m-1 ),si( 2*m-1 ), sr( &
                                 2*m ), si( 2*m ),v( 1, m ) )
                       alpha = v( 1, m )
                       call stdlib_slarfg( 3, alpha, v( 2, m ), 1, v( 1, m ) )
                    else
                       ! ==== perform delayed transformation of row below
                       ! .    mth bulge. exploit fact that first two elements
                       ! .    of row are actually zero. ====
                       refsum = v( 1, m )*v( 3, m )*h( k+3, k+2 )
                       h( k+3, k   ) = -refsum
                       h( k+3, k+1 ) = -refsum*v( 2, m )
                       h( k+3, k+2 ) = h( k+3, k+2 ) - refsum*v( 3, m )
                       ! ==== calculate reflection to move
                       ! .    mth bulge one step. ====
                       beta      = h( k+1, k )
                       v( 2, m ) = h( k+2, k )
                       v( 3, m ) = h( k+3, k )
                       call stdlib_slarfg( 3, beta, v( 2, m ), 1, v( 1, m ) )
                       ! ==== a bulge may collapse because of vigilant
                       ! .    deflation or destructive underflow.  in the
                       ! .    underflow case, try the two-small-subdiagonals
                       ! .    trick to try to reinflate the bulge.  ====
                       if( h( k+3, k )/=zero .or. h( k+3, k+1 )/=zero .or. h( k+3, k+2 )==zero ) &
                                 then
                          ! ==== typical case: not collapsed (yet). ====
                          h( k+1, k ) = beta
                          h( k+2, k ) = zero
                          h( k+3, k ) = zero
                       else
                          ! ==== atypical case: collapsed.  attempt to
                          ! .    reintroduce ignoring h(k+1,k) and h(k+2,k).
                          ! .    if the fill resulting from the new
                          ! .    reflector is too large, then abandon it.
                          ! .    otherwise, use the new one. ====
                          call stdlib_slaqr1( 3, h( k+1, k+1 ), ldh, sr( 2*m-1 ),si( 2*m-1 ), sr( &
                                    2*m ), si( 2*m ),vt )
                          alpha = vt( 1 )
                          call stdlib_slarfg( 3, alpha, vt( 2 ), 1, vt( 1 ) )
                          refsum = vt( 1 )*( h( k+1, k )+vt( 2 )*h( k+2, k ) )
                          if( abs( h( k+2, k )-refsum*vt( 2 ) )+abs( refsum*vt( 3 ) )>ulp*( abs( &
                                    h( k, k ) )+abs( h( k+1,k+1 ) )+abs( h( k+2, k+2 ) ) ) ) then
                             ! ==== starting a new bulge here would
                             ! .    create non-negligible fill.  use
                             ! .    the old one with trepidation. ====
                             h( k+1, k ) = beta
                             h( k+2, k ) = zero
                             h( k+3, k ) = zero
                          else
                             ! ==== starting a new bulge here would
                             ! .    create only negligible fill.
                             ! .    replace the old reflector with
                             ! .    the new one. ====
                             h( k+1, k ) = h( k+1, k ) - refsum
                             h( k+2, k ) = zero
                             h( k+3, k ) = zero
                             v( 1, m ) = vt( 1 )
                             v( 2, m ) = vt( 2 )
                             v( 3, m ) = vt( 3 )
                          end if
                       end if
                    end if
                    ! ====  apply reflection from the right and
                    ! .     the first column of update from the left.
                    ! .     these updates are required for the vigilant
                    ! .     deflation check. we still delay most of the
                    ! .     updates from the left for efficiency. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m )*( h( j, k+1 )+v( 2, m )*h( j, k+2 )+v( 3, m )*h( j, k+3 &
                                 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) - refsum*v( 2, m )
                       h( j, k+3 ) = h( j, k+3 ) - refsum*v( 3, m )
                    end do
                    ! ==== perform update from left for subsequent
                    ! .    column. ====
                    refsum = v( 1, m )*( h( k+1, k+1 )+v( 2, m )*h( k+2, k+1 )+v( 3, m )*h( k+3, &
                              k+1 ) )
                    h( k+1, k+1 ) = h( k+1, k+1 ) - refsum
                    h( k+2, k+1 ) = h( k+2, k+1 ) - refsum*v( 2, m )
                    h( k+3, k+1 ) = h( k+3, k+1 ) - refsum*v( 3, m )
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is zero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k<ktop)cycle
                    if( h( k+1, k )/=zero ) then
                       tst1 = abs( h( k, k ) ) + abs( h( k+1, k+1 ) )
                       if( tst1==zero ) then
                          if( k>=ktop+1 )tst1 = tst1 + abs( h( k, k-1 ) )
                          if( k>=ktop+2 )tst1 = tst1 + abs( h( k, k-2 ) )
                          if( k>=ktop+3 )tst1 = tst1 + abs( h( k, k-3 ) )
                          if( k<=kbot-2 )tst1 = tst1 + abs( h( k+2, k+1 ) )
                          if( k<=kbot-3 )tst1 = tst1 + abs( h( k+3, k+1 ) )
                          if( k<=kbot-4 )tst1 = tst1 + abs( h( k+4, k+1 ) )
                       end if
                       if( abs( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) )then
                          h12 = max( abs( h( k+1, k ) ), abs( h( k, k+1 ) ) )
                          h21 = min( abs( h( k+1, k ) ), abs( h( k, k+1 ) ) )
                          h11 = max( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                          h22 = min( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                          scl = h11 + h12
                          tst2 = h22*( h11 / scl )
                          if( tst2==zero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) ) &
                                    then
                             h( k+1, k ) = zero
                          end if
                       end if
                    end if
                 end do loop_80
                 ! ==== multiply h by reflections from the left ====
                 if( accum ) then
                    jbot = min( ndcol, kbot )
                 else if( wantt ) then
                    jbot = n
                 else
                    jbot = kbot
                 end if
                 do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    do j = max( ktop, krcol + 2*m ), jbot
                       refsum = v( 1, m )*( h( k+1, j )+v( 2, m )*h( k+2, j )+v( 3, m )*h( k+3, j &
                                 ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m )
                       h( k+3, j ) = h( k+3, j ) - refsum*v( 3, m )
                    end do
                 end do
                 ! ==== accumulate orthogonal transformations. ====
                 if( accum ) then
                    ! ==== accumulate u. (if needed, update z later
                    ! .    with an efficient matrix-matrix
                    ! .    multiply.) ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       kms = k - incol
                       i2 = max( 1, ktop-incol )
                       i2 = max( i2, kms-(krcol-incol)+1 )
                       i4 = min( kdu, krcol + 2*( mbot-1 ) - incol + 5 )
                       do j = i2, i4
                          refsum = v( 1, m )*( u( j, kms+1 )+v( 2, m )*u( j, kms+2 )+v( 3, m )*u( &
                                    j, kms+3 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) - refsum*v( 2, m )
                          u( j, kms+3 ) = u( j, kms+3 ) - refsum*v( 3, m )
                       end do
                    end do
                 else if( wantz ) then
                    ! ==== u is not accumulated, so update z
                    ! .    now by multiplying by reflections
                    ! .    from the right. ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       do j = iloz, ihiz
                          refsum = v( 1, m )*( z( j, k+1 )+v( 2, m )*z( j, k+2 )+v( 3, m )*z( j, &
                                    k+3 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) - refsum*v( 2, m )
                          z( j, k+3 ) = z( j, k+3 ) - refsum*v( 3, m )
                       end do
                    end do
                 end if
                 ! ==== end of near-the-diagonal bulge chase. ====
              end do loop_145
              ! ==== use u (if accumulated) to update far-from-diagonal
              ! .    entries in h.  if required, use u to update z as
              ! .    well. ====
              if( accum ) then
                 if( wantt ) then
                    jtop = 1
                    jbot = n
                 else
                    jtop = ktop
                    jbot = kbot
                 end if
                 k1 = max( 1, ktop-incol )
                 nu = ( kdu-max( 0, ndcol-kbot ) ) - k1 + 1
                 ! ==== horizontal multiply ====
                 do jcol = min( ndcol, kbot ) + 1, jbot, nh
                    jlen = min( nh, jbot-jcol+1 )
                    call stdlib_sgemm( 'C', 'N', nu, jlen, nu, one, u( k1, k1 ),ldu, h( incol+k1, &
                              jcol ), ldh, zero, wh,ldwh )
                    call stdlib_slacpy( 'ALL', nu, jlen, wh, ldwh,h( incol+k1, jcol ), ldh )
                              
                 end do
                 ! ==== vertical multiply ====
                 do jrow = jtop, max( ktop, incol ) - 1, nv
                    jlen = min( nv, max( ktop, incol )-jrow )
                    call stdlib_sgemm( 'N', 'N', jlen, nu, nu, one,h( jrow, incol+k1 ), ldh, u( &
                              k1, k1 ),ldu, zero, wv, ldwv )
                    call stdlib_slacpy( 'ALL', jlen, nu, wv, ldwv,h( jrow, incol+k1 ), ldh )
                              
                 end do
                 ! ==== z multiply (also vertical) ====
                 if( wantz ) then
                    do jrow = iloz, ihiz, nv
                       jlen = min( nv, ihiz-jrow+1 )
                       call stdlib_sgemm( 'N', 'N', jlen, nu, nu, one,z( jrow, incol+k1 ), ldz, u(&
                                  k1, k1 ),ldu, zero, wv, ldwv )
                       call stdlib_slacpy( 'ALL', jlen, nu, wv, ldwv,z( jrow, incol+k1 ), ldz )
                                 
                    end do
                 end if
              end if
           end do loop_180
     end subroutine stdlib_slaqr5

     pure subroutine stdlib_dlaqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts,sr, si, h, ldh, &
     !! DLAQR5 , called by DLAQR0, performs a
     !! single small-bulge multi-shift QR sweep.
               iloz, ihiz, z, ldz, v, ldv, u,ldu, nv, wv, ldwv, nh, wh, ldwh )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv, ldwh, ldwv, &
                     ldz, n, nh, nshfts, nv
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(dp), intent(inout) :: h(ldh,*), si(*), sr(*), z(ldz,*)
           real(dp), intent(out) :: u(ldu,*), v(ldv,*), wh(ldwh,*), wv(ldwv,*)
        ! ================================================================
           
           ! Local Scalars 
           real(dp) :: alpha, beta, h11, h12, h21, h22, refsum, safmax, safmin, scl, smlnum, swap,&
                      tst1, tst2, ulp
           integer(ilp) :: i, i2, i4, incol, j, jbot, jcol, jlen, jrow, jtop, k, k1, kdu, kms, &
                     krcol, m, m22, mbot, mtop, nbmps, ndcol, ns, nu
           logical(lk) :: accum, bmp22
           ! Intrinsic Functions 
           ! Local Arrays 
           real(dp) :: vt(3)
           ! Executable Statements 
           ! ==== if there are no shifts, then there is nothing to do. ====
           if( nshfts<2 )return
           ! ==== if the active block is empty or 1-by-1, then there
           ! .    is nothing to do. ====
           if( ktop>=kbot )return
           ! ==== shuffle shifts into pairs of real shifts and pairs
           ! .    of complex conjugate shifts assuming complex
           ! .    conjugate shifts are already adjacent to one
           ! .    another. ====
           do i = 1, nshfts - 2, 2
              if( si( i )/=-si( i+1 ) ) then
                 swap = sr( i )
                 sr( i ) = sr( i+1 )
                 sr( i+1 ) = sr( i+2 )
                 sr( i+2 ) = swap
                 swap = si( i )
                 si( i ) = si( i+1 )
                 si( i+1 ) = si( i+2 )
                 si( i+2 ) = swap
              end if
           end do
           ! ==== nshfts is supposed to be even, but if it is odd,
           ! .    then simply reduce it by one.  the shuffle above
           ! .    ensures that the dropped shift is real and that
           ! .    the remaining shifts are paired. ====
           ns = nshfts - mod( nshfts, 2 )
           ! ==== machine constants for deflation ====
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safmax = one / safmin
           call stdlib_dlabad( safmin, safmax )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=dp) / ulp )
           ! ==== use accumulated reflections to update far-from-diagonal
           ! .    entries ? ====
           accum = ( kacc22==1 ) .or. ( kacc22==2 )
           ! ==== clear trash ====
           if( ktop+2<=kbot )h( ktop+2, ktop ) = zero
           ! ==== nbmps = number of 2-shift bulges in the chain ====
           nbmps = ns / 2
           ! ==== kdu = width of slab ====
           kdu = 4*nbmps
           ! ==== create and chase chains of nbmps bulges ====
           loop_180: do incol = ktop - 2*nbmps + 1, kbot - 2, 2*nbmps
              ! jtop = index from which updates from the right start.
              if( accum ) then
                 jtop = max( ktop, incol )
              else if( wantt ) then
                 jtop = 1
              else
                 jtop = ktop
              end if
              ndcol = incol + kdu
              if( accum )call stdlib_dlaset( 'ALL', kdu, kdu, zero, one, u, ldu )
              ! ==== near-the-diagonal bulge chase.  the following loop
              ! .    performs the near-the-diagonal part of a small bulge
              ! .    multi-shift qr sweep.  each 4*nbmps column diagonal
              ! .    chunk extends from column incol to column ndcol
              ! .    (including both column incol and column ndcol). the
              ! .    following loop chases a 2*nbmps+1 column long chain of
              ! .    nbmps bulges 2*nbmps columns to the right.  (incol
              ! .    may be less than ktop and and ndcol may be greater than
              ! .    kbot indicating phantom columns from which to chase
              ! .    bulges before they are actually introduced or to which
              ! .    to chase bulges beyond column kbot.)  ====
              loop_145: do krcol = incol, min( incol+2*nbmps-1, kbot-2 )
                 ! ==== bulges number mtop to mbot are active double implicit
                 ! .    shift bulges.  there may or may not also be small
                 ! .    2-by-2 bulge, if there is room.  the inactive bulges
                 ! .    (if any) must wait until the active bulges have moved
                 ! .    down the diagonal to make room.  the phantom matrix
                 ! .    paradigm described above helps keep track.  ====
                 mtop = max( 1, ( ktop-krcol ) / 2+1 )
                 mbot = min( nbmps, ( kbot-krcol-1 ) / 2 )
                 m22 = mbot + 1
                 bmp22 = ( mbot<nbmps ) .and. ( krcol+2*( m22-1 ) )==( kbot-2 )
                 ! ==== generate reflections to chase the chain right
                 ! .    one column.  (the minimum value of k is ktop-1.) ====
                 if ( bmp22 ) then
                    ! ==== special case: 2-by-2 reflection at bottom treated
                    ! .    separately ====
                    k = krcol + 2*( m22-1 )
                    if( k==ktop-1 ) then
                       call stdlib_dlaqr1( 2, h( k+1, k+1 ), ldh, sr( 2*m22-1 ),si( 2*m22-1 ), sr(&
                                  2*m22 ), si( 2*m22 ),v( 1, m22 ) )
                       beta = v( 1, m22 )
                       call stdlib_dlarfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                    else
                       beta = h( k+1, k )
                       v( 2, m22 ) = h( k+2, k )
                       call stdlib_dlarfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                       h( k+1, k ) = beta
                       h( k+2, k ) = zero
                    end if
                    ! ==== perform update from right within
                    ! .    computational window. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m22 )*( h( j, k+1 )+v( 2, m22 )*h( j, k+2 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) - refsum*v( 2, m22 )
                    end do
                    ! ==== perform update from left within
                    ! .    computational window. ====
                    if( accum ) then
                       jbot = min( ndcol, kbot )
                    else if( wantt ) then
                       jbot = n
                    else
                       jbot = kbot
                    end if
                    do j = k+1, jbot
                       refsum = v( 1, m22 )*( h( k+1, j )+v( 2, m22 )*h( k+2, j ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m22 )
                    end do
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is zero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k>=ktop ) then
                       if( h( k+1, k )/=zero ) then
                          tst1 = abs( h( k, k ) ) + abs( h( k+1, k+1 ) )
                          if( tst1==zero ) then
                             if( k>=ktop+1 )tst1 = tst1 + abs( h( k, k-1 ) )
                             if( k>=ktop+2 )tst1 = tst1 + abs( h( k, k-2 ) )
                             if( k>=ktop+3 )tst1 = tst1 + abs( h( k, k-3 ) )
                             if( k<=kbot-2 )tst1 = tst1 + abs( h( k+2, k+1 ) )
                             if( k<=kbot-3 )tst1 = tst1 + abs( h( k+3, k+1 ) )
                             if( k<=kbot-4 )tst1 = tst1 + abs( h( k+4, k+1 ) )
                          end if
                          if( abs( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) ) then
                             h12 = max( abs( h( k+1, k ) ),abs( h( k, k+1 ) ) )
                             h21 = min( abs( h( k+1, k ) ),abs( h( k, k+1 ) ) )
                             h11 = max( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             h22 = min( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             scl = h11 + h12
                             tst2 = h22*( h11 / scl )
                             if( tst2==zero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) ) &
                                       then
                                h( k+1, k ) = zero
                             end if
                          end if
                       end if
                    end if
                    ! ==== accumulate orthogonal transformations. ====
                    if( accum ) then
                       kms = k - incol
                       do j = max( 1, ktop-incol ), kdu
                          refsum = v( 1, m22 )*( u( j, kms+1 )+v( 2, m22 )*u( j, kms+2 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) - refsum*v( 2, m22 )
                       end do
                    else if( wantz ) then
                       do j = iloz, ihiz
                          refsum = v( 1, m22 )*( z( j, k+1 )+v( 2, m22 )*z( j, k+2 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) - refsum*v( 2, m22 )
                       end do
                    end if
                 end if
                 ! ==== normal case: chain of 3-by-3 reflections ====
                 loop_80: do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    if( k==ktop-1 ) then
                       call stdlib_dlaqr1( 3, h( ktop, ktop ), ldh, sr( 2*m-1 ),si( 2*m-1 ), sr( &
                                 2*m ), si( 2*m ),v( 1, m ) )
                       alpha = v( 1, m )
                       call stdlib_dlarfg( 3, alpha, v( 2, m ), 1, v( 1, m ) )
                    else
                       ! ==== perform delayed transformation of row below
                       ! .    mth bulge. exploit fact that first two elements
                       ! .    of row are actually zero. ====
                       refsum = v( 1, m )*v( 3, m )*h( k+3, k+2 )
                       h( k+3, k   ) = -refsum
                       h( k+3, k+1 ) = -refsum*v( 2, m )
                       h( k+3, k+2 ) = h( k+3, k+2 ) - refsum*v( 3, m )
                       ! ==== calculate reflection to move
                       ! .    mth bulge one step. ====
                       beta      = h( k+1, k )
                       v( 2, m ) = h( k+2, k )
                       v( 3, m ) = h( k+3, k )
                       call stdlib_dlarfg( 3, beta, v( 2, m ), 1, v( 1, m ) )
                       ! ==== a bulge may collapse because of vigilant
                       ! .    deflation or destructive underflow.  in the
                       ! .    underflow case, try the two-small-subdiagonals
                       ! .    trick to try to reinflate the bulge.  ====
                       if( h( k+3, k )/=zero .or. h( k+3, k+1 )/=zero .or. h( k+3, k+2 )==zero ) &
                                 then
                          ! ==== typical case: not collapsed (yet). ====
                          h( k+1, k ) = beta
                          h( k+2, k ) = zero
                          h( k+3, k ) = zero
                       else
                          ! ==== atypical case: collapsed.  attempt to
                          ! .    reintroduce ignoring h(k+1,k) and h(k+2,k).
                          ! .    if the fill resulting from the new
                          ! .    reflector is too large, then abandon it.
                          ! .    otherwise, use the new one. ====
                          call stdlib_dlaqr1( 3, h( k+1, k+1 ), ldh, sr( 2*m-1 ),si( 2*m-1 ), sr( &
                                    2*m ), si( 2*m ),vt )
                          alpha = vt( 1 )
                          call stdlib_dlarfg( 3, alpha, vt( 2 ), 1, vt( 1 ) )
                          refsum = vt( 1 )*( h( k+1, k )+vt( 2 )*h( k+2, k ) )
                          if( abs( h( k+2, k )-refsum*vt( 2 ) )+abs( refsum*vt( 3 ) )>ulp*( abs( &
                                    h( k, k ) )+abs( h( k+1,k+1 ) )+abs( h( k+2, k+2 ) ) ) ) then
                             ! ==== starting a new bulge here would
                             ! .    create non-negligible fill.  use
                             ! .    the old one with trepidation. ====
                             h( k+1, k ) = beta
                             h( k+2, k ) = zero
                             h( k+3, k ) = zero
                          else
                             ! ==== starting a new bulge here would
                             ! .    create only negligible fill.
                             ! .    replace the old reflector with
                             ! .    the new one. ====
                             h( k+1, k ) = h( k+1, k ) - refsum
                             h( k+2, k ) = zero
                             h( k+3, k ) = zero
                             v( 1, m ) = vt( 1 )
                             v( 2, m ) = vt( 2 )
                             v( 3, m ) = vt( 3 )
                          end if
                       end if
                    end if
                    ! ====  apply reflection from the right and
                    ! .     the first column of update from the left.
                    ! .     these updates are required for the vigilant
                    ! .     deflation check. we still delay most of the
                    ! .     updates from the left for efficiency. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m )*( h( j, k+1 )+v( 2, m )*h( j, k+2 )+v( 3, m )*h( j, k+3 &
                                 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) - refsum*v( 2, m )
                       h( j, k+3 ) = h( j, k+3 ) - refsum*v( 3, m )
                    end do
                    ! ==== perform update from left for subsequent
                    ! .    column. ====
                    refsum = v( 1, m )*( h( k+1, k+1 )+v( 2, m )*h( k+2, k+1 )+v( 3, m )*h( k+3, &
                              k+1 ) )
                    h( k+1, k+1 ) = h( k+1, k+1 ) - refsum
                    h( k+2, k+1 ) = h( k+2, k+1 ) - refsum*v( 2, m )
                    h( k+3, k+1 ) = h( k+3, k+1 ) - refsum*v( 3, m )
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is zero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k<ktop)cycle
                    if( h( k+1, k )/=zero ) then
                       tst1 = abs( h( k, k ) ) + abs( h( k+1, k+1 ) )
                       if( tst1==zero ) then
                          if( k>=ktop+1 )tst1 = tst1 + abs( h( k, k-1 ) )
                          if( k>=ktop+2 )tst1 = tst1 + abs( h( k, k-2 ) )
                          if( k>=ktop+3 )tst1 = tst1 + abs( h( k, k-3 ) )
                          if( k<=kbot-2 )tst1 = tst1 + abs( h( k+2, k+1 ) )
                          if( k<=kbot-3 )tst1 = tst1 + abs( h( k+3, k+1 ) )
                          if( k<=kbot-4 )tst1 = tst1 + abs( h( k+4, k+1 ) )
                       end if
                       if( abs( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) )then
                          h12 = max( abs( h( k+1, k ) ), abs( h( k, k+1 ) ) )
                          h21 = min( abs( h( k+1, k ) ), abs( h( k, k+1 ) ) )
                          h11 = max( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                          h22 = min( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                          scl = h11 + h12
                          tst2 = h22*( h11 / scl )
                          if( tst2==zero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) ) &
                                    then
                             h( k+1, k ) = zero
                          end if
                       end if
                    end if
                 end do loop_80
                 ! ==== multiply h by reflections from the left ====
                 if( accum ) then
                    jbot = min( ndcol, kbot )
                 else if( wantt ) then
                    jbot = n
                 else
                    jbot = kbot
                 end if
                 do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    do j = max( ktop, krcol + 2*m ), jbot
                       refsum = v( 1, m )*( h( k+1, j )+v( 2, m )*h( k+2, j )+v( 3, m )*h( k+3, j &
                                 ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m )
                       h( k+3, j ) = h( k+3, j ) - refsum*v( 3, m )
                    end do
                 end do
                 ! ==== accumulate orthogonal transformations. ====
                 if( accum ) then
                    ! ==== accumulate u. (if needed, update z later
                    ! .    with an efficient matrix-matrix
                    ! .    multiply.) ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       kms = k - incol
                       i2 = max( 1, ktop-incol )
                       i2 = max( i2, kms-(krcol-incol)+1 )
                       i4 = min( kdu, krcol + 2*( mbot-1 ) - incol + 5 )
                       do j = i2, i4
                          refsum = v( 1, m )*( u( j, kms+1 )+v( 2, m )*u( j, kms+2 )+v( 3, m )*u( &
                                    j, kms+3 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) - refsum*v( 2, m )
                          u( j, kms+3 ) = u( j, kms+3 ) - refsum*v( 3, m )
                       end do
                    end do
                 else if( wantz ) then
                    ! ==== u is not accumulated, so update z
                    ! .    now by multiplying by reflections
                    ! .    from the right. ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       do j = iloz, ihiz
                          refsum = v( 1, m )*( z( j, k+1 )+v( 2, m )*z( j, k+2 )+v( 3, m )*z( j, &
                                    k+3 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) - refsum*v( 2, m )
                          z( j, k+3 ) = z( j, k+3 ) - refsum*v( 3, m )
                       end do
                    end do
                 end if
                 ! ==== end of near-the-diagonal bulge chase. ====
              end do loop_145
              ! ==== use u (if accumulated) to update far-from-diagonal
              ! .    entries in h.  if required, use u to update z as
              ! .    well. ====
              if( accum ) then
                 if( wantt ) then
                    jtop = 1
                    jbot = n
                 else
                    jtop = ktop
                    jbot = kbot
                 end if
                 k1 = max( 1, ktop-incol )
                 nu = ( kdu-max( 0, ndcol-kbot ) ) - k1 + 1
                 ! ==== horizontal multiply ====
                 do jcol = min( ndcol, kbot ) + 1, jbot, nh
                    jlen = min( nh, jbot-jcol+1 )
                    call stdlib_dgemm( 'C', 'N', nu, jlen, nu, one, u( k1, k1 ),ldu, h( incol+k1, &
                              jcol ), ldh, zero, wh,ldwh )
                    call stdlib_dlacpy( 'ALL', nu, jlen, wh, ldwh,h( incol+k1, jcol ), ldh )
                              
                 end do
                 ! ==== vertical multiply ====
                 do jrow = jtop, max( ktop, incol ) - 1, nv
                    jlen = min( nv, max( ktop, incol )-jrow )
                    call stdlib_dgemm( 'N', 'N', jlen, nu, nu, one,h( jrow, incol+k1 ), ldh, u( &
                              k1, k1 ),ldu, zero, wv, ldwv )
                    call stdlib_dlacpy( 'ALL', jlen, nu, wv, ldwv,h( jrow, incol+k1 ), ldh )
                              
                 end do
                 ! ==== z multiply (also vertical) ====
                 if( wantz ) then
                    do jrow = iloz, ihiz, nv
                       jlen = min( nv, ihiz-jrow+1 )
                       call stdlib_dgemm( 'N', 'N', jlen, nu, nu, one,z( jrow, incol+k1 ), ldz, u(&
                                  k1, k1 ),ldu, zero, wv, ldwv )
                       call stdlib_dlacpy( 'ALL', jlen, nu, wv, ldwv,z( jrow, incol+k1 ), ldz )
                                 
                    end do
                 end if
              end if
           end do loop_180
     end subroutine stdlib_dlaqr5

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$laqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts,sr, si, h, ldh, &
     !! DLAQR5:, called by DLAQR0, performs a
     !! single small-bulge multi-shift QR sweep.
               iloz, ihiz, z, ldz, v, ldv, u,ldu, nv, wv, ldwv, nh, wh, ldwh )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv, ldwh, ldwv, &
                     ldz, n, nh, nshfts, nv
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           real(${rk}$), intent(inout) :: h(ldh,*), si(*), sr(*), z(ldz,*)
           real(${rk}$), intent(out) :: u(ldu,*), v(ldv,*), wh(ldwh,*), wv(ldwv,*)
        ! ================================================================
           
           ! Local Scalars 
           real(${rk}$) :: alpha, beta, h11, h12, h21, h22, refsum, safmax, safmin, scl, smlnum, swap,&
                      tst1, tst2, ulp
           integer(ilp) :: i, i2, i4, incol, j, jbot, jcol, jlen, jrow, jtop, k, k1, kdu, kms, &
                     krcol, m, m22, mbot, mtop, nbmps, ndcol, ns, nu
           logical(lk) :: accum, bmp22
           ! Intrinsic Functions 
           ! Local Arrays 
           real(${rk}$) :: vt(3)
           ! Executable Statements 
           ! ==== if there are no shifts, then there is nothing to do. ====
           if( nshfts<2 )return
           ! ==== if the active block is empty or 1-by-1, then there
           ! .    is nothing to do. ====
           if( ktop>=kbot )return
           ! ==== shuffle shifts into pairs of real shifts and pairs
           ! .    of complex conjugate shifts assuming complex
           ! .    conjugate shifts are already adjacent to one
           ! .    another. ====
           do i = 1, nshfts - 2, 2
              if( si( i )/=-si( i+1 ) ) then
                 swap = sr( i )
                 sr( i ) = sr( i+1 )
                 sr( i+1 ) = sr( i+2 )
                 sr( i+2 ) = swap
                 swap = si( i )
                 si( i ) = si( i+1 )
                 si( i+1 ) = si( i+2 )
                 si( i+2 ) = swap
              end if
           end do
           ! ==== nshfts is supposed to be even, but if it is odd,
           ! .    then simply reduce it by one.  the shuffle above
           ! .    ensures that the dropped shift is real and that
           ! .    the remaining shifts are paired. ====
           ns = nshfts - mod( nshfts, 2 )
           ! ==== machine constants for deflation ====
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safmax = one / safmin
           call stdlib_${ri}$labad( safmin, safmax )
           ulp = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=${rk}$) / ulp )
           ! ==== use accumulated reflections to update far-from-diagonal
           ! .    entries ? ====
           accum = ( kacc22==1 ) .or. ( kacc22==2 )
           ! ==== clear trash ====
           if( ktop+2<=kbot )h( ktop+2, ktop ) = zero
           ! ==== nbmps = number of 2-shift bulges in the chain ====
           nbmps = ns / 2
           ! ==== kdu = width of slab ====
           kdu = 4*nbmps
           ! ==== create and chase chains of nbmps bulges ====
           loop_180: do incol = ktop - 2*nbmps + 1, kbot - 2, 2*nbmps
              ! jtop = index from which updates from the right start.
              if( accum ) then
                 jtop = max( ktop, incol )
              else if( wantt ) then
                 jtop = 1
              else
                 jtop = ktop
              end if
              ndcol = incol + kdu
              if( accum )call stdlib_${ri}$laset( 'ALL', kdu, kdu, zero, one, u, ldu )
              ! ==== near-the-diagonal bulge chase.  the following loop
              ! .    performs the near-the-diagonal part of a small bulge
              ! .    multi-shift qr sweep.  each 4*nbmps column diagonal
              ! .    chunk extends from column incol to column ndcol
              ! .    (including both column incol and column ndcol). the
              ! .    following loop chases a 2*nbmps+1 column long chain of
              ! .    nbmps bulges 2*nbmps columns to the right.  (incol
              ! .    may be less than ktop and and ndcol may be greater than
              ! .    kbot indicating phantom columns from which to chase
              ! .    bulges before they are actually introduced or to which
              ! .    to chase bulges beyond column kbot.)  ====
              loop_145: do krcol = incol, min( incol+2*nbmps-1, kbot-2 )
                 ! ==== bulges number mtop to mbot are active double implicit
                 ! .    shift bulges.  there may or may not also be small
                 ! .    2-by-2 bulge, if there is room.  the inactive bulges
                 ! .    (if any) must wait until the active bulges have moved
                 ! .    down the diagonal to make room.  the phantom matrix
                 ! .    paradigm described above helps keep track.  ====
                 mtop = max( 1, ( ktop-krcol ) / 2+1 )
                 mbot = min( nbmps, ( kbot-krcol-1 ) / 2 )
                 m22 = mbot + 1
                 bmp22 = ( mbot<nbmps ) .and. ( krcol+2*( m22-1 ) )==( kbot-2 )
                 ! ==== generate reflections to chase the chain right
                 ! .    one column.  (the minimum value of k is ktop-1.) ====
                 if ( bmp22 ) then
                    ! ==== special case: 2-by-2 reflection at bottom treated
                    ! .    separately ====
                    k = krcol + 2*( m22-1 )
                    if( k==ktop-1 ) then
                       call stdlib_${ri}$laqr1( 2, h( k+1, k+1 ), ldh, sr( 2*m22-1 ),si( 2*m22-1 ), sr(&
                                  2*m22 ), si( 2*m22 ),v( 1, m22 ) )
                       beta = v( 1, m22 )
                       call stdlib_${ri}$larfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                    else
                       beta = h( k+1, k )
                       v( 2, m22 ) = h( k+2, k )
                       call stdlib_${ri}$larfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                       h( k+1, k ) = beta
                       h( k+2, k ) = zero
                    end if
                    ! ==== perform update from right within
                    ! .    computational window. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m22 )*( h( j, k+1 )+v( 2, m22 )*h( j, k+2 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) - refsum*v( 2, m22 )
                    end do
                    ! ==== perform update from left within
                    ! .    computational window. ====
                    if( accum ) then
                       jbot = min( ndcol, kbot )
                    else if( wantt ) then
                       jbot = n
                    else
                       jbot = kbot
                    end if
                    do j = k+1, jbot
                       refsum = v( 1, m22 )*( h( k+1, j )+v( 2, m22 )*h( k+2, j ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m22 )
                    end do
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is zero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k>=ktop ) then
                       if( h( k+1, k )/=zero ) then
                          tst1 = abs( h( k, k ) ) + abs( h( k+1, k+1 ) )
                          if( tst1==zero ) then
                             if( k>=ktop+1 )tst1 = tst1 + abs( h( k, k-1 ) )
                             if( k>=ktop+2 )tst1 = tst1 + abs( h( k, k-2 ) )
                             if( k>=ktop+3 )tst1 = tst1 + abs( h( k, k-3 ) )
                             if( k<=kbot-2 )tst1 = tst1 + abs( h( k+2, k+1 ) )
                             if( k<=kbot-3 )tst1 = tst1 + abs( h( k+3, k+1 ) )
                             if( k<=kbot-4 )tst1 = tst1 + abs( h( k+4, k+1 ) )
                          end if
                          if( abs( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) ) then
                             h12 = max( abs( h( k+1, k ) ),abs( h( k, k+1 ) ) )
                             h21 = min( abs( h( k+1, k ) ),abs( h( k, k+1 ) ) )
                             h11 = max( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             h22 = min( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             scl = h11 + h12
                             tst2 = h22*( h11 / scl )
                             if( tst2==zero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) ) &
                                       then
                                h( k+1, k ) = zero
                             end if
                          end if
                       end if
                    end if
                    ! ==== accumulate orthogonal transformations. ====
                    if( accum ) then
                       kms = k - incol
                       do j = max( 1, ktop-incol ), kdu
                          refsum = v( 1, m22 )*( u( j, kms+1 )+v( 2, m22 )*u( j, kms+2 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) - refsum*v( 2, m22 )
                       end do
                    else if( wantz ) then
                       do j = iloz, ihiz
                          refsum = v( 1, m22 )*( z( j, k+1 )+v( 2, m22 )*z( j, k+2 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) - refsum*v( 2, m22 )
                       end do
                    end if
                 end if
                 ! ==== normal case: chain of 3-by-3 reflections ====
                 loop_80: do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    if( k==ktop-1 ) then
                       call stdlib_${ri}$laqr1( 3, h( ktop, ktop ), ldh, sr( 2*m-1 ),si( 2*m-1 ), sr( &
                                 2*m ), si( 2*m ),v( 1, m ) )
                       alpha = v( 1, m )
                       call stdlib_${ri}$larfg( 3, alpha, v( 2, m ), 1, v( 1, m ) )
                    else
                       ! ==== perform delayed transformation of row below
                       ! .    mth bulge. exploit fact that first two elements
                       ! .    of row are actually zero. ====
                       refsum = v( 1, m )*v( 3, m )*h( k+3, k+2 )
                       h( k+3, k   ) = -refsum
                       h( k+3, k+1 ) = -refsum*v( 2, m )
                       h( k+3, k+2 ) = h( k+3, k+2 ) - refsum*v( 3, m )
                       ! ==== calculate reflection to move
                       ! .    mth bulge one step. ====
                       beta      = h( k+1, k )
                       v( 2, m ) = h( k+2, k )
                       v( 3, m ) = h( k+3, k )
                       call stdlib_${ri}$larfg( 3, beta, v( 2, m ), 1, v( 1, m ) )
                       ! ==== a bulge may collapse because of vigilant
                       ! .    deflation or destructive underflow.  in the
                       ! .    underflow case, try the two-small-subdiagonals
                       ! .    trick to try to reinflate the bulge.  ====
                       if( h( k+3, k )/=zero .or. h( k+3, k+1 )/=zero .or. h( k+3, k+2 )==zero ) &
                                 then
                          ! ==== typical case: not collapsed (yet). ====
                          h( k+1, k ) = beta
                          h( k+2, k ) = zero
                          h( k+3, k ) = zero
                       else
                          ! ==== atypical case: collapsed.  attempt to
                          ! .    reintroduce ignoring h(k+1,k) and h(k+2,k).
                          ! .    if the fill resulting from the new
                          ! .    reflector is too large, then abandon it.
                          ! .    otherwise, use the new one. ====
                          call stdlib_${ri}$laqr1( 3, h( k+1, k+1 ), ldh, sr( 2*m-1 ),si( 2*m-1 ), sr( &
                                    2*m ), si( 2*m ),vt )
                          alpha = vt( 1 )
                          call stdlib_${ri}$larfg( 3, alpha, vt( 2 ), 1, vt( 1 ) )
                          refsum = vt( 1 )*( h( k+1, k )+vt( 2 )*h( k+2, k ) )
                          if( abs( h( k+2, k )-refsum*vt( 2 ) )+abs( refsum*vt( 3 ) )>ulp*( abs( &
                                    h( k, k ) )+abs( h( k+1,k+1 ) )+abs( h( k+2, k+2 ) ) ) ) then
                             ! ==== starting a new bulge here would
                             ! .    create non-negligible fill.  use
                             ! .    the old one with trepidation. ====
                             h( k+1, k ) = beta
                             h( k+2, k ) = zero
                             h( k+3, k ) = zero
                          else
                             ! ==== starting a new bulge here would
                             ! .    create only negligible fill.
                             ! .    replace the old reflector with
                             ! .    the new one. ====
                             h( k+1, k ) = h( k+1, k ) - refsum
                             h( k+2, k ) = zero
                             h( k+3, k ) = zero
                             v( 1, m ) = vt( 1 )
                             v( 2, m ) = vt( 2 )
                             v( 3, m ) = vt( 3 )
                          end if
                       end if
                    end if
                    ! ====  apply reflection from the right and
                    ! .     the first column of update from the left.
                    ! .     these updates are required for the vigilant
                    ! .     deflation check. we still delay most of the
                    ! .     updates from the left for efficiency. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m )*( h( j, k+1 )+v( 2, m )*h( j, k+2 )+v( 3, m )*h( j, k+3 &
                                 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) - refsum*v( 2, m )
                       h( j, k+3 ) = h( j, k+3 ) - refsum*v( 3, m )
                    end do
                    ! ==== perform update from left for subsequent
                    ! .    column. ====
                    refsum = v( 1, m )*( h( k+1, k+1 )+v( 2, m )*h( k+2, k+1 )+v( 3, m )*h( k+3, &
                              k+1 ) )
                    h( k+1, k+1 ) = h( k+1, k+1 ) - refsum
                    h( k+2, k+1 ) = h( k+2, k+1 ) - refsum*v( 2, m )
                    h( k+3, k+1 ) = h( k+3, k+1 ) - refsum*v( 3, m )
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is zero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k<ktop)cycle
                    if( h( k+1, k )/=zero ) then
                       tst1 = abs( h( k, k ) ) + abs( h( k+1, k+1 ) )
                       if( tst1==zero ) then
                          if( k>=ktop+1 )tst1 = tst1 + abs( h( k, k-1 ) )
                          if( k>=ktop+2 )tst1 = tst1 + abs( h( k, k-2 ) )
                          if( k>=ktop+3 )tst1 = tst1 + abs( h( k, k-3 ) )
                          if( k<=kbot-2 )tst1 = tst1 + abs( h( k+2, k+1 ) )
                          if( k<=kbot-3 )tst1 = tst1 + abs( h( k+3, k+1 ) )
                          if( k<=kbot-4 )tst1 = tst1 + abs( h( k+4, k+1 ) )
                       end if
                       if( abs( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) )then
                          h12 = max( abs( h( k+1, k ) ), abs( h( k, k+1 ) ) )
                          h21 = min( abs( h( k+1, k ) ), abs( h( k, k+1 ) ) )
                          h11 = max( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                          h22 = min( abs( h( k+1, k+1 ) ),abs( h( k, k )-h( k+1, k+1 ) ) )
                          scl = h11 + h12
                          tst2 = h22*( h11 / scl )
                          if( tst2==zero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) ) &
                                    then
                             h( k+1, k ) = zero
                          end if
                       end if
                    end if
                 end do loop_80
                 ! ==== multiply h by reflections from the left ====
                 if( accum ) then
                    jbot = min( ndcol, kbot )
                 else if( wantt ) then
                    jbot = n
                 else
                    jbot = kbot
                 end if
                 do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    do j = max( ktop, krcol + 2*m ), jbot
                       refsum = v( 1, m )*( h( k+1, j )+v( 2, m )*h( k+2, j )+v( 3, m )*h( k+3, j &
                                 ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m )
                       h( k+3, j ) = h( k+3, j ) - refsum*v( 3, m )
                    end do
                 end do
                 ! ==== accumulate orthogonal transformations. ====
                 if( accum ) then
                    ! ==== accumulate u. (if needed, update z later
                    ! .    with an efficient matrix-matrix
                    ! .    multiply.) ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       kms = k - incol
                       i2 = max( 1, ktop-incol )
                       i2 = max( i2, kms-(krcol-incol)+1 )
                       i4 = min( kdu, krcol + 2*( mbot-1 ) - incol + 5 )
                       do j = i2, i4
                          refsum = v( 1, m )*( u( j, kms+1 )+v( 2, m )*u( j, kms+2 )+v( 3, m )*u( &
                                    j, kms+3 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) - refsum*v( 2, m )
                          u( j, kms+3 ) = u( j, kms+3 ) - refsum*v( 3, m )
                       end do
                    end do
                 else if( wantz ) then
                    ! ==== u is not accumulated, so update z
                    ! .    now by multiplying by reflections
                    ! .    from the right. ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       do j = iloz, ihiz
                          refsum = v( 1, m )*( z( j, k+1 )+v( 2, m )*z( j, k+2 )+v( 3, m )*z( j, &
                                    k+3 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) - refsum*v( 2, m )
                          z( j, k+3 ) = z( j, k+3 ) - refsum*v( 3, m )
                       end do
                    end do
                 end if
                 ! ==== end of near-the-diagonal bulge chase. ====
              end do loop_145
              ! ==== use u (if accumulated) to update far-from-diagonal
              ! .    entries in h.  if required, use u to update z as
              ! .    well. ====
              if( accum ) then
                 if( wantt ) then
                    jtop = 1
                    jbot = n
                 else
                    jtop = ktop
                    jbot = kbot
                 end if
                 k1 = max( 1, ktop-incol )
                 nu = ( kdu-max( 0, ndcol-kbot ) ) - k1 + 1
                 ! ==== horizontal multiply ====
                 do jcol = min( ndcol, kbot ) + 1, jbot, nh
                    jlen = min( nh, jbot-jcol+1 )
                    call stdlib_${ri}$gemm( 'C', 'N', nu, jlen, nu, one, u( k1, k1 ),ldu, h( incol+k1, &
                              jcol ), ldh, zero, wh,ldwh )
                    call stdlib_${ri}$lacpy( 'ALL', nu, jlen, wh, ldwh,h( incol+k1, jcol ), ldh )
                              
                 end do
                 ! ==== vertical multiply ====
                 do jrow = jtop, max( ktop, incol ) - 1, nv
                    jlen = min( nv, max( ktop, incol )-jrow )
                    call stdlib_${ri}$gemm( 'N', 'N', jlen, nu, nu, one,h( jrow, incol+k1 ), ldh, u( &
                              k1, k1 ),ldu, zero, wv, ldwv )
                    call stdlib_${ri}$lacpy( 'ALL', jlen, nu, wv, ldwv,h( jrow, incol+k1 ), ldh )
                              
                 end do
                 ! ==== z multiply (also vertical) ====
                 if( wantz ) then
                    do jrow = iloz, ihiz, nv
                       jlen = min( nv, ihiz-jrow+1 )
                       call stdlib_${ri}$gemm( 'N', 'N', jlen, nu, nu, one,z( jrow, incol+k1 ), ldz, u(&
                                  k1, k1 ),ldu, zero, wv, ldwv )
                       call stdlib_${ri}$lacpy( 'ALL', jlen, nu, wv, ldwv,z( jrow, incol+k1 ), ldz )
                                 
                    end do
                 end if
              end if
           end do loop_180
     end subroutine stdlib_${ri}$laqr5

#:endif
#:endfor

     pure subroutine stdlib_claqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts, s,h, ldh, iloz, &
     !! CLAQR5 called by CLAQR0 performs a
     !! single small-bulge multi-shift QR sweep.
               ihiz, z, ldz, v, ldv, u, ldu, nv,wv, ldwv, nh, wh, ldwh )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv, ldwh, ldwv, &
                     ldz, n, nh, nshfts, nv
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(sp), intent(inout) :: h(ldh,*), s(*), z(ldz,*)
           complex(sp), intent(out) :: u(ldu,*), v(ldv,*), wh(ldwh,*), wv(ldwv,*)
        ! ================================================================
           ! Parameters 
           real(sp), parameter :: rzero = 0.0_sp
           real(sp), parameter :: rone = 1.0_sp
           
           
           ! Local Scalars 
           complex(sp) :: alpha, beta, cdum, refsum
           real(sp) :: h11, h12, h21, h22, safmax, safmin, scl, smlnum, tst1, tst2, ulp
           integer(ilp) :: i2, i4, incol, j, jbot, jcol, jlen, jrow, jtop, k, k1, kdu, kms, krcol,&
                      m, m22, mbot, mtop, nbmps, ndcol, ns, nu
           logical(lk) :: accum, bmp22
           ! Intrinsic Functions 
           ! Local Arrays 
           complex(sp) :: vt(3)
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! ==== if there are no shifts, then there is nothing to do. ====
           if( nshfts<2 )return
           ! ==== if the active block is empty or 1-by-1, then there
           ! .    is nothing to do. ====
           if( ktop>=kbot )return
           ! ==== nshfts is supposed to be even, but if it is odd,
           ! .    then simply reduce it by cone.  ====
           ns = nshfts - mod( nshfts, 2 )
           ! ==== machine constants for deflation ====
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=sp) / ulp )
           ! ==== use accumulated reflections to update far-from-diagonal
           ! .    entries ? ====
           accum = ( kacc22==1 ) .or. ( kacc22==2 )
           ! ==== clear trash ====
           if( ktop+2<=kbot )h( ktop+2, ktop ) = czero
           ! ==== nbmps = number of 2-shift bulges in the chain ====
           nbmps = ns / 2
           ! ==== kdu = width of slab ====
           kdu = 4*nbmps
           ! ==== create and chase chains of nbmps bulges ====
           loop_180: do incol = ktop - 2*nbmps + 1, kbot - 2, 2*nbmps
              ! jtop = index from which updates from the right start.
              if( accum ) then
                 jtop = max( ktop, incol )
              else if( wantt ) then
                 jtop = 1
              else
                 jtop = ktop
              end if
              ndcol = incol + kdu
              if( accum )call stdlib_claset( 'ALL', kdu, kdu, czero, cone, u, ldu )
              ! ==== near-the-diagonal bulge chase.  the following loop
              ! .    performs the near-the-diagonal part of a small bulge
              ! .    multi-shift qr sweep.  each 4*nbmps column diagonal
              ! .    chunk extends from column incol to column ndcol
              ! .    (including both column incol and column ndcol). the
              ! .    following loop chases a 2*nbmps+1 column long chain of
              ! .    nbmps bulges 2*nbmps columns to the right.  (incol
              ! .    may be less than ktop and and ndcol may be greater than
              ! .    kbot indicating phantom columns from which to chase
              ! .    bulges before they are actually introduced or to which
              ! .    to chase bulges beyond column kbot.)  ====
              loop_145: do krcol = incol, min( incol+2*nbmps-1, kbot-2 )
                 ! ==== bulges number mtop to mbot are active double implicit
                 ! .    shift bulges.  there may or may not also be small
                 ! .    2-by-2 bulge, if there is room.  the inactive bulges
                 ! .    (if any) must wait until the active bulges have moved
                 ! .    down the diagonal to make room.  the phantom matrix
                 ! .    paradigm described above helps keep track.  ====
                 mtop = max( 1, ( ktop-krcol ) / 2+1 )
                 mbot = min( nbmps, ( kbot-krcol-1 ) / 2 )
                 m22 = mbot + 1
                 bmp22 = ( mbot<nbmps ) .and. ( krcol+2*( m22-1 ) )==( kbot-2 )
                 ! ==== generate reflections to chase the chain right
                 ! .    cone column.  (the minimum value of k is ktop-1.) ====
                 if ( bmp22 ) then
                    ! ==== special case: 2-by-2 reflection at bottom treated
                    ! .    separately ====
                    k = krcol + 2*( m22-1 )
                    if( k==ktop-1 ) then
                       call stdlib_claqr1( 2, h( k+1, k+1 ), ldh, s( 2*m22-1 ),s( 2*m22 ), v( 1, &
                                 m22 ) )
                       beta = v( 1, m22 )
                       call stdlib_clarfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                    else
                       beta = h( k+1, k )
                       v( 2, m22 ) = h( k+2, k )
                       call stdlib_clarfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                       h( k+1, k ) = beta
                       h( k+2, k ) = czero
                    end if
                    ! ==== perform update from right within
                    ! .    computational window. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m22 )*( h( j, k+1 )+v( 2, m22 )*h( j, k+2 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) -refsum*conjg( v( 2, m22 ) )
                    end do
                    ! ==== perform update from left within
                    ! .    computational window. ====
                    if( accum ) then
                       jbot = min( ndcol, kbot )
                    else if( wantt ) then
                       jbot = n
                    else
                       jbot = kbot
                    end if
                    do j = k+1, jbot
                       refsum = conjg( v( 1, m22 ) )*( h( k+1, j )+conjg( v( 2, m22 ) )*h( k+2, j &
                                 ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m22 )
                    end do
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is czero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k>=ktop) then
                       if( h( k+1, k )/=czero ) then
                          tst1 = cabs1( h( k, k ) ) + cabs1( h( k+1, k+1 ) )
                          if( tst1==rzero ) then
                             if( k>=ktop+1 )tst1 = tst1 + cabs1( h( k, k-1 ) )
                             if( k>=ktop+2 )tst1 = tst1 + cabs1( h( k, k-2 ) )
                             if( k>=ktop+3 )tst1 = tst1 + cabs1( h( k, k-3 ) )
                             if( k<=kbot-2 )tst1 = tst1 + cabs1( h( k+2, k+1 ) )
                             if( k<=kbot-3 )tst1 = tst1 + cabs1( h( k+3, k+1 ) )
                             if( k<=kbot-4 )tst1 = tst1 + cabs1( h( k+4, k+1 ) )
                          end if
                          if( cabs1( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) ) then
                             h12 = max( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                             h21 = min( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                             h11 = max( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             h22 = min( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             scl = h11 + h12
                             tst2 = h22*( h11 / scl )
                             if( tst2==rzero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) )h( &
                                       k+1, k ) = czero
                          end if
                       end if
                    end if
                    ! ==== accumulate orthogonal transformations. ====
                    if( accum ) then
                       kms = k - incol
                       do j = max( 1, ktop-incol ), kdu
                          refsum = v( 1, m22 )*( u( j, kms+1 )+v( 2, m22 )*u( j, kms+2 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) -refsum*conjg( v( 2, m22 ) )
                       end do
                    else if( wantz ) then
                       do j = iloz, ihiz
                          refsum = v( 1, m22 )*( z( j, k+1 )+v( 2, m22 )*z( j, k+2 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) -refsum*conjg( v( 2, m22 ) )
                       end do
                    end if
                 end if
                 ! ==== normal case: chain of 3-by-3 reflections ====
                 loop_80: do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    if( k==ktop-1 ) then
                       call stdlib_claqr1( 3, h( ktop, ktop ), ldh, s( 2*m-1 ),s( 2*m ), v( 1, m )&
                                  )
                       alpha = v( 1, m )
                       call stdlib_clarfg( 3, alpha, v( 2, m ), 1, v( 1, m ) )
                    else
                       ! ==== perform delayed transformation of row below
                       ! .    mth bulge. exploit fact that first two elements
                       ! .    of row are actually czero. ====
                       refsum = v( 1, m )*v( 3, m )*h( k+3, k+2 )
                       h( k+3, k   ) = -refsum
                       h( k+3, k+1 ) = -refsum*conjg( v( 2, m ) )
                       h( k+3, k+2 ) = h( k+3, k+2 ) -refsum*conjg( v( 3, m ) )
                       ! ==== calculate reflection to move
                       ! .    mth bulge cone step. ====
                       beta      = h( k+1, k )
                       v( 2, m ) = h( k+2, k )
                       v( 3, m ) = h( k+3, k )
                       call stdlib_clarfg( 3, beta, v( 2, m ), 1, v( 1, m ) )
                       ! ==== a bulge may collapse because of vigilant
                       ! .    deflation or destructive underflow.  in the
                       ! .    underflow case, try the two-small-subdiagonals
                       ! .    trick to try to reinflate the bulge.  ====
                       if( h( k+3, k )/=czero .or. h( k+3, k+1 )/=czero .or. h( k+3, k+2 )==czero &
                                 ) then
                          ! ==== typical case: not collapsed (yet). ====
                          h( k+1, k ) = beta
                          h( k+2, k ) = czero
                          h( k+3, k ) = czero
                       else
                          ! ==== atypical case: collapsed.  attempt to
                          ! .    reintroduce ignoring h(k+1,k) and h(k+2,k).
                          ! .    if the fill resulting from the new
                          ! .    reflector is too large, then abandon it.
                          ! .    otherwise, use the new cone. ====
                          call stdlib_claqr1( 3, h( k+1, k+1 ), ldh, s( 2*m-1 ),s( 2*m ), vt )
                                    
                          alpha = vt( 1 )
                          call stdlib_clarfg( 3, alpha, vt( 2 ), 1, vt( 1 ) )
                          refsum = conjg( vt( 1 ) )*( h( k+1, k )+conjg( vt( 2 ) )*h( k+2, k ) )
                                    
                          if( cabs1( h( k+2, k )-refsum*vt( 2 ) )+cabs1( refsum*vt( 3 ) )>ulp*( &
                          cabs1( h( k, k ) )+cabs1( h( k+1,k+1 ) )+cabs1( h( k+2, k+2 ) ) ) ) &
                                    then
                             ! ==== starting a new bulge here would
                             ! .    create non-negligible fill.  use
                             ! .    the old cone with trepidation. ====
                             h( k+1, k ) = beta
                             h( k+2, k ) = czero
                             h( k+3, k ) = czero
                          else
                             ! ==== starting a new bulge here would
                             ! .    create only negligible fill.
                             ! .    replace the old reflector with
                             ! .    the new cone. ====
                             h( k+1, k ) = h( k+1, k ) - refsum
                             h( k+2, k ) = czero
                             h( k+3, k ) = czero
                             v( 1, m ) = vt( 1 )
                             v( 2, m ) = vt( 2 )
                             v( 3, m ) = vt( 3 )
                          end if
                       end if
                    end if
                    ! ====  apply reflection from the right and
                    ! .     the first column of update from the left.
                    ! .     these updates are required for the vigilant
                    ! .     deflation check. we still delay most of the
                    ! .     updates from the left for efficiency. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m )*( h( j, k+1 )+v( 2, m )*h( j, k+2 )+v( 3, m )*h( j, k+3 &
                                 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) -refsum*conjg( v( 2, m ) )
                       h( j, k+3 ) = h( j, k+3 ) -refsum*conjg( v( 3, m ) )
                    end do
                    ! ==== perform update from left for subsequent
                    ! .    column. ====
                    refsum =  conjg( v( 1, m ) )*( h( k+1, k+1 )+conjg( v( 2, m ) )*h( k+2, k+1 )+&
                              conjg( v( 3, m ) )*h( k+3, k+1 ) )
                    h( k+1, k+1 ) = h( k+1, k+1 ) - refsum
                    h( k+2, k+1 ) = h( k+2, k+1 ) - refsum*v( 2, m )
                    h( k+3, k+1 ) = h( k+3, k+1 ) - refsum*v( 3, m )
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is czero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k<ktop)cycle
                    if( h( k+1, k )/=czero ) then
                       tst1 = cabs1( h( k, k ) ) + cabs1( h( k+1, k+1 ) )
                       if( tst1==rzero ) then
                          if( k>=ktop+1 )tst1 = tst1 + cabs1( h( k, k-1 ) )
                          if( k>=ktop+2 )tst1 = tst1 + cabs1( h( k, k-2 ) )
                          if( k>=ktop+3 )tst1 = tst1 + cabs1( h( k, k-3 ) )
                          if( k<=kbot-2 )tst1 = tst1 + cabs1( h( k+2, k+1 ) )
                          if( k<=kbot-3 )tst1 = tst1 + cabs1( h( k+3, k+1 ) )
                          if( k<=kbot-4 )tst1 = tst1 + cabs1( h( k+4, k+1 ) )
                       end if
                       if( cabs1( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) )then
                          h12 = max( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                          h21 = min( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                          h11 = max( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                    
                          h22 = min( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                    
                          scl = h11 + h12
                          tst2 = h22*( h11 / scl )
                          if( tst2==rzero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) )h( k+1,&
                                     k ) = czero
                       end if
                    end if
                 end do loop_80
                 ! ==== multiply h by reflections from the left ====
                 if( accum ) then
                    jbot = min( ndcol, kbot )
                 else if( wantt ) then
                    jbot = n
                 else
                    jbot = kbot
                 end if
                 do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    do j = max( ktop, krcol + 2*m ), jbot
                       refsum = conjg( v( 1, m ) )*( h( k+1, j )+conjg( v( 2, m ) )*h( k+2, j )+&
                                 conjg( v( 3, m ) )*h( k+3, j ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m )
                       h( k+3, j ) = h( k+3, j ) - refsum*v( 3, m )
                    end do
                 end do
                 ! ==== accumulate orthogonal transformations. ====
                 if( accum ) then
                    ! ==== accumulate u. (if needed, update z later
                    ! .    with an efficient matrix-matrix
                    ! .    multiply.) ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       kms = k - incol
                       i2 = max( 1, ktop-incol )
                       i2 = max( i2, kms-(krcol-incol)+1 )
                       i4 = min( kdu, krcol + 2*( mbot-1 ) - incol + 5 )
                       do j = i2, i4
                          refsum = v( 1, m )*( u( j, kms+1 )+v( 2, m )*u( j, kms+2 )+v( 3, m )*u( &
                                    j, kms+3 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) -refsum*conjg( v( 2, m ) )
                          u( j, kms+3 ) = u( j, kms+3 ) -refsum*conjg( v( 3, m ) )
                       end do
                    end do
                 else if( wantz ) then
                    ! ==== u is not accumulated, so update z
                    ! .    now by multiplying by reflections
                    ! .    from the right. ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       do j = iloz, ihiz
                          refsum = v( 1, m )*( z( j, k+1 )+v( 2, m )*z( j, k+2 )+v( 3, m )*z( j, &
                                    k+3 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) -refsum*conjg( v( 2, m ) )
                          z( j, k+3 ) = z( j, k+3 ) -refsum*conjg( v( 3, m ) )
                       end do
                    end do
                 end if
                 ! ==== end of near-the-diagonal bulge chase. ====
              end do loop_145
              ! ==== use u (if accumulated) to update far-from-diagonal
              ! .    entries in h.  if required, use u to update z as
              ! .    well. ====
              if( accum ) then
                 if( wantt ) then
                    jtop = 1
                    jbot = n
                 else
                    jtop = ktop
                    jbot = kbot
                 end if
                 k1 = max( 1, ktop-incol )
                 nu = ( kdu-max( 0, ndcol-kbot ) ) - k1 + 1
                 ! ==== horizontal multiply ====
                 do jcol = min( ndcol, kbot ) + 1, jbot, nh
                    jlen = min( nh, jbot-jcol+1 )
                    call stdlib_cgemm( 'C', 'N', nu, jlen, nu, cone, u( k1, k1 ),ldu, h( incol+k1,&
                               jcol ), ldh, czero, wh,ldwh )
                    call stdlib_clacpy( 'ALL', nu, jlen, wh, ldwh,h( incol+k1, jcol ), ldh )
                              
                 end do
                 ! ==== vertical multiply ====
                 do jrow = jtop, max( ktop, incol ) - 1, nv
                    jlen = min( nv, max( ktop, incol )-jrow )
                    call stdlib_cgemm( 'N', 'N', jlen, nu, nu, cone,h( jrow, incol+k1 ), ldh, u( &
                              k1, k1 ),ldu, czero, wv, ldwv )
                    call stdlib_clacpy( 'ALL', jlen, nu, wv, ldwv,h( jrow, incol+k1 ), ldh )
                              
                 end do
                 ! ==== z multiply (also vertical) ====
                 if( wantz ) then
                    do jrow = iloz, ihiz, nv
                       jlen = min( nv, ihiz-jrow+1 )
                       call stdlib_cgemm( 'N', 'N', jlen, nu, nu, cone,z( jrow, incol+k1 ), ldz, &
                                 u( k1, k1 ),ldu, czero, wv, ldwv )
                       call stdlib_clacpy( 'ALL', jlen, nu, wv, ldwv,z( jrow, incol+k1 ), ldz )
                                 
                    end do
                 end if
              end if
           end do loop_180
     end subroutine stdlib_claqr5

     pure subroutine stdlib_zlaqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts, s,h, ldh, iloz, &
     !! ZLAQR5 , called by ZLAQR0, performs a
     !! single small-bulge multi-shift QR sweep.
               ihiz, z, ldz, v, ldv, u, ldu, nv,wv, ldwv, nh, wh, ldwh )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv, ldwh, ldwv, &
                     ldz, n, nh, nshfts, nv
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(dp), intent(inout) :: h(ldh,*), s(*), z(ldz,*)
           complex(dp), intent(out) :: u(ldu,*), v(ldv,*), wh(ldwh,*), wv(ldwv,*)
        ! ================================================================
           ! Parameters 
           real(dp), parameter :: rzero = 0.0_dp
           real(dp), parameter :: rone = 1.0_dp
           
           
           ! Local Scalars 
           complex(dp) :: alpha, beta, cdum, refsum
           real(dp) :: h11, h12, h21, h22, safmax, safmin, scl, smlnum, tst1, tst2, ulp
           integer(ilp) :: i2, i4, incol, j, jbot, jcol, jlen, jrow, jtop, k, k1, kdu, kms, krcol,&
                      m, m22, mbot, mtop, nbmps, ndcol, ns, nu
           logical(lk) :: accum, bmp22
           ! Intrinsic Functions 
           ! Local Arrays 
           complex(dp) :: vt(3)
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! ==== if there are no shifts, then there is nothing to do. ====
           if( nshfts<2 )return
           ! ==== if the active block is empty or 1-by-1, then there
           ! .    is nothing to do. ====
           if( ktop>=kbot )return
           ! ==== nshfts is supposed to be even, but if it is odd,
           ! .    then simply reduce it by cone.  ====
           ns = nshfts - mod( nshfts, 2 )
           ! ==== machine constants for deflation ====
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_dlabad( safmin, safmax )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=dp) / ulp )
           ! ==== use accumulated reflections to update far-from-diagonal
           ! .    entries ? ====
           accum = ( kacc22==1 ) .or. ( kacc22==2 )
           ! ==== clear trash ====
           if( ktop+2<=kbot )h( ktop+2, ktop ) = czero
           ! ==== nbmps = number of 2-shift bulges in the chain ====
           nbmps = ns / 2
           ! ==== kdu = width of slab ====
           kdu = 4*nbmps
           ! ==== create and chase chains of nbmps bulges ====
           loop_180: do incol = ktop - 2*nbmps + 1, kbot - 2, 2*nbmps
              ! jtop = index from which updates from the right start.
              if( accum ) then
                 jtop = max( ktop, incol )
              else if( wantt ) then
                 jtop = 1
              else
                 jtop = ktop
              end if
              ndcol = incol + kdu
              if( accum )call stdlib_zlaset( 'ALL', kdu, kdu, czero, cone, u, ldu )
              ! ==== near-the-diagonal bulge chase.  the following loop
              ! .    performs the near-the-diagonal part of a small bulge
              ! .    multi-shift qr sweep.  each 4*nbmps column diagonal
              ! .    chunk extends from column incol to column ndcol
              ! .    (including both column incol and column ndcol). the
              ! .    following loop chases a 2*nbmps+1 column long chain of
              ! .    nbmps bulges 2*nbmps columns to the right.  (incol
              ! .    may be less than ktop and and ndcol may be greater than
              ! .    kbot indicating phantom columns from which to chase
              ! .    bulges before they are actually introduced or to which
              ! .    to chase bulges beyond column kbot.)  ====
              loop_145: do krcol = incol, min( incol+2*nbmps-1, kbot-2 )
                 ! ==== bulges number mtop to mbot are active double implicit
                 ! .    shift bulges.  there may or may not also be small
                 ! .    2-by-2 bulge, if there is room.  the inactive bulges
                 ! .    (if any) must wait until the active bulges have moved
                 ! .    down the diagonal to make room.  the phantom matrix
                 ! .    paradigm described above helps keep track.  ====
                 mtop = max( 1, ( ktop-krcol ) / 2+1 )
                 mbot = min( nbmps, ( kbot-krcol-1 ) / 2 )
                 m22 = mbot + 1
                 bmp22 = ( mbot<nbmps ) .and. ( krcol+2*( m22-1 ) )==( kbot-2 )
                 ! ==== generate reflections to chase the chain right
                 ! .    cone column.  (the minimum value of k is ktop-1.) ====
                 if ( bmp22 ) then
                    ! ==== special case: 2-by-2 reflection at bottom treated
                    ! .    separately ====
                    k = krcol + 2*( m22-1 )
                    if( k==ktop-1 ) then
                       call stdlib_zlaqr1( 2, h( k+1, k+1 ), ldh, s( 2*m22-1 ),s( 2*m22 ), v( 1, &
                                 m22 ) )
                       beta = v( 1, m22 )
                       call stdlib_zlarfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                    else
                       beta = h( k+1, k )
                       v( 2, m22 ) = h( k+2, k )
                       call stdlib_zlarfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                       h( k+1, k ) = beta
                       h( k+2, k ) = czero
                    end if
                    ! ==== perform update from right within
                    ! .    computational window. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m22 )*( h( j, k+1 )+v( 2, m22 )*h( j, k+2 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) -refsum*conjg( v( 2, m22 ) )
                    end do
                    ! ==== perform update from left within
                    ! .    computational window. ====
                    if( accum ) then
                       jbot = min( ndcol, kbot )
                    else if( wantt ) then
                       jbot = n
                    else
                       jbot = kbot
                    end if
                    do j = k+1, jbot
                       refsum = conjg( v( 1, m22 ) )*( h( k+1, j )+conjg( v( 2, m22 ) )*h( k+2, j &
                                 ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m22 )
                    end do
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is czero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k>=ktop ) then
                       if( h( k+1, k )/=czero ) then
                          tst1 = cabs1( h( k, k ) ) + cabs1( h( k+1, k+1 ) )
                          if( tst1==rzero ) then
                             if( k>=ktop+1 )tst1 = tst1 + cabs1( h( k, k-1 ) )
                             if( k>=ktop+2 )tst1 = tst1 + cabs1( h( k, k-2 ) )
                             if( k>=ktop+3 )tst1 = tst1 + cabs1( h( k, k-3 ) )
                             if( k<=kbot-2 )tst1 = tst1 + cabs1( h( k+2, k+1 ) )
                             if( k<=kbot-3 )tst1 = tst1 + cabs1( h( k+3, k+1 ) )
                             if( k<=kbot-4 )tst1 = tst1 + cabs1( h( k+4, k+1 ) )
                          end if
                          if( cabs1( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) ) then
                             h12 = max( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                             h21 = min( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                             h11 = max( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             h22 = min( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             scl = h11 + h12
                             tst2 = h22*( h11 / scl )
                             if( tst2==rzero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) )h( &
                                       k+1, k ) = czero
                          end if
                       end if
                    end if
                    ! ==== accumulate orthogonal transformations. ====
                    if( accum ) then
                       kms = k - incol
                       do j = max( 1, ktop-incol ), kdu
                          refsum = v( 1, m22 )*( u( j, kms+1 )+v( 2, m22 )*u( j, kms+2 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) -refsum*conjg( v( 2, m22 ) )
                       end do
                    else if( wantz ) then
                       do j = iloz, ihiz
                          refsum = v( 1, m22 )*( z( j, k+1 )+v( 2, m22 )*z( j, k+2 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) -refsum*conjg( v( 2, m22 ) )
                       end do
                    end if
                 end if
                 ! ==== normal case: chain of 3-by-3 reflections ====
                 loop_80: do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    if( k==ktop-1 ) then
                       call stdlib_zlaqr1( 3, h( ktop, ktop ), ldh, s( 2*m-1 ),s( 2*m ), v( 1, m )&
                                  )
                       alpha = v( 1, m )
                       call stdlib_zlarfg( 3, alpha, v( 2, m ), 1, v( 1, m ) )
                    else
                       ! ==== perform delayed transformation of row below
                       ! .    mth bulge. exploit fact that first two elements
                       ! .    of row are actually czero. ====
                       refsum = v( 1, m )*v( 3, m )*h( k+3, k+2 )
                       h( k+3, k   ) = -refsum
                       h( k+3, k+1 ) = -refsum*conjg( v( 2, m ) )
                       h( k+3, k+2 ) = h( k+3, k+2 ) -refsum*conjg( v( 3, m ) )
                       ! ==== calculate reflection to move
                       ! .    mth bulge cone step. ====
                       beta      = h( k+1, k )
                       v( 2, m ) = h( k+2, k )
                       v( 3, m ) = h( k+3, k )
                       call stdlib_zlarfg( 3, beta, v( 2, m ), 1, v( 1, m ) )
                       ! ==== a bulge may collapse because of vigilant
                       ! .    deflation or destructive underflow.  in the
                       ! .    underflow case, try the two-small-subdiagonals
                       ! .    trick to try to reinflate the bulge.  ====
                       if( h( k+3, k )/=czero .or. h( k+3, k+1 )/=czero .or. h( k+3, k+2 )==czero &
                                 ) then
                          ! ==== typical case: not collapsed (yet). ====
                          h( k+1, k ) = beta
                          h( k+2, k ) = czero
                          h( k+3, k ) = czero
                       else
                          ! ==== atypical case: collapsed.  attempt to
                          ! .    reintroduce ignoring h(k+1,k) and h(k+2,k).
                          ! .    if the fill resulting from the new
                          ! .    reflector is too large, then abandon it.
                          ! .    otherwise, use the new cone. ====
                          call stdlib_zlaqr1( 3, h( k+1, k+1 ), ldh, s( 2*m-1 ),s( 2*m ), vt )
                                    
                          alpha = vt( 1 )
                          call stdlib_zlarfg( 3, alpha, vt( 2 ), 1, vt( 1 ) )
                          refsum = conjg( vt( 1 ) )*( h( k+1, k )+conjg( vt( 2 ) )*h( k+2, k ) )
                                    
                          if( cabs1( h( k+2, k )-refsum*vt( 2 ) )+cabs1( refsum*vt( 3 ) )>ulp*( &
                          cabs1( h( k, k ) )+cabs1( h( k+1,k+1 ) )+cabs1( h( k+2, k+2 ) ) ) ) &
                                    then
                             ! ==== starting a new bulge here would
                             ! .    create non-negligible fill.  use
                             ! .    the old cone with trepidation. ====
                             h( k+1, k ) = beta
                             h( k+2, k ) = czero
                             h( k+3, k ) = czero
                          else
                             ! ==== starting a new bulge here would
                             ! .    create only negligible fill.
                             ! .    replace the old reflector with
                             ! .    the new cone. ====
                             h( k+1, k ) = h( k+1, k ) - refsum
                             h( k+2, k ) = czero
                             h( k+3, k ) = czero
                             v( 1, m ) = vt( 1 )
                             v( 2, m ) = vt( 2 )
                             v( 3, m ) = vt( 3 )
                          end if
                       end if
                    end if
                    ! ====  apply reflection from the right and
                    ! .     the first column of update from the left.
                    ! .     these updates are required for the vigilant
                    ! .     deflation check. we still delay most of the
                    ! .     updates from the left for efficiency. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m )*( h( j, k+1 )+v( 2, m )*h( j, k+2 )+v( 3, m )*h( j, k+3 &
                                 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) -refsum*conjg( v( 2, m ) )
                       h( j, k+3 ) = h( j, k+3 ) -refsum*conjg( v( 3, m ) )
                    end do
                    ! ==== perform update from left for subsequent
                    ! .    column. ====
                    refsum =  conjg( v( 1, m ) )*( h( k+1, k+1 )+conjg( v( 2, m ) )*h( k+2, k+1 )+&
                              conjg( v( 3, m ) )*h( k+3, k+1 ) )
                    h( k+1, k+1 ) = h( k+1, k+1 ) - refsum
                    h( k+2, k+1 ) = h( k+2, k+1 ) - refsum*v( 2, m )
                    h( k+3, k+1 ) = h( k+3, k+1 ) - refsum*v( 3, m )
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is czero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k<ktop)cycle
                    if( h( k+1, k )/=czero ) then
                       tst1 = cabs1( h( k, k ) ) + cabs1( h( k+1, k+1 ) )
                       if( tst1==rzero ) then
                          if( k>=ktop+1 )tst1 = tst1 + cabs1( h( k, k-1 ) )
                          if( k>=ktop+2 )tst1 = tst1 + cabs1( h( k, k-2 ) )
                          if( k>=ktop+3 )tst1 = tst1 + cabs1( h( k, k-3 ) )
                          if( k<=kbot-2 )tst1 = tst1 + cabs1( h( k+2, k+1 ) )
                          if( k<=kbot-3 )tst1 = tst1 + cabs1( h( k+3, k+1 ) )
                          if( k<=kbot-4 )tst1 = tst1 + cabs1( h( k+4, k+1 ) )
                       end if
                       if( cabs1( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) )then
                          h12 = max( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                          h21 = min( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                          h11 = max( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                    
                          h22 = min( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                    
                          scl = h11 + h12
                          tst2 = h22*( h11 / scl )
                          if( tst2==rzero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) )h( k+1,&
                                     k ) = czero
                       end if
                    end if
                 end do loop_80
                 ! ==== multiply h by reflections from the left ====
                 if( accum ) then
                    jbot = min( ndcol, kbot )
                 else if( wantt ) then
                    jbot = n
                 else
                    jbot = kbot
                 end if
                 do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    do j = max( ktop, krcol + 2*m ), jbot
                       refsum = conjg( v( 1, m ) )*( h( k+1, j )+conjg( v( 2, m ) )*h( k+2, j )+&
                                 conjg( v( 3, m ) )*h( k+3, j ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m )
                       h( k+3, j ) = h( k+3, j ) - refsum*v( 3, m )
                    end do
                 end do
                 ! ==== accumulate orthogonal transformations. ====
                 if( accum ) then
                    ! ==== accumulate u. (if needed, update z later
                    ! .    with an efficient matrix-matrix
                    ! .    multiply.) ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       kms = k - incol
                       i2 = max( 1, ktop-incol )
                       i2 = max( i2, kms-(krcol-incol)+1 )
                       i4 = min( kdu, krcol + 2*( mbot-1 ) - incol + 5 )
                       do j = i2, i4
                          refsum = v( 1, m )*( u( j, kms+1 )+v( 2, m )*u( j, kms+2 )+v( 3, m )*u( &
                                    j, kms+3 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) -refsum*conjg( v( 2, m ) )
                          u( j, kms+3 ) = u( j, kms+3 ) -refsum*conjg( v( 3, m ) )
                       end do
                    end do
                 else if( wantz ) then
                    ! ==== u is not accumulated, so update z
                    ! .    now by multiplying by reflections
                    ! .    from the right. ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       do j = iloz, ihiz
                          refsum = v( 1, m )*( z( j, k+1 )+v( 2, m )*z( j, k+2 )+v( 3, m )*z( j, &
                                    k+3 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) -refsum*conjg( v( 2, m ) )
                          z( j, k+3 ) = z( j, k+3 ) -refsum*conjg( v( 3, m ) )
                       end do
                    end do
                 end if
                 ! ==== end of near-the-diagonal bulge chase. ====
              end do loop_145
              ! ==== use u (if accumulated) to update far-from-diagonal
              ! .    entries in h.  if required, use u to update z as
              ! .    well. ====
              if( accum ) then
                 if( wantt ) then
                    jtop = 1
                    jbot = n
                 else
                    jtop = ktop
                    jbot = kbot
                 end if
                 k1 = max( 1, ktop-incol )
                 nu = ( kdu-max( 0, ndcol-kbot ) ) - k1 + 1
                 ! ==== horizontal multiply ====
                 do jcol = min( ndcol, kbot ) + 1, jbot, nh
                    jlen = min( nh, jbot-jcol+1 )
                    call stdlib_zgemm( 'C', 'N', nu, jlen, nu, cone, u( k1, k1 ),ldu, h( incol+k1,&
                               jcol ), ldh, czero, wh,ldwh )
                    call stdlib_zlacpy( 'ALL', nu, jlen, wh, ldwh,h( incol+k1, jcol ), ldh )
                              
                 end do
                 ! ==== vertical multiply ====
                 do jrow = jtop, max( ktop, incol ) - 1, nv
                    jlen = min( nv, max( ktop, incol )-jrow )
                    call stdlib_zgemm( 'N', 'N', jlen, nu, nu, cone,h( jrow, incol+k1 ), ldh, u( &
                              k1, k1 ),ldu, czero, wv, ldwv )
                    call stdlib_zlacpy( 'ALL', jlen, nu, wv, ldwv,h( jrow, incol+k1 ), ldh )
                              
                 end do
                 ! ==== z multiply (also vertical) ====
                 if( wantz ) then
                    do jrow = iloz, ihiz, nv
                       jlen = min( nv, ihiz-jrow+1 )
                       call stdlib_zgemm( 'N', 'N', jlen, nu, nu, cone,z( jrow, incol+k1 ), ldz, &
                                 u( k1, k1 ),ldu, czero, wv, ldwv )
                       call stdlib_zlacpy( 'ALL', jlen, nu, wv, ldwv,z( jrow, incol+k1 ), ldz )
                                 
                    end do
                 end if
              end if
           end do loop_180
     end subroutine stdlib_zlaqr5

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$laqr5( wantt, wantz, kacc22, n, ktop, kbot, nshfts, s,h, ldh, iloz, &
     !! ZLAQR5:, called by ZLAQR0, performs a
     !! single small-bulge multi-shift QR sweep.
               ihiz, z, ldz, v, ldv, u, ldu, nv,wv, ldwv, nh, wh, ldwh )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kacc22, kbot, ktop, ldh, ldu, ldv, ldwh, ldwv, &
                     ldz, n, nh, nshfts, nv
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: h(ldh,*), s(*), z(ldz,*)
           complex(${ck}$), intent(out) :: u(ldu,*), v(ldv,*), wh(ldwh,*), wv(ldwv,*)
        ! ================================================================
           ! Parameters 
           real(${ck}$), parameter :: rzero = 0.0_${ck}$
           real(${ck}$), parameter :: rone = 1.0_${ck}$
           
           
           ! Local Scalars 
           complex(${ck}$) :: alpha, beta, cdum, refsum
           real(${ck}$) :: h11, h12, h21, h22, safmax, safmin, scl, smlnum, tst1, tst2, ulp
           integer(ilp) :: i2, i4, incol, j, jbot, jcol, jlen, jrow, jtop, k, k1, kdu, kms, krcol,&
                      m, m22, mbot, mtop, nbmps, ndcol, ns, nu
           logical(lk) :: accum, bmp22
           ! Intrinsic Functions 
           ! Local Arrays 
           complex(${ck}$) :: vt(3)
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! ==== if there are no shifts, then there is nothing to do. ====
           if( nshfts<2 )return
           ! ==== if the active block is empty or 1-by-1, then there
           ! .    is nothing to do. ====
           if( ktop>=kbot )return
           ! ==== nshfts is supposed to be even, but if it is odd,
           ! .    then simply reduce it by cone.  ====
           ns = nshfts - mod( nshfts, 2 )
           ! ==== machine constants for deflation ====
           safmin = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_${c2ri(ci)}$labad( safmin, safmax )
           ulp = stdlib_${c2ri(ci)}$lamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=${ck}$) / ulp )
           ! ==== use accumulated reflections to update far-from-diagonal
           ! .    entries ? ====
           accum = ( kacc22==1 ) .or. ( kacc22==2 )
           ! ==== clear trash ====
           if( ktop+2<=kbot )h( ktop+2, ktop ) = czero
           ! ==== nbmps = number of 2-shift bulges in the chain ====
           nbmps = ns / 2
           ! ==== kdu = width of slab ====
           kdu = 4*nbmps
           ! ==== create and chase chains of nbmps bulges ====
           loop_180: do incol = ktop - 2*nbmps + 1, kbot - 2, 2*nbmps
              ! jtop = index from which updates from the right start.
              if( accum ) then
                 jtop = max( ktop, incol )
              else if( wantt ) then
                 jtop = 1
              else
                 jtop = ktop
              end if
              ndcol = incol + kdu
              if( accum )call stdlib_${ci}$laset( 'ALL', kdu, kdu, czero, cone, u, ldu )
              ! ==== near-the-diagonal bulge chase.  the following loop
              ! .    performs the near-the-diagonal part of a small bulge
              ! .    multi-shift qr sweep.  each 4*nbmps column diagonal
              ! .    chunk extends from column incol to column ndcol
              ! .    (including both column incol and column ndcol). the
              ! .    following loop chases a 2*nbmps+1 column long chain of
              ! .    nbmps bulges 2*nbmps columns to the right.  (incol
              ! .    may be less than ktop and and ndcol may be greater than
              ! .    kbot indicating phantom columns from which to chase
              ! .    bulges before they are actually introduced or to which
              ! .    to chase bulges beyond column kbot.)  ====
              loop_145: do krcol = incol, min( incol+2*nbmps-1, kbot-2 )
                 ! ==== bulges number mtop to mbot are active double implicit
                 ! .    shift bulges.  there may or may not also be small
                 ! .    2-by-2 bulge, if there is room.  the inactive bulges
                 ! .    (if any) must wait until the active bulges have moved
                 ! .    down the diagonal to make room.  the phantom matrix
                 ! .    paradigm described above helps keep track.  ====
                 mtop = max( 1, ( ktop-krcol ) / 2+1 )
                 mbot = min( nbmps, ( kbot-krcol-1 ) / 2 )
                 m22 = mbot + 1
                 bmp22 = ( mbot<nbmps ) .and. ( krcol+2*( m22-1 ) )==( kbot-2 )
                 ! ==== generate reflections to chase the chain right
                 ! .    cone column.  (the minimum value of k is ktop-1.) ====
                 if ( bmp22 ) then
                    ! ==== special case: 2-by-2 reflection at bottom treated
                    ! .    separately ====
                    k = krcol + 2*( m22-1 )
                    if( k==ktop-1 ) then
                       call stdlib_${ci}$laqr1( 2, h( k+1, k+1 ), ldh, s( 2*m22-1 ),s( 2*m22 ), v( 1, &
                                 m22 ) )
                       beta = v( 1, m22 )
                       call stdlib_${ci}$larfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                    else
                       beta = h( k+1, k )
                       v( 2, m22 ) = h( k+2, k )
                       call stdlib_${ci}$larfg( 2, beta, v( 2, m22 ), 1, v( 1, m22 ) )
                       h( k+1, k ) = beta
                       h( k+2, k ) = czero
                    end if
                    ! ==== perform update from right within
                    ! .    computational window. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m22 )*( h( j, k+1 )+v( 2, m22 )*h( j, k+2 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) -refsum*conjg( v( 2, m22 ) )
                    end do
                    ! ==== perform update from left within
                    ! .    computational window. ====
                    if( accum ) then
                       jbot = min( ndcol, kbot )
                    else if( wantt ) then
                       jbot = n
                    else
                       jbot = kbot
                    end if
                    do j = k+1, jbot
                       refsum = conjg( v( 1, m22 ) )*( h( k+1, j )+conjg( v( 2, m22 ) )*h( k+2, j &
                                 ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m22 )
                    end do
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is czero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k>=ktop ) then
                       if( h( k+1, k )/=czero ) then
                          tst1 = cabs1( h( k, k ) ) + cabs1( h( k+1, k+1 ) )
                          if( tst1==rzero ) then
                             if( k>=ktop+1 )tst1 = tst1 + cabs1( h( k, k-1 ) )
                             if( k>=ktop+2 )tst1 = tst1 + cabs1( h( k, k-2 ) )
                             if( k>=ktop+3 )tst1 = tst1 + cabs1( h( k, k-3 ) )
                             if( k<=kbot-2 )tst1 = tst1 + cabs1( h( k+2, k+1 ) )
                             if( k<=kbot-3 )tst1 = tst1 + cabs1( h( k+3, k+1 ) )
                             if( k<=kbot-4 )tst1 = tst1 + cabs1( h( k+4, k+1 ) )
                          end if
                          if( cabs1( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) ) then
                             h12 = max( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                             h21 = min( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                             h11 = max( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             h22 = min( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                       
                             scl = h11 + h12
                             tst2 = h22*( h11 / scl )
                             if( tst2==rzero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) )h( &
                                       k+1, k ) = czero
                          end if
                       end if
                    end if
                    ! ==== accumulate orthogonal transformations. ====
                    if( accum ) then
                       kms = k - incol
                       do j = max( 1, ktop-incol ), kdu
                          refsum = v( 1, m22 )*( u( j, kms+1 )+v( 2, m22 )*u( j, kms+2 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) -refsum*conjg( v( 2, m22 ) )
                       end do
                    else if( wantz ) then
                       do j = iloz, ihiz
                          refsum = v( 1, m22 )*( z( j, k+1 )+v( 2, m22 )*z( j, k+2 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) -refsum*conjg( v( 2, m22 ) )
                       end do
                    end if
                 end if
                 ! ==== normal case: chain of 3-by-3 reflections ====
                 loop_80: do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    if( k==ktop-1 ) then
                       call stdlib_${ci}$laqr1( 3, h( ktop, ktop ), ldh, s( 2*m-1 ),s( 2*m ), v( 1, m )&
                                  )
                       alpha = v( 1, m )
                       call stdlib_${ci}$larfg( 3, alpha, v( 2, m ), 1, v( 1, m ) )
                    else
                       ! ==== perform delayed transformation of row below
                       ! .    mth bulge. exploit fact that first two elements
                       ! .    of row are actually czero. ====
                       refsum = v( 1, m )*v( 3, m )*h( k+3, k+2 )
                       h( k+3, k   ) = -refsum
                       h( k+3, k+1 ) = -refsum*conjg( v( 2, m ) )
                       h( k+3, k+2 ) = h( k+3, k+2 ) -refsum*conjg( v( 3, m ) )
                       ! ==== calculate reflection to move
                       ! .    mth bulge cone step. ====
                       beta      = h( k+1, k )
                       v( 2, m ) = h( k+2, k )
                       v( 3, m ) = h( k+3, k )
                       call stdlib_${ci}$larfg( 3, beta, v( 2, m ), 1, v( 1, m ) )
                       ! ==== a bulge may collapse because of vigilant
                       ! .    deflation or destructive underflow.  in the
                       ! .    underflow case, try the two-small-subdiagonals
                       ! .    trick to try to reinflate the bulge.  ====
                       if( h( k+3, k )/=czero .or. h( k+3, k+1 )/=czero .or. h( k+3, k+2 )==czero &
                                 ) then
                          ! ==== typical case: not collapsed (yet). ====
                          h( k+1, k ) = beta
                          h( k+2, k ) = czero
                          h( k+3, k ) = czero
                       else
                          ! ==== atypical case: collapsed.  attempt to
                          ! .    reintroduce ignoring h(k+1,k) and h(k+2,k).
                          ! .    if the fill resulting from the new
                          ! .    reflector is too large, then abandon it.
                          ! .    otherwise, use the new cone. ====
                          call stdlib_${ci}$laqr1( 3, h( k+1, k+1 ), ldh, s( 2*m-1 ),s( 2*m ), vt )
                                    
                          alpha = vt( 1 )
                          call stdlib_${ci}$larfg( 3, alpha, vt( 2 ), 1, vt( 1 ) )
                          refsum = conjg( vt( 1 ) )*( h( k+1, k )+conjg( vt( 2 ) )*h( k+2, k ) )
                                    
                          if( cabs1( h( k+2, k )-refsum*vt( 2 ) )+cabs1( refsum*vt( 3 ) )>ulp*( &
                          cabs1( h( k, k ) )+cabs1( h( k+1,k+1 ) )+cabs1( h( k+2, k+2 ) ) ) ) &
                                    then
                             ! ==== starting a new bulge here would
                             ! .    create non-negligible fill.  use
                             ! .    the old cone with trepidation. ====
                             h( k+1, k ) = beta
                             h( k+2, k ) = czero
                             h( k+3, k ) = czero
                          else
                             ! ==== starting a new bulge here would
                             ! .    create only negligible fill.
                             ! .    replace the old reflector with
                             ! .    the new cone. ====
                             h( k+1, k ) = h( k+1, k ) - refsum
                             h( k+2, k ) = czero
                             h( k+3, k ) = czero
                             v( 1, m ) = vt( 1 )
                             v( 2, m ) = vt( 2 )
                             v( 3, m ) = vt( 3 )
                          end if
                       end if
                    end if
                    ! ====  apply reflection from the right and
                    ! .     the first column of update from the left.
                    ! .     these updates are required for the vigilant
                    ! .     deflation check. we still delay most of the
                    ! .     updates from the left for efficiency. ====
                    do j = jtop, min( kbot, k+3 )
                       refsum = v( 1, m )*( h( j, k+1 )+v( 2, m )*h( j, k+2 )+v( 3, m )*h( j, k+3 &
                                 ) )
                       h( j, k+1 ) = h( j, k+1 ) - refsum
                       h( j, k+2 ) = h( j, k+2 ) -refsum*conjg( v( 2, m ) )
                       h( j, k+3 ) = h( j, k+3 ) -refsum*conjg( v( 3, m ) )
                    end do
                    ! ==== perform update from left for subsequent
                    ! .    column. ====
                    refsum =  conjg( v( 1, m ) )*( h( k+1, k+1 )+conjg( v( 2, m ) )*h( k+2, k+1 )+&
                              conjg( v( 3, m ) )*h( k+3, k+1 ) )
                    h( k+1, k+1 ) = h( k+1, k+1 ) - refsum
                    h( k+2, k+1 ) = h( k+2, k+1 ) - refsum*v( 2, m )
                    h( k+3, k+1 ) = h( k+3, k+1 ) - refsum*v( 3, m )
                    ! ==== the following convergence test requires that
                    ! .    the tradition small-compared-to-nearby-diagonals
                    ! .    criterion and the ahues
                    ! .    criteria both be satisfied.  the latter improves
                    ! .    accuracy in some examples. falling back on an
                    ! .    alternate convergence criterion when tst1 or tst2
                    ! .    is czero (as done here) is traditional but probably
                    ! .    unnecessary. ====
                    if( k<ktop)cycle
                    if( h( k+1, k )/=czero ) then
                       tst1 = cabs1( h( k, k ) ) + cabs1( h( k+1, k+1 ) )
                       if( tst1==rzero ) then
                          if( k>=ktop+1 )tst1 = tst1 + cabs1( h( k, k-1 ) )
                          if( k>=ktop+2 )tst1 = tst1 + cabs1( h( k, k-2 ) )
                          if( k>=ktop+3 )tst1 = tst1 + cabs1( h( k, k-3 ) )
                          if( k<=kbot-2 )tst1 = tst1 + cabs1( h( k+2, k+1 ) )
                          if( k<=kbot-3 )tst1 = tst1 + cabs1( h( k+3, k+1 ) )
                          if( k<=kbot-4 )tst1 = tst1 + cabs1( h( k+4, k+1 ) )
                       end if
                       if( cabs1( h( k+1, k ) )<=max( smlnum, ulp*tst1 ) )then
                          h12 = max( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                          h21 = min( cabs1( h( k+1, k ) ),cabs1( h( k, k+1 ) ) )
                          h11 = max( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                    
                          h22 = min( cabs1( h( k+1, k+1 ) ),cabs1( h( k, k )-h( k+1, k+1 ) ) )
                                    
                          scl = h11 + h12
                          tst2 = h22*( h11 / scl )
                          if( tst2==rzero .or. h21*( h12 / scl )<=max( smlnum, ulp*tst2 ) )h( k+1,&
                                     k ) = czero
                       end if
                    end if
                 end do loop_80
                 ! ==== multiply h by reflections from the left ====
                 if( accum ) then
                    jbot = min( ndcol, kbot )
                 else if( wantt ) then
                    jbot = n
                 else
                    jbot = kbot
                 end if
                 do m = mbot, mtop, -1
                    k = krcol + 2*( m-1 )
                    do j = max( ktop, krcol + 2*m ), jbot
                       refsum = conjg( v( 1, m ) )*( h( k+1, j )+conjg( v( 2, m ) )*h( k+2, j )+&
                                 conjg( v( 3, m ) )*h( k+3, j ) )
                       h( k+1, j ) = h( k+1, j ) - refsum
                       h( k+2, j ) = h( k+2, j ) - refsum*v( 2, m )
                       h( k+3, j ) = h( k+3, j ) - refsum*v( 3, m )
                    end do
                 end do
                 ! ==== accumulate orthogonal transformations. ====
                 if( accum ) then
                    ! ==== accumulate u. (if needed, update z later
                    ! .    with an efficient matrix-matrix
                    ! .    multiply.) ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       kms = k - incol
                       i2 = max( 1, ktop-incol )
                       i2 = max( i2, kms-(krcol-incol)+1 )
                       i4 = min( kdu, krcol + 2*( mbot-1 ) - incol + 5 )
                       do j = i2, i4
                          refsum = v( 1, m )*( u( j, kms+1 )+v( 2, m )*u( j, kms+2 )+v( 3, m )*u( &
                                    j, kms+3 ) )
                          u( j, kms+1 ) = u( j, kms+1 ) - refsum
                          u( j, kms+2 ) = u( j, kms+2 ) -refsum*conjg( v( 2, m ) )
                          u( j, kms+3 ) = u( j, kms+3 ) -refsum*conjg( v( 3, m ) )
                       end do
                    end do
                 else if( wantz ) then
                    ! ==== u is not accumulated, so update z
                    ! .    now by multiplying by reflections
                    ! .    from the right. ====
                    do m = mbot, mtop, -1
                       k = krcol + 2*( m-1 )
                       do j = iloz, ihiz
                          refsum = v( 1, m )*( z( j, k+1 )+v( 2, m )*z( j, k+2 )+v( 3, m )*z( j, &
                                    k+3 ) )
                          z( j, k+1 ) = z( j, k+1 ) - refsum
                          z( j, k+2 ) = z( j, k+2 ) -refsum*conjg( v( 2, m ) )
                          z( j, k+3 ) = z( j, k+3 ) -refsum*conjg( v( 3, m ) )
                       end do
                    end do
                 end if
                 ! ==== end of near-the-diagonal bulge chase. ====
              end do loop_145
              ! ==== use u (if accumulated) to update far-from-diagonal
              ! .    entries in h.  if required, use u to update z as
              ! .    well. ====
              if( accum ) then
                 if( wantt ) then
                    jtop = 1
                    jbot = n
                 else
                    jtop = ktop
                    jbot = kbot
                 end if
                 k1 = max( 1, ktop-incol )
                 nu = ( kdu-max( 0, ndcol-kbot ) ) - k1 + 1
                 ! ==== horizontal multiply ====
                 do jcol = min( ndcol, kbot ) + 1, jbot, nh
                    jlen = min( nh, jbot-jcol+1 )
                    call stdlib_${ci}$gemm( 'C', 'N', nu, jlen, nu, cone, u( k1, k1 ),ldu, h( incol+k1,&
                               jcol ), ldh, czero, wh,ldwh )
                    call stdlib_${ci}$lacpy( 'ALL', nu, jlen, wh, ldwh,h( incol+k1, jcol ), ldh )
                              
                 end do
                 ! ==== vertical multiply ====
                 do jrow = jtop, max( ktop, incol ) - 1, nv
                    jlen = min( nv, max( ktop, incol )-jrow )
                    call stdlib_${ci}$gemm( 'N', 'N', jlen, nu, nu, cone,h( jrow, incol+k1 ), ldh, u( &
                              k1, k1 ),ldu, czero, wv, ldwv )
                    call stdlib_${ci}$lacpy( 'ALL', jlen, nu, wv, ldwv,h( jrow, incol+k1 ), ldh )
                              
                 end do
                 ! ==== z multiply (also vertical) ====
                 if( wantz ) then
                    do jrow = iloz, ihiz, nv
                       jlen = min( nv, ihiz-jrow+1 )
                       call stdlib_${ci}$gemm( 'N', 'N', jlen, nu, nu, cone,z( jrow, incol+k1 ), ldz, &
                                 u( k1, k1 ),ldu, czero, wv, ldwv )
                       call stdlib_${ci}$lacpy( 'ALL', jlen, nu, wv, ldwv,z( jrow, incol+k1 ), ldz )
                                 
                    end do
                 end if
              end if
           end do loop_180
     end subroutine stdlib_${ci}$laqr5

#:endif
#:endfor





     pure subroutine stdlib_slaqz1( a, lda, b, ldb, sr1, sr2, si, beta1, beta2,v )
     !! Given a 3-by-3 matrix pencil (A,B), SLAQZ1: sets v to a
     !! scalar multiple of the first column of the product
     !! (*)  K = (A - (beta2*sr2 - i*si)*B)*B^(-1)*(beta1*A - (sr2 + i*si2)*B)*B^(-1).
     !! It is assumed that either
     !! 1) sr1 = sr2
     !! or
     !! 2) si = 0.
     !! This is useful for starting double implicit shift bulges
     !! in the QZ algorithm.
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           integer(ilp), intent( in ) :: lda, ldb
           real(sp), intent( in ) :: a( lda, * ), b( ldb, * ), sr1, sr2, si,beta1, beta2
           real(sp), intent( out ) :: v( * )
           
           ! local scalars
           real(sp) :: w(2), safmin, safmax, scale1, scale2
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           ! calculate first shifted vector
           w( 1 ) = beta1*a( 1, 1 )-sr1*b( 1, 1 )
           w( 2 ) = beta1*a( 2, 1 )-sr1*b( 2, 1 )
           scale1 = sqrt( abs( w( 1 ) ) ) * sqrt( abs( w( 2 ) ) )
           if( scale1 >= safmin .and. scale1 <= safmax ) then
              w( 1 ) = w( 1 )/scale1
              w( 2 ) = w( 2 )/scale1
           end if
           ! solve linear system
           w( 2 ) = w( 2 )/b( 2, 2 )
           w( 1 ) = ( w( 1 )-b( 1, 2 )*w( 2 ) )/b( 1, 1 )
           scale2 = sqrt( abs( w( 1 ) ) ) * sqrt( abs( w( 2 ) ) )
           if( scale2 >= safmin .and. scale2 <= safmax ) then
              w( 1 ) = w( 1 )/scale2
              w( 2 ) = w( 2 )/scale2
           end if
           ! apply second shift
           v( 1 ) = beta2*( a( 1, 1 )*w( 1 )+a( 1, 2 )*w( 2 ) )-sr2*( b( 1,1 )*w( 1 )+b( 1, 2 )*w(&
                      2 ) )
           v( 2 ) = beta2*( a( 2, 1 )*w( 1 )+a( 2, 2 )*w( 2 ) )-sr2*( b( 2,1 )*w( 1 )+b( 2, 2 )*w(&
                      2 ) )
           v( 3 ) = beta2*( a( 3, 1 )*w( 1 )+a( 3, 2 )*w( 2 ) )-sr2*( b( 3,1 )*w( 1 )+b( 3, 2 )*w(&
                      2 ) )
           ! account for imaginary part
           v( 1 ) = v( 1 )+si*si*b( 1, 1 )/scale1/scale2
           ! check for overflow
           if( abs( v( 1 ) )>safmax .or. abs( v( 2 ) ) > safmax .or.abs( v( 3 ) )>safmax .or. &
           stdlib_sisnan( v( 1 ) ) .or.stdlib_sisnan( v( 2 ) ) .or. stdlib_sisnan( v( 3 ) ) ) &
                     then
              v( 1 ) = zero
              v( 2 ) = zero
              v( 3 ) = zero
           end if
     end subroutine stdlib_slaqz1

     pure subroutine stdlib_dlaqz1( a, lda, b, ldb, sr1, sr2, si, beta1, beta2,v )
     !! Given a 3-by-3 matrix pencil (A,B), DLAQZ1: sets v to a
     !! scalar multiple of the first column of the product
     !! (*)  K = (A - (beta2*sr2 - i*si)*B)*B^(-1)*(beta1*A - (sr2 + i*si2)*B)*B^(-1).
     !! It is assumed that either
     !! 1) sr1 = sr2
     !! or
     !! 2) si = 0.
     !! This is useful for starting double implicit shift bulges
     !! in the QZ algorithm.
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           integer(ilp), intent( in ) :: lda, ldb
           real(dp), intent( in ) :: a( lda, * ), b( ldb, * ), sr1,sr2, si, beta1, beta2
           real(dp), intent( out ) :: v( * )
           
           ! local scalars
           real(dp) :: w(2), safmin, safmax, scale1, scale2
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           ! calculate first shifted vector
           w( 1 ) = beta1*a( 1, 1 )-sr1*b( 1, 1 )
           w( 2 ) = beta1*a( 2, 1 )-sr1*b( 2, 1 )
           scale1 = sqrt( abs( w( 1 ) ) ) * sqrt( abs( w( 2 ) ) )
           if( scale1 >= safmin .and. scale1 <= safmax ) then
              w( 1 ) = w( 1 )/scale1
              w( 2 ) = w( 2 )/scale1
           end if
           ! solve linear system
           w( 2 ) = w( 2 )/b( 2, 2 )
           w( 1 ) = ( w( 1 )-b( 1, 2 )*w( 2 ) )/b( 1, 1 )
           scale2 = sqrt( abs( w( 1 ) ) ) * sqrt( abs( w( 2 ) ) )
           if( scale2 >= safmin .and. scale2 <= safmax ) then
              w( 1 ) = w( 1 )/scale2
              w( 2 ) = w( 2 )/scale2
           end if
           ! apply second shift
           v( 1 ) = beta2*( a( 1, 1 )*w( 1 )+a( 1, 2 )*w( 2 ) )-sr2*( b( 1,1 )*w( 1 )+b( 1, 2 )*w(&
                      2 ) )
           v( 2 ) = beta2*( a( 2, 1 )*w( 1 )+a( 2, 2 )*w( 2 ) )-sr2*( b( 2,1 )*w( 1 )+b( 2, 2 )*w(&
                      2 ) )
           v( 3 ) = beta2*( a( 3, 1 )*w( 1 )+a( 3, 2 )*w( 2 ) )-sr2*( b( 3,1 )*w( 1 )+b( 3, 2 )*w(&
                      2 ) )
           ! account for imaginary part
           v( 1 ) = v( 1 )+si*si*b( 1, 1 )/scale1/scale2
           ! check for overflow
           if( abs( v( 1 ) )>safmax .or. abs( v( 2 ) ) > safmax .or.abs( v( 3 ) )>safmax .or. &
           stdlib_disnan( v( 1 ) ) .or.stdlib_disnan( v( 2 ) ) .or. stdlib_disnan( v( 3 ) ) ) &
                     then
              v( 1 ) = zero
              v( 2 ) = zero
              v( 3 ) = zero
           end if
     end subroutine stdlib_dlaqz1

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$laqz1( a, lda, b, ldb, sr1, sr2, si, beta1, beta2,v )
     !! Given a 3-by-3 matrix pencil (A,B), DLAQZ1: sets v to a
     !! scalar multiple of the first column of the product
     !! (*)  K = (A - (beta2*sr2 - i*si)*B)*B^(-1)*(beta1*A - (sr2 + i*si2)*B)*B^(-1).
     !! It is assumed that either
     !! 1) sr1 = sr2
     !! or
     !! 2) si = 0.
     !! This is useful for starting double implicit shift bulges
     !! in the QZ algorithm.
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           integer(ilp), intent( in ) :: lda, ldb
           real(${rk}$), intent( in ) :: a( lda, * ), b( ldb, * ), sr1,sr2, si, beta1, beta2
           real(${rk}$), intent( out ) :: v( * )
           
           ! local scalars
           real(${rk}$) :: w(2), safmin, safmax, scale1, scale2
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safmax = one/safmin
           ! calculate first shifted vector
           w( 1 ) = beta1*a( 1, 1 )-sr1*b( 1, 1 )
           w( 2 ) = beta1*a( 2, 1 )-sr1*b( 2, 1 )
           scale1 = sqrt( abs( w( 1 ) ) ) * sqrt( abs( w( 2 ) ) )
           if( scale1 >= safmin .and. scale1 <= safmax ) then
              w( 1 ) = w( 1 )/scale1
              w( 2 ) = w( 2 )/scale1
           end if
           ! solve linear system
           w( 2 ) = w( 2 )/b( 2, 2 )
           w( 1 ) = ( w( 1 )-b( 1, 2 )*w( 2 ) )/b( 1, 1 )
           scale2 = sqrt( abs( w( 1 ) ) ) * sqrt( abs( w( 2 ) ) )
           if( scale2 >= safmin .and. scale2 <= safmax ) then
              w( 1 ) = w( 1 )/scale2
              w( 2 ) = w( 2 )/scale2
           end if
           ! apply second shift
           v( 1 ) = beta2*( a( 1, 1 )*w( 1 )+a( 1, 2 )*w( 2 ) )-sr2*( b( 1,1 )*w( 1 )+b( 1, 2 )*w(&
                      2 ) )
           v( 2 ) = beta2*( a( 2, 1 )*w( 1 )+a( 2, 2 )*w( 2 ) )-sr2*( b( 2,1 )*w( 1 )+b( 2, 2 )*w(&
                      2 ) )
           v( 3 ) = beta2*( a( 3, 1 )*w( 1 )+a( 3, 2 )*w( 2 ) )-sr2*( b( 3,1 )*w( 1 )+b( 3, 2 )*w(&
                      2 ) )
           ! account for imaginary part
           v( 1 ) = v( 1 )+si*si*b( 1, 1 )/scale1/scale2
           ! check for overflow
           if( abs( v( 1 ) )>safmax .or. abs( v( 2 ) ) > safmax .or.abs( v( 3 ) )>safmax .or. &
           stdlib_${ri}$isnan( v( 1 ) ) .or.stdlib_${ri}$isnan( v( 2 ) ) .or. stdlib_${ri}$isnan( v( 3 ) ) ) &
                     then
              v( 1 ) = zero
              v( 2 ) = zero
              v( 3 ) = zero
           end if
     end subroutine stdlib_${ri}$laqz1

#:endif
#:endfor

     pure subroutine stdlib_claqz1( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, qstart, &
     !! CLAQZ1 chases a 1x1 shift bulge in a matrix pencil down a single position
               q, ldq, nz, zstart, z, ldz )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           logical(lk), intent( in ) :: ilq, ilz
           integer(ilp), intent( in ) :: k, lda, ldb, ldq, ldz, istartm, istopm,nq, nz, qstart, &
                     zstart, ihi
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           
           
           ! local variables
           real(sp) :: c
           complex(sp) :: s, temp
           if( k+1 == ihi ) then
              ! shift is located on the edge of the matrix, remove it
              call stdlib_clartg( b( ihi, ihi ), b( ihi, ihi-1 ), c, s, temp )
              b( ihi, ihi ) = temp
              b( ihi, ihi-1 ) = czero
              call stdlib_crot( ihi-istartm, b( istartm, ihi ), 1, b( istartm,ihi-1 ), 1, c, s )
                        
              call stdlib_crot( ihi-istartm+1, a( istartm, ihi ), 1, a( istartm,ihi-1 ), 1, c, s )
                        
              if ( ilz ) then
                 call stdlib_crot( nz, z( 1, ihi-zstart+1 ), 1, z( 1, ihi-1-zstart+1 ), 1, c, s )
                           
              end if
           else
              ! normal operation, move bulge down
              ! apply transformation from the right
              call stdlib_clartg( b( k+1, k+1 ), b( k+1, k ), c, s, temp )
              b( k+1, k+1 ) = temp
              b( k+1, k ) = czero
              call stdlib_crot( k+2-istartm+1, a( istartm, k+1 ), 1, a( istartm,k ), 1, c, s )
                        
              call stdlib_crot( k-istartm+1, b( istartm, k+1 ), 1, b( istartm, k ),1, c, s )
                        
              if ( ilz ) then
                 call stdlib_crot( nz, z( 1, k+1-zstart+1 ), 1, z( 1, k-zstart+1 ),1, c, s )
                           
              end if
              ! apply transformation from the left
              call stdlib_clartg( a( k+1, k ), a( k+2, k ), c, s, temp )
              a( k+1, k ) = temp
              a( k+2, k ) = czero
              call stdlib_crot( istopm-k, a( k+1, k+1 ), lda, a( k+2, k+1 ), lda, c,s )
              call stdlib_crot( istopm-k, b( k+1, k+1 ), ldb, b( k+2, k+1 ), ldb, c,s )
              if ( ilq ) then
                 call stdlib_crot( nq, q( 1, k+1-qstart+1 ), 1, q( 1, k+2-qstart+1 ), 1, c, conjg(&
                            s ) )
              end if
           end if
     end subroutine stdlib_claqz1

     pure subroutine stdlib_zlaqz1( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, qstart, &
     !! ZLAQZ1 chases a 1x1 shift bulge in a matrix pencil down a single position
               q, ldq, nz, zstart, z, ldz )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           logical(lk), intent( in ) :: ilq, ilz
           integer(ilp), intent( in ) :: k, lda, ldb, ldq, ldz, istartm, istopm,nq, nz, qstart, &
                     zstart, ihi
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           
           
           ! local variables
           real(dp) :: c
           complex(dp) :: s, temp
           if( k+1 == ihi ) then
              ! shift is located on the edge of the matrix, remove it
              call stdlib_zlartg( b( ihi, ihi ), b( ihi, ihi-1 ), c, s, temp )
              b( ihi, ihi ) = temp
              b( ihi, ihi-1 ) = czero
              call stdlib_zrot( ihi-istartm, b( istartm, ihi ), 1, b( istartm,ihi-1 ), 1, c, s )
                        
              call stdlib_zrot( ihi-istartm+1, a( istartm, ihi ), 1, a( istartm,ihi-1 ), 1, c, s )
                        
              if ( ilz ) then
                 call stdlib_zrot( nz, z( 1, ihi-zstart+1 ), 1, z( 1, ihi-1-zstart+1 ), 1, c, s )
                           
              end if
           else
              ! normal operation, move bulge down
              ! apply transformation from the right
              call stdlib_zlartg( b( k+1, k+1 ), b( k+1, k ), c, s, temp )
              b( k+1, k+1 ) = temp
              b( k+1, k ) = czero
              call stdlib_zrot( k+2-istartm+1, a( istartm, k+1 ), 1, a( istartm,k ), 1, c, s )
                        
              call stdlib_zrot( k-istartm+1, b( istartm, k+1 ), 1, b( istartm, k ),1, c, s )
                        
              if ( ilz ) then
                 call stdlib_zrot( nz, z( 1, k+1-zstart+1 ), 1, z( 1, k-zstart+1 ),1, c, s )
                           
              end if
              ! apply transformation from the left
              call stdlib_zlartg( a( k+1, k ), a( k+2, k ), c, s, temp )
              a( k+1, k ) = temp
              a( k+2, k ) = czero
              call stdlib_zrot( istopm-k, a( k+1, k+1 ), lda, a( k+2, k+1 ), lda, c,s )
              call stdlib_zrot( istopm-k, b( k+1, k+1 ), ldb, b( k+2, k+1 ), ldb, c,s )
              if ( ilq ) then
                 call stdlib_zrot( nq, q( 1, k+1-qstart+1 ), 1, q( 1, k+2-qstart+1 ), 1, c, conjg(&
                            s ) )
              end if
           end if
     end subroutine stdlib_zlaqz1

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$laqz1( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, qstart, &
     !! ZLAQZ1: chases a 1x1 shift bulge in a matrix pencil down a single position
               q, ldq, nz, zstart, z, ldz )
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           logical(lk), intent( in ) :: ilq, ilz
           integer(ilp), intent( in ) :: k, lda, ldb, ldq, ldz, istartm, istopm,nq, nz, qstart, &
                     zstart, ihi
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           
           
           ! local variables
           real(${ck}$) :: c
           complex(${ck}$) :: s, temp
           if( k+1 == ihi ) then
              ! shift is located on the edge of the matrix, remove it
              call stdlib_${ci}$lartg( b( ihi, ihi ), b( ihi, ihi-1 ), c, s, temp )
              b( ihi, ihi ) = temp
              b( ihi, ihi-1 ) = czero
              call stdlib_${ci}$rot( ihi-istartm, b( istartm, ihi ), 1, b( istartm,ihi-1 ), 1, c, s )
                        
              call stdlib_${ci}$rot( ihi-istartm+1, a( istartm, ihi ), 1, a( istartm,ihi-1 ), 1, c, s )
                        
              if ( ilz ) then
                 call stdlib_${ci}$rot( nz, z( 1, ihi-zstart+1 ), 1, z( 1, ihi-1-zstart+1 ), 1, c, s )
                           
              end if
           else
              ! normal operation, move bulge down
              ! apply transformation from the right
              call stdlib_${ci}$lartg( b( k+1, k+1 ), b( k+1, k ), c, s, temp )
              b( k+1, k+1 ) = temp
              b( k+1, k ) = czero
              call stdlib_${ci}$rot( k+2-istartm+1, a( istartm, k+1 ), 1, a( istartm,k ), 1, c, s )
                        
              call stdlib_${ci}$rot( k-istartm+1, b( istartm, k+1 ), 1, b( istartm, k ),1, c, s )
                        
              if ( ilz ) then
                 call stdlib_${ci}$rot( nz, z( 1, k+1-zstart+1 ), 1, z( 1, k-zstart+1 ),1, c, s )
                           
              end if
              ! apply transformation from the left
              call stdlib_${ci}$lartg( a( k+1, k ), a( k+2, k ), c, s, temp )
              a( k+1, k ) = temp
              a( k+2, k ) = czero
              call stdlib_${ci}$rot( istopm-k, a( k+1, k+1 ), lda, a( k+2, k+1 ), lda, c,s )
              call stdlib_${ci}$rot( istopm-k, b( k+1, k+1 ), ldb, b( k+2, k+1 ), ldb, c,s )
              if ( ilq ) then
                 call stdlib_${ci}$rot( nq, q( 1, k+1-qstart+1 ), 1, q( 1, k+2-qstart+1 ), 1, c, conjg(&
                            s ) )
              end if
           end if
     end subroutine stdlib_${ci}$laqz1

#:endif
#:endfor



     pure subroutine stdlib_sorghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! SORGHR generates a real orthogonal matrix Q which is defined as the
     !! product of IHI-ILO elementary reflectors of order N, as returned by
     !! SGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(in) :: tau(*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, iinfo, j, lwkopt, nb, nh
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, nh ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              nb = stdlib_ilaenv( 1, 'SORGQR', ' ', nh, nh, nh, -1 )
              lwkopt = max( 1, nh )*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SORGHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           ! shift the vectors which define the elementary reflectors one
           ! column to the right, and set the first ilo and the last n-ihi
           ! rows and columns to those of the unit matrix
           do j = ihi, ilo + 1, -1
              do i = 1, j - 1
                 a( i, j ) = zero
              end do
              do i = j + 1, ihi
                 a( i, j ) = a( i, j-1 )
              end do
              do i = ihi + 1, n
                 a( i, j ) = zero
              end do
           end do
           do j = 1, ilo
              do i = 1, n
                 a( i, j ) = zero
              end do
              a( j, j ) = one
           end do
           do j = ihi + 1, n
              do i = 1, n
                 a( i, j ) = zero
              end do
              a( j, j ) = one
           end do
           if( nh>0 ) then
              ! generate q(ilo+1:ihi,ilo+1:ihi)
              call stdlib_sorgqr( nh, nh, nh, a( ilo+1, ilo+1 ), lda, tau( ilo ),work, lwork, &
                        iinfo )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_sorghr

     pure subroutine stdlib_dorghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! DORGHR generates a real orthogonal matrix Q which is defined as the
     !! product of IHI-ILO elementary reflectors of order N, as returned by
     !! DGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(in) :: tau(*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, iinfo, j, lwkopt, nb, nh
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, nh ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              nb = stdlib_ilaenv( 1, 'DORGQR', ' ', nh, nh, nh, -1 )
              lwkopt = max( 1, nh )*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORGHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           ! shift the vectors which define the elementary reflectors one
           ! column to the right, and set the first ilo and the last n-ihi
           ! rows and columns to those of the unit matrix
           do j = ihi, ilo + 1, -1
              do i = 1, j - 1
                 a( i, j ) = zero
              end do
              do i = j + 1, ihi
                 a( i, j ) = a( i, j-1 )
              end do
              do i = ihi + 1, n
                 a( i, j ) = zero
              end do
           end do
           do j = 1, ilo
              do i = 1, n
                 a( i, j ) = zero
              end do
              a( j, j ) = one
           end do
           do j = ihi + 1, n
              do i = 1, n
                 a( i, j ) = zero
              end do
              a( j, j ) = one
           end do
           if( nh>0 ) then
              ! generate q(ilo+1:ihi,ilo+1:ihi)
              call stdlib_dorgqr( nh, nh, nh, a( ilo+1, ilo+1 ), lda, tau( ilo ),work, lwork, &
                        iinfo )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dorghr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$orghr( n, ilo, ihi, a, lda, tau, work, lwork, info )
     !! DORGHR: generates a real orthogonal matrix Q which is defined as the
     !! product of IHI-ILO elementary reflectors of order N, as returned by
     !! DGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihi, ilo, lda, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, iinfo, j, lwkopt, nb, nh
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( ilo<1 .or. ilo>max( 1, n ) ) then
              info = -2
           else if( ihi<min( ilo, n ) .or. ihi>n ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( lwork<max( 1, nh ) .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              nb = stdlib_ilaenv( 1, 'DORGQR', ' ', nh, nh, nh, -1 )
              lwkopt = max( 1, nh )*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORGHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           ! shift the vectors which define the elementary reflectors one
           ! column to the right, and set the first ilo and the last n-ihi
           ! rows and columns to those of the unit matrix
           do j = ihi, ilo + 1, -1
              do i = 1, j - 1
                 a( i, j ) = zero
              end do
              do i = j + 1, ihi
                 a( i, j ) = a( i, j-1 )
              end do
              do i = ihi + 1, n
                 a( i, j ) = zero
              end do
           end do
           do j = 1, ilo
              do i = 1, n
                 a( i, j ) = zero
              end do
              a( j, j ) = one
           end do
           do j = ihi + 1, n
              do i = 1, n
                 a( i, j ) = zero
              end do
              a( j, j ) = one
           end do
           if( nh>0 ) then
              ! generate q(ilo+1:ihi,ilo+1:ihi)
              call stdlib_${ri}$orgqr( nh, nh, nh, a( ilo+1, ilo+1 ), lda, tau( ilo ),work, lwork, &
                        iinfo )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$orghr

#:endif
#:endfor





     pure subroutine stdlib_slasy2( ltranl, ltranr, isgn, n1, n2, tl, ldtl, tr,ldtr, b, ldb, &
     !! SLASY2 solves for the N1 by N2 matrix X, 1 <= N1,N2 <= 2, in
     !! op(TL)*X + ISGN*X*op(TR) = SCALE*B,
     !! where TL is N1 by N1, TR is N2 by N2, B is N1 by N2, and ISGN = 1 or
     !! -1.  op(T) = T or T**T, where T**T denotes the transpose of T.
               scale, x, ldx, xnorm, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: ltranl, ltranr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: isgn, ldb, ldtl, ldtr, ldx, n1, n2
           real(sp), intent(out) :: scale, xnorm
           ! Array Arguments 
           real(sp), intent(in) :: b(ldb,*), tl(ldtl,*), tr(ldtr,*)
           real(sp), intent(out) :: x(ldx,*)
       ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: bswap, xswap
           integer(ilp) :: i, ip, ipiv, ipsv, j, jp, jpsv, k
           real(sp) :: bet, eps, gam, l21, sgn, smin, smlnum, tau1, temp, u11, u12, u22, &
                     xmax
           ! Local Arrays 
           logical(lk) :: bswpiv(4), xswpiv(4)
           integer(ilp) :: jpiv(4), locl21(4), locu12(4), locu22(4)
           real(sp) :: btmp(4), t16(4,4), tmp(4), x2(2)
           ! Intrinsic Functions 
           ! Data Statements 
           locu12 = [3,4,1,2]
           locl21 = [2,1,4,3]
           locu22 = [4,3,2,1]
           xswpiv = [.false.,.false.,.true.,.true.]
           bswpiv = [.false.,.true.,.false.,.true.]
           ! Executable Statements 
           ! do not check the input parameters for errors
           info = 0
           ! quick return if possible
           if( n1==0 .or. n2==0 )return
           ! set constants to control overflow
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' ) / eps
           sgn = isgn
           k = n1 + n1 + n2 - 2
           go to ( 10, 20, 30, 50 )k
           ! 1 by 1: tl11*x + sgn*x*tr11 = b11
           10 continue
           tau1 = tl( 1, 1 ) + sgn*tr( 1, 1 )
           bet = abs( tau1 )
           if( bet<=smlnum ) then
              tau1 = smlnum
              bet = smlnum
              info = 1
           end if
           scale = one
           gam = abs( b( 1, 1 ) )
           if( smlnum*gam>bet )scale = one / gam
           x( 1, 1 ) = ( b( 1, 1 )*scale ) / tau1
           xnorm = abs( x( 1, 1 ) )
           return
           ! 1 by 2:
           ! tl11*[x11 x12] + isgn*[x11 x12]*op[tr11 tr12]  = [b11 b12]
                                             ! [tr21 tr22]
                                             20 continue
           smin = max( eps*max( abs( tl( 1, 1 ) ), abs( tr( 1, 1 ) ),abs( tr( 1, 2 ) ), abs( tr( &
                     2, 1 ) ), abs( tr( 2, 2 ) ) ),smlnum )
           tmp( 1 ) = tl( 1, 1 ) + sgn*tr( 1, 1 )
           tmp( 4 ) = tl( 1, 1 ) + sgn*tr( 2, 2 )
           if( ltranr ) then
              tmp( 2 ) = sgn*tr( 2, 1 )
              tmp( 3 ) = sgn*tr( 1, 2 )
           else
              tmp( 2 ) = sgn*tr( 1, 2 )
              tmp( 3 ) = sgn*tr( 2, 1 )
           end if
           btmp( 1 ) = b( 1, 1 )
           btmp( 2 ) = b( 1, 2 )
           go to 40
           ! 2 by 1:
                ! op[tl11 tl12]*[x11] + isgn* [x11]*tr11  = [b11]
                  ! [tl21 tl22] [x21]         [x21]         [b21]
                  30 continue
           smin = max( eps*max( abs( tr( 1, 1 ) ), abs( tl( 1, 1 ) ),abs( tl( 1, 2 ) ), abs( tl( &
                     2, 1 ) ), abs( tl( 2, 2 ) ) ),smlnum )
           tmp( 1 ) = tl( 1, 1 ) + sgn*tr( 1, 1 )
           tmp( 4 ) = tl( 2, 2 ) + sgn*tr( 1, 1 )
           if( ltranl ) then
              tmp( 2 ) = tl( 1, 2 )
              tmp( 3 ) = tl( 2, 1 )
           else
              tmp( 2 ) = tl( 2, 1 )
              tmp( 3 ) = tl( 1, 2 )
           end if
           btmp( 1 ) = b( 1, 1 )
           btmp( 2 ) = b( 2, 1 )
           40 continue
           ! solve 2 by 2 system using complete pivoting.
           ! set pivots less than smin to smin.
           ipiv = stdlib_isamax( 4, tmp, 1 )
           u11 = tmp( ipiv )
           if( abs( u11 )<=smin ) then
              info = 1
              u11 = smin
           end if
           u12 = tmp( locu12( ipiv ) )
           l21 = tmp( locl21( ipiv ) ) / u11
           u22 = tmp( locu22( ipiv ) ) - u12*l21
           xswap = xswpiv( ipiv )
           bswap = bswpiv( ipiv )
           if( abs( u22 )<=smin ) then
              info = 1
              u22 = smin
           end if
           if( bswap ) then
              temp = btmp( 2 )
              btmp( 2 ) = btmp( 1 ) - l21*temp
              btmp( 1 ) = temp
           else
              btmp( 2 ) = btmp( 2 ) - l21*btmp( 1 )
           end if
           scale = one
           if( ( two*smlnum )*abs( btmp( 2 ) )>abs( u22 ) .or.( two*smlnum )*abs( btmp( 1 ) )>abs(&
                      u11 ) ) then
              scale = half / max( abs( btmp( 1 ) ), abs( btmp( 2 ) ) )
              btmp( 1 ) = btmp( 1 )*scale
              btmp( 2 ) = btmp( 2 )*scale
           end if
           x2( 2 ) = btmp( 2 ) / u22
           x2( 1 ) = btmp( 1 ) / u11 - ( u12 / u11 )*x2( 2 )
           if( xswap ) then
              temp = x2( 2 )
              x2( 2 ) = x2( 1 )
              x2( 1 ) = temp
           end if
           x( 1, 1 ) = x2( 1 )
           if( n1==1 ) then
              x( 1, 2 ) = x2( 2 )
              xnorm = abs( x( 1, 1 ) ) + abs( x( 1, 2 ) )
           else
              x( 2, 1 ) = x2( 2 )
              xnorm = max( abs( x( 1, 1 ) ), abs( x( 2, 1 ) ) )
           end if
           return
           ! 2 by 2:
           ! op[tl11 tl12]*[x11 x12] +isgn* [x11 x12]*op[tr11 tr12] = [b11 b12]
             ! [tl21 tl22] [x21 x22]        [x21 x22]   [tr21 tr22]   [b21 b22]
           ! solve equivalent 4 by 4 system using complete pivoting.
           ! set pivots less than smin to smin.
           50 continue
           smin = max( abs( tr( 1, 1 ) ), abs( tr( 1, 2 ) ),abs( tr( 2, 1 ) ), abs( tr( 2, 2 ) ) )
                     
           smin = max( smin, abs( tl( 1, 1 ) ), abs( tl( 1, 2 ) ),abs( tl( 2, 1 ) ), abs( tl( 2, &
                     2 ) ) )
           smin = max( eps*smin, smlnum )
           btmp( 1 ) = zero
           call stdlib_scopy( 16, btmp, 0, t16, 1 )
           t16( 1, 1 ) = tl( 1, 1 ) + sgn*tr( 1, 1 )
           t16( 2, 2 ) = tl( 2, 2 ) + sgn*tr( 1, 1 )
           t16( 3, 3 ) = tl( 1, 1 ) + sgn*tr( 2, 2 )
           t16( 4, 4 ) = tl( 2, 2 ) + sgn*tr( 2, 2 )
           if( ltranl ) then
              t16( 1, 2 ) = tl( 2, 1 )
              t16( 2, 1 ) = tl( 1, 2 )
              t16( 3, 4 ) = tl( 2, 1 )
              t16( 4, 3 ) = tl( 1, 2 )
           else
              t16( 1, 2 ) = tl( 1, 2 )
              t16( 2, 1 ) = tl( 2, 1 )
              t16( 3, 4 ) = tl( 1, 2 )
              t16( 4, 3 ) = tl( 2, 1 )
           end if
           if( ltranr ) then
              t16( 1, 3 ) = sgn*tr( 1, 2 )
              t16( 2, 4 ) = sgn*tr( 1, 2 )
              t16( 3, 1 ) = sgn*tr( 2, 1 )
              t16( 4, 2 ) = sgn*tr( 2, 1 )
           else
              t16( 1, 3 ) = sgn*tr( 2, 1 )
              t16( 2, 4 ) = sgn*tr( 2, 1 )
              t16( 3, 1 ) = sgn*tr( 1, 2 )
              t16( 4, 2 ) = sgn*tr( 1, 2 )
           end if
           btmp( 1 ) = b( 1, 1 )
           btmp( 2 ) = b( 2, 1 )
           btmp( 3 ) = b( 1, 2 )
           btmp( 4 ) = b( 2, 2 )
           ! perform elimination
           loop_100: do i = 1, 3
              xmax = zero
              do ip = i, 4
                 do jp = i, 4
                    if( abs( t16( ip, jp ) )>=xmax ) then
                       xmax = abs( t16( ip, jp ) )
                       ipsv = ip
                       jpsv = jp
                    end if
                 end do
              end do
              if( ipsv/=i ) then
                 call stdlib_sswap( 4, t16( ipsv, 1 ), 4, t16( i, 1 ), 4 )
                 temp = btmp( i )
                 btmp( i ) = btmp( ipsv )
                 btmp( ipsv ) = temp
              end if
              if( jpsv/=i )call stdlib_sswap( 4, t16( 1, jpsv ), 1, t16( 1, i ), 1 )
              jpiv( i ) = jpsv
              if( abs( t16( i, i ) )<smin ) then
                 info = 1
                 t16( i, i ) = smin
              end if
              do j = i + 1, 4
                 t16( j, i ) = t16( j, i ) / t16( i, i )
                 btmp( j ) = btmp( j ) - t16( j, i )*btmp( i )
                 do k = i + 1, 4
                    t16( j, k ) = t16( j, k ) - t16( j, i )*t16( i, k )
                 end do
              end do
           end do loop_100
           if( abs( t16( 4, 4 ) )<smin ) then
              info = 1
              t16( 4, 4 ) = smin
           end if
           scale = one
           if( ( eight*smlnum )*abs( btmp( 1 ) )>abs( t16( 1, 1 ) ) .or.( eight*smlnum )*abs( &
           btmp( 2 ) )>abs( t16( 2, 2 ) ) .or.( eight*smlnum )*abs( btmp( 3 ) )>abs( t16( 3, 3 ) )&
                      .or.( eight*smlnum )*abs( btmp( 4 ) )>abs( t16( 4, 4 ) ) ) then
              scale = ( one / eight ) / max( abs( btmp( 1 ) ),abs( btmp( 2 ) ), abs( btmp( 3 ) ), &
                        abs( btmp( 4 ) ) )
              btmp( 1 ) = btmp( 1 )*scale
              btmp( 2 ) = btmp( 2 )*scale
              btmp( 3 ) = btmp( 3 )*scale
              btmp( 4 ) = btmp( 4 )*scale
           end if
           do i = 1, 4
              k = 5 - i
              temp = one / t16( k, k )
              tmp( k ) = btmp( k )*temp
              do j = k + 1, 4
                 tmp( k ) = tmp( k ) - ( temp*t16( k, j ) )*tmp( j )
              end do
           end do
           do i = 1, 3
              if( jpiv( 4-i )/=4-i ) then
                 temp = tmp( 4-i )
                 tmp( 4-i ) = tmp( jpiv( 4-i ) )
                 tmp( jpiv( 4-i ) ) = temp
              end if
           end do
           x( 1, 1 ) = tmp( 1 )
           x( 2, 1 ) = tmp( 2 )
           x( 1, 2 ) = tmp( 3 )
           x( 2, 2 ) = tmp( 4 )
           xnorm = max( abs( tmp( 1 ) )+abs( tmp( 3 ) ),abs( tmp( 2 ) )+abs( tmp( 4 ) ) )
           return
     end subroutine stdlib_slasy2

     pure subroutine stdlib_dlasy2( ltranl, ltranr, isgn, n1, n2, tl, ldtl, tr,ldtr, b, ldb, &
     !! DLASY2 solves for the N1 by N2 matrix X, 1 <= N1,N2 <= 2, in
     !! op(TL)*X + ISGN*X*op(TR) = SCALE*B,
     !! where TL is N1 by N1, TR is N2 by N2, B is N1 by N2, and ISGN = 1 or
     !! -1.  op(T) = T or T**T, where T**T denotes the transpose of T.
               scale, x, ldx, xnorm, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: ltranl, ltranr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: isgn, ldb, ldtl, ldtr, ldx, n1, n2
           real(dp), intent(out) :: scale, xnorm
           ! Array Arguments 
           real(dp), intent(in) :: b(ldb,*), tl(ldtl,*), tr(ldtr,*)
           real(dp), intent(out) :: x(ldx,*)
       ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: bswap, xswap
           integer(ilp) :: i, ip, ipiv, ipsv, j, jp, jpsv, k
           real(dp) :: bet, eps, gam, l21, sgn, smin, smlnum, tau1, temp, u11, u12, u22, &
                     xmax
           ! Local Arrays 
           logical(lk) :: bswpiv(4), xswpiv(4)
           integer(ilp) :: jpiv(4), locl21(4), locu12(4), locu22(4)
           real(dp) :: btmp(4), t16(4,4), tmp(4), x2(2)
           ! Intrinsic Functions 
           ! Data Statements 
           locu12 = [3,4,1,2]
           locl21 = [2,1,4,3]
           locu22 = [4,3,2,1]
           xswpiv = [.false.,.false.,.true.,.true.]
           bswpiv = [.false.,.true.,.false.,.true.]
           ! Executable Statements 
           ! do not check the input parameters for errors
           info = 0
           ! quick return if possible
           if( n1==0 .or. n2==0 )return
           ! set constants to control overflow
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' ) / eps
           sgn = isgn
           k = n1 + n1 + n2 - 2
           go to ( 10, 20, 30, 50 )k
           ! 1 by 1: tl11*x + sgn*x*tr11 = b11
           10 continue
           tau1 = tl( 1, 1 ) + sgn*tr( 1, 1 )
           bet = abs( tau1 )
           if( bet<=smlnum ) then
              tau1 = smlnum
              bet = smlnum
              info = 1
           end if
           scale = one
           gam = abs( b( 1, 1 ) )
           if( smlnum*gam>bet )scale = one / gam
           x( 1, 1 ) = ( b( 1, 1 )*scale ) / tau1
           xnorm = abs( x( 1, 1 ) )
           return
           ! 1 by 2:
           ! tl11*[x11 x12] + isgn*[x11 x12]*op[tr11 tr12]  = [b11 b12]
                                             ! [tr21 tr22]
                                             20 continue
           smin = max( eps*max( abs( tl( 1, 1 ) ), abs( tr( 1, 1 ) ),abs( tr( 1, 2 ) ), abs( tr( &
                     2, 1 ) ), abs( tr( 2, 2 ) ) ),smlnum )
           tmp( 1 ) = tl( 1, 1 ) + sgn*tr( 1, 1 )
           tmp( 4 ) = tl( 1, 1 ) + sgn*tr( 2, 2 )
           if( ltranr ) then
              tmp( 2 ) = sgn*tr( 2, 1 )
              tmp( 3 ) = sgn*tr( 1, 2 )
           else
              tmp( 2 ) = sgn*tr( 1, 2 )
              tmp( 3 ) = sgn*tr( 2, 1 )
           end if
           btmp( 1 ) = b( 1, 1 )
           btmp( 2 ) = b( 1, 2 )
           go to 40
           ! 2 by 1:
                ! op[tl11 tl12]*[x11] + isgn* [x11]*tr11  = [b11]
                  ! [tl21 tl22] [x21]         [x21]         [b21]
                  30 continue
           smin = max( eps*max( abs( tr( 1, 1 ) ), abs( tl( 1, 1 ) ),abs( tl( 1, 2 ) ), abs( tl( &
                     2, 1 ) ), abs( tl( 2, 2 ) ) ),smlnum )
           tmp( 1 ) = tl( 1, 1 ) + sgn*tr( 1, 1 )
           tmp( 4 ) = tl( 2, 2 ) + sgn*tr( 1, 1 )
           if( ltranl ) then
              tmp( 2 ) = tl( 1, 2 )
              tmp( 3 ) = tl( 2, 1 )
           else
              tmp( 2 ) = tl( 2, 1 )
              tmp( 3 ) = tl( 1, 2 )
           end if
           btmp( 1 ) = b( 1, 1 )
           btmp( 2 ) = b( 2, 1 )
           40 continue
           ! solve 2 by 2 system using complete pivoting.
           ! set pivots less than smin to smin.
           ipiv = stdlib_idamax( 4, tmp, 1 )
           u11 = tmp( ipiv )
           if( abs( u11 )<=smin ) then
              info = 1
              u11 = smin
           end if
           u12 = tmp( locu12( ipiv ) )
           l21 = tmp( locl21( ipiv ) ) / u11
           u22 = tmp( locu22( ipiv ) ) - u12*l21
           xswap = xswpiv( ipiv )
           bswap = bswpiv( ipiv )
           if( abs( u22 )<=smin ) then
              info = 1
              u22 = smin
           end if
           if( bswap ) then
              temp = btmp( 2 )
              btmp( 2 ) = btmp( 1 ) - l21*temp
              btmp( 1 ) = temp
           else
              btmp( 2 ) = btmp( 2 ) - l21*btmp( 1 )
           end if
           scale = one
           if( ( two*smlnum )*abs( btmp( 2 ) )>abs( u22 ) .or.( two*smlnum )*abs( btmp( 1 ) )>abs(&
                      u11 ) ) then
              scale = half / max( abs( btmp( 1 ) ), abs( btmp( 2 ) ) )
              btmp( 1 ) = btmp( 1 )*scale
              btmp( 2 ) = btmp( 2 )*scale
           end if
           x2( 2 ) = btmp( 2 ) / u22
           x2( 1 ) = btmp( 1 ) / u11 - ( u12 / u11 )*x2( 2 )
           if( xswap ) then
              temp = x2( 2 )
              x2( 2 ) = x2( 1 )
              x2( 1 ) = temp
           end if
           x( 1, 1 ) = x2( 1 )
           if( n1==1 ) then
              x( 1, 2 ) = x2( 2 )
              xnorm = abs( x( 1, 1 ) ) + abs( x( 1, 2 ) )
           else
              x( 2, 1 ) = x2( 2 )
              xnorm = max( abs( x( 1, 1 ) ), abs( x( 2, 1 ) ) )
           end if
           return
           ! 2 by 2:
           ! op[tl11 tl12]*[x11 x12] +isgn* [x11 x12]*op[tr11 tr12] = [b11 b12]
             ! [tl21 tl22] [x21 x22]        [x21 x22]   [tr21 tr22]   [b21 b22]
           ! solve equivalent 4 by 4 system using complete pivoting.
           ! set pivots less than smin to smin.
           50 continue
           smin = max( abs( tr( 1, 1 ) ), abs( tr( 1, 2 ) ),abs( tr( 2, 1 ) ), abs( tr( 2, 2 ) ) )
                     
           smin = max( smin, abs( tl( 1, 1 ) ), abs( tl( 1, 2 ) ),abs( tl( 2, 1 ) ), abs( tl( 2, &
                     2 ) ) )
           smin = max( eps*smin, smlnum )
           btmp( 1 ) = zero
           call stdlib_dcopy( 16, btmp, 0, t16, 1 )
           t16( 1, 1 ) = tl( 1, 1 ) + sgn*tr( 1, 1 )
           t16( 2, 2 ) = tl( 2, 2 ) + sgn*tr( 1, 1 )
           t16( 3, 3 ) = tl( 1, 1 ) + sgn*tr( 2, 2 )
           t16( 4, 4 ) = tl( 2, 2 ) + sgn*tr( 2, 2 )
           if( ltranl ) then
              t16( 1, 2 ) = tl( 2, 1 )
              t16( 2, 1 ) = tl( 1, 2 )
              t16( 3, 4 ) = tl( 2, 1 )
              t16( 4, 3 ) = tl( 1, 2 )
           else
              t16( 1, 2 ) = tl( 1, 2 )
              t16( 2, 1 ) = tl( 2, 1 )
              t16( 3, 4 ) = tl( 1, 2 )
              t16( 4, 3 ) = tl( 2, 1 )
           end if
           if( ltranr ) then
              t16( 1, 3 ) = sgn*tr( 1, 2 )
              t16( 2, 4 ) = sgn*tr( 1, 2 )
              t16( 3, 1 ) = sgn*tr( 2, 1 )
              t16( 4, 2 ) = sgn*tr( 2, 1 )
           else
              t16( 1, 3 ) = sgn*tr( 2, 1 )
              t16( 2, 4 ) = sgn*tr( 2, 1 )
              t16( 3, 1 ) = sgn*tr( 1, 2 )
              t16( 4, 2 ) = sgn*tr( 1, 2 )
           end if
           btmp( 1 ) = b( 1, 1 )
           btmp( 2 ) = b( 2, 1 )
           btmp( 3 ) = b( 1, 2 )
           btmp( 4 ) = b( 2, 2 )
           ! perform elimination
           loop_100: do i = 1, 3
              xmax = zero
              do ip = i, 4
                 do jp = i, 4
                    if( abs( t16( ip, jp ) )>=xmax ) then
                       xmax = abs( t16( ip, jp ) )
                       ipsv = ip
                       jpsv = jp
                    end if
                 end do
              end do
              if( ipsv/=i ) then
                 call stdlib_dswap( 4, t16( ipsv, 1 ), 4, t16( i, 1 ), 4 )
                 temp = btmp( i )
                 btmp( i ) = btmp( ipsv )
                 btmp( ipsv ) = temp
              end if
              if( jpsv/=i )call stdlib_dswap( 4, t16( 1, jpsv ), 1, t16( 1, i ), 1 )
              jpiv( i ) = jpsv
              if( abs( t16( i, i ) )<smin ) then
                 info = 1
                 t16( i, i ) = smin
              end if
              do j = i + 1, 4
                 t16( j, i ) = t16( j, i ) / t16( i, i )
                 btmp( j ) = btmp( j ) - t16( j, i )*btmp( i )
                 do k = i + 1, 4
                    t16( j, k ) = t16( j, k ) - t16( j, i )*t16( i, k )
                 end do
              end do
           end do loop_100
           if( abs( t16( 4, 4 ) )<smin ) then
              info = 1
              t16( 4, 4 ) = smin
           end if
           scale = one
           if( ( eight*smlnum )*abs( btmp( 1 ) )>abs( t16( 1, 1 ) ) .or.( eight*smlnum )*abs( &
           btmp( 2 ) )>abs( t16( 2, 2 ) ) .or.( eight*smlnum )*abs( btmp( 3 ) )>abs( t16( 3, 3 ) )&
                      .or.( eight*smlnum )*abs( btmp( 4 ) )>abs( t16( 4, 4 ) ) ) then
              scale = ( one / eight ) / max( abs( btmp( 1 ) ),abs( btmp( 2 ) ), abs( btmp( 3 ) ), &
                        abs( btmp( 4 ) ) )
              btmp( 1 ) = btmp( 1 )*scale
              btmp( 2 ) = btmp( 2 )*scale
              btmp( 3 ) = btmp( 3 )*scale
              btmp( 4 ) = btmp( 4 )*scale
           end if
           do i = 1, 4
              k = 5 - i
              temp = one / t16( k, k )
              tmp( k ) = btmp( k )*temp
              do j = k + 1, 4
                 tmp( k ) = tmp( k ) - ( temp*t16( k, j ) )*tmp( j )
              end do
           end do
           do i = 1, 3
              if( jpiv( 4-i )/=4-i ) then
                 temp = tmp( 4-i )
                 tmp( 4-i ) = tmp( jpiv( 4-i ) )
                 tmp( jpiv( 4-i ) ) = temp
              end if
           end do
           x( 1, 1 ) = tmp( 1 )
           x( 2, 1 ) = tmp( 2 )
           x( 1, 2 ) = tmp( 3 )
           x( 2, 2 ) = tmp( 4 )
           xnorm = max( abs( tmp( 1 ) )+abs( tmp( 3 ) ),abs( tmp( 2 ) )+abs( tmp( 4 ) ) )
           return
     end subroutine stdlib_dlasy2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$lasy2( ltranl, ltranr, isgn, n1, n2, tl, ldtl, tr,ldtr, b, ldb, &
     !! DLASY2: solves for the N1 by N2 matrix X, 1 <= N1,N2 <= 2, in
     !! op(TL)*X + ISGN*X*op(TR) = SCALE*B,
     !! where TL is N1 by N1, TR is N2 by N2, B is N1 by N2, and ISGN = 1 or
     !! -1.  op(T) = T or T**T, where T**T denotes the transpose of T.
               scale, x, ldx, xnorm, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: ltranl, ltranr
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: isgn, ldb, ldtl, ldtr, ldx, n1, n2
           real(${rk}$), intent(out) :: scale, xnorm
           ! Array Arguments 
           real(${rk}$), intent(in) :: b(ldb,*), tl(ldtl,*), tr(ldtr,*)
           real(${rk}$), intent(out) :: x(ldx,*)
       ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: bswap, xswap
           integer(ilp) :: i, ip, ipiv, ipsv, j, jp, jpsv, k
           real(${rk}$) :: bet, eps, gam, l21, sgn, smin, smlnum, tau1, temp, u11, u12, u22, &
                     xmax
           ! Local Arrays 
           logical(lk) :: bswpiv(4), xswpiv(4)
           integer(ilp) :: jpiv(4), locl21(4), locu12(4), locu22(4)
           real(${rk}$) :: btmp(4), t16(4,4), tmp(4), x2(2)
           ! Intrinsic Functions 
           ! Data Statements 
           locu12 = [3,4,1,2]
           locl21 = [2,1,4,3]
           locu22 = [4,3,2,1]
           xswpiv = [.false.,.false.,.true.,.true.]
           bswpiv = [.false.,.true.,.false.,.true.]
           ! Executable Statements 
           ! do not check the input parameters for errors
           info = 0
           ! quick return if possible
           if( n1==0 .or. n2==0 )return
           ! set constants to control overflow
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' ) / eps
           sgn = isgn
           k = n1 + n1 + n2 - 2
           go to ( 10, 20, 30, 50 )k
           ! 1 by 1: tl11*x + sgn*x*tr11 = b11
           10 continue
           tau1 = tl( 1, 1 ) + sgn*tr( 1, 1 )
           bet = abs( tau1 )
           if( bet<=smlnum ) then
              tau1 = smlnum
              bet = smlnum
              info = 1
           end if
           scale = one
           gam = abs( b( 1, 1 ) )
           if( smlnum*gam>bet )scale = one / gam
           x( 1, 1 ) = ( b( 1, 1 )*scale ) / tau1
           xnorm = abs( x( 1, 1 ) )
           return
           ! 1 by 2:
           ! tl11*[x11 x12] + isgn*[x11 x12]*op[tr11 tr12]  = [b11 b12]
                                             ! [tr21 tr22]
                                             20 continue
           smin = max( eps*max( abs( tl( 1, 1 ) ), abs( tr( 1, 1 ) ),abs( tr( 1, 2 ) ), abs( tr( &
                     2, 1 ) ), abs( tr( 2, 2 ) ) ),smlnum )
           tmp( 1 ) = tl( 1, 1 ) + sgn*tr( 1, 1 )
           tmp( 4 ) = tl( 1, 1 ) + sgn*tr( 2, 2 )
           if( ltranr ) then
              tmp( 2 ) = sgn*tr( 2, 1 )
              tmp( 3 ) = sgn*tr( 1, 2 )
           else
              tmp( 2 ) = sgn*tr( 1, 2 )
              tmp( 3 ) = sgn*tr( 2, 1 )
           end if
           btmp( 1 ) = b( 1, 1 )
           btmp( 2 ) = b( 1, 2 )
           go to 40
           ! 2 by 1:
                ! op[tl11 tl12]*[x11] + isgn* [x11]*tr11  = [b11]
                  ! [tl21 tl22] [x21]         [x21]         [b21]
                  30 continue
           smin = max( eps*max( abs( tr( 1, 1 ) ), abs( tl( 1, 1 ) ),abs( tl( 1, 2 ) ), abs( tl( &
                     2, 1 ) ), abs( tl( 2, 2 ) ) ),smlnum )
           tmp( 1 ) = tl( 1, 1 ) + sgn*tr( 1, 1 )
           tmp( 4 ) = tl( 2, 2 ) + sgn*tr( 1, 1 )
           if( ltranl ) then
              tmp( 2 ) = tl( 1, 2 )
              tmp( 3 ) = tl( 2, 1 )
           else
              tmp( 2 ) = tl( 2, 1 )
              tmp( 3 ) = tl( 1, 2 )
           end if
           btmp( 1 ) = b( 1, 1 )
           btmp( 2 ) = b( 2, 1 )
           40 continue
           ! solve 2 by 2 system using complete pivoting.
           ! set pivots less than smin to smin.
           ipiv = stdlib_i${ri}$amax( 4, tmp, 1 )
           u11 = tmp( ipiv )
           if( abs( u11 )<=smin ) then
              info = 1
              u11 = smin
           end if
           u12 = tmp( locu12( ipiv ) )
           l21 = tmp( locl21( ipiv ) ) / u11
           u22 = tmp( locu22( ipiv ) ) - u12*l21
           xswap = xswpiv( ipiv )
           bswap = bswpiv( ipiv )
           if( abs( u22 )<=smin ) then
              info = 1
              u22 = smin
           end if
           if( bswap ) then
              temp = btmp( 2 )
              btmp( 2 ) = btmp( 1 ) - l21*temp
              btmp( 1 ) = temp
           else
              btmp( 2 ) = btmp( 2 ) - l21*btmp( 1 )
           end if
           scale = one
           if( ( two*smlnum )*abs( btmp( 2 ) )>abs( u22 ) .or.( two*smlnum )*abs( btmp( 1 ) )>abs(&
                      u11 ) ) then
              scale = half / max( abs( btmp( 1 ) ), abs( btmp( 2 ) ) )
              btmp( 1 ) = btmp( 1 )*scale
              btmp( 2 ) = btmp( 2 )*scale
           end if
           x2( 2 ) = btmp( 2 ) / u22
           x2( 1 ) = btmp( 1 ) / u11 - ( u12 / u11 )*x2( 2 )
           if( xswap ) then
              temp = x2( 2 )
              x2( 2 ) = x2( 1 )
              x2( 1 ) = temp
           end if
           x( 1, 1 ) = x2( 1 )
           if( n1==1 ) then
              x( 1, 2 ) = x2( 2 )
              xnorm = abs( x( 1, 1 ) ) + abs( x( 1, 2 ) )
           else
              x( 2, 1 ) = x2( 2 )
              xnorm = max( abs( x( 1, 1 ) ), abs( x( 2, 1 ) ) )
           end if
           return
           ! 2 by 2:
           ! op[tl11 tl12]*[x11 x12] +isgn* [x11 x12]*op[tr11 tr12] = [b11 b12]
             ! [tl21 tl22] [x21 x22]        [x21 x22]   [tr21 tr22]   [b21 b22]
           ! solve equivalent 4 by 4 system using complete pivoting.
           ! set pivots less than smin to smin.
           50 continue
           smin = max( abs( tr( 1, 1 ) ), abs( tr( 1, 2 ) ),abs( tr( 2, 1 ) ), abs( tr( 2, 2 ) ) )
                     
           smin = max( smin, abs( tl( 1, 1 ) ), abs( tl( 1, 2 ) ),abs( tl( 2, 1 ) ), abs( tl( 2, &
                     2 ) ) )
           smin = max( eps*smin, smlnum )
           btmp( 1 ) = zero
           call stdlib_${ri}$copy( 16, btmp, 0, t16, 1 )
           t16( 1, 1 ) = tl( 1, 1 ) + sgn*tr( 1, 1 )
           t16( 2, 2 ) = tl( 2, 2 ) + sgn*tr( 1, 1 )
           t16( 3, 3 ) = tl( 1, 1 ) + sgn*tr( 2, 2 )
           t16( 4, 4 ) = tl( 2, 2 ) + sgn*tr( 2, 2 )
           if( ltranl ) then
              t16( 1, 2 ) = tl( 2, 1 )
              t16( 2, 1 ) = tl( 1, 2 )
              t16( 3, 4 ) = tl( 2, 1 )
              t16( 4, 3 ) = tl( 1, 2 )
           else
              t16( 1, 2 ) = tl( 1, 2 )
              t16( 2, 1 ) = tl( 2, 1 )
              t16( 3, 4 ) = tl( 1, 2 )
              t16( 4, 3 ) = tl( 2, 1 )
           end if
           if( ltranr ) then
              t16( 1, 3 ) = sgn*tr( 1, 2 )
              t16( 2, 4 ) = sgn*tr( 1, 2 )
              t16( 3, 1 ) = sgn*tr( 2, 1 )
              t16( 4, 2 ) = sgn*tr( 2, 1 )
           else
              t16( 1, 3 ) = sgn*tr( 2, 1 )
              t16( 2, 4 ) = sgn*tr( 2, 1 )
              t16( 3, 1 ) = sgn*tr( 1, 2 )
              t16( 4, 2 ) = sgn*tr( 1, 2 )
           end if
           btmp( 1 ) = b( 1, 1 )
           btmp( 2 ) = b( 2, 1 )
           btmp( 3 ) = b( 1, 2 )
           btmp( 4 ) = b( 2, 2 )
           ! perform elimination
           loop_100: do i = 1, 3
              xmax = zero
              do ip = i, 4
                 do jp = i, 4
                    if( abs( t16( ip, jp ) )>=xmax ) then
                       xmax = abs( t16( ip, jp ) )
                       ipsv = ip
                       jpsv = jp
                    end if
                 end do
              end do
              if( ipsv/=i ) then
                 call stdlib_${ri}$swap( 4, t16( ipsv, 1 ), 4, t16( i, 1 ), 4 )
                 temp = btmp( i )
                 btmp( i ) = btmp( ipsv )
                 btmp( ipsv ) = temp
              end if
              if( jpsv/=i )call stdlib_${ri}$swap( 4, t16( 1, jpsv ), 1, t16( 1, i ), 1 )
              jpiv( i ) = jpsv
              if( abs( t16( i, i ) )<smin ) then
                 info = 1
                 t16( i, i ) = smin
              end if
              do j = i + 1, 4
                 t16( j, i ) = t16( j, i ) / t16( i, i )
                 btmp( j ) = btmp( j ) - t16( j, i )*btmp( i )
                 do k = i + 1, 4
                    t16( j, k ) = t16( j, k ) - t16( j, i )*t16( i, k )
                 end do
              end do
           end do loop_100
           if( abs( t16( 4, 4 ) )<smin ) then
              info = 1
              t16( 4, 4 ) = smin
           end if
           scale = one
           if( ( eight*smlnum )*abs( btmp( 1 ) )>abs( t16( 1, 1 ) ) .or.( eight*smlnum )*abs( &
           btmp( 2 ) )>abs( t16( 2, 2 ) ) .or.( eight*smlnum )*abs( btmp( 3 ) )>abs( t16( 3, 3 ) )&
                      .or.( eight*smlnum )*abs( btmp( 4 ) )>abs( t16( 4, 4 ) ) ) then
              scale = ( one / eight ) / max( abs( btmp( 1 ) ),abs( btmp( 2 ) ), abs( btmp( 3 ) ), &
                        abs( btmp( 4 ) ) )
              btmp( 1 ) = btmp( 1 )*scale
              btmp( 2 ) = btmp( 2 )*scale
              btmp( 3 ) = btmp( 3 )*scale
              btmp( 4 ) = btmp( 4 )*scale
           end if
           do i = 1, 4
              k = 5 - i
              temp = one / t16( k, k )
              tmp( k ) = btmp( k )*temp
              do j = k + 1, 4
                 tmp( k ) = tmp( k ) - ( temp*t16( k, j ) )*tmp( j )
              end do
           end do
           do i = 1, 3
              if( jpiv( 4-i )/=4-i ) then
                 temp = tmp( 4-i )
                 tmp( 4-i ) = tmp( jpiv( 4-i ) )
                 tmp( jpiv( 4-i ) ) = temp
              end if
           end do
           x( 1, 1 ) = tmp( 1 )
           x( 2, 1 ) = tmp( 2 )
           x( 1, 2 ) = tmp( 3 )
           x( 2, 2 ) = tmp( 4 )
           xnorm = max( abs( tmp( 1 ) )+abs( tmp( 3 ) ),abs( tmp( 2 ) )+abs( tmp( 4 ) ) )
           return
     end subroutine stdlib_${ri}$lasy2

#:endif
#:endfor



     pure subroutine stdlib_claqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
     !! Aggressive early deflation:
     !! CLAQR3 accepts as input an upper Hessenberg matrix
     !! H and performs an unitary similarity transformation
     !! designed to detect and deflate fully converged eigenvalues from
     !! a trailing principal submatrix.  On output H has been over-
     !! written by a new Hessenberg matrix that is a perturbation of
     !! an unitary similarity transformation of H.  It is to be
     !! hoped that the final version of H has many zero subdiagonal
     !! entries.
               ns, nd, sh, v, ldv, nh, t, ldt,nv, wv, ldwv, work, lwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(ilp), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: sh(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
        ! ================================================================
           ! Parameters 
           real(sp), parameter :: rzero = 0.0_sp
           real(sp), parameter :: rone = 1.0_sp
           
           
           ! Local Scalars 
           complex(sp) :: beta, cdum, s, tau
           real(sp) :: foo, safmax, safmin, smlnum, ulp
           integer(ilp) :: i, ifst, ilst, info, infqr, j, jw, kcol, kln, knt, krow, kwtop, ltop, &
                     lwk1, lwk2, lwk3, lwkopt, nmin
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! ==== estimate optimal workspace. ====
           jw = min( nw, kbot-ktop+1 )
           if( jw<=2 ) then
              lwkopt = 1
           else
              ! ==== workspace query call to stdlib_cgehrd ====
              call stdlib_cgehrd( jw, 1, jw-1, t, ldt, work, work, -1, info )
              lwk1 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_cunmhr ====
              call stdlib_cunmhr( 'R', 'N', jw, jw, 1, jw-1, t, ldt, work, v, ldv,work, -1, info )
                        
              lwk2 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_claqr4 ====
              call stdlib_claqr4( .true., .true., jw, 1, jw, t, ldt, sh, 1, jw, v,ldv, work, -1, &
                        infqr )
              lwk3 = int( work( 1 ),KIND=ilp)
              ! ==== optimal workspace ====
              lwkopt = max( jw+max( lwk1, lwk2 ), lwk3 )
           end if
           ! ==== quick return in case of workspace query. ====
           if( lwork==-1 ) then
              work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
              return
           end if
           ! ==== nothing to do ...
           ! ... for an empty active block ... ====
           ns = 0
           nd = 0
           work( 1 ) = cone
           if( ktop>kbot )return
           ! ... nor for an empty deflation window. ====
           if( nw<1 )return
           ! ==== machine constants ====
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=sp) / ulp )
           ! ==== setup deflation window ====
           jw = min( nw, kbot-ktop+1 )
           kwtop = kbot - jw + 1
           if( kwtop==ktop ) then
              s = czero
           else
              s = h( kwtop, kwtop-1 )
           end if
           if( kbot==kwtop ) then
              ! ==== 1-by-1 deflation window: not much to do ====
              sh( kwtop ) = h( kwtop, kwtop )
              ns = 1
              nd = 0
              if( cabs1( s )<=max( smlnum, ulp*cabs1( h( kwtop,kwtop ) ) ) ) then
                 ns = 0
                 nd = 1
                 if( kwtop>ktop )h( kwtop, kwtop-1 ) = czero
              end if
              work( 1 ) = cone
              return
           end if
           ! ==== convert to spike-triangular form.  (in case of a
           ! .    rare qr failure, this routine continues to do
           ! .    aggressive early deflation using that part of
           ! .    the deflation window that converged using infqr
           ! .    here and there to keep track.) ====
           call stdlib_clacpy( 'U', jw, jw, h( kwtop, kwtop ), ldh, t, ldt )
           call stdlib_ccopy( jw-1, h( kwtop+1, kwtop ), ldh+1, t( 2, 1 ), ldt+1 )
           call stdlib_claset( 'A', jw, jw, czero, cone, v, ldv )
           nmin = stdlib_ilaenv( 12, 'CLAQR3', 'SV', jw, 1, jw, lwork )
           if( jw>nmin ) then
              call stdlib_claqr4( .true., .true., jw, 1, jw, t, ldt, sh( kwtop ), 1,jw, v, ldv, &
                        work, lwork, infqr )
           else
              call stdlib_clahqr( .true., .true., jw, 1, jw, t, ldt, sh( kwtop ), 1,jw, v, ldv, &
                        infqr )
           end if
           ! ==== deflation detection loop ====
           ns = jw
           ilst = infqr + 1
           do knt = infqr + 1, jw
              ! ==== small spike tip deflation test ====
              foo = cabs1( t( ns, ns ) )
              if( foo==rzero )foo = cabs1( s )
              if( cabs1( s )*cabs1( v( 1, ns ) )<=max( smlnum, ulp*foo ) )then
                 ! ==== cone more converged eigenvalue ====
                 ns = ns - 1
              else
                 ! ==== cone undeflatable eigenvalue.  move it up out of the
                 ! .    way.   (stdlib_ctrexc can not fail in this case.) ====
                 ifst = ns
                 call stdlib_ctrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                 ilst = ilst + 1
              end if
           end do
              ! ==== return to hessenberg form ====
           if( ns==0 )s = czero
           if( ns<jw ) then
              ! ==== sorting the diagonal of t improves accuracy for
              ! .    graded matrices.  ====
              do i = infqr + 1, ns
                 ifst = i
                 do j = i + 1, ns
                    if( cabs1( t( j, j ) )>cabs1( t( ifst, ifst ) ) )ifst = j
                 end do
                 ilst = i
                 if( ifst/=ilst )call stdlib_ctrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                           
              end do
           end if
           ! ==== restore shift/eigenvalue array from t ====
           do i = infqr + 1, jw
              sh( kwtop+i-1 ) = t( i, i )
           end do
           if( ns<jw .or. s==czero ) then
              if( ns>1 .and. s/=czero ) then
                 ! ==== reflect spike back into lower triangle ====
                 call stdlib_ccopy( ns, v, ldv, work, 1 )
                 do i = 1, ns
                    work( i ) = conjg( work( i ) )
                 end do
                 beta = work( 1 )
                 call stdlib_clarfg( ns, beta, work( 2 ), 1, tau )
                 work( 1 ) = cone
                 call stdlib_claset( 'L', jw-2, jw-2, czero, czero, t( 3, 1 ), ldt )
                 call stdlib_clarf( 'L', ns, jw, work, 1, conjg( tau ), t, ldt,work( jw+1 ) )
                           
                 call stdlib_clarf( 'R', ns, ns, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_clarf( 'R', jw, ns, work, 1, tau, v, ldv,work( jw+1 ) )
                 call stdlib_cgehrd( jw, 1, ns, t, ldt, work, work( jw+1 ),lwork-jw, info )
                           
              end if
              ! ==== copy updated reduced window into place ====
              if( kwtop>1 )h( kwtop, kwtop-1 ) = s*conjg( v( 1, 1 ) )
              call stdlib_clacpy( 'U', jw, jw, t, ldt, h( kwtop, kwtop ), ldh )
              call stdlib_ccopy( jw-1, t( 2, 1 ), ldt+1, h( kwtop+1, kwtop ),ldh+1 )
              ! ==== accumulate orthogonal matrix in order update
              ! .    h and z, if requested.  ====
              if( ns>1 .and. s/=czero )call stdlib_cunmhr( 'R', 'N', jw, ns, 1, ns, t, ldt, work, &
                        v, ldv,work( jw+1 ), lwork-jw, info )
              ! ==== update vertical slab in h ====
              if( wantt ) then
                 ltop = 1
              else
                 ltop = ktop
              end if
              do krow = ltop, kwtop - 1, nv
                 kln = min( nv, kwtop-krow )
                 call stdlib_cgemm( 'N', 'N', kln, jw, jw, cone, h( krow, kwtop ),ldh, v, ldv, &
                           czero, wv, ldwv )
                 call stdlib_clacpy( 'A', kln, jw, wv, ldwv, h( krow, kwtop ), ldh )
              end do
              ! ==== update horizontal slab in h ====
              if( wantt ) then
                 do kcol = kbot + 1, n, nh
                    kln = min( nh, n-kcol+1 )
                    call stdlib_cgemm( 'C', 'N', jw, kln, jw, cone, v, ldv,h( kwtop, kcol ), ldh, &
                              czero, t, ldt )
                    call stdlib_clacpy( 'A', jw, kln, t, ldt, h( kwtop, kcol ),ldh )
                 end do
              end if
              ! ==== update vertical slab in z ====
              if( wantz ) then
                 do krow = iloz, ihiz, nv
                    kln = min( nv, ihiz-krow+1 )
                    call stdlib_cgemm( 'N', 'N', kln, jw, jw, cone, z( krow, kwtop ),ldz, v, ldv, &
                              czero, wv, ldwv )
                    call stdlib_clacpy( 'A', kln, jw, wv, ldwv, z( krow, kwtop ),ldz )
                 end do
              end if
           end if
           ! ==== return the number of deflations ... ====
           nd = jw - ns
           ! ==== ... and the number of shifts. (subtracting
           ! .    infqr from the spike length takes care
           ! .    of the case of a rare qr failure while
           ! .    calculating eigenvalues of the deflation
           ! .    window.)  ====
           ns = ns - infqr
            ! ==== return optimal workspace. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
     end subroutine stdlib_claqr3

     pure subroutine stdlib_zlaqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
     !! Aggressive early deflation:
     !! ZLAQR3 accepts as input an upper Hessenberg matrix
     !! H and performs an unitary similarity transformation
     !! designed to detect and deflate fully converged eigenvalues from
     !! a trailing principal submatrix.  On output H has been over-
     !! written by a new Hessenberg matrix that is a perturbation of
     !! an unitary similarity transformation of H.  It is to be
     !! hoped that the final version of H has many zero subdiagonal
     !! entries.
               ns, nd, sh, v, ldv, nh, t, ldt,nv, wv, ldwv, work, lwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(ilp), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(dp), intent(out) :: sh(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
        ! ================================================================
           ! Parameters 
           real(dp), parameter :: rzero = 0.0_dp
           real(dp), parameter :: rone = 1.0_dp
           
           
           ! Local Scalars 
           complex(dp) :: beta, cdum, s, tau
           real(dp) :: foo, safmax, safmin, smlnum, ulp
           integer(ilp) :: i, ifst, ilst, info, infqr, j, jw, kcol, kln, knt, krow, kwtop, ltop, &
                     lwk1, lwk2, lwk3, lwkopt, nmin
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! ==== estimate optimal workspace. ====
           jw = min( nw, kbot-ktop+1 )
           if( jw<=2 ) then
              lwkopt = 1
           else
              ! ==== workspace query call to stdlib_zgehrd ====
              call stdlib_zgehrd( jw, 1, jw-1, t, ldt, work, work, -1, info )
              lwk1 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_zunmhr ====
              call stdlib_zunmhr( 'R', 'N', jw, jw, 1, jw-1, t, ldt, work, v, ldv,work, -1, info )
                        
              lwk2 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_zlaqr4 ====
              call stdlib_zlaqr4( .true., .true., jw, 1, jw, t, ldt, sh, 1, jw, v,ldv, work, -1, &
                        infqr )
              lwk3 = int( work( 1 ),KIND=ilp)
              ! ==== optimal workspace ====
              lwkopt = max( jw+max( lwk1, lwk2 ), lwk3 )
           end if
           ! ==== quick return in case of workspace query. ====
           if( lwork==-1 ) then
              work( 1 ) = cmplx( lwkopt, 0,KIND=dp)
              return
           end if
           ! ==== nothing to do ...
           ! ... for an empty active block ... ====
           ns = 0
           nd = 0
           work( 1 ) = cone
           if( ktop>kbot )return
           ! ... nor for an empty deflation window. ====
           if( nw<1 )return
           ! ==== machine constants ====
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_dlabad( safmin, safmax )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=dp) / ulp )
           ! ==== setup deflation window ====
           jw = min( nw, kbot-ktop+1 )
           kwtop = kbot - jw + 1
           if( kwtop==ktop ) then
              s = czero
           else
              s = h( kwtop, kwtop-1 )
           end if
           if( kbot==kwtop ) then
              ! ==== 1-by-1 deflation window: not much to do ====
              sh( kwtop ) = h( kwtop, kwtop )
              ns = 1
              nd = 0
              if( cabs1( s )<=max( smlnum, ulp*cabs1( h( kwtop,kwtop ) ) ) ) then
                 ns = 0
                 nd = 1
                 if( kwtop>ktop )h( kwtop, kwtop-1 ) = czero
              end if
              work( 1 ) = cone
              return
           end if
           ! ==== convert to spike-triangular form.  (in case of a
           ! .    rare qr failure, this routine continues to do
           ! .    aggressive early deflation using that part of
           ! .    the deflation window that converged using infqr
           ! .    here and there to keep track.) ====
           call stdlib_zlacpy( 'U', jw, jw, h( kwtop, kwtop ), ldh, t, ldt )
           call stdlib_zcopy( jw-1, h( kwtop+1, kwtop ), ldh+1, t( 2, 1 ), ldt+1 )
           call stdlib_zlaset( 'A', jw, jw, czero, cone, v, ldv )
           nmin = stdlib_ilaenv( 12, 'ZLAQR3', 'SV', jw, 1, jw, lwork )
           if( jw>nmin ) then
              call stdlib_zlaqr4( .true., .true., jw, 1, jw, t, ldt, sh( kwtop ), 1,jw, v, ldv, &
                        work, lwork, infqr )
           else
              call stdlib_zlahqr( .true., .true., jw, 1, jw, t, ldt, sh( kwtop ), 1,jw, v, ldv, &
                        infqr )
           end if
           ! ==== deflation detection loop ====
           ns = jw
           ilst = infqr + 1
           do knt = infqr + 1, jw
              ! ==== small spike tip deflation test ====
              foo = cabs1( t( ns, ns ) )
              if( foo==rzero )foo = cabs1( s )
              if( cabs1( s )*cabs1( v( 1, ns ) )<=max( smlnum, ulp*foo ) )then
                 ! ==== cone more converged eigenvalue ====
                 ns = ns - 1
              else
                 ! ==== cone undeflatable eigenvalue.  move it up out of the
                 ! .    way.   (stdlib_ztrexc can not fail in this case.) ====
                 ifst = ns
                 call stdlib_ztrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                 ilst = ilst + 1
              end if
           end do
              ! ==== return to hessenberg form ====
           if( ns==0 )s = czero
           if( ns<jw ) then
              ! ==== sorting the diagonal of t improves accuracy for
              ! .    graded matrices.  ====
              do i = infqr + 1, ns
                 ifst = i
                 do j = i + 1, ns
                    if( cabs1( t( j, j ) )>cabs1( t( ifst, ifst ) ) )ifst = j
                 end do
                 ilst = i
                 if( ifst/=ilst )call stdlib_ztrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                           
              end do
           end if
           ! ==== restore shift/eigenvalue array from t ====
           do i = infqr + 1, jw
              sh( kwtop+i-1 ) = t( i, i )
           end do
           if( ns<jw .or. s==czero ) then
              if( ns>1 .and. s/=czero ) then
                 ! ==== reflect spike back into lower triangle ====
                 call stdlib_zcopy( ns, v, ldv, work, 1 )
                 do i = 1, ns
                    work( i ) = conjg( work( i ) )
                 end do
                 beta = work( 1 )
                 call stdlib_zlarfg( ns, beta, work( 2 ), 1, tau )
                 work( 1 ) = cone
                 call stdlib_zlaset( 'L', jw-2, jw-2, czero, czero, t( 3, 1 ), ldt )
                 call stdlib_zlarf( 'L', ns, jw, work, 1, conjg( tau ), t, ldt,work( jw+1 ) )
                           
                 call stdlib_zlarf( 'R', ns, ns, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_zlarf( 'R', jw, ns, work, 1, tau, v, ldv,work( jw+1 ) )
                 call stdlib_zgehrd( jw, 1, ns, t, ldt, work, work( jw+1 ),lwork-jw, info )
                           
              end if
              ! ==== copy updated reduced window into place ====
              if( kwtop>1 )h( kwtop, kwtop-1 ) = s*conjg( v( 1, 1 ) )
              call stdlib_zlacpy( 'U', jw, jw, t, ldt, h( kwtop, kwtop ), ldh )
              call stdlib_zcopy( jw-1, t( 2, 1 ), ldt+1, h( kwtop+1, kwtop ),ldh+1 )
              ! ==== accumulate orthogonal matrix in order update
              ! .    h and z, if requested.  ====
              if( ns>1 .and. s/=czero )call stdlib_zunmhr( 'R', 'N', jw, ns, 1, ns, t, ldt, work, &
                        v, ldv,work( jw+1 ), lwork-jw, info )
              ! ==== update vertical slab in h ====
              if( wantt ) then
                 ltop = 1
              else
                 ltop = ktop
              end if
              do krow = ltop, kwtop - 1, nv
                 kln = min( nv, kwtop-krow )
                 call stdlib_zgemm( 'N', 'N', kln, jw, jw, cone, h( krow, kwtop ),ldh, v, ldv, &
                           czero, wv, ldwv )
                 call stdlib_zlacpy( 'A', kln, jw, wv, ldwv, h( krow, kwtop ), ldh )
              end do
              ! ==== update horizontal slab in h ====
              if( wantt ) then
                 do kcol = kbot + 1, n, nh
                    kln = min( nh, n-kcol+1 )
                    call stdlib_zgemm( 'C', 'N', jw, kln, jw, cone, v, ldv,h( kwtop, kcol ), ldh, &
                              czero, t, ldt )
                    call stdlib_zlacpy( 'A', jw, kln, t, ldt, h( kwtop, kcol ),ldh )
                 end do
              end if
              ! ==== update vertical slab in z ====
              if( wantz ) then
                 do krow = iloz, ihiz, nv
                    kln = min( nv, ihiz-krow+1 )
                    call stdlib_zgemm( 'N', 'N', kln, jw, jw, cone, z( krow, kwtop ),ldz, v, ldv, &
                              czero, wv, ldwv )
                    call stdlib_zlacpy( 'A', kln, jw, wv, ldwv, z( krow, kwtop ),ldz )
                 end do
              end if
           end if
           ! ==== return the number of deflations ... ====
           nd = jw - ns
           ! ==== ... and the number of shifts. (subtracting
           ! .    infqr from the spike length takes care
           ! .    of the case of a rare qr failure while
           ! .    calculating eigenvalues of the deflation
           ! .    window.)  ====
           ns = ns - infqr
            ! ==== return optimal workspace. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=dp)
     end subroutine stdlib_zlaqr3

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$laqr3( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
     !! Aggressive early deflation:
     !! ZLAQR3: accepts as input an upper Hessenberg matrix
     !! H and performs an unitary similarity transformation
     !! designed to detect and deflate fully converged eigenvalues from
     !! a trailing principal submatrix.  On output H has been over-
     !! written by a new Hessenberg matrix that is a perturbation of
     !! an unitary similarity transformation of H.  It is to be
     !! hoped that the final version of H has many zero subdiagonal
     !! entries.
               ns, nd, sh, v, ldv, nh, t, ldt,nv, wv, ldwv, work, lwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(ilp), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(${ck}$), intent(out) :: sh(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
        ! ================================================================
           ! Parameters 
           real(${ck}$), parameter :: rzero = 0.0_${ck}$
           real(${ck}$), parameter :: rone = 1.0_${ck}$
           
           
           ! Local Scalars 
           complex(${ck}$) :: beta, cdum, s, tau
           real(${ck}$) :: foo, safmax, safmin, smlnum, ulp
           integer(ilp) :: i, ifst, ilst, info, infqr, j, jw, kcol, kln, knt, krow, kwtop, ltop, &
                     lwk1, lwk2, lwk3, lwkopt, nmin
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! ==== estimate optimal workspace. ====
           jw = min( nw, kbot-ktop+1 )
           if( jw<=2 ) then
              lwkopt = 1
           else
              ! ==== workspace query call to stdlib_${ci}$gehrd ====
              call stdlib_${ci}$gehrd( jw, 1, jw-1, t, ldt, work, work, -1, info )
              lwk1 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_${ci}$unmhr ====
              call stdlib_${ci}$unmhr( 'R', 'N', jw, jw, 1, jw-1, t, ldt, work, v, ldv,work, -1, info )
                        
              lwk2 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_${ci}$laqr4 ====
              call stdlib_${ci}$laqr4( .true., .true., jw, 1, jw, t, ldt, sh, 1, jw, v,ldv, work, -1, &
                        infqr )
              lwk3 = int( work( 1 ),KIND=ilp)
              ! ==== optimal workspace ====
              lwkopt = max( jw+max( lwk1, lwk2 ), lwk3 )
           end if
           ! ==== quick return in case of workspace query. ====
           if( lwork==-1 ) then
              work( 1 ) = cmplx( lwkopt, 0,KIND=${ck}$)
              return
           end if
           ! ==== nothing to do ...
           ! ... for an empty active block ... ====
           ns = 0
           nd = 0
           work( 1 ) = cone
           if( ktop>kbot )return
           ! ... nor for an empty deflation window. ====
           if( nw<1 )return
           ! ==== machine constants ====
           safmin = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_${c2ri(ci)}$labad( safmin, safmax )
           ulp = stdlib_${c2ri(ci)}$lamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=${ck}$) / ulp )
           ! ==== setup deflation window ====
           jw = min( nw, kbot-ktop+1 )
           kwtop = kbot - jw + 1
           if( kwtop==ktop ) then
              s = czero
           else
              s = h( kwtop, kwtop-1 )
           end if
           if( kbot==kwtop ) then
              ! ==== 1-by-1 deflation window: not much to do ====
              sh( kwtop ) = h( kwtop, kwtop )
              ns = 1
              nd = 0
              if( cabs1( s )<=max( smlnum, ulp*cabs1( h( kwtop,kwtop ) ) ) ) then
                 ns = 0
                 nd = 1
                 if( kwtop>ktop )h( kwtop, kwtop-1 ) = czero
              end if
              work( 1 ) = cone
              return
           end if
           ! ==== convert to spike-triangular form.  (in case of a
           ! .    rare qr failure, this routine continues to do
           ! .    aggressive early deflation using that part of
           ! .    the deflation window that converged using infqr
           ! .    here and there to keep track.) ====
           call stdlib_${ci}$lacpy( 'U', jw, jw, h( kwtop, kwtop ), ldh, t, ldt )
           call stdlib_${ci}$copy( jw-1, h( kwtop+1, kwtop ), ldh+1, t( 2, 1 ), ldt+1 )
           call stdlib_${ci}$laset( 'A', jw, jw, czero, cone, v, ldv )
           nmin = stdlib_ilaenv( 12, 'ZLAQR3', 'SV', jw, 1, jw, lwork )
           if( jw>nmin ) then
              call stdlib_${ci}$laqr4( .true., .true., jw, 1, jw, t, ldt, sh( kwtop ), 1,jw, v, ldv, &
                        work, lwork, infqr )
           else
              call stdlib_${ci}$lahqr( .true., .true., jw, 1, jw, t, ldt, sh( kwtop ), 1,jw, v, ldv, &
                        infqr )
           end if
           ! ==== deflation detection loop ====
           ns = jw
           ilst = infqr + 1
           do knt = infqr + 1, jw
              ! ==== small spike tip deflation test ====
              foo = cabs1( t( ns, ns ) )
              if( foo==rzero )foo = cabs1( s )
              if( cabs1( s )*cabs1( v( 1, ns ) )<=max( smlnum, ulp*foo ) )then
                 ! ==== cone more converged eigenvalue ====
                 ns = ns - 1
              else
                 ! ==== cone undeflatable eigenvalue.  move it up out of the
                 ! .    way.   (stdlib_${ci}$trexc can not fail in this case.) ====
                 ifst = ns
                 call stdlib_${ci}$trexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                 ilst = ilst + 1
              end if
           end do
              ! ==== return to hessenberg form ====
           if( ns==0 )s = czero
           if( ns<jw ) then
              ! ==== sorting the diagonal of t improves accuracy for
              ! .    graded matrices.  ====
              do i = infqr + 1, ns
                 ifst = i
                 do j = i + 1, ns
                    if( cabs1( t( j, j ) )>cabs1( t( ifst, ifst ) ) )ifst = j
                 end do
                 ilst = i
                 if( ifst/=ilst )call stdlib_${ci}$trexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                           
              end do
           end if
           ! ==== restore shift/eigenvalue array from t ====
           do i = infqr + 1, jw
              sh( kwtop+i-1 ) = t( i, i )
           end do
           if( ns<jw .or. s==czero ) then
              if( ns>1 .and. s/=czero ) then
                 ! ==== reflect spike back into lower triangle ====
                 call stdlib_${ci}$copy( ns, v, ldv, work, 1 )
                 do i = 1, ns
                    work( i ) = conjg( work( i ) )
                 end do
                 beta = work( 1 )
                 call stdlib_${ci}$larfg( ns, beta, work( 2 ), 1, tau )
                 work( 1 ) = cone
                 call stdlib_${ci}$laset( 'L', jw-2, jw-2, czero, czero, t( 3, 1 ), ldt )
                 call stdlib_${ci}$larf( 'L', ns, jw, work, 1, conjg( tau ), t, ldt,work( jw+1 ) )
                           
                 call stdlib_${ci}$larf( 'R', ns, ns, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_${ci}$larf( 'R', jw, ns, work, 1, tau, v, ldv,work( jw+1 ) )
                 call stdlib_${ci}$gehrd( jw, 1, ns, t, ldt, work, work( jw+1 ),lwork-jw, info )
                           
              end if
              ! ==== copy updated reduced window into place ====
              if( kwtop>1 )h( kwtop, kwtop-1 ) = s*conjg( v( 1, 1 ) )
              call stdlib_${ci}$lacpy( 'U', jw, jw, t, ldt, h( kwtop, kwtop ), ldh )
              call stdlib_${ci}$copy( jw-1, t( 2, 1 ), ldt+1, h( kwtop+1, kwtop ),ldh+1 )
              ! ==== accumulate orthogonal matrix in order update
              ! .    h and z, if requested.  ====
              if( ns>1 .and. s/=czero )call stdlib_${ci}$unmhr( 'R', 'N', jw, ns, 1, ns, t, ldt, work, &
                        v, ldv,work( jw+1 ), lwork-jw, info )
              ! ==== update vertical slab in h ====
              if( wantt ) then
                 ltop = 1
              else
                 ltop = ktop
              end if
              do krow = ltop, kwtop - 1, nv
                 kln = min( nv, kwtop-krow )
                 call stdlib_${ci}$gemm( 'N', 'N', kln, jw, jw, cone, h( krow, kwtop ),ldh, v, ldv, &
                           czero, wv, ldwv )
                 call stdlib_${ci}$lacpy( 'A', kln, jw, wv, ldwv, h( krow, kwtop ), ldh )
              end do
              ! ==== update horizontal slab in h ====
              if( wantt ) then
                 do kcol = kbot + 1, n, nh
                    kln = min( nh, n-kcol+1 )
                    call stdlib_${ci}$gemm( 'C', 'N', jw, kln, jw, cone, v, ldv,h( kwtop, kcol ), ldh, &
                              czero, t, ldt )
                    call stdlib_${ci}$lacpy( 'A', jw, kln, t, ldt, h( kwtop, kcol ),ldh )
                 end do
              end if
              ! ==== update vertical slab in z ====
              if( wantz ) then
                 do krow = iloz, ihiz, nv
                    kln = min( nv, ihiz-krow+1 )
                    call stdlib_${ci}$gemm( 'N', 'N', kln, jw, jw, cone, z( krow, kwtop ),ldz, v, ldv, &
                              czero, wv, ldwv )
                    call stdlib_${ci}$lacpy( 'A', kln, jw, wv, ldwv, z( krow, kwtop ),ldz )
                 end do
              end if
           end if
           ! ==== return the number of deflations ... ====
           nd = jw - ns
           ! ==== ... and the number of shifts. (subtracting
           ! .    infqr from the spike length takes care
           ! .    of the case of a rare qr failure while
           ! .    calculating eigenvalues of the deflation
           ! .    window.)  ====
           ns = ns - infqr
            ! ==== return optimal workspace. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=${ck}$)
     end subroutine stdlib_${ci}$laqr3

#:endif
#:endfor



     pure subroutine stdlib_ctrsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm,&
     !! CTRSNA estimates reciprocal condition numbers for specified
     !! eigenvalues and/or right eigenvectors of a complex upper triangular
     !! matrix T (or of any matrix Q*T*Q**H with Q unitary).
                m, work, ldwork, rwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, ldwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(sp), intent(out) :: rwork(*), s(*), sep(*)
           complex(sp), intent(in) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(sp), intent(out) :: work(ldwork,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: somcon, wantbh, wants, wantsp
           character :: normin
           integer(ilp) :: i, ierr, ix, j, k, kase, ks
           real(sp) :: bignum, eps, est, lnrm, rnrm, scale, smlnum, xnorm
           complex(sp) :: cdum, prod
           ! Local Arrays 
           integer(ilp) :: isave(3)
           complex(sp) :: dummy(1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantsp = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           ! set m to the number of eigenpairs for which condition numbers are
           ! to be computed.
           if( somcon ) then
              m = 0
              do j = 1, n
                 if( select( j ) )m = m + 1
              end do
           else
              m = n
           end if
           info = 0
           if( .not.wants .and. .not.wantsp ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( wants .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( wants .and. ldvr<n ) ) then
              info = -10
           else if( mm<m ) then
              info = -13
           else if( ldwork<1 .or. ( wantsp .and. ldwork<n ) ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTRSNA', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( somcon ) then
                 if( .not.select( 1 ) )return
              end if
              if( wants )s( 1 ) = one
              if( wantsp )sep( 1 ) = abs( t( 1, 1 ) )
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' ) / eps
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           ks = 1
           loop_50: do k = 1, n
              if( somcon ) then
                 if( .not.select( k ) )cycle loop_50
              end if
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 prod = stdlib_cdotc( n, vr( 1, ks ), 1, vl( 1, ks ), 1 )
                 rnrm = stdlib_scnrm2( n, vr( 1, ks ), 1 )
                 lnrm = stdlib_scnrm2( n, vl( 1, ks ), 1 )
                 s( ks ) = abs( prod ) / ( rnrm*lnrm )
              end if
              if( wantsp ) then
                 ! estimate the reciprocal condition number of the k-th
                 ! eigenvector.
                 ! copy the matrix t to the array work and swap the k-th
                 ! diagonal element to the (1,1) position.
                 call stdlib_clacpy( 'FULL', n, n, t, ldt, work, ldwork )
                 call stdlib_ctrexc( 'NO Q', n, work, ldwork, dummy, 1, k, 1, ierr )
                 ! form  c = t22 - lambda*i in work(2:n,2:n).
                 do i = 2, n
                    work( i, i ) = work( i, i ) - work( 1, 1 )
                 end do
                 ! estimate a lower bound for the 1-norm of inv(c**h). the 1st
                 ! and (n+1)th columns of work are used to store work vectors.
                 sep( ks ) = zero
                 est = zero
                 kase = 0
                 normin = 'N'
                 30 continue
                 call stdlib_clacn2( n-1, work( 1, n+1 ), work, est, kase, isave )
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve c**h*x = scale*b
                       call stdlib_clatrs( 'UPPER', 'CONJUGATE TRANSPOSE','NONUNIT', normin, n-1, &
                                 work( 2, 2 ),ldwork, work, scale, rwork, ierr )
                    else
                       ! solve c*x = scale*b
                       call stdlib_clatrs( 'UPPER', 'NO TRANSPOSE', 'NONUNIT',normin, n-1, work( &
                                 2, 2 ), ldwork, work,scale, rwork, ierr )
                    end if
                    normin = 'Y'
                    if( scale/=one ) then
                       ! multiply by 1/scale if doing so will not cause
                       ! overflow.
                       ix = stdlib_icamax( n-1, work, 1 )
                       xnorm = cabs1( work( ix, 1 ) )
                       if( scale<xnorm*smlnum .or. scale==zero )go to 40
                       call stdlib_csrscl( n, scale, work, 1 )
                    end if
                    go to 30
                 end if
                 sep( ks ) = one / max( est, smlnum )
              end if
              40 continue
              ks = ks + 1
           end do loop_50
           return
     end subroutine stdlib_ctrsna

     pure subroutine stdlib_ztrsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm,&
     !! ZTRSNA estimates reciprocal condition numbers for specified
     !! eigenvalues and/or right eigenvectors of a complex upper triangular
     !! matrix T (or of any matrix Q*T*Q**H with Q unitary).
                m, work, ldwork, rwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, ldwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(dp), intent(out) :: rwork(*), s(*), sep(*)
           complex(dp), intent(in) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(dp), intent(out) :: work(ldwork,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: somcon, wantbh, wants, wantsp
           character :: normin
           integer(ilp) :: i, ierr, ix, j, k, kase, ks
           real(dp) :: bignum, eps, est, lnrm, rnrm, scale, smlnum, xnorm
           complex(dp) :: cdum, prod
           ! Local Arrays 
           integer(ilp) :: isave(3)
           complex(dp) :: dummy(1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantsp = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           ! set m to the number of eigenpairs for which condition numbers are
           ! to be computed.
           if( somcon ) then
              m = 0
              do j = 1, n
                 if( select( j ) )m = m + 1
              end do
           else
              m = n
           end if
           info = 0
           if( .not.wants .and. .not.wantsp ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( wants .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( wants .and. ldvr<n ) ) then
              info = -10
           else if( mm<m ) then
              info = -13
           else if( ldwork<1 .or. ( wantsp .and. ldwork<n ) ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTRSNA', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( somcon ) then
                 if( .not.select( 1 ) )return
              end if
              if( wants )s( 1 ) = one
              if( wantsp )sep( 1 ) = abs( t( 1, 1 ) )
              return
           end if
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' ) / eps
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           ks = 1
           loop_50: do k = 1, n
              if( somcon ) then
                 if( .not.select( k ) )cycle loop_50
              end if
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 prod = stdlib_zdotc( n, vr( 1, ks ), 1, vl( 1, ks ), 1 )
                 rnrm = stdlib_dznrm2( n, vr( 1, ks ), 1 )
                 lnrm = stdlib_dznrm2( n, vl( 1, ks ), 1 )
                 s( ks ) = abs( prod ) / ( rnrm*lnrm )
              end if
              if( wantsp ) then
                 ! estimate the reciprocal condition number of the k-th
                 ! eigenvector.
                 ! copy the matrix t to the array work and swap the k-th
                 ! diagonal element to the (1,1) position.
                 call stdlib_zlacpy( 'FULL', n, n, t, ldt, work, ldwork )
                 call stdlib_ztrexc( 'NO Q', n, work, ldwork, dummy, 1, k, 1, ierr )
                 ! form  c = t22 - lambda*i in work(2:n,2:n).
                 do i = 2, n
                    work( i, i ) = work( i, i ) - work( 1, 1 )
                 end do
                 ! estimate a lower bound for the 1-norm of inv(c**h). the 1st
                 ! and (n+1)th columns of work are used to store work vectors.
                 sep( ks ) = zero
                 est = zero
                 kase = 0
                 normin = 'N'
                 30 continue
                 call stdlib_zlacn2( n-1, work( 1, n+1 ), work, est, kase, isave )
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve c**h*x = scale*b
                       call stdlib_zlatrs( 'UPPER', 'CONJUGATE TRANSPOSE','NONUNIT', normin, n-1, &
                                 work( 2, 2 ),ldwork, work, scale, rwork, ierr )
                    else
                       ! solve c*x = scale*b
                       call stdlib_zlatrs( 'UPPER', 'NO TRANSPOSE', 'NONUNIT',normin, n-1, work( &
                                 2, 2 ), ldwork, work,scale, rwork, ierr )
                    end if
                    normin = 'Y'
                    if( scale/=one ) then
                       ! multiply by 1/scale if doing so will not cause
                       ! overflow.
                       ix = stdlib_izamax( n-1, work, 1 )
                       xnorm = cabs1( work( ix, 1 ) )
                       if( scale<xnorm*smlnum .or. scale==zero )go to 40
                       call stdlib_zdrscl( n, scale, work, 1 )
                    end if
                    go to 30
                 end if
                 sep( ks ) = one / max( est, smlnum )
              end if
              40 continue
              ks = ks + 1
           end do loop_50
           return
     end subroutine stdlib_ztrsna

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$trsna( job, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, s, sep, mm,&
     !! ZTRSNA: estimates reciprocal condition numbers for specified
     !! eigenvalues and/or right eigenvectors of a complex upper triangular
     !! matrix T (or of any matrix Q*T*Q**H with Q unitary).
                m, work, ldwork, rwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, ldwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(${ck}$), intent(out) :: rwork(*), s(*), sep(*)
           complex(${ck}$), intent(in) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(${ck}$), intent(out) :: work(ldwork,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: somcon, wantbh, wants, wantsp
           character :: normin
           integer(ilp) :: i, ierr, ix, j, k, kase, ks
           real(${ck}$) :: bignum, eps, est, lnrm, rnrm, scale, smlnum, xnorm
           complex(${ck}$) :: cdum, prod
           ! Local Arrays 
           integer(ilp) :: isave(3)
           complex(${ck}$) :: dummy(1)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantsp = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           ! set m to the number of eigenpairs for which condition numbers are
           ! to be computed.
           if( somcon ) then
              m = 0
              do j = 1, n
                 if( select( j ) )m = m + 1
              end do
           else
              m = n
           end if
           info = 0
           if( .not.wants .and. .not.wantsp ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( wants .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( wants .and. ldvr<n ) ) then
              info = -10
           else if( mm<m ) then
              info = -13
           else if( ldwork<1 .or. ( wantsp .and. ldwork<n ) ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTRSNA', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( somcon ) then
                 if( .not.select( 1 ) )return
              end if
              if( wants )s( 1 ) = one
              if( wantsp )sep( 1 ) = abs( t( 1, 1 ) )
              return
           end if
           ! get machine constants
           eps = stdlib_${c2ri(ci)}$lamch( 'P' )
           smlnum = stdlib_${c2ri(ci)}$lamch( 'S' ) / eps
           bignum = one / smlnum
           call stdlib_${c2ri(ci)}$labad( smlnum, bignum )
           ks = 1
           loop_50: do k = 1, n
              if( somcon ) then
                 if( .not.select( k ) )cycle loop_50
              end if
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 prod = stdlib_${ci}$dotc( n, vr( 1, ks ), 1, vl( 1, ks ), 1 )
                 rnrm = stdlib_${c2ri(ci)}$znrm2( n, vr( 1, ks ), 1 )
                 lnrm = stdlib_${c2ri(ci)}$znrm2( n, vl( 1, ks ), 1 )
                 s( ks ) = abs( prod ) / ( rnrm*lnrm )
              end if
              if( wantsp ) then
                 ! estimate the reciprocal condition number of the k-th
                 ! eigenvector.
                 ! copy the matrix t to the array work and swap the k-th
                 ! diagonal element to the (1,1) position.
                 call stdlib_${ci}$lacpy( 'FULL', n, n, t, ldt, work, ldwork )
                 call stdlib_${ci}$trexc( 'NO Q', n, work, ldwork, dummy, 1, k, 1, ierr )
                 ! form  c = t22 - lambda*i in work(2:n,2:n).
                 do i = 2, n
                    work( i, i ) = work( i, i ) - work( 1, 1 )
                 end do
                 ! estimate a lower bound for the 1-norm of inv(c**h). the 1st
                 ! and (n+1)th columns of work are used to store work vectors.
                 sep( ks ) = zero
                 est = zero
                 kase = 0
                 normin = 'N'
                 30 continue
                 call stdlib_${ci}$lacn2( n-1, work( 1, n+1 ), work, est, kase, isave )
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve c**h*x = scale*b
                       call stdlib_${ci}$latrs( 'UPPER', 'CONJUGATE TRANSPOSE','NONUNIT', normin, n-1, &
                                 work( 2, 2 ),ldwork, work, scale, rwork, ierr )
                    else
                       ! solve c*x = scale*b
                       call stdlib_${ci}$latrs( 'UPPER', 'NO TRANSPOSE', 'NONUNIT',normin, n-1, work( &
                                 2, 2 ), ldwork, work,scale, rwork, ierr )
                    end if
                    normin = 'Y'
                    if( scale/=one ) then
                       ! multiply by 1/scale if doing so will not cause
                       ! overflow.
                       ix = stdlib_i${ci}$amax( n-1, work, 1 )
                       xnorm = cabs1( work( ix, 1 ) )
                       if( scale<xnorm*smlnum .or. scale==zero )go to 40
                       call stdlib_${ci}$drscl( n, scale, work, 1 )
                    end if
                    go to 30
                 end if
                 sep( ks ) = one / max( est, smlnum )
              end if
              40 continue
              ks = ks + 1
           end do loop_50
           return
     end subroutine stdlib_${ci}$trsna

#:endif
#:endfor





     pure subroutine stdlib_slaqr1( n, h, ldh, sr1, si1, sr2, si2, v )
     !! Given a 2-by-2 or 3-by-3 matrix H, SLAQR1: sets v to a
     !! scalar multiple of the first column of the product
     !! (*)  K = (H - (sr1 + i*si1)*I)*(H - (sr2 + i*si2)*I)
     !! scaling to avoid overflows and most underflows. It
     !! is assumed that either
     !! 1) sr1 = sr2 and si1 = -si2
     !! or
     !! 2) si1 = si2 = 0.
     !! This is useful for starting double implicit shift bulges
     !! in the QR algorithm.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(sp), intent(in) :: si1, si2, sr1, sr2
           integer(ilp), intent(in) :: ldh, n
           ! Array Arguments 
           real(sp), intent(in) :: h(ldh,*)
           real(sp), intent(out) :: v(*)
        ! ================================================================
           
           ! Local Scalars 
           real(sp) :: h21s, h31s, s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n/=2 .and. n/=3 ) then
              return
           end if
           if( n==2 ) then
              s = abs( h( 1, 1 )-sr2 ) + abs( si2 ) + abs( h( 2, 1 ) )
              if( s==zero ) then
                 v( 1 ) = zero
                 v( 2 ) = zero
              else
                 h21s = h( 2, 1 ) / s
                 v( 1 ) = h21s*h( 1, 2 ) + ( h( 1, 1 )-sr1 )*( ( h( 1, 1 )-sr2 ) / s ) - si1*( &
                           si2 / s )
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-sr1-sr2 )
              end if
           else
              s = abs( h( 1, 1 )-sr2 ) + abs( si2 ) + abs( h( 2, 1 ) ) +abs( h( 3, 1 ) )
              if( s==zero ) then
                 v( 1 ) = zero
                 v( 2 ) = zero
                 v( 3 ) = zero
              else
                 h21s = h( 2, 1 ) / s
                 h31s = h( 3, 1 ) / s
                 v( 1 ) = ( h( 1, 1 )-sr1 )*( ( h( 1, 1 )-sr2 ) / s ) -si1*( si2 / s ) + h( 1, 2 )&
                           *h21s + h( 1, 3 )*h31s
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-sr1-sr2 ) +h( 2, 3 )*h31s
                 v( 3 ) = h31s*( h( 1, 1 )+h( 3, 3 )-sr1-sr2 ) +h21s*h( 3, 2 )
              end if
           end if
     end subroutine stdlib_slaqr1

     pure subroutine stdlib_dlaqr1( n, h, ldh, sr1, si1, sr2, si2, v )
     !! Given a 2-by-2 or 3-by-3 matrix H, DLAQR1: sets v to a
     !! scalar multiple of the first column of the product
     !! (*)  K = (H - (sr1 + i*si1)*I)*(H - (sr2 + i*si2)*I)
     !! scaling to avoid overflows and most underflows. It
     !! is assumed that either
     !! 1) sr1 = sr2 and si1 = -si2
     !! or
     !! 2) si1 = si2 = 0.
     !! This is useful for starting double implicit shift bulges
     !! in the QR algorithm.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(dp), intent(in) :: si1, si2, sr1, sr2
           integer(ilp), intent(in) :: ldh, n
           ! Array Arguments 
           real(dp), intent(in) :: h(ldh,*)
           real(dp), intent(out) :: v(*)
        ! ================================================================
           
           ! Local Scalars 
           real(dp) :: h21s, h31s, s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n/=2 .and. n/=3 ) then
              return
           end if
           if( n==2 ) then
              s = abs( h( 1, 1 )-sr2 ) + abs( si2 ) + abs( h( 2, 1 ) )
              if( s==zero ) then
                 v( 1 ) = zero
                 v( 2 ) = zero
              else
                 h21s = h( 2, 1 ) / s
                 v( 1 ) = h21s*h( 1, 2 ) + ( h( 1, 1 )-sr1 )*( ( h( 1, 1 )-sr2 ) / s ) - si1*( &
                           si2 / s )
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-sr1-sr2 )
              end if
           else
              s = abs( h( 1, 1 )-sr2 ) + abs( si2 ) + abs( h( 2, 1 ) ) +abs( h( 3, 1 ) )
              if( s==zero ) then
                 v( 1 ) = zero
                 v( 2 ) = zero
                 v( 3 ) = zero
              else
                 h21s = h( 2, 1 ) / s
                 h31s = h( 3, 1 ) / s
                 v( 1 ) = ( h( 1, 1 )-sr1 )*( ( h( 1, 1 )-sr2 ) / s ) -si1*( si2 / s ) + h( 1, 2 )&
                           *h21s + h( 1, 3 )*h31s
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-sr1-sr2 ) +h( 2, 3 )*h31s
                 v( 3 ) = h31s*( h( 1, 1 )+h( 3, 3 )-sr1-sr2 ) +h21s*h( 3, 2 )
              end if
           end if
     end subroutine stdlib_dlaqr1

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$laqr1( n, h, ldh, sr1, si1, sr2, si2, v )
     !! Given a 2-by-2 or 3-by-3 matrix H, DLAQR1: sets v to a
     !! scalar multiple of the first column of the product
     !! (*)  K = (H - (sr1 + i*si1)*I)*(H - (sr2 + i*si2)*I)
     !! scaling to avoid overflows and most underflows. It
     !! is assumed that either
     !! 1) sr1 = sr2 and si1 = -si2
     !! or
     !! 2) si1 = si2 = 0.
     !! This is useful for starting double implicit shift bulges
     !! in the QR algorithm.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: si1, si2, sr1, sr2
           integer(ilp), intent(in) :: ldh, n
           ! Array Arguments 
           real(${rk}$), intent(in) :: h(ldh,*)
           real(${rk}$), intent(out) :: v(*)
        ! ================================================================
           
           ! Local Scalars 
           real(${rk}$) :: h21s, h31s, s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n/=2 .and. n/=3 ) then
              return
           end if
           if( n==2 ) then
              s = abs( h( 1, 1 )-sr2 ) + abs( si2 ) + abs( h( 2, 1 ) )
              if( s==zero ) then
                 v( 1 ) = zero
                 v( 2 ) = zero
              else
                 h21s = h( 2, 1 ) / s
                 v( 1 ) = h21s*h( 1, 2 ) + ( h( 1, 1 )-sr1 )*( ( h( 1, 1 )-sr2 ) / s ) - si1*( &
                           si2 / s )
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-sr1-sr2 )
              end if
           else
              s = abs( h( 1, 1 )-sr2 ) + abs( si2 ) + abs( h( 2, 1 ) ) +abs( h( 3, 1 ) )
              if( s==zero ) then
                 v( 1 ) = zero
                 v( 2 ) = zero
                 v( 3 ) = zero
              else
                 h21s = h( 2, 1 ) / s
                 h31s = h( 3, 1 ) / s
                 v( 1 ) = ( h( 1, 1 )-sr1 )*( ( h( 1, 1 )-sr2 ) / s ) -si1*( si2 / s ) + h( 1, 2 )&
                           *h21s + h( 1, 3 )*h31s
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-sr1-sr2 ) +h( 2, 3 )*h31s
                 v( 3 ) = h31s*( h( 1, 1 )+h( 3, 3 )-sr1-sr2 ) +h21s*h( 3, 2 )
              end if
           end if
     end subroutine stdlib_${ri}$laqr1

#:endif
#:endfor

     pure subroutine stdlib_claqr1( n, h, ldh, s1, s2, v )
     !! Given a 2-by-2 or 3-by-3 matrix H, CLAQR1: sets v to a
     !! scalar multiple of the first column of the product
     !! (*)  K = (H - s1*I)*(H - s2*I)
     !! scaling to avoid overflows and most underflows.
     !! This is useful for starting double implicit shift bulges
     !! in the QR algorithm.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           complex(sp), intent(in) :: s1, s2
           integer(ilp), intent(in) :: ldh, n
           ! Array Arguments 
           complex(sp), intent(in) :: h(ldh,*)
           complex(sp), intent(out) :: v(*)
        ! ================================================================
           ! Parameters 
           real(sp), parameter :: rzero = 0.0_sp
           
           
           ! Local Scalars 
           complex(sp) :: cdum, h21s, h31s
           real(sp) :: s
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! quick return if possible
           if( n/=2 .and. n/=3 ) then
              return
           end if
           if( n==2 ) then
              s = cabs1( h( 1, 1 )-s2 ) + cabs1( h( 2, 1 ) )
              if( s==rzero ) then
                 v( 1 ) = czero
                 v( 2 ) = czero
              else
                 h21s = h( 2, 1 ) / s
                 v( 1 ) = h21s*h( 1, 2 ) + ( h( 1, 1 )-s1 )*( ( h( 1, 1 )-s2 ) / s )
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-s1-s2 )
              end if
           else
              s = cabs1( h( 1, 1 )-s2 ) + cabs1( h( 2, 1 ) ) +cabs1( h( 3, 1 ) )
              if( s==czero ) then
                 v( 1 ) = czero
                 v( 2 ) = czero
                 v( 3 ) = czero
              else
                 h21s = h( 2, 1 ) / s
                 h31s = h( 3, 1 ) / s
                 v( 1 ) = ( h( 1, 1 )-s1 )*( ( h( 1, 1 )-s2 ) / s ) +h( 1, 2 )*h21s + h( 1, 3 )&
                           *h31s
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-s1-s2 ) + h( 2, 3 )*h31s
                 v( 3 ) = h31s*( h( 1, 1 )+h( 3, 3 )-s1-s2 ) + h21s*h( 3, 2 )
              end if
           end if
     end subroutine stdlib_claqr1

     pure subroutine stdlib_zlaqr1( n, h, ldh, s1, s2, v )
     !! Given a 2-by-2 or 3-by-3 matrix H, ZLAQR1: sets v to a
     !! scalar multiple of the first column of the product
     !! (*)  K = (H - s1*I)*(H - s2*I)
     !! scaling to avoid overflows and most underflows.
     !! This is useful for starting double implicit shift bulges
     !! in the QR algorithm.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           complex(dp), intent(in) :: s1, s2
           integer(ilp), intent(in) :: ldh, n
           ! Array Arguments 
           complex(dp), intent(in) :: h(ldh,*)
           complex(dp), intent(out) :: v(*)
        ! ================================================================
           ! Parameters 
           real(dp), parameter :: rzero = 0.0_dp
           
           
           ! Local Scalars 
           complex(dp) :: cdum, h21s, h31s
           real(dp) :: s
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! quick return if possible
           if( n/=2 .and. n/=3 ) then
              return
           end if
           if( n==2 ) then
              s = cabs1( h( 1, 1 )-s2 ) + cabs1( h( 2, 1 ) )
              if( s==rzero ) then
                 v( 1 ) = czero
                 v( 2 ) = czero
              else
                 h21s = h( 2, 1 ) / s
                 v( 1 ) = h21s*h( 1, 2 ) + ( h( 1, 1 )-s1 )*( ( h( 1, 1 )-s2 ) / s )
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-s1-s2 )
              end if
           else
              s = cabs1( h( 1, 1 )-s2 ) + cabs1( h( 2, 1 ) ) +cabs1( h( 3, 1 ) )
              if( s==czero ) then
                 v( 1 ) = czero
                 v( 2 ) = czero
                 v( 3 ) = czero
              else
                 h21s = h( 2, 1 ) / s
                 h31s = h( 3, 1 ) / s
                 v( 1 ) = ( h( 1, 1 )-s1 )*( ( h( 1, 1 )-s2 ) / s ) +h( 1, 2 )*h21s + h( 1, 3 )&
                           *h31s
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-s1-s2 ) + h( 2, 3 )*h31s
                 v( 3 ) = h31s*( h( 1, 1 )+h( 3, 3 )-s1-s2 ) + h21s*h( 3, 2 )
              end if
           end if
     end subroutine stdlib_zlaqr1

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$laqr1( n, h, ldh, s1, s2, v )
     !! Given a 2-by-2 or 3-by-3 matrix H, ZLAQR1: sets v to a
     !! scalar multiple of the first column of the product
     !! (*)  K = (H - s1*I)*(H - s2*I)
     !! scaling to avoid overflows and most underflows.
     !! This is useful for starting double implicit shift bulges
     !! in the QR algorithm.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           complex(${ck}$), intent(in) :: s1, s2
           integer(ilp), intent(in) :: ldh, n
           ! Array Arguments 
           complex(${ck}$), intent(in) :: h(ldh,*)
           complex(${ck}$), intent(out) :: v(*)
        ! ================================================================
           ! Parameters 
           real(${ck}$), parameter :: rzero = 0.0_${ck}$
           
           
           ! Local Scalars 
           complex(${ck}$) :: cdum, h21s, h31s
           real(${ck}$) :: s
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! quick return if possible
           if( n/=2 .and. n/=3 ) then
              return
           end if
           if( n==2 ) then
              s = cabs1( h( 1, 1 )-s2 ) + cabs1( h( 2, 1 ) )
              if( s==rzero ) then
                 v( 1 ) = czero
                 v( 2 ) = czero
              else
                 h21s = h( 2, 1 ) / s
                 v( 1 ) = h21s*h( 1, 2 ) + ( h( 1, 1 )-s1 )*( ( h( 1, 1 )-s2 ) / s )
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-s1-s2 )
              end if
           else
              s = cabs1( h( 1, 1 )-s2 ) + cabs1( h( 2, 1 ) ) +cabs1( h( 3, 1 ) )
              if( s==czero ) then
                 v( 1 ) = czero
                 v( 2 ) = czero
                 v( 3 ) = czero
              else
                 h21s = h( 2, 1 ) / s
                 h31s = h( 3, 1 ) / s
                 v( 1 ) = ( h( 1, 1 )-s1 )*( ( h( 1, 1 )-s2 ) / s ) +h( 1, 2 )*h21s + h( 1, 3 )&
                           *h31s
                 v( 2 ) = h21s*( h( 1, 1 )+h( 2, 2 )-s1-s2 ) + h( 2, 3 )*h31s
                 v( 3 ) = h31s*( h( 1, 1 )+h( 3, 3 )-s1-s2 ) + h21s*h( 3, 2 )
              end if
           end if
     end subroutine stdlib_${ci}$laqr1

#:endif
#:endfor



     pure subroutine stdlib_slaqz2( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, qstart, &
     !! SLAQZ2 chases a 2x2 shift bulge in a matrix pencil down a single position
               q, ldq, nz, zstart, z, ldz )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           logical(lk), intent( in ) :: ilq, ilz
           integer(ilp), intent( in ) :: k, lda, ldb, ldq, ldz, istartm, istopm,nq, nz, qstart, &
                     zstart, ihi
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           
           ! local variables
           real(sp) :: h(2,3), c1, s1, c2, s2, temp
           if( k+2 == ihi ) then
              ! shift is located on the edge of the matrix, remove it
              h = b( ihi-1:ihi, ihi-2:ihi )
              ! make h upper triangular
              call stdlib_slartg( h( 1, 1 ), h( 2, 1 ), c1, s1, temp )
              h( 2, 1 ) = zero
              h( 1, 1 ) = temp
              call stdlib_srot( 2, h( 1, 2 ), 2, h( 2, 2 ), 2, c1, s1 )
              call stdlib_slartg( h( 2, 3 ), h( 2, 2 ), c1, s1, temp )
              call stdlib_srot( 1, h( 1, 3 ), 1, h( 1, 2 ), 1, c1, s1 )
              call stdlib_slartg( h( 1, 2 ), h( 1, 1 ), c2, s2, temp )
              call stdlib_srot( ihi-istartm+1, b( istartm, ihi ), 1, b( istartm,ihi-1 ), 1, c1, &
                        s1 )
              call stdlib_srot( ihi-istartm+1, b( istartm, ihi-1 ), 1, b( istartm,ihi-2 ), 1, c2, &
                        s2 )
              b( ihi-1, ihi-2 ) = zero
              b( ihi, ihi-2 ) = zero
              call stdlib_srot( ihi-istartm+1, a( istartm, ihi ), 1, a( istartm,ihi-1 ), 1, c1, &
                        s1 )
              call stdlib_srot( ihi-istartm+1, a( istartm, ihi-1 ), 1, a( istartm,ihi-2 ), 1, c2, &
                        s2 )
              if ( ilz ) then
                 call stdlib_srot( nz, z( 1, ihi-zstart+1 ), 1, z( 1, ihi-1-zstart+1 ), 1, c1, s1 &
                           )
                 call stdlib_srot( nz, z( 1, ihi-1-zstart+1 ), 1, z( 1,ihi-2-zstart+1 ), 1, c2, &
                           s2 )
              end if
              call stdlib_slartg( a( ihi-1, ihi-2 ), a( ihi, ihi-2 ), c1, s1,temp )
              a( ihi-1, ihi-2 ) = temp
              a( ihi, ihi-2 ) = zero
              call stdlib_srot( istopm-ihi+2, a( ihi-1, ihi-1 ), lda, a( ihi,ihi-1 ), lda, c1, s1 &
                        )
              call stdlib_srot( istopm-ihi+2, b( ihi-1, ihi-1 ), ldb, b( ihi,ihi-1 ), ldb, c1, s1 &
                        )
              if ( ilq ) then
                 call stdlib_srot( nq, q( 1, ihi-1-qstart+1 ), 1, q( 1, ihi-qstart+1 ), 1, c1, s1 &
                           )
              end if
              call stdlib_slartg( b( ihi, ihi ), b( ihi, ihi-1 ), c1, s1, temp )
              b( ihi, ihi ) = temp
              b( ihi, ihi-1 ) = zero
              call stdlib_srot( ihi-istartm, b( istartm, ihi ), 1, b( istartm,ihi-1 ), 1, c1, s1 )
                        
              call stdlib_srot( ihi-istartm+1, a( istartm, ihi ), 1, a( istartm,ihi-1 ), 1, c1, &
                        s1 )
              if ( ilz ) then
                 call stdlib_srot( nz, z( 1, ihi-zstart+1 ), 1, z( 1, ihi-1-zstart+1 ), 1, c1, s1 &
                           )
              end if
           else
              ! normal operation, move bulge down
              h = b( k+1:k+2, k:k+2 )
              ! make h upper triangular
              call stdlib_slartg( h( 1, 1 ), h( 2, 1 ), c1, s1, temp )
              h( 2, 1 ) = zero
              h( 1, 1 ) = temp
              call stdlib_srot( 2, h( 1, 2 ), 2, h( 2, 2 ), 2, c1, s1 )
              ! calculate z1 and z2
              call stdlib_slartg( h( 2, 3 ), h( 2, 2 ), c1, s1, temp )
              call stdlib_srot( 1, h( 1, 3 ), 1, h( 1, 2 ), 1, c1, s1 )
              call stdlib_slartg( h( 1, 2 ), h( 1, 1 ), c2, s2, temp )
              ! apply transformations from the right
              call stdlib_srot( k+3-istartm+1, a( istartm, k+2 ), 1, a( istartm,k+1 ), 1, c1, s1 )
                        
              call stdlib_srot( k+3-istartm+1, a( istartm, k+1 ), 1, a( istartm,k ), 1, c2, s2 )
                        
              call stdlib_srot( k+2-istartm+1, b( istartm, k+2 ), 1, b( istartm,k+1 ), 1, c1, s1 )
                        
              call stdlib_srot( k+2-istartm+1, b( istartm, k+1 ), 1, b( istartm,k ), 1, c2, s2 )
                        
              if ( ilz ) then
                 call stdlib_srot( nz, z( 1, k+2-zstart+1 ), 1, z( 1, k+1-zstart+1 ), 1, c1, s1 )
                           
                 call stdlib_srot( nz, z( 1, k+1-zstart+1 ), 1, z( 1, k-zstart+1 ),1, c2, s2 )
                           
              end if
              b( k+1, k ) = zero
              b( k+2, k ) = zero
              ! calculate q1 and q2
              call stdlib_slartg( a( k+2, k ), a( k+3, k ), c1, s1, temp )
              a( k+2, k ) = temp
              a( k+3, k ) = zero
              call stdlib_slartg( a( k+1, k ), a( k+2, k ), c2, s2, temp )
              a( k+1, k ) = temp
              a( k+2, k ) = zero
           ! apply transformations from the left
              call stdlib_srot( istopm-k, a( k+2, k+1 ), lda, a( k+3, k+1 ), lda,c1, s1 )
              call stdlib_srot( istopm-k, a( k+1, k+1 ), lda, a( k+2, k+1 ), lda,c2, s2 )
              call stdlib_srot( istopm-k, b( k+2, k+1 ), ldb, b( k+3, k+1 ), ldb,c1, s1 )
              call stdlib_srot( istopm-k, b( k+1, k+1 ), ldb, b( k+2, k+1 ), ldb,c2, s2 )
              if ( ilq ) then
                 call stdlib_srot( nq, q( 1, k+2-qstart+1 ), 1, q( 1, k+3-qstart+1 ), 1, c1, s1 )
                           
                 call stdlib_srot( nq, q( 1, k+1-qstart+1 ), 1, q( 1, k+2-qstart+1 ), 1, c2, s2 )
                           
              end if
           end if
     end subroutine stdlib_slaqz2

     pure subroutine stdlib_dlaqz2( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, qstart, &
     !! DLAQZ2 chases a 2x2 shift bulge in a matrix pencil down a single position
               q, ldq, nz, zstart, z, ldz )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           logical(lk), intent( in ) :: ilq, ilz
           integer(ilp), intent( in ) :: k, lda, ldb, ldq, ldz, istartm, istopm,nq, nz, qstart, &
                     zstart, ihi
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           
           ! local variables
           real(dp) :: h(2,3), c1, s1, c2, s2, temp
           if( k+2 == ihi ) then
              ! shift is located on the edge of the matrix, remove it
              h = b( ihi-1:ihi, ihi-2:ihi )
              ! make h upper triangular
              call stdlib_dlartg( h( 1, 1 ), h( 2, 1 ), c1, s1, temp )
              h( 2, 1 ) = zero
              h( 1, 1 ) = temp
              call stdlib_drot( 2, h( 1, 2 ), 2, h( 2, 2 ), 2, c1, s1 )
              call stdlib_dlartg( h( 2, 3 ), h( 2, 2 ), c1, s1, temp )
              call stdlib_drot( 1, h( 1, 3 ), 1, h( 1, 2 ), 1, c1, s1 )
              call stdlib_dlartg( h( 1, 2 ), h( 1, 1 ), c2, s2, temp )
              call stdlib_drot( ihi-istartm+1, b( istartm, ihi ), 1, b( istartm,ihi-1 ), 1, c1, &
                        s1 )
              call stdlib_drot( ihi-istartm+1, b( istartm, ihi-1 ), 1, b( istartm,ihi-2 ), 1, c2, &
                        s2 )
              b( ihi-1, ihi-2 ) = zero
              b( ihi, ihi-2 ) = zero
              call stdlib_drot( ihi-istartm+1, a( istartm, ihi ), 1, a( istartm,ihi-1 ), 1, c1, &
                        s1 )
              call stdlib_drot( ihi-istartm+1, a( istartm, ihi-1 ), 1, a( istartm,ihi-2 ), 1, c2, &
                        s2 )
              if ( ilz ) then
                 call stdlib_drot( nz, z( 1, ihi-zstart+1 ), 1, z( 1, ihi-1-zstart+1 ), 1, c1, s1 &
                           )
                 call stdlib_drot( nz, z( 1, ihi-1-zstart+1 ), 1, z( 1,ihi-2-zstart+1 ), 1, c2, &
                           s2 )
              end if
              call stdlib_dlartg( a( ihi-1, ihi-2 ), a( ihi, ihi-2 ), c1, s1,temp )
              a( ihi-1, ihi-2 ) = temp
              a( ihi, ihi-2 ) = zero
              call stdlib_drot( istopm-ihi+2, a( ihi-1, ihi-1 ), lda, a( ihi,ihi-1 ), lda, c1, s1 &
                        )
              call stdlib_drot( istopm-ihi+2, b( ihi-1, ihi-1 ), ldb, b( ihi,ihi-1 ), ldb, c1, s1 &
                        )
              if ( ilq ) then
                 call stdlib_drot( nq, q( 1, ihi-1-qstart+1 ), 1, q( 1, ihi-qstart+1 ), 1, c1, s1 &
                           )
              end if
              call stdlib_dlartg( b( ihi, ihi ), b( ihi, ihi-1 ), c1, s1, temp )
              b( ihi, ihi ) = temp
              b( ihi, ihi-1 ) = zero
              call stdlib_drot( ihi-istartm, b( istartm, ihi ), 1, b( istartm,ihi-1 ), 1, c1, s1 )
                        
              call stdlib_drot( ihi-istartm+1, a( istartm, ihi ), 1, a( istartm,ihi-1 ), 1, c1, &
                        s1 )
              if ( ilz ) then
                 call stdlib_drot( nz, z( 1, ihi-zstart+1 ), 1, z( 1, ihi-1-zstart+1 ), 1, c1, s1 &
                           )
              end if
           else
              ! normal operation, move bulge down
              h = b( k+1:k+2, k:k+2 )
              ! make h upper triangular
              call stdlib_dlartg( h( 1, 1 ), h( 2, 1 ), c1, s1, temp )
              h( 2, 1 ) = zero
              h( 1, 1 ) = temp
              call stdlib_drot( 2, h( 1, 2 ), 2, h( 2, 2 ), 2, c1, s1 )
              ! calculate z1 and z2
              call stdlib_dlartg( h( 2, 3 ), h( 2, 2 ), c1, s1, temp )
              call stdlib_drot( 1, h( 1, 3 ), 1, h( 1, 2 ), 1, c1, s1 )
              call stdlib_dlartg( h( 1, 2 ), h( 1, 1 ), c2, s2, temp )
              ! apply transformations from the right
              call stdlib_drot( k+3-istartm+1, a( istartm, k+2 ), 1, a( istartm,k+1 ), 1, c1, s1 )
                        
              call stdlib_drot( k+3-istartm+1, a( istartm, k+1 ), 1, a( istartm,k ), 1, c2, s2 )
                        
              call stdlib_drot( k+2-istartm+1, b( istartm, k+2 ), 1, b( istartm,k+1 ), 1, c1, s1 )
                        
              call stdlib_drot( k+2-istartm+1, b( istartm, k+1 ), 1, b( istartm,k ), 1, c2, s2 )
                        
              if ( ilz ) then
                 call stdlib_drot( nz, z( 1, k+2-zstart+1 ), 1, z( 1, k+1-zstart+1 ), 1, c1, s1 )
                           
                 call stdlib_drot( nz, z( 1, k+1-zstart+1 ), 1, z( 1, k-zstart+1 ),1, c2, s2 )
                           
              end if
              b( k+1, k ) = zero
              b( k+2, k ) = zero
              ! calculate q1 and q2
              call stdlib_dlartg( a( k+2, k ), a( k+3, k ), c1, s1, temp )
              a( k+2, k ) = temp
              a( k+3, k ) = zero
              call stdlib_dlartg( a( k+1, k ), a( k+2, k ), c2, s2, temp )
              a( k+1, k ) = temp
              a( k+2, k ) = zero
              ! apply transformations from the left
              call stdlib_drot( istopm-k, a( k+2, k+1 ), lda, a( k+3, k+1 ), lda,c1, s1 )
              call stdlib_drot( istopm-k, a( k+1, k+1 ), lda, a( k+2, k+1 ), lda,c2, s2 )
              call stdlib_drot( istopm-k, b( k+2, k+1 ), ldb, b( k+3, k+1 ), ldb,c1, s1 )
              call stdlib_drot( istopm-k, b( k+1, k+1 ), ldb, b( k+2, k+1 ), ldb,c2, s2 )
              if ( ilq ) then
                 call stdlib_drot( nq, q( 1, k+2-qstart+1 ), 1, q( 1, k+3-qstart+1 ), 1, c1, s1 )
                           
                 call stdlib_drot( nq, q( 1, k+1-qstart+1 ), 1, q( 1, k+2-qstart+1 ), 1, c2, s2 )
                           
              end if
           end if
     end subroutine stdlib_dlaqz2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$laqz2( ilq, ilz, k, istartm, istopm, ihi, a, lda, b,ldb, nq, qstart, &
     !! DLAQZ2: chases a 2x2 shift bulge in a matrix pencil down a single position
               q, ldq, nz, zstart, z, ldz )
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! arguments
           logical(lk), intent( in ) :: ilq, ilz
           integer(ilp), intent( in ) :: k, lda, ldb, ldq, ldz, istartm, istopm,nq, nz, qstart, &
                     zstart, ihi
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           
           ! local variables
           real(${rk}$) :: h(2,3), c1, s1, c2, s2, temp
           if( k+2 == ihi ) then
              ! shift is located on the edge of the matrix, remove it
              h = b( ihi-1:ihi, ihi-2:ihi )
              ! make h upper triangular
              call stdlib_${ri}$lartg( h( 1, 1 ), h( 2, 1 ), c1, s1, temp )
              h( 2, 1 ) = zero
              h( 1, 1 ) = temp
              call stdlib_${ri}$rot( 2, h( 1, 2 ), 2, h( 2, 2 ), 2, c1, s1 )
              call stdlib_${ri}$lartg( h( 2, 3 ), h( 2, 2 ), c1, s1, temp )
              call stdlib_${ri}$rot( 1, h( 1, 3 ), 1, h( 1, 2 ), 1, c1, s1 )
              call stdlib_${ri}$lartg( h( 1, 2 ), h( 1, 1 ), c2, s2, temp )
              call stdlib_${ri}$rot( ihi-istartm+1, b( istartm, ihi ), 1, b( istartm,ihi-1 ), 1, c1, &
                        s1 )
              call stdlib_${ri}$rot( ihi-istartm+1, b( istartm, ihi-1 ), 1, b( istartm,ihi-2 ), 1, c2, &
                        s2 )
              b( ihi-1, ihi-2 ) = zero
              b( ihi, ihi-2 ) = zero
              call stdlib_${ri}$rot( ihi-istartm+1, a( istartm, ihi ), 1, a( istartm,ihi-1 ), 1, c1, &
                        s1 )
              call stdlib_${ri}$rot( ihi-istartm+1, a( istartm, ihi-1 ), 1, a( istartm,ihi-2 ), 1, c2, &
                        s2 )
              if ( ilz ) then
                 call stdlib_${ri}$rot( nz, z( 1, ihi-zstart+1 ), 1, z( 1, ihi-1-zstart+1 ), 1, c1, s1 &
                           )
                 call stdlib_${ri}$rot( nz, z( 1, ihi-1-zstart+1 ), 1, z( 1,ihi-2-zstart+1 ), 1, c2, &
                           s2 )
              end if
              call stdlib_${ri}$lartg( a( ihi-1, ihi-2 ), a( ihi, ihi-2 ), c1, s1,temp )
              a( ihi-1, ihi-2 ) = temp
              a( ihi, ihi-2 ) = zero
              call stdlib_${ri}$rot( istopm-ihi+2, a( ihi-1, ihi-1 ), lda, a( ihi,ihi-1 ), lda, c1, s1 &
                        )
              call stdlib_${ri}$rot( istopm-ihi+2, b( ihi-1, ihi-1 ), ldb, b( ihi,ihi-1 ), ldb, c1, s1 &
                        )
              if ( ilq ) then
                 call stdlib_${ri}$rot( nq, q( 1, ihi-1-qstart+1 ), 1, q( 1, ihi-qstart+1 ), 1, c1, s1 &
                           )
              end if
              call stdlib_${ri}$lartg( b( ihi, ihi ), b( ihi, ihi-1 ), c1, s1, temp )
              b( ihi, ihi ) = temp
              b( ihi, ihi-1 ) = zero
              call stdlib_${ri}$rot( ihi-istartm, b( istartm, ihi ), 1, b( istartm,ihi-1 ), 1, c1, s1 )
                        
              call stdlib_${ri}$rot( ihi-istartm+1, a( istartm, ihi ), 1, a( istartm,ihi-1 ), 1, c1, &
                        s1 )
              if ( ilz ) then
                 call stdlib_${ri}$rot( nz, z( 1, ihi-zstart+1 ), 1, z( 1, ihi-1-zstart+1 ), 1, c1, s1 &
                           )
              end if
           else
              ! normal operation, move bulge down
              h = b( k+1:k+2, k:k+2 )
              ! make h upper triangular
              call stdlib_${ri}$lartg( h( 1, 1 ), h( 2, 1 ), c1, s1, temp )
              h( 2, 1 ) = zero
              h( 1, 1 ) = temp
              call stdlib_${ri}$rot( 2, h( 1, 2 ), 2, h( 2, 2 ), 2, c1, s1 )
              ! calculate z1 and z2
              call stdlib_${ri}$lartg( h( 2, 3 ), h( 2, 2 ), c1, s1, temp )
              call stdlib_${ri}$rot( 1, h( 1, 3 ), 1, h( 1, 2 ), 1, c1, s1 )
              call stdlib_${ri}$lartg( h( 1, 2 ), h( 1, 1 ), c2, s2, temp )
              ! apply transformations from the right
              call stdlib_${ri}$rot( k+3-istartm+1, a( istartm, k+2 ), 1, a( istartm,k+1 ), 1, c1, s1 )
                        
              call stdlib_${ri}$rot( k+3-istartm+1, a( istartm, k+1 ), 1, a( istartm,k ), 1, c2, s2 )
                        
              call stdlib_${ri}$rot( k+2-istartm+1, b( istartm, k+2 ), 1, b( istartm,k+1 ), 1, c1, s1 )
                        
              call stdlib_${ri}$rot( k+2-istartm+1, b( istartm, k+1 ), 1, b( istartm,k ), 1, c2, s2 )
                        
              if ( ilz ) then
                 call stdlib_${ri}$rot( nz, z( 1, k+2-zstart+1 ), 1, z( 1, k+1-zstart+1 ), 1, c1, s1 )
                           
                 call stdlib_${ri}$rot( nz, z( 1, k+1-zstart+1 ), 1, z( 1, k-zstart+1 ),1, c2, s2 )
                           
              end if
              b( k+1, k ) = zero
              b( k+2, k ) = zero
              ! calculate q1 and q2
              call stdlib_${ri}$lartg( a( k+2, k ), a( k+3, k ), c1, s1, temp )
              a( k+2, k ) = temp
              a( k+3, k ) = zero
              call stdlib_${ri}$lartg( a( k+1, k ), a( k+2, k ), c2, s2, temp )
              a( k+1, k ) = temp
              a( k+2, k ) = zero
              ! apply transformations from the left
              call stdlib_${ri}$rot( istopm-k, a( k+2, k+1 ), lda, a( k+3, k+1 ), lda,c1, s1 )
              call stdlib_${ri}$rot( istopm-k, a( k+1, k+1 ), lda, a( k+2, k+1 ), lda,c2, s2 )
              call stdlib_${ri}$rot( istopm-k, b( k+2, k+1 ), ldb, b( k+3, k+1 ), ldb,c1, s1 )
              call stdlib_${ri}$rot( istopm-k, b( k+1, k+1 ), ldb, b( k+2, k+1 ), ldb,c2, s2 )
              if ( ilq ) then
                 call stdlib_${ri}$rot( nq, q( 1, k+2-qstart+1 ), 1, q( 1, k+3-qstart+1 ), 1, c1, s1 )
                           
                 call stdlib_${ri}$rot( nq, q( 1, k+1-qstart+1 ), 1, q( 1, k+2-qstart+1 ), 1, c2, s2 )
                           
              end if
           end if
     end subroutine stdlib_${ri}$laqz2

#:endif
#:endfor



     pure subroutine stdlib_ctrexc( compq, n, t, ldt, q, ldq, ifst, ilst, info )
     !! CTREXC reorders the Schur factorization of a complex matrix
     !! A = Q*T*Q**H, so that the diagonal element of T with row index IFST
     !! is moved to row ILST.
     !! The Schur form T is reordered by a unitary similarity transformation
     !! Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by
     !! postmultplying it with Z.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq
           integer(ilp), intent(in) :: ifst, ilst, ldq, ldt, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: q(ldq,*), t(ldt,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: wantq
           integer(ilp) :: k, m1, m2, m3
           real(sp) :: cs
           complex(sp) :: sn, t11, t22, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           info = 0
           wantq = stdlib_lsame( compq, 'V' )
           if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldt<max( 1, n ) ) then
              info = -4
           else if( ldq<1 .or. ( wantq .and. ldq<max( 1, n ) ) ) then
              info = -6
           else if(( ifst<1 .or. ifst>n ).and.( n>0 )) then
              info = -7
           else if(( ilst<1 .or. ilst>n ).and.( n>0 )) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTREXC', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 .or. ifst==ilst )return
           if( ifst<ilst ) then
              ! move the ifst-th diagonal element forward down the diagonal.
              m1 = 0
              m2 = -1
              m3 = 1
           else
              ! move the ifst-th diagonal element backward up the diagonal.
              m1 = -1
              m2 = 0
              m3 = -1
           end if
           do k = ifst + m1, ilst + m2, m3
              ! interchange the k-th and (k+1)-th diagonal elements.
              t11 = t( k, k )
              t22 = t( k+1, k+1 )
              ! determine the transformation to perform the interchange.
              call stdlib_clartg( t( k, k+1 ), t22-t11, cs, sn, temp )
              ! apply transformation to the matrix t.
              if( k+2<=n )call stdlib_crot( n-k-1, t( k, k+2 ), ldt, t( k+1, k+2 ), ldt, cs,sn )
                        
              call stdlib_crot( k-1, t( 1, k ), 1, t( 1, k+1 ), 1, cs, conjg( sn ) )
              t( k, k ) = t22
              t( k+1, k+1 ) = t11
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_crot( n, q( 1, k ), 1, q( 1, k+1 ), 1, cs,conjg( sn ) )
              end if
           end do
           return
     end subroutine stdlib_ctrexc

     pure subroutine stdlib_ztrexc( compq, n, t, ldt, q, ldq, ifst, ilst, info )
     !! ZTREXC reorders the Schur factorization of a complex matrix
     !! A = Q*T*Q**H, so that the diagonal element of T with row index IFST
     !! is moved to row ILST.
     !! The Schur form T is reordered by a unitary similarity transformation
     !! Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by
     !! postmultplying it with Z.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq
           integer(ilp), intent(in) :: ifst, ilst, ldq, ldt, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(dp), intent(inout) :: q(ldq,*), t(ldt,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: wantq
           integer(ilp) :: k, m1, m2, m3
           real(dp) :: cs
           complex(dp) :: sn, t11, t22, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           info = 0
           wantq = stdlib_lsame( compq, 'V' )
           if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldt<max( 1, n ) ) then
              info = -4
           else if( ldq<1 .or. ( wantq .and. ldq<max( 1, n ) ) ) then
              info = -6
           else if(( ifst<1 .or. ifst>n ).and.( n>0 )) then
              info = -7
           else if(( ilst<1 .or. ilst>n ).and.( n>0 )) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTREXC', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 .or. ifst==ilst )return
           if( ifst<ilst ) then
              ! move the ifst-th diagonal element forward down the diagonal.
              m1 = 0
              m2 = -1
              m3 = 1
           else
              ! move the ifst-th diagonal element backward up the diagonal.
              m1 = -1
              m2 = 0
              m3 = -1
           end if
           do k = ifst + m1, ilst + m2, m3
              ! interchange the k-th and (k+1)-th diagonal elements.
              t11 = t( k, k )
              t22 = t( k+1, k+1 )
              ! determine the transformation to perform the interchange.
              call stdlib_zlartg( t( k, k+1 ), t22-t11, cs, sn, temp )
              ! apply transformation to the matrix t.
              if( k+2<=n )call stdlib_zrot( n-k-1, t( k, k+2 ), ldt, t( k+1, k+2 ), ldt, cs,sn )
                        
              call stdlib_zrot( k-1, t( 1, k ), 1, t( 1, k+1 ), 1, cs,conjg( sn ) )
              t( k, k ) = t22
              t( k+1, k+1 ) = t11
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_zrot( n, q( 1, k ), 1, q( 1, k+1 ), 1, cs,conjg( sn ) )
              end if
           end do
           return
     end subroutine stdlib_ztrexc

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$trexc( compq, n, t, ldt, q, ldq, ifst, ilst, info )
     !! ZTREXC: reorders the Schur factorization of a complex matrix
     !! A = Q*T*Q**H, so that the diagonal element of T with row index IFST
     !! is moved to row ILST.
     !! The Schur form T is reordered by a unitary similarity transformation
     !! Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by
     !! postmultplying it with Z.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq
           integer(ilp), intent(in) :: ifst, ilst, ldq, ldt, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: q(ldq,*), t(ldt,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: wantq
           integer(ilp) :: k, m1, m2, m3
           real(${ck}$) :: cs
           complex(${ck}$) :: sn, t11, t22, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           info = 0
           wantq = stdlib_lsame( compq, 'V' )
           if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldt<max( 1, n ) ) then
              info = -4
           else if( ldq<1 .or. ( wantq .and. ldq<max( 1, n ) ) ) then
              info = -6
           else if(( ifst<1 .or. ifst>n ).and.( n>0 )) then
              info = -7
           else if(( ilst<1 .or. ilst>n ).and.( n>0 )) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTREXC', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 .or. ifst==ilst )return
           if( ifst<ilst ) then
              ! move the ifst-th diagonal element forward down the diagonal.
              m1 = 0
              m2 = -1
              m3 = 1
           else
              ! move the ifst-th diagonal element backward up the diagonal.
              m1 = -1
              m2 = 0
              m3 = -1
           end if
           do k = ifst + m1, ilst + m2, m3
              ! interchange the k-th and (k+1)-th diagonal elements.
              t11 = t( k, k )
              t22 = t( k+1, k+1 )
              ! determine the transformation to perform the interchange.
              call stdlib_${ci}$lartg( t( k, k+1 ), t22-t11, cs, sn, temp )
              ! apply transformation to the matrix t.
              if( k+2<=n )call stdlib_${ci}$rot( n-k-1, t( k, k+2 ), ldt, t( k+1, k+2 ), ldt, cs,sn )
                        
              call stdlib_${ci}$rot( k-1, t( 1, k ), 1, t( 1, k+1 ), 1, cs,conjg( sn ) )
              t( k, k ) = t22
              t( k+1, k+1 ) = t11
              if( wantq ) then
                 ! accumulate transformation in the matrix q.
                 call stdlib_${ci}$rot( n, q( 1, k ), 1, q( 1, k+1 ), 1, cs,conjg( sn ) )
              end if
           end do
           return
     end subroutine stdlib_${ci}$trexc

#:endif
#:endfor





     pure subroutine stdlib_slaqz4( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_desired, sr, &
     !! SLAQZ4 Executes a single multishift QZ sweep
               si, ss, a, lda, b, ldb, q,ldq, z, ldz, qc, ldqc, zc, ldzc, work, lwork,info )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! function arguments
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(ilp), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,nshifts, &
                     nblock_desired, ldqc, ldzc
           real(sp), intent( inout ) :: a( lda, * ), b( ldb, * ), q( ldq, * ),z( ldz, * ), qc( &
                     ldqc, * ), zc( ldzc, * ), work( * ), sr( * ),si( * ), ss( * )
           integer(ilp), intent( out ) :: info
           
           ! local scalars
           integer(ilp) :: i, j, ns, istartm, istopm, sheight, swidth, k, np, istartb, istopb, &
                     ishift, nblock, npos
           real(sp) :: temp, v(3), c1, s1, c2, s2, swap
           info = 0
           if ( nblock_desired < nshifts+1 ) then
              info = -8
           end if
           if ( lwork ==-1 ) then
              ! workspace query, quick return
              work( 1 ) = n*nblock_desired
              return
           else if ( lwork < n*nblock_desired ) then
              info = -25
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SLAQZ4', -info )
              return
           end if
           ! executable statements
           if ( nshifts < 2 ) then
              return
           end if
           if ( ilo >= ihi ) then
              return
           end if
           if ( ilschur ) then
              istartm = 1
              istopm = n
           else
              istartm = ilo
              istopm = ihi
           end if
           ! shuffle shifts into pairs of real shifts and pairs
           ! of complex conjugate shifts assuming complex
           ! conjugate shifts are already adjacent to one
           ! another
           do i = 1, nshifts-2, 2
              if( si( i )/=-si( i+1 ) ) then
                 swap = sr( i )
                 sr( i ) = sr( i+1 )
                 sr( i+1 ) = sr( i+2 )
                 sr( i+2 ) = swap
                 swap = si( i )
                 si( i ) = si( i+1 )
                 si( i+1 ) = si( i+2 )
                 si( i+2 ) = swap
                 swap = ss( i )
                 ss( i ) = ss( i+1 )
                 ss( i+1 ) = ss( i+2 )
                 ss( i+2 ) = swap
              end if
           end do
           ! nshfts is supposed to be even, but if it is odd,
           ! then simply reduce it by one.  the shuffle above
           ! ensures that the dropped shift is real and that
           ! the remaining shifts are paired.
           ns = nshifts-mod( nshifts, 2 )
           npos = max( nblock_desired-ns, 1 )
           ! the following block introduces the shifts and chases
           ! them down one by one just enough to make space for
           ! the other shifts. the near-the-diagonal block is
           ! of size (ns+1) x ns.
           call stdlib_slaset( 'FULL', ns+1, ns+1, zero, one, qc, ldqc )
           call stdlib_slaset( 'FULL', ns, ns, zero, one, zc, ldzc )
           do i = 1, ns, 2
              ! introduce the shift
              call stdlib_slaqz1( a( ilo, ilo ), lda, b( ilo, ilo ), ldb, sr( i ),sr( i+1 ), si( &
                        i ), ss( i ), ss( i+1 ), v )
              temp = v( 2 )
              call stdlib_slartg( temp, v( 3 ), c1, s1, v( 2 ) )
              call stdlib_slartg( v( 1 ), v( 2 ), c2, s2, temp )
              call stdlib_srot( ns, a( ilo+1, ilo ), lda, a( ilo+2, ilo ), lda, c1,s1 )
              call stdlib_srot( ns, a( ilo, ilo ), lda, a( ilo+1, ilo ), lda, c2,s2 )
              call stdlib_srot( ns, b( ilo+1, ilo ), ldb, b( ilo+2, ilo ), ldb, c1,s1 )
              call stdlib_srot( ns, b( ilo, ilo ), ldb, b( ilo+1, ilo ), ldb, c2,s2 )
              call stdlib_srot( ns+1, qc( 1, 2 ), 1, qc( 1, 3 ), 1, c1, s1 )
              call stdlib_srot( ns+1, qc( 1, 1 ), 1, qc( 1, 2 ), 1, c2, s2 )
              ! chase the shift down
              do j = 1, ns-1-i
                 call stdlib_slaqz2( .true., .true., j, 1, ns, ihi-ilo+1, a( ilo,ilo ), lda, b( &
                           ilo, ilo ), ldb, ns+1, 1, qc,ldqc, ns, 1, zc, ldzc )
              end do
           end do
           ! update the rest of the pencil
           ! update a(ilo:ilo+ns,ilo+ns:istopm) and b(ilo:ilo+ns,ilo+ns:istopm)
           ! from the left with qc(1:ns+1,1:ns+1)'
           sheight = ns+1
           swidth = istopm-( ilo+ns )+1
           if ( swidth > 0 ) then
              call stdlib_sgemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,a( ilo, ilo+ns &
                        ), lda, zero, work, sheight )
              call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight, a( ilo,ilo+ns ), lda )
                        
              call stdlib_sgemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,b( ilo, ilo+ns &
                        ), ldb, zero, work, sheight )
              call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight, b( ilo,ilo+ns ), ldb )
                        
           end if
           if ( ilq ) then
              call stdlib_sgemm( 'N', 'N', n, sheight, sheight, one, q( 1, ilo ),ldq, qc, ldqc, &
                        zero, work, n )
              call stdlib_slacpy( 'ALL', n, sheight, work, n, q( 1, ilo ), ldq )
           end if
           ! update a(istartm:ilo-1,ilo:ilo+ns-1) and b(istartm:ilo-1,ilo:ilo+ns-1)
           ! from the right with zc(1:ns,1:ns)
           sheight = ilo-1-istartm+1
           swidth = ns
           if ( sheight > 0 ) then
              call stdlib_sgemm( 'N', 'N', sheight, swidth, swidth, one, a( istartm,ilo ), lda, &
                        zc, ldzc, zero, work, sheight )
              call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ilo ), lda )
                        
              call stdlib_sgemm( 'N', 'N', sheight, swidth, swidth, one, b( istartm,ilo ), ldb, &
                        zc, ldzc, zero, work, sheight )
              call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ilo ), ldb )
                        
           end if
           if ( ilz ) then
              call stdlib_sgemm( 'N', 'N', n, swidth, swidth, one, z( 1, ilo ), ldz,zc, ldzc, &
                        zero, work, n )
              call stdlib_slacpy( 'ALL', n, swidth, work, n, z( 1, ilo ), ldz )
           end if
           ! the following block chases the shifts down to the bottom
           ! right block. if possible, a shift is moved down npos
           ! positions at a time
           k = ilo
           do while ( k < ihi-ns )
              np = min( ihi-ns-k, npos )
              ! size of the near-the-diagonal block
              nblock = ns+np
              ! istartb points to the first row we will be updating
              istartb = k+1
              ! istopb points to the last column we will be updating
              istopb = k+nblock-1
              call stdlib_slaset( 'FULL', ns+np, ns+np, zero, one, qc, ldqc )
              call stdlib_slaset( 'FULL', ns+np, ns+np, zero, one, zc, ldzc )
              ! near the diagonal shift chase
              do i = ns-1, 0, -2
                 do j = 0, np-1
                    ! move down the block with index k+i+j-1, updating
                    ! the (ns+np x ns+np) block:
                    ! (k:k+ns+np,k:k+ns+np-1)
                    call stdlib_slaqz2( .true., .true., k+i+j-1, istartb, istopb,ihi, a, lda, b, &
                              ldb, nblock, k+1, qc, ldqc,nblock, k, zc, ldzc )
                 end do
              end do
              ! update rest of the pencil
              ! update a(k+1:k+ns+np, k+ns+np:istopm) and
              ! b(k+1:k+ns+np, k+ns+np:istopm)
              ! from the left with qc(1:ns+np,1:ns+np)'
              sheight = ns+np
              swidth = istopm-( k+ns+np )+1
              if ( swidth > 0 ) then
                 call stdlib_sgemm( 'T', 'N', sheight, swidth, sheight, one, qc,ldqc, a( k+1, k+&
                           ns+np ), lda, zero, work,sheight )
                 call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight, a( k+1,k+ns+np ), lda &
                           )
                 call stdlib_sgemm( 'T', 'N', sheight, swidth, sheight, one, qc,ldqc, b( k+1, k+&
                           ns+np ), ldb, zero, work,sheight )
                 call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight, b( k+1,k+ns+np ), ldb &
                           )
              end if
              if ( ilq ) then
                 call stdlib_sgemm( 'N', 'N', n, nblock, nblock, one, q( 1, k+1 ),ldq, qc, ldqc, &
                           zero, work, n )
                 call stdlib_slacpy( 'ALL', n, nblock, work, n, q( 1, k+1 ), ldq )
              end if
              ! update a(istartm:k,k:k+ns+npos-1) and b(istartm:k,k:k+ns+npos-1)
              ! from the right with zc(1:ns+np,1:ns+np)
              sheight = k-istartm+1
              swidth = nblock
              if ( sheight > 0 ) then
                 call stdlib_sgemm( 'N', 'N', sheight, swidth, swidth, one,a( istartm, k ), lda, &
                           zc, ldzc, zero, work,sheight )
                 call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight,a( istartm, k ), lda )
                           
                 call stdlib_sgemm( 'N', 'N', sheight, swidth, swidth, one,b( istartm, k ), ldb, &
                           zc, ldzc, zero, work,sheight )
                 call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight,b( istartm, k ), ldb )
                           
              end if
              if ( ilz ) then
                 call stdlib_sgemm( 'N', 'N', n, nblock, nblock, one, z( 1, k ),ldz, zc, ldzc, &
                           zero, work, n )
                 call stdlib_slacpy( 'ALL', n, nblock, work, n, z( 1, k ), ldz )
              end if
              k = k+np
           end do
           ! the following block removes the shifts from the bottom right corner
           ! one by one. updates are initially applied to a(ihi-ns+1:ihi,ihi-ns:ihi).
           call stdlib_slaset( 'FULL', ns, ns, zero, one, qc, ldqc )
           call stdlib_slaset( 'FULL', ns+1, ns+1, zero, one, zc, ldzc )
           ! istartb points to the first row we will be updating
           istartb = ihi-ns+1
           ! istopb points to the last column we will be updating
           istopb = ihi
           do i = 1, ns, 2
              ! chase the shift down to the bottom right corner
              do ishift = ihi-i-1, ihi-2
                 call stdlib_slaqz2( .true., .true., ishift, istartb, istopb, ihi,a, lda, b, ldb, &
                           ns, ihi-ns+1, qc, ldqc, ns+1,ihi-ns, zc, ldzc )
              end do
           end do
           ! update rest of the pencil
           ! update a(ihi-ns+1:ihi, ihi+1:istopm)
           ! from the left with qc(1:ns,1:ns)'
           sheight = ns
           swidth = istopm-( ihi+1 )+1
           if ( swidth > 0 ) then
              call stdlib_sgemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,a( ihi-ns+1, &
                        ihi+1 ), lda, zero, work, sheight )
              call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight,a( ihi-ns+1, ihi+1 ), lda &
                        )
              call stdlib_sgemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,b( ihi-ns+1, &
                        ihi+1 ), ldb, zero, work, sheight )
              call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight,b( ihi-ns+1, ihi+1 ), ldb &
                        )
           end if
           if ( ilq ) then
              call stdlib_sgemm( 'N', 'N', n, ns, ns, one, q( 1, ihi-ns+1 ), ldq,qc, ldqc, zero, &
                        work, n )
              call stdlib_slacpy( 'ALL', n, ns, work, n, q( 1, ihi-ns+1 ), ldq )
           end if
           ! update a(istartm:ihi-ns,ihi-ns:ihi)
           ! from the right with zc(1:ns+1,1:ns+1)
           sheight = ihi-ns-istartm+1
           swidth = ns+1
           if ( sheight > 0 ) then
              call stdlib_sgemm( 'N', 'N', sheight, swidth, swidth, one, a( istartm,ihi-ns ), lda,&
                         zc, ldzc, zero, work, sheight )
              call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ihi-ns ), lda &
                        )
              call stdlib_sgemm( 'N', 'N', sheight, swidth, swidth, one, b( istartm,ihi-ns ), ldb,&
                         zc, ldzc, zero, work, sheight )
              call stdlib_slacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ihi-ns ), ldb &
                        )
           end if
           if ( ilz ) then
           call stdlib_sgemm( 'N', 'N', n, ns+1, ns+1, one, z( 1, ihi-ns ), ldz, zc,ldzc, zero, &
                     work, n )
              call stdlib_slacpy( 'ALL', n, ns+1, work, n, z( 1, ihi-ns ), ldz )
           end if
     end subroutine stdlib_slaqz4

     pure subroutine stdlib_dlaqz4( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_desired, sr, &
     !! DLAQZ4 Executes a single multishift QZ sweep
               si, ss, a, lda, b, ldb, q,ldq, z, ldz, qc, ldqc, zc, ldzc, work, lwork,info )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! function arguments
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(ilp), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,nshifts, &
                     nblock_desired, ldqc, ldzc
           real(dp), intent( inout ) :: a( lda, * ), b( ldb, * ),q( ldq, * ), z( ldz, * ), qc( &
                     ldqc, * ),zc( ldzc, * ), work( * ), sr( * ), si( * ),ss( * )
           integer(ilp), intent( out ) :: info
           
           ! local scalars
           integer(ilp) :: i, j, ns, istartm, istopm, sheight, swidth, k, np, istartb, istopb, &
                     ishift, nblock, npos
           real(dp) :: temp, v(3), c1, s1, c2, s2, swap
           info = 0
           if ( nblock_desired < nshifts+1 ) then
              info = -8
           end if
           if ( lwork ==-1 ) then
              ! workspace query, quick return
              work( 1 ) = n*nblock_desired
              return
           else if ( lwork < n*nblock_desired ) then
              info = -25
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAQZ4', -info )
              return
           end if
           ! executable statements
           if ( nshifts < 2 ) then
              return
           end if
           if ( ilo >= ihi ) then
              return
           end if
           if ( ilschur ) then
              istartm = 1
              istopm = n
           else
              istartm = ilo
              istopm = ihi
           end if
           ! shuffle shifts into pairs of real shifts and pairs
           ! of complex conjugate shifts assuming complex
           ! conjugate shifts are already adjacent to one
           ! another
           do i = 1, nshifts-2, 2
              if( si( i )/=-si( i+1 ) ) then
                 swap = sr( i )
                 sr( i ) = sr( i+1 )
                 sr( i+1 ) = sr( i+2 )
                 sr( i+2 ) = swap
                 swap = si( i )
                 si( i ) = si( i+1 )
                 si( i+1 ) = si( i+2 )
                 si( i+2 ) = swap
                 swap = ss( i )
                 ss( i ) = ss( i+1 )
                 ss( i+1 ) = ss( i+2 )
                 ss( i+2 ) = swap
              end if
           end do
           ! nshfts is supposed to be even, but if it is odd,
           ! then simply reduce it by one.  the shuffle above
           ! ensures that the dropped shift is real and that
           ! the remaining shifts are paired.
           ns = nshifts-mod( nshifts, 2 )
           npos = max( nblock_desired-ns, 1 )
           ! the following block introduces the shifts and chases
           ! them down one by one just enough to make space for
           ! the other shifts. the near-the-diagonal block is
           ! of size (ns+1) x ns.
           call stdlib_dlaset( 'FULL', ns+1, ns+1, zero, one, qc, ldqc )
           call stdlib_dlaset( 'FULL', ns, ns, zero, one, zc, ldzc )
           do i = 1, ns, 2
              ! introduce the shift
              call stdlib_dlaqz1( a( ilo, ilo ), lda, b( ilo, ilo ), ldb, sr( i ),sr( i+1 ), si( &
                        i ), ss( i ), ss( i+1 ), v )
              temp = v( 2 )
              call stdlib_dlartg( temp, v( 3 ), c1, s1, v( 2 ) )
              call stdlib_dlartg( v( 1 ), v( 2 ), c2, s2, temp )
              call stdlib_drot( ns, a( ilo+1, ilo ), lda, a( ilo+2, ilo ), lda, c1,s1 )
              call stdlib_drot( ns, a( ilo, ilo ), lda, a( ilo+1, ilo ), lda, c2,s2 )
              call stdlib_drot( ns, b( ilo+1, ilo ), ldb, b( ilo+2, ilo ), ldb, c1,s1 )
              call stdlib_drot( ns, b( ilo, ilo ), ldb, b( ilo+1, ilo ), ldb, c2,s2 )
              call stdlib_drot( ns+1, qc( 1, 2 ), 1, qc( 1, 3 ), 1, c1, s1 )
              call stdlib_drot( ns+1, qc( 1, 1 ), 1, qc( 1, 2 ), 1, c2, s2 )
              ! chase the shift down
              do j = 1, ns-1-i
                 call stdlib_dlaqz2( .true., .true., j, 1, ns, ihi-ilo+1, a( ilo,ilo ), lda, b( &
                           ilo, ilo ), ldb, ns+1, 1, qc,ldqc, ns, 1, zc, ldzc )
              end do
           end do
           ! update the rest of the pencil
           ! update a(ilo:ilo+ns,ilo+ns:istopm) and b(ilo:ilo+ns,ilo+ns:istopm)
           ! from the left with qc(1:ns+1,1:ns+1)'
           sheight = ns+1
           swidth = istopm-( ilo+ns )+1
           if ( swidth > 0 ) then
              call stdlib_dgemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,a( ilo, ilo+ns &
                        ), lda, zero, work, sheight )
              call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight, a( ilo,ilo+ns ), lda )
                        
              call stdlib_dgemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,b( ilo, ilo+ns &
                        ), ldb, zero, work, sheight )
              call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight, b( ilo,ilo+ns ), ldb )
                        
           end if
           if ( ilq ) then
              call stdlib_dgemm( 'N', 'N', n, sheight, sheight, one, q( 1, ilo ),ldq, qc, ldqc, &
                        zero, work, n )
              call stdlib_dlacpy( 'ALL', n, sheight, work, n, q( 1, ilo ), ldq )
           end if
           ! update a(istartm:ilo-1,ilo:ilo+ns-1) and b(istartm:ilo-1,ilo:ilo+ns-1)
           ! from the right with zc(1:ns,1:ns)
           sheight = ilo-1-istartm+1
           swidth = ns
           if ( sheight > 0 ) then
              call stdlib_dgemm( 'N', 'N', sheight, swidth, swidth, one, a( istartm,ilo ), lda, &
                        zc, ldzc, zero, work, sheight )
              call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ilo ), lda )
                        
              call stdlib_dgemm( 'N', 'N', sheight, swidth, swidth, one, b( istartm,ilo ), ldb, &
                        zc, ldzc, zero, work, sheight )
              call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ilo ), ldb )
                        
           end if
           if ( ilz ) then
              call stdlib_dgemm( 'N', 'N', n, swidth, swidth, one, z( 1, ilo ), ldz,zc, ldzc, &
                        zero, work, n )
              call stdlib_dlacpy( 'ALL', n, swidth, work, n, z( 1, ilo ), ldz )
           end if
           ! the following block chases the shifts down to the bottom
           ! right block. if possible, a shift is moved down npos
           ! positions at a time
           k = ilo
           do while ( k < ihi-ns )
              np = min( ihi-ns-k, npos )
              ! size of the near-the-diagonal block
              nblock = ns+np
              ! istartb points to the first row we will be updating
              istartb = k+1
              ! istopb points to the last column we will be updating
              istopb = k+nblock-1
              call stdlib_dlaset( 'FULL', ns+np, ns+np, zero, one, qc, ldqc )
              call stdlib_dlaset( 'FULL', ns+np, ns+np, zero, one, zc, ldzc )
              ! near the diagonal shift chase
              do i = ns-1, 0, -2
                 do j = 0, np-1
                    ! move down the block with index k+i+j-1, updating
                    ! the (ns+np x ns+np) block:
                    ! (k:k+ns+np,k:k+ns+np-1)
                    call stdlib_dlaqz2( .true., .true., k+i+j-1, istartb, istopb,ihi, a, lda, b, &
                              ldb, nblock, k+1, qc, ldqc,nblock, k, zc, ldzc )
                 end do
              end do
              ! update rest of the pencil
              ! update a(k+1:k+ns+np, k+ns+np:istopm) and
              ! b(k+1:k+ns+np, k+ns+np:istopm)
              ! from the left with qc(1:ns+np,1:ns+np)'
              sheight = ns+np
              swidth = istopm-( k+ns+np )+1
              if ( swidth > 0 ) then
                 call stdlib_dgemm( 'T', 'N', sheight, swidth, sheight, one, qc,ldqc, a( k+1, k+&
                           ns+np ), lda, zero, work,sheight )
                 call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight, a( k+1,k+ns+np ), lda &
                           )
                 call stdlib_dgemm( 'T', 'N', sheight, swidth, sheight, one, qc,ldqc, b( k+1, k+&
                           ns+np ), ldb, zero, work,sheight )
                 call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight, b( k+1,k+ns+np ), ldb &
                           )
              end if
              if ( ilq ) then
                 call stdlib_dgemm( 'N', 'N', n, nblock, nblock, one, q( 1, k+1 ),ldq, qc, ldqc, &
                           zero, work, n )
                 call stdlib_dlacpy( 'ALL', n, nblock, work, n, q( 1, k+1 ), ldq )
              end if
              ! update a(istartm:k,k:k+ns+npos-1) and b(istartm:k,k:k+ns+npos-1)
              ! from the right with zc(1:ns+np,1:ns+np)
              sheight = k-istartm+1
              swidth = nblock
              if ( sheight > 0 ) then
                 call stdlib_dgemm( 'N', 'N', sheight, swidth, swidth, one,a( istartm, k ), lda, &
                           zc, ldzc, zero, work,sheight )
                 call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight,a( istartm, k ), lda )
                           
                 call stdlib_dgemm( 'N', 'N', sheight, swidth, swidth, one,b( istartm, k ), ldb, &
                           zc, ldzc, zero, work,sheight )
                 call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight,b( istartm, k ), ldb )
                           
              end if
              if ( ilz ) then
                 call stdlib_dgemm( 'N', 'N', n, nblock, nblock, one, z( 1, k ),ldz, zc, ldzc, &
                           zero, work, n )
                 call stdlib_dlacpy( 'ALL', n, nblock, work, n, z( 1, k ), ldz )
              end if
              k = k+np
           end do
           ! the following block removes the shifts from the bottom right corner
           ! one by one. updates are initially applied to a(ihi-ns+1:ihi,ihi-ns:ihi).
           call stdlib_dlaset( 'FULL', ns, ns, zero, one, qc, ldqc )
           call stdlib_dlaset( 'FULL', ns+1, ns+1, zero, one, zc, ldzc )
           ! istartb points to the first row we will be updating
           istartb = ihi-ns+1
           ! istopb points to the last column we will be updating
           istopb = ihi
           do i = 1, ns, 2
              ! chase the shift down to the bottom right corner
              do ishift = ihi-i-1, ihi-2
                 call stdlib_dlaqz2( .true., .true., ishift, istartb, istopb, ihi,a, lda, b, ldb, &
                           ns, ihi-ns+1, qc, ldqc, ns+1,ihi-ns, zc, ldzc )
              end do
           end do
           ! update rest of the pencil
           ! update a(ihi-ns+1:ihi, ihi+1:istopm)
           ! from the left with qc(1:ns,1:ns)'
           sheight = ns
           swidth = istopm-( ihi+1 )+1
           if ( swidth > 0 ) then
              call stdlib_dgemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,a( ihi-ns+1, &
                        ihi+1 ), lda, zero, work, sheight )
              call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight,a( ihi-ns+1, ihi+1 ), lda &
                        )
              call stdlib_dgemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,b( ihi-ns+1, &
                        ihi+1 ), ldb, zero, work, sheight )
              call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight,b( ihi-ns+1, ihi+1 ), ldb &
                        )
           end if
           if ( ilq ) then
              call stdlib_dgemm( 'N', 'N', n, ns, ns, one, q( 1, ihi-ns+1 ), ldq,qc, ldqc, zero, &
                        work, n )
              call stdlib_dlacpy( 'ALL', n, ns, work, n, q( 1, ihi-ns+1 ), ldq )
           end if
           ! update a(istartm:ihi-ns,ihi-ns:ihi)
           ! from the right with zc(1:ns+1,1:ns+1)
           sheight = ihi-ns-istartm+1
           swidth = ns+1
           if ( sheight > 0 ) then
              call stdlib_dgemm( 'N', 'N', sheight, swidth, swidth, one, a( istartm,ihi-ns ), lda,&
                         zc, ldzc, zero, work, sheight )
              call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ihi-ns ), lda &
                        )
              call stdlib_dgemm( 'N', 'N', sheight, swidth, swidth, one, b( istartm,ihi-ns ), ldb,&
                         zc, ldzc, zero, work, sheight )
              call stdlib_dlacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ihi-ns ), ldb &
                        )
           end if
           if ( ilz ) then
              call stdlib_dgemm( 'N', 'N', n, ns+1, ns+1, one, z( 1, ihi-ns ), ldz,zc, ldzc, zero,&
                         work, n )
              call stdlib_dlacpy( 'ALL', n, ns+1, work, n, z( 1, ihi-ns ), ldz )
           end if
     end subroutine stdlib_dlaqz4

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$laqz4( ilschur, ilq, ilz, n, ilo, ihi, nshifts,nblock_qesired, sr, &
     !! DLAQZ4: Executes a single multishift QZ sweep
               si, ss, a, lda, b, ldb, q,ldq, z, ldz, qc, ldqc, zc, ldzc, work, lwork,info )
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! function arguments
           logical(lk), intent( in ) :: ilschur, ilq, ilz
           integer(ilp), intent( in ) :: n, ilo, ihi, lda, ldb, ldq, ldz, lwork,nshifts, &
                     nblock_qesired, ldqc, ldzc
           real(${rk}$), intent( inout ) :: a( lda, * ), b( ldb, * ),q( ldq, * ), z( ldz, * ), qc( &
                     ldqc, * ),zc( ldzc, * ), work( * ), sr( * ), si( * ),ss( * )
           integer(ilp), intent( out ) :: info
           
           ! local scalars
           integer(ilp) :: i, j, ns, istartm, istopm, sheight, swidth, k, np, istartb, istopb, &
                     ishift, nblock, npos
           real(${rk}$) :: temp, v(3), c1, s1, c2, s2, swap
           info = 0
           if ( nblock_qesired < nshifts+1 ) then
              info = -8
           end if
           if ( lwork ==-1 ) then
              ! workspace query, quick return
              work( 1 ) = n*nblock_qesired
              return
           else if ( lwork < n*nblock_qesired ) then
              info = -25
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAQZ4', -info )
              return
           end if
           ! executable statements
           if ( nshifts < 2 ) then
              return
           end if
           if ( ilo >= ihi ) then
              return
           end if
           if ( ilschur ) then
              istartm = 1
              istopm = n
           else
              istartm = ilo
              istopm = ihi
           end if
           ! shuffle shifts into pairs of real shifts and pairs
           ! of complex conjugate shifts assuming complex
           ! conjugate shifts are already adjacent to one
           ! another
           do i = 1, nshifts-2, 2
              if( si( i )/=-si( i+1 ) ) then
                 swap = sr( i )
                 sr( i ) = sr( i+1 )
                 sr( i+1 ) = sr( i+2 )
                 sr( i+2 ) = swap
                 swap = si( i )
                 si( i ) = si( i+1 )
                 si( i+1 ) = si( i+2 )
                 si( i+2 ) = swap
                 swap = ss( i )
                 ss( i ) = ss( i+1 )
                 ss( i+1 ) = ss( i+2 )
                 ss( i+2 ) = swap
              end if
           end do
           ! nshfts is supposed to be even, but if it is odd,
           ! then simply reduce it by one.  the shuffle above
           ! ensures that the dropped shift is real and that
           ! the remaining shifts are paired.
           ns = nshifts-mod( nshifts, 2 )
           npos = max( nblock_qesired-ns, 1 )
           ! the following block introduces the shifts and chases
           ! them down one by one just enough to make space for
           ! the other shifts. the near-the-diagonal block is
           ! of size (ns+1) x ns.
           call stdlib_${ri}$laset( 'FULL', ns+1, ns+1, zero, one, qc, ldqc )
           call stdlib_${ri}$laset( 'FULL', ns, ns, zero, one, zc, ldzc )
           do i = 1, ns, 2
              ! introduce the shift
              call stdlib_${ri}$laqz1( a( ilo, ilo ), lda, b( ilo, ilo ), ldb, sr( i ),sr( i+1 ), si( &
                        i ), ss( i ), ss( i+1 ), v )
              temp = v( 2 )
              call stdlib_${ri}$lartg( temp, v( 3 ), c1, s1, v( 2 ) )
              call stdlib_${ri}$lartg( v( 1 ), v( 2 ), c2, s2, temp )
              call stdlib_${ri}$rot( ns, a( ilo+1, ilo ), lda, a( ilo+2, ilo ), lda, c1,s1 )
              call stdlib_${ri}$rot( ns, a( ilo, ilo ), lda, a( ilo+1, ilo ), lda, c2,s2 )
              call stdlib_${ri}$rot( ns, b( ilo+1, ilo ), ldb, b( ilo+2, ilo ), ldb, c1,s1 )
              call stdlib_${ri}$rot( ns, b( ilo, ilo ), ldb, b( ilo+1, ilo ), ldb, c2,s2 )
              call stdlib_${ri}$rot( ns+1, qc( 1, 2 ), 1, qc( 1, 3 ), 1, c1, s1 )
              call stdlib_${ri}$rot( ns+1, qc( 1, 1 ), 1, qc( 1, 2 ), 1, c2, s2 )
              ! chase the shift down
              do j = 1, ns-1-i
                 call stdlib_${ri}$laqz2( .true., .true., j, 1, ns, ihi-ilo+1, a( ilo,ilo ), lda, b( &
                           ilo, ilo ), ldb, ns+1, 1, qc,ldqc, ns, 1, zc, ldzc )
              end do
           end do
           ! update the rest of the pencil
           ! update a(ilo:ilo+ns,ilo+ns:istopm) and b(ilo:ilo+ns,ilo+ns:istopm)
           ! from the left with qc(1:ns+1,1:ns+1)'
           sheight = ns+1
           swidth = istopm-( ilo+ns )+1
           if ( swidth > 0 ) then
              call stdlib_${ri}$gemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,a( ilo, ilo+ns &
                        ), lda, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, a( ilo,ilo+ns ), lda )
                        
              call stdlib_${ri}$gemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,b( ilo, ilo+ns &
                        ), ldb, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, b( ilo,ilo+ns ), ldb )
                        
           end if
           if ( ilq ) then
              call stdlib_${ri}$gemm( 'N', 'N', n, sheight, sheight, one, q( 1, ilo ),ldq, qc, ldqc, &
                        zero, work, n )
              call stdlib_${ri}$lacpy( 'ALL', n, sheight, work, n, q( 1, ilo ), ldq )
           end if
           ! update a(istartm:ilo-1,ilo:ilo+ns-1) and b(istartm:ilo-1,ilo:ilo+ns-1)
           ! from the right with zc(1:ns,1:ns)
           sheight = ilo-1-istartm+1
           swidth = ns
           if ( sheight > 0 ) then
              call stdlib_${ri}$gemm( 'N', 'N', sheight, swidth, swidth, one, a( istartm,ilo ), lda, &
                        zc, ldzc, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ilo ), lda )
                        
              call stdlib_${ri}$gemm( 'N', 'N', sheight, swidth, swidth, one, b( istartm,ilo ), ldb, &
                        zc, ldzc, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ilo ), ldb )
                        
           end if
           if ( ilz ) then
              call stdlib_${ri}$gemm( 'N', 'N', n, swidth, swidth, one, z( 1, ilo ), ldz,zc, ldzc, &
                        zero, work, n )
              call stdlib_${ri}$lacpy( 'ALL', n, swidth, work, n, z( 1, ilo ), ldz )
           end if
           ! the following block chases the shifts down to the bottom
           ! right block. if possible, a shift is moved down npos
           ! positions at a time
           k = ilo
           do while ( k < ihi-ns )
              np = min( ihi-ns-k, npos )
              ! size of the near-the-diagonal block
              nblock = ns+np
              ! istartb points to the first row we will be updating
              istartb = k+1
              ! istopb points to the last column we will be updating
              istopb = k+nblock-1
              call stdlib_${ri}$laset( 'FULL', ns+np, ns+np, zero, one, qc, ldqc )
              call stdlib_${ri}$laset( 'FULL', ns+np, ns+np, zero, one, zc, ldzc )
              ! near the diagonal shift chase
              do i = ns-1, 0, -2
                 do j = 0, np-1
                    ! move down the block with index k+i+j-1, updating
                    ! the (ns+np x ns+np) block:
                    ! (k:k+ns+np,k:k+ns+np-1)
                    call stdlib_${ri}$laqz2( .true., .true., k+i+j-1, istartb, istopb,ihi, a, lda, b, &
                              ldb, nblock, k+1, qc, ldqc,nblock, k, zc, ldzc )
                 end do
              end do
              ! update rest of the pencil
              ! update a(k+1:k+ns+np, k+ns+np:istopm) and
              ! b(k+1:k+ns+np, k+ns+np:istopm)
              ! from the left with qc(1:ns+np,1:ns+np)'
              sheight = ns+np
              swidth = istopm-( k+ns+np )+1
              if ( swidth > 0 ) then
                 call stdlib_${ri}$gemm( 'T', 'N', sheight, swidth, sheight, one, qc,ldqc, a( k+1, k+&
                           ns+np ), lda, zero, work,sheight )
                 call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, a( k+1,k+ns+np ), lda &
                           )
                 call stdlib_${ri}$gemm( 'T', 'N', sheight, swidth, sheight, one, qc,ldqc, b( k+1, k+&
                           ns+np ), ldb, zero, work,sheight )
                 call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, b( k+1,k+ns+np ), ldb &
                           )
              end if
              if ( ilq ) then
                 call stdlib_${ri}$gemm( 'N', 'N', n, nblock, nblock, one, q( 1, k+1 ),ldq, qc, ldqc, &
                           zero, work, n )
                 call stdlib_${ri}$lacpy( 'ALL', n, nblock, work, n, q( 1, k+1 ), ldq )
              end if
              ! update a(istartm:k,k:k+ns+npos-1) and b(istartm:k,k:k+ns+npos-1)
              ! from the right with zc(1:ns+np,1:ns+np)
              sheight = k-istartm+1
              swidth = nblock
              if ( sheight > 0 ) then
                 call stdlib_${ri}$gemm( 'N', 'N', sheight, swidth, swidth, one,a( istartm, k ), lda, &
                           zc, ldzc, zero, work,sheight )
                 call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight,a( istartm, k ), lda )
                           
                 call stdlib_${ri}$gemm( 'N', 'N', sheight, swidth, swidth, one,b( istartm, k ), ldb, &
                           zc, ldzc, zero, work,sheight )
                 call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight,b( istartm, k ), ldb )
                           
              end if
              if ( ilz ) then
                 call stdlib_${ri}$gemm( 'N', 'N', n, nblock, nblock, one, z( 1, k ),ldz, zc, ldzc, &
                           zero, work, n )
                 call stdlib_${ri}$lacpy( 'ALL', n, nblock, work, n, z( 1, k ), ldz )
              end if
              k = k+np
           end do
           ! the following block removes the shifts from the bottom right corner
           ! one by one. updates are initially applied to a(ihi-ns+1:ihi,ihi-ns:ihi).
           call stdlib_${ri}$laset( 'FULL', ns, ns, zero, one, qc, ldqc )
           call stdlib_${ri}$laset( 'FULL', ns+1, ns+1, zero, one, zc, ldzc )
           ! istartb points to the first row we will be updating
           istartb = ihi-ns+1
           ! istopb points to the last column we will be updating
           istopb = ihi
           do i = 1, ns, 2
              ! chase the shift down to the bottom right corner
              do ishift = ihi-i-1, ihi-2
                 call stdlib_${ri}$laqz2( .true., .true., ishift, istartb, istopb, ihi,a, lda, b, ldb, &
                           ns, ihi-ns+1, qc, ldqc, ns+1,ihi-ns, zc, ldzc )
              end do
           end do
           ! update rest of the pencil
           ! update a(ihi-ns+1:ihi, ihi+1:istopm)
           ! from the left with qc(1:ns,1:ns)'
           sheight = ns
           swidth = istopm-( ihi+1 )+1
           if ( swidth > 0 ) then
              call stdlib_${ri}$gemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,a( ihi-ns+1, &
                        ihi+1 ), lda, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight,a( ihi-ns+1, ihi+1 ), lda &
                        )
              call stdlib_${ri}$gemm( 'T', 'N', sheight, swidth, sheight, one, qc, ldqc,b( ihi-ns+1, &
                        ihi+1 ), ldb, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight,b( ihi-ns+1, ihi+1 ), ldb &
                        )
           end if
           if ( ilq ) then
              call stdlib_${ri}$gemm( 'N', 'N', n, ns, ns, one, q( 1, ihi-ns+1 ), ldq,qc, ldqc, zero, &
                        work, n )
              call stdlib_${ri}$lacpy( 'ALL', n, ns, work, n, q( 1, ihi-ns+1 ), ldq )
           end if
           ! update a(istartm:ihi-ns,ihi-ns:ihi)
           ! from the right with zc(1:ns+1,1:ns+1)
           sheight = ihi-ns-istartm+1
           swidth = ns+1
           if ( sheight > 0 ) then
              call stdlib_${ri}$gemm( 'N', 'N', sheight, swidth, swidth, one, a( istartm,ihi-ns ), lda,&
                         zc, ldzc, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, a( istartm,ihi-ns ), lda &
                        )
              call stdlib_${ri}$gemm( 'N', 'N', sheight, swidth, swidth, one, b( istartm,ihi-ns ), ldb,&
                         zc, ldzc, zero, work, sheight )
              call stdlib_${ri}$lacpy( 'ALL', sheight, swidth, work, sheight, b( istartm,ihi-ns ), ldb &
                        )
           end if
           if ( ilz ) then
              call stdlib_${ri}$gemm( 'N', 'N', n, ns+1, ns+1, one, z( 1, ihi-ns ), ldz,zc, ldzc, zero,&
                         work, n )
              call stdlib_${ri}$lacpy( 'ALL', n, ns+1, work, n, z( 1, ihi-ns ), ldz )
           end if
     end subroutine stdlib_${ri}$laqz4

#:endif
#:endfor







     pure subroutine stdlib_strevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
     !! STREVC computes some or all of the right and/or left eigenvectors of
     !! a real upper quasi-triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a real general matrix:  A = Q*T*Q**T, as computed by SHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**H)*T = w*(y**H)
     !! where y**H denotes the conjugate transpose of y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal blocks of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix.  If Q is the orthogonal factor that reduces a matrix
     !! A to Schur form T, then Q*X and Q*Y are the matrices of right and
     !! left eigenvectors of A.
               work, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(inout) :: select(*)
           real(sp), intent(in) :: t(ldt,*)
           real(sp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, over, pair, rightv, somev
           integer(ilp) :: i, ierr, ii, ip, is, j, j1, j2, jnxt, k, ki, n2
           real(sp) :: beta, bignum, emax, ovfl, rec, remax, scale, smin, smlnum, ulp, unfl, &
                     vcrit, vmax, wi, wr, xnorm
           ! Intrinsic Functions 
           ! Local Arrays 
           real(sp) :: x(2,2)
           ! Executable Statements 
           ! decode and test the input parameters
           bothv = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv = stdlib_lsame( side, 'L' ) .or. bothv
           allv = stdlib_lsame( howmny, 'A' )
           over = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           info = 0
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else
              ! set m to the number of columns required to store the selected
              ! eigenvectors, standardize the array select if necessary, and
              ! test mm.
              if( somev ) then
                 m = 0
                 pair = .false.
                 do j = 1, n
                    if( pair ) then
                       pair = .false.
                       select( j ) = .false.
                    else
                       if( j<n ) then
                          if( t( j+1, j )==zero ) then
                             if( select( j ) )m = m + 1
                          else
                             pair = .true.
                             if( select( j ) .or. select( j+1 ) ) then
                                select( j ) = .true.
                                m = m + 2
                             end if
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( mm<m ) then
                 info = -11
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STREVC', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! set the constants to control overflow.
           unfl = stdlib_slamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_slabad( unfl, ovfl )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           bignum = ( one-ulp ) / smlnum
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           work( 1 ) = zero
           do j = 2, n
              work( j ) = zero
              do i = 1, j - 1
                 work( j ) = work( j ) + abs( t( i, j ) )
              end do
           end do
           ! index ip is used to specify the real or complex eigenvalue:
             ! ip = 0, real eigenvalue,
                  ! 1, first of conjugate complex pair: (wr,wi)
                 ! -1, second of conjugate complex pair: (wr,wi)
           n2 = 2*n
           if( rightv ) then
              ! compute right eigenvectors.
              ip = 0
              is = m
              loop_140: do ki = n, 1, -1
                 if( ip==1 )go to 130
                 if( ki==1 )go to 40
                 if( t( ki, ki-1 )==zero )go to 40
                 ip = -1
                 40 continue
                 if( somev ) then
                    if( ip==0 ) then
                       if( .not.select( ki ) )go to 130
                    else
                       if( .not.select( ki-1 ) )go to 130
                    end if
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki-1 ) ) )*sqrt( abs( t( ki-1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! real right eigenvector
                    work( ki+n ) = one
                    ! form right-hand side
                    do k = 1, ki - 1
                       work( k+n ) = -t( k, ki )
                    end do
                    ! solve the upper quasi-triangular system:
                       ! (t(1:ki-1,1:ki-1) - wr)*x = scale*work.
                    jnxt = ki - 1
                    loop_60: do j = ki - 1, 1, -1
                       if( j>jnxt )cycle loop_60
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1 = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_slaln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_sscal( ki, scale, work( 1+n ), 1 )
                          work( j+n ) = x( 1, 1 )
                          ! update right-hand side
                          call stdlib_saxpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_slaln2( .false., 2, 1, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+n ), n, wr, zero, x, 2,scale, xnorm, ierr )
                          ! scale x(1,1) and x(2,1) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 2, 1 ) = x( 2, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_sscal( ki, scale, work( 1+n ), 1 )
                          work( j-1+n ) = x( 1, 1 )
                          work( j+n ) = x( 2, 1 )
                          ! update right-hand side
                          call stdlib_saxpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_saxpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                       end if
                    end do loop_60
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       call stdlib_scopy( ki, work( 1+n ), 1, vr( 1, is ), 1 )
                       ii = stdlib_isamax( ki, vr( 1, is ), 1 )
                       remax = one / abs( vr( ii, is ) )
                       call stdlib_sscal( ki, remax, vr( 1, is ), 1 )
                       do k = ki + 1, n
                          vr( k, is ) = zero
                       end do
                    else
                       if( ki>1 )call stdlib_sgemv( 'N', n, ki-1, one, vr, ldvr,work( 1+n ), 1, &
                                 work( ki+n ),vr( 1, ki ), 1 )
                       ii = stdlib_isamax( n, vr( 1, ki ), 1 )
                       remax = one / abs( vr( ii, ki ) )
                       call stdlib_sscal( n, remax, vr( 1, ki ), 1 )
                    end if
                 else
                    ! complex right eigenvector.
                    ! initial solve
                      ! [ (t(ki-1,ki-1) t(ki-1,ki) ) - (wr + i* wi)]*x = 0.
                      ! [ (t(ki,ki-1)   t(ki,ki)   )               ]
                    if( abs( t( ki-1, ki ) )>=abs( t( ki, ki-1 ) ) ) then
                       work( ki-1+n ) = one
                       work( ki+n2 ) = wi / t( ki-1, ki )
                    else
                       work( ki-1+n ) = -wi / t( ki, ki-1 )
                       work( ki+n2 ) = one
                    end if
                    work( ki+n ) = zero
                    work( ki-1+n2 ) = zero
                    ! form right-hand side
                    do k = 1, ki - 2
                       work( k+n ) = -work( ki-1+n )*t( k, ki-1 )
                       work( k+n2 ) = -work( ki+n2 )*t( k, ki )
                    end do
                    ! solve upper quasi-triangular system:
                    ! (t(1:ki-2,1:ki-2) - (wr+i*wi))*x = scale*(work+i*work2)
                    jnxt = ki - 2
                    loop_90: do j = ki - 2, 1, -1
                       if( j>jnxt )cycle loop_90
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1 = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_slaln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr, wi,x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) and x(1,2) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 1, 2 ) = x( 1, 2 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_sscal( ki, scale, work( 1+n ), 1 )
                             call stdlib_sscal( ki, scale, work( 1+n2 ), 1 )
                          end if
                          work( j+n ) = x( 1, 1 )
                          work( j+n2 ) = x( 1, 2 )
                          ! update the right-hand side
                          call stdlib_saxpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_saxpy( j-1, -x( 1, 2 ), t( 1, j ), 1,work( 1+n2 ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_slaln2( .false., 2, 2, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+n ), n, wr, wi, x, 2, scale,xnorm, ierr )
                          ! scale x to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                rec = one / xnorm
                                x( 1, 1 ) = x( 1, 1 )*rec
                                x( 1, 2 ) = x( 1, 2 )*rec
                                x( 2, 1 ) = x( 2, 1 )*rec
                                x( 2, 2 ) = x( 2, 2 )*rec
                                scale = scale*rec
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_sscal( ki, scale, work( 1+n ), 1 )
                             call stdlib_sscal( ki, scale, work( 1+n2 ), 1 )
                          end if
                          work( j-1+n ) = x( 1, 1 )
                          work( j+n ) = x( 2, 1 )
                          work( j-1+n2 ) = x( 1, 2 )
                          work( j+n2 ) = x( 2, 2 )
                          ! update the right-hand side
                          call stdlib_saxpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_saxpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_saxpy( j-2, -x( 1, 2 ), t( 1, j-1 ), 1,work( 1+n2 ), 1 )
                                    
                          call stdlib_saxpy( j-2, -x( 2, 2 ), t( 1, j ), 1,work( 1+n2 ), 1 )
                                    
                       end if
                    end do loop_90
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       call stdlib_scopy( ki, work( 1+n ), 1, vr( 1, is-1 ), 1 )
                       call stdlib_scopy( ki, work( 1+n2 ), 1, vr( 1, is ), 1 )
                       emax = zero
                       do k = 1, ki
                          emax = max( emax, abs( vr( k, is-1 ) )+abs( vr( k, is ) ) )
                       end do
                       remax = one / emax
                       call stdlib_sscal( ki, remax, vr( 1, is-1 ), 1 )
                       call stdlib_sscal( ki, remax, vr( 1, is ), 1 )
                       do k = ki + 1, n
                          vr( k, is-1 ) = zero
                          vr( k, is ) = zero
                       end do
                    else
                       if( ki>2 ) then
                          call stdlib_sgemv( 'N', n, ki-2, one, vr, ldvr,work( 1+n ), 1, work( ki-&
                                    1+n ),vr( 1, ki-1 ), 1 )
                          call stdlib_sgemv( 'N', n, ki-2, one, vr, ldvr,work( 1+n2 ), 1, work( &
                                    ki+n2 ),vr( 1, ki ), 1 )
                       else
                          call stdlib_sscal( n, work( ki-1+n ), vr( 1, ki-1 ), 1 )
                          call stdlib_sscal( n, work( ki+n2 ), vr( 1, ki ), 1 )
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vr( k, ki-1 ) )+abs( vr( k, ki ) ) )
                       end do
                       remax = one / emax
                       call stdlib_sscal( n, remax, vr( 1, ki-1 ), 1 )
                       call stdlib_sscal( n, remax, vr( 1, ki ), 1 )
                    end if
                 end if
                 is = is - 1
                 if( ip/=0 )is = is - 1
                 130 continue
                 if( ip==1 )ip = 0
                 if( ip==-1 )ip = 1
              end do loop_140
           end if
           if( leftv ) then
              ! compute left eigenvectors.
              ip = 0
              is = 1
              loop_260: do ki = 1, n
                 if( ip==-1 )go to 250
                 if( ki==n )go to 150
                 if( t( ki+1, ki )==zero )go to 150
                 ip = 1
                 150 continue
                 if( somev ) then
                    if( .not.select( ki ) )go to 250
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki+1 ) ) )*sqrt( abs( t( ki+1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! real left eigenvector.
                    work( ki+n ) = one
                    ! form right-hand side
                    do k = ki + 1, n
                       work( k+n ) = -t( ki, k )
                    end do
                    ! solve the quasi-triangular system:
                       ! (t(ki+1:n,ki+1:n) - wr)**t*x = scale*work
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 1
                    loop_170: do j = ki + 1, n
                       if( j<jnxt )cycle loop_170
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_sscal( n-ki+1, rec, work( ki+n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_sdot( j-ki-1, t( ki+1, j ), 1,work( &
                                    ki+1+n ), 1 )
                          ! solve (t(j,j)-wr)**t*x = work
                          call stdlib_slaln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_sscal( n-ki+1, scale, work( ki+n ), 1 )
                                    
                          work( j+n ) = x( 1, 1 )
                          vmax = max( abs( work( j+n ) ), vmax )
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_sscal( n-ki+1, rec, work( ki+n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_sdot( j-ki-1, t( ki+1, j ), 1,work( &
                                    ki+1+n ), 1 )
                          work( j+1+n ) = work( j+1+n ) -stdlib_sdot( j-ki-1, t( ki+1, j+1 ), 1,&
                                    work( ki+1+n ), 1 )
                          ! solve
                            ! [t(j,j)-wr   t(j,j+1)     ]**t* x = scale*( work1 )
                            ! [t(j+1,j)    t(j+1,j+1)-wr]               ( work2 )
                          call stdlib_slaln2( .true., 2, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_sscal( n-ki+1, scale, work( ki+n ), 1 )
                                    
                          work( j+n ) = x( 1, 1 )
                          work( j+1+n ) = x( 2, 1 )
                          vmax = max( abs( work( j+n ) ),abs( work( j+1+n ) ), vmax )
                          vcrit = bignum / vmax
                       end if
                    end do loop_170
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       call stdlib_scopy( n-ki+1, work( ki+n ), 1, vl( ki, is ), 1 )
                       ii = stdlib_isamax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                       remax = one / abs( vl( ii, is ) )
                       call stdlib_sscal( n-ki+1, remax, vl( ki, is ), 1 )
                       do k = 1, ki - 1
                          vl( k, is ) = zero
                       end do
                    else
                       if( ki<n )call stdlib_sgemv( 'N', n, n-ki, one, vl( 1, ki+1 ), ldvl,work( &
                                 ki+1+n ), 1, work( ki+n ),vl( 1, ki ), 1 )
                       ii = stdlib_isamax( n, vl( 1, ki ), 1 )
                       remax = one / abs( vl( ii, ki ) )
                       call stdlib_sscal( n, remax, vl( 1, ki ), 1 )
                    end if
                 else
                    ! complex left eigenvector.
                     ! initial solve:
                       ! ((t(ki,ki)    t(ki,ki+1) )**t - (wr - i* wi))*x = 0.
                       ! ((t(ki+1,ki) t(ki+1,ki+1))                )
                    if( abs( t( ki, ki+1 ) )>=abs( t( ki+1, ki ) ) ) then
                       work( ki+n ) = wi / t( ki, ki+1 )
                       work( ki+1+n2 ) = one
                    else
                       work( ki+n ) = one
                       work( ki+1+n2 ) = -wi / t( ki+1, ki )
                    end if
                    work( ki+1+n ) = zero
                    work( ki+n2 ) = zero
                    ! form right-hand side
                    do k = ki + 2, n
                       work( k+n ) = -work( ki+n )*t( ki, k )
                       work( k+n2 ) = -work( ki+1+n2 )*t( ki+1, k )
                    end do
                    ! solve complex quasi-triangular system:
                    ! ( t(ki+2,n:ki+2,n) - (wr-i*wi) )*x = work1+i*work2
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 2
                    loop_200: do j = ki + 2, n
                       if( j<jnxt )cycle loop_200
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when
                          ! forming the right-hand side elements.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_sscal( n-ki+1, rec, work( ki+n ), 1 )
                             call stdlib_sscal( n-ki+1, rec, work( ki+n2 ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_sdot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n ), 1 )
                          work( j+n2 ) = work( j+n2 ) -stdlib_sdot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n2 ), 1 )
                          ! solve (t(j,j)-(wr-i*wi))*(x11+i*x12)= wk+i*wk2
                          call stdlib_slaln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_sscal( n-ki+1, scale, work( ki+n ), 1 )
                             call stdlib_sscal( n-ki+1, scale, work( ki+n2 ), 1 )
                          end if
                          work( j+n ) = x( 1, 1 )
                          work( j+n2 ) = x( 1, 2 )
                          vmax = max( abs( work( j+n ) ),abs( work( j+n2 ) ), vmax )
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side elements.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_sscal( n-ki+1, rec, work( ki+n ), 1 )
                             call stdlib_sscal( n-ki+1, rec, work( ki+n2 ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_sdot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n ), 1 )
                          work( j+n2 ) = work( j+n2 ) -stdlib_sdot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n2 ), 1 )
                          work( j+1+n ) = work( j+1+n ) -stdlib_sdot( j-ki-2, t( ki+2, j+1 ), 1,&
                                    work( ki+2+n ), 1 )
                          work( j+1+n2 ) = work( j+1+n2 ) -stdlib_sdot( j-ki-2, t( ki+2, j+1 ), 1,&
                                    work( ki+2+n2 ), 1 )
                          ! solve 2-by-2 complex linear equation
                            ! ([t(j,j)   t(j,j+1)  ]**t-(wr-i*wi)*i)*x = scale*b
                            ! ([t(j+1,j) t(j+1,j+1)]               )
                          call stdlib_slaln2( .true., 2, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_sscal( n-ki+1, scale, work( ki+n ), 1 )
                             call stdlib_sscal( n-ki+1, scale, work( ki+n2 ), 1 )
                          end if
                          work( j+n ) = x( 1, 1 )
                          work( j+n2 ) = x( 1, 2 )
                          work( j+1+n ) = x( 2, 1 )
                          work( j+1+n2 ) = x( 2, 2 )
                          vmax = max( abs( x( 1, 1 ) ), abs( x( 1, 2 ) ),abs( x( 2, 1 ) ), abs( x(&
                                     2, 2 ) ), vmax )
                          vcrit = bignum / vmax
                       end if
                    end do loop_200
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       call stdlib_scopy( n-ki+1, work( ki+n ), 1, vl( ki, is ), 1 )
                       call stdlib_scopy( n-ki+1, work( ki+n2 ), 1, vl( ki, is+1 ),1 )
                       emax = zero
                       do k = ki, n
                          emax = max( emax, abs( vl( k, is ) )+abs( vl( k, is+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_sscal( n-ki+1, remax, vl( ki, is ), 1 )
                       call stdlib_sscal( n-ki+1, remax, vl( ki, is+1 ), 1 )
                       do k = 1, ki - 1
                          vl( k, is ) = zero
                          vl( k, is+1 ) = zero
                       end do
                    else
                       if( ki<n-1 ) then
                          call stdlib_sgemv( 'N', n, n-ki-1, one, vl( 1, ki+2 ),ldvl, work( ki+2+&
                                    n ), 1, work( ki+n ),vl( 1, ki ), 1 )
                          call stdlib_sgemv( 'N', n, n-ki-1, one, vl( 1, ki+2 ),ldvl, work( ki+2+&
                                    n2 ), 1,work( ki+1+n2 ), vl( 1, ki+1 ), 1 )
                       else
                          call stdlib_sscal( n, work( ki+n ), vl( 1, ki ), 1 )
                          call stdlib_sscal( n, work( ki+1+n2 ), vl( 1, ki+1 ), 1 )
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vl( k, ki ) )+abs( vl( k, ki+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_sscal( n, remax, vl( 1, ki ), 1 )
                       call stdlib_sscal( n, remax, vl( 1, ki+1 ), 1 )
                    end if
                 end if
                 is = is + 1
                 if( ip/=0 )is = is + 1
                 250 continue
                 if( ip==-1 )ip = 0
                 if( ip==1 )ip = -1
              end do loop_260
           end if
           return
     end subroutine stdlib_strevc

     pure subroutine stdlib_dtrevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
     !! DTREVC computes some or all of the right and/or left eigenvectors of
     !! a real upper quasi-triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a real general matrix:  A = Q*T*Q**T, as computed by DHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**H)*T = w*(y**H)
     !! where y**H denotes the conjugate transpose of y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal blocks of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix.  If Q is the orthogonal factor that reduces a matrix
     !! A to Schur form T, then Q*X and Q*Y are the matrices of right and
     !! left eigenvectors of A.
               work, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(inout) :: select(*)
           real(dp), intent(in) :: t(ldt,*)
           real(dp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, over, pair, rightv, somev
           integer(ilp) :: i, ierr, ii, ip, is, j, j1, j2, jnxt, k, ki, n2
           real(dp) :: beta, bignum, emax, ovfl, rec, remax, scale, smin, smlnum, ulp, unfl, &
                     vcrit, vmax, wi, wr, xnorm
           ! Intrinsic Functions 
           ! Local Arrays 
           real(dp) :: x(2,2)
           ! Executable Statements 
           ! decode and test the input parameters
           bothv = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv = stdlib_lsame( side, 'L' ) .or. bothv
           allv = stdlib_lsame( howmny, 'A' )
           over = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           info = 0
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else
              ! set m to the number of columns required to store the selected
              ! eigenvectors, standardize the array select if necessary, and
              ! test mm.
              if( somev ) then
                 m = 0
                 pair = .false.
                 do j = 1, n
                    if( pair ) then
                       pair = .false.
                       select( j ) = .false.
                    else
                       if( j<n ) then
                          if( t( j+1, j )==zero ) then
                             if( select( j ) )m = m + 1
                          else
                             pair = .true.
                             if( select( j ) .or. select( j+1 ) ) then
                                select( j ) = .true.
                                m = m + 2
                             end if
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( mm<m ) then
                 info = -11
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTREVC', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! set the constants to control overflow.
           unfl = stdlib_dlamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_dlabad( unfl, ovfl )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           bignum = ( one-ulp ) / smlnum
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           work( 1 ) = zero
           do j = 2, n
              work( j ) = zero
              do i = 1, j - 1
                 work( j ) = work( j ) + abs( t( i, j ) )
              end do
           end do
           ! index ip is used to specify the real or complex eigenvalue:
             ! ip = 0, real eigenvalue,
                  ! 1, first of conjugate complex pair: (wr,wi)
                 ! -1, second of conjugate complex pair: (wr,wi)
           n2 = 2*n
           if( rightv ) then
              ! compute right eigenvectors.
              ip = 0
              is = m
              loop_140: do ki = n, 1, -1
                 if( ip==1 )go to 130
                 if( ki==1 )go to 40
                 if( t( ki, ki-1 )==zero )go to 40
                 ip = -1
                 40 continue
                 if( somev ) then
                    if( ip==0 ) then
                       if( .not.select( ki ) )go to 130
                    else
                       if( .not.select( ki-1 ) )go to 130
                    end if
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki-1 ) ) )*sqrt( abs( t( ki-1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! real right eigenvector
                    work( ki+n ) = one
                    ! form right-hand side
                    do k = 1, ki - 1
                       work( k+n ) = -t( k, ki )
                    end do
                    ! solve the upper quasi-triangular system:
                       ! (t(1:ki-1,1:ki-1) - wr)*x = scale*work.
                    jnxt = ki - 1
                    loop_60: do j = ki - 1, 1, -1
                       if( j>jnxt )cycle loop_60
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1 = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_dlaln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_dscal( ki, scale, work( 1+n ), 1 )
                          work( j+n ) = x( 1, 1 )
                          ! update right-hand side
                          call stdlib_daxpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_dlaln2( .false., 2, 1, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+n ), n, wr, zero, x, 2,scale, xnorm, ierr )
                          ! scale x(1,1) and x(2,1) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 2, 1 ) = x( 2, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_dscal( ki, scale, work( 1+n ), 1 )
                          work( j-1+n ) = x( 1, 1 )
                          work( j+n ) = x( 2, 1 )
                          ! update right-hand side
                          call stdlib_daxpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_daxpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                       end if
                    end do loop_60
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       call stdlib_dcopy( ki, work( 1+n ), 1, vr( 1, is ), 1 )
                       ii = stdlib_idamax( ki, vr( 1, is ), 1 )
                       remax = one / abs( vr( ii, is ) )
                       call stdlib_dscal( ki, remax, vr( 1, is ), 1 )
                       do k = ki + 1, n
                          vr( k, is ) = zero
                       end do
                    else
                       if( ki>1 )call stdlib_dgemv( 'N', n, ki-1, one, vr, ldvr,work( 1+n ), 1, &
                                 work( ki+n ),vr( 1, ki ), 1 )
                       ii = stdlib_idamax( n, vr( 1, ki ), 1 )
                       remax = one / abs( vr( ii, ki ) )
                       call stdlib_dscal( n, remax, vr( 1, ki ), 1 )
                    end if
                 else
                    ! complex right eigenvector.
                    ! initial solve
                      ! [ (t(ki-1,ki-1) t(ki-1,ki) ) - (wr + i* wi)]*x = 0.
                      ! [ (t(ki,ki-1)   t(ki,ki)   )               ]
                    if( abs( t( ki-1, ki ) )>=abs( t( ki, ki-1 ) ) ) then
                       work( ki-1+n ) = one
                       work( ki+n2 ) = wi / t( ki-1, ki )
                    else
                       work( ki-1+n ) = -wi / t( ki, ki-1 )
                       work( ki+n2 ) = one
                    end if
                    work( ki+n ) = zero
                    work( ki-1+n2 ) = zero
                    ! form right-hand side
                    do k = 1, ki - 2
                       work( k+n ) = -work( ki-1+n )*t( k, ki-1 )
                       work( k+n2 ) = -work( ki+n2 )*t( k, ki )
                    end do
                    ! solve upper quasi-triangular system:
                    ! (t(1:ki-2,1:ki-2) - (wr+i*wi))*x = scale*(work+i*work2)
                    jnxt = ki - 2
                    loop_90: do j = ki - 2, 1, -1
                       if( j>jnxt )cycle loop_90
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1 = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_dlaln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr, wi,x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) and x(1,2) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 1, 2 ) = x( 1, 2 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_dscal( ki, scale, work( 1+n ), 1 )
                             call stdlib_dscal( ki, scale, work( 1+n2 ), 1 )
                          end if
                          work( j+n ) = x( 1, 1 )
                          work( j+n2 ) = x( 1, 2 )
                          ! update the right-hand side
                          call stdlib_daxpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_daxpy( j-1, -x( 1, 2 ), t( 1, j ), 1,work( 1+n2 ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_dlaln2( .false., 2, 2, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+n ), n, wr, wi, x, 2, scale,xnorm, ierr )
                          ! scale x to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                rec = one / xnorm
                                x( 1, 1 ) = x( 1, 1 )*rec
                                x( 1, 2 ) = x( 1, 2 )*rec
                                x( 2, 1 ) = x( 2, 1 )*rec
                                x( 2, 2 ) = x( 2, 2 )*rec
                                scale = scale*rec
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_dscal( ki, scale, work( 1+n ), 1 )
                             call stdlib_dscal( ki, scale, work( 1+n2 ), 1 )
                          end if
                          work( j-1+n ) = x( 1, 1 )
                          work( j+n ) = x( 2, 1 )
                          work( j-1+n2 ) = x( 1, 2 )
                          work( j+n2 ) = x( 2, 2 )
                          ! update the right-hand side
                          call stdlib_daxpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_daxpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_daxpy( j-2, -x( 1, 2 ), t( 1, j-1 ), 1,work( 1+n2 ), 1 )
                                    
                          call stdlib_daxpy( j-2, -x( 2, 2 ), t( 1, j ), 1,work( 1+n2 ), 1 )
                                    
                       end if
                    end do loop_90
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       call stdlib_dcopy( ki, work( 1+n ), 1, vr( 1, is-1 ), 1 )
                       call stdlib_dcopy( ki, work( 1+n2 ), 1, vr( 1, is ), 1 )
                       emax = zero
                       do k = 1, ki
                          emax = max( emax, abs( vr( k, is-1 ) )+abs( vr( k, is ) ) )
                       end do
                       remax = one / emax
                       call stdlib_dscal( ki, remax, vr( 1, is-1 ), 1 )
                       call stdlib_dscal( ki, remax, vr( 1, is ), 1 )
                       do k = ki + 1, n
                          vr( k, is-1 ) = zero
                          vr( k, is ) = zero
                       end do
                    else
                       if( ki>2 ) then
                          call stdlib_dgemv( 'N', n, ki-2, one, vr, ldvr,work( 1+n ), 1, work( ki-&
                                    1+n ),vr( 1, ki-1 ), 1 )
                          call stdlib_dgemv( 'N', n, ki-2, one, vr, ldvr,work( 1+n2 ), 1, work( &
                                    ki+n2 ),vr( 1, ki ), 1 )
                       else
                          call stdlib_dscal( n, work( ki-1+n ), vr( 1, ki-1 ), 1 )
                          call stdlib_dscal( n, work( ki+n2 ), vr( 1, ki ), 1 )
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vr( k, ki-1 ) )+abs( vr( k, ki ) ) )
                       end do
                       remax = one / emax
                       call stdlib_dscal( n, remax, vr( 1, ki-1 ), 1 )
                       call stdlib_dscal( n, remax, vr( 1, ki ), 1 )
                    end if
                 end if
                 is = is - 1
                 if( ip/=0 )is = is - 1
                 130 continue
                 if( ip==1 )ip = 0
                 if( ip==-1 )ip = 1
              end do loop_140
           end if
           if( leftv ) then
              ! compute left eigenvectors.
              ip = 0
              is = 1
              loop_260: do ki = 1, n
                 if( ip==-1 )go to 250
                 if( ki==n )go to 150
                 if( t( ki+1, ki )==zero )go to 150
                 ip = 1
                 150 continue
                 if( somev ) then
                    if( .not.select( ki ) )go to 250
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki+1 ) ) )*sqrt( abs( t( ki+1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! real left eigenvector.
                    work( ki+n ) = one
                    ! form right-hand side
                    do k = ki + 1, n
                       work( k+n ) = -t( ki, k )
                    end do
                    ! solve the quasi-triangular system:
                       ! (t(ki+1:n,ki+1:n) - wr)**t*x = scale*work
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 1
                    loop_170: do j = ki + 1, n
                       if( j<jnxt )cycle loop_170
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_dscal( n-ki+1, rec, work( ki+n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_ddot( j-ki-1, t( ki+1, j ), 1,work( &
                                    ki+1+n ), 1 )
                          ! solve (t(j,j)-wr)**t*x = work
                          call stdlib_dlaln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_dscal( n-ki+1, scale, work( ki+n ), 1 )
                                    
                          work( j+n ) = x( 1, 1 )
                          vmax = max( abs( work( j+n ) ), vmax )
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_dscal( n-ki+1, rec, work( ki+n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_ddot( j-ki-1, t( ki+1, j ), 1,work( &
                                    ki+1+n ), 1 )
                          work( j+1+n ) = work( j+1+n ) -stdlib_ddot( j-ki-1, t( ki+1, j+1 ), 1,&
                                    work( ki+1+n ), 1 )
                          ! solve
                            ! [t(j,j)-wr   t(j,j+1)     ]**t * x = scale*( work1 )
                            ! [t(j+1,j)    t(j+1,j+1)-wr]                ( work2 )
                          call stdlib_dlaln2( .true., 2, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_dscal( n-ki+1, scale, work( ki+n ), 1 )
                                    
                          work( j+n ) = x( 1, 1 )
                          work( j+1+n ) = x( 2, 1 )
                          vmax = max( abs( work( j+n ) ),abs( work( j+1+n ) ), vmax )
                          vcrit = bignum / vmax
                       end if
                    end do loop_170
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       call stdlib_dcopy( n-ki+1, work( ki+n ), 1, vl( ki, is ), 1 )
                       ii = stdlib_idamax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                       remax = one / abs( vl( ii, is ) )
                       call stdlib_dscal( n-ki+1, remax, vl( ki, is ), 1 )
                       do k = 1, ki - 1
                          vl( k, is ) = zero
                       end do
                    else
                       if( ki<n )call stdlib_dgemv( 'N', n, n-ki, one, vl( 1, ki+1 ), ldvl,work( &
                                 ki+1+n ), 1, work( ki+n ),vl( 1, ki ), 1 )
                       ii = stdlib_idamax( n, vl( 1, ki ), 1 )
                       remax = one / abs( vl( ii, ki ) )
                       call stdlib_dscal( n, remax, vl( 1, ki ), 1 )
                    end if
                 else
                    ! complex left eigenvector.
                     ! initial solve:
                       ! ((t(ki,ki)    t(ki,ki+1) )**t - (wr - i* wi))*x = 0.
                       ! ((t(ki+1,ki) t(ki+1,ki+1))                )
                    if( abs( t( ki, ki+1 ) )>=abs( t( ki+1, ki ) ) ) then
                       work( ki+n ) = wi / t( ki, ki+1 )
                       work( ki+1+n2 ) = one
                    else
                       work( ki+n ) = one
                       work( ki+1+n2 ) = -wi / t( ki+1, ki )
                    end if
                    work( ki+1+n ) = zero
                    work( ki+n2 ) = zero
                    ! form right-hand side
                    do k = ki + 2, n
                       work( k+n ) = -work( ki+n )*t( ki, k )
                       work( k+n2 ) = -work( ki+1+n2 )*t( ki+1, k )
                    end do
                    ! solve complex quasi-triangular system:
                    ! ( t(ki+2,n:ki+2,n) - (wr-i*wi) )*x = work1+i*work2
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 2
                    loop_200: do j = ki + 2, n
                       if( j<jnxt )cycle loop_200
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when
                          ! forming the right-hand side elements.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_dscal( n-ki+1, rec, work( ki+n ), 1 )
                             call stdlib_dscal( n-ki+1, rec, work( ki+n2 ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_ddot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n ), 1 )
                          work( j+n2 ) = work( j+n2 ) -stdlib_ddot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n2 ), 1 )
                          ! solve (t(j,j)-(wr-i*wi))*(x11+i*x12)= wk+i*wk2
                          call stdlib_dlaln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_dscal( n-ki+1, scale, work( ki+n ), 1 )
                             call stdlib_dscal( n-ki+1, scale, work( ki+n2 ), 1 )
                          end if
                          work( j+n ) = x( 1, 1 )
                          work( j+n2 ) = x( 1, 2 )
                          vmax = max( abs( work( j+n ) ),abs( work( j+n2 ) ), vmax )
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side elements.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_dscal( n-ki+1, rec, work( ki+n ), 1 )
                             call stdlib_dscal( n-ki+1, rec, work( ki+n2 ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_ddot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n ), 1 )
                          work( j+n2 ) = work( j+n2 ) -stdlib_ddot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n2 ), 1 )
                          work( j+1+n ) = work( j+1+n ) -stdlib_ddot( j-ki-2, t( ki+2, j+1 ), 1,&
                                    work( ki+2+n ), 1 )
                          work( j+1+n2 ) = work( j+1+n2 ) -stdlib_ddot( j-ki-2, t( ki+2, j+1 ), 1,&
                                    work( ki+2+n2 ), 1 )
                          ! solve 2-by-2 complex linear equation
                            ! ([t(j,j)   t(j,j+1)  ]**t-(wr-i*wi)*i)*x = scale*b
                            ! ([t(j+1,j) t(j+1,j+1)]               )
                          call stdlib_dlaln2( .true., 2, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_dscal( n-ki+1, scale, work( ki+n ), 1 )
                             call stdlib_dscal( n-ki+1, scale, work( ki+n2 ), 1 )
                          end if
                          work( j+n ) = x( 1, 1 )
                          work( j+n2 ) = x( 1, 2 )
                          work( j+1+n ) = x( 2, 1 )
                          work( j+1+n2 ) = x( 2, 2 )
                          vmax = max( abs( x( 1, 1 ) ), abs( x( 1, 2 ) ),abs( x( 2, 1 ) ), abs( x(&
                                     2, 2 ) ), vmax )
                          vcrit = bignum / vmax
                       end if
                    end do loop_200
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       call stdlib_dcopy( n-ki+1, work( ki+n ), 1, vl( ki, is ), 1 )
                       call stdlib_dcopy( n-ki+1, work( ki+n2 ), 1, vl( ki, is+1 ),1 )
                       emax = zero
                       do k = ki, n
                          emax = max( emax, abs( vl( k, is ) )+abs( vl( k, is+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_dscal( n-ki+1, remax, vl( ki, is ), 1 )
                       call stdlib_dscal( n-ki+1, remax, vl( ki, is+1 ), 1 )
                       do k = 1, ki - 1
                          vl( k, is ) = zero
                          vl( k, is+1 ) = zero
                       end do
                    else
                       if( ki<n-1 ) then
                          call stdlib_dgemv( 'N', n, n-ki-1, one, vl( 1, ki+2 ),ldvl, work( ki+2+&
                                    n ), 1, work( ki+n ),vl( 1, ki ), 1 )
                          call stdlib_dgemv( 'N', n, n-ki-1, one, vl( 1, ki+2 ),ldvl, work( ki+2+&
                                    n2 ), 1,work( ki+1+n2 ), vl( 1, ki+1 ), 1 )
                       else
                          call stdlib_dscal( n, work( ki+n ), vl( 1, ki ), 1 )
                          call stdlib_dscal( n, work( ki+1+n2 ), vl( 1, ki+1 ), 1 )
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vl( k, ki ) )+abs( vl( k, ki+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_dscal( n, remax, vl( 1, ki ), 1 )
                       call stdlib_dscal( n, remax, vl( 1, ki+1 ), 1 )
                    end if
                 end if
                 is = is + 1
                 if( ip/=0 )is = is + 1
                 250 continue
                 if( ip==-1 )ip = 0
                 if( ip==1 )ip = -1
              end do loop_260
           end if
           return
     end subroutine stdlib_dtrevc

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$trevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
     !! DTREVC: computes some or all of the right and/or left eigenvectors of
     !! a real upper quasi-triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a real general matrix:  A = Q*T*Q**T, as computed by DHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**H)*T = w*(y**H)
     !! where y**H denotes the conjugate transpose of y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal blocks of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix.  If Q is the orthogonal factor that reduces a matrix
     !! A to Schur form T, then Q*X and Q*Y are the matrices of right and
     !! left eigenvectors of A.
               work, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(inout) :: select(*)
           real(${rk}$), intent(in) :: t(ldt,*)
           real(${rk}$), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, over, pair, rightv, somev
           integer(ilp) :: i, ierr, ii, ip, is, j, j1, j2, jnxt, k, ki, n2
           real(${rk}$) :: beta, bignum, emax, ovfl, rec, remax, scale, smin, smlnum, ulp, unfl, &
                     vcrit, vmax, wi, wr, xnorm
           ! Intrinsic Functions 
           ! Local Arrays 
           real(${rk}$) :: x(2,2)
           ! Executable Statements 
           ! decode and test the input parameters
           bothv = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv = stdlib_lsame( side, 'L' ) .or. bothv
           allv = stdlib_lsame( howmny, 'A' )
           over = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           info = 0
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else
              ! set m to the number of columns required to store the selected
              ! eigenvectors, standardize the array select if necessary, and
              ! test mm.
              if( somev ) then
                 m = 0
                 pair = .false.
                 do j = 1, n
                    if( pair ) then
                       pair = .false.
                       select( j ) = .false.
                    else
                       if( j<n ) then
                          if( t( j+1, j )==zero ) then
                             if( select( j ) )m = m + 1
                          else
                             pair = .true.
                             if( select( j ) .or. select( j+1 ) ) then
                                select( j ) = .true.
                                m = m + 2
                             end if
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( mm<m ) then
                 info = -11
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTREVC', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! set the constants to control overflow.
           unfl = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_${ri}$labad( unfl, ovfl )
           ulp = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           bignum = ( one-ulp ) / smlnum
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           work( 1 ) = zero
           do j = 2, n
              work( j ) = zero
              do i = 1, j - 1
                 work( j ) = work( j ) + abs( t( i, j ) )
              end do
           end do
           ! index ip is used to specify the real or complex eigenvalue:
             ! ip = 0, real eigenvalue,
                  ! 1, first of conjugate complex pair: (wr,wi)
                 ! -1, second of conjugate complex pair: (wr,wi)
           n2 = 2*n
           if( rightv ) then
              ! compute right eigenvectors.
              ip = 0
              is = m
              loop_140: do ki = n, 1, -1
                 if( ip==1 )go to 130
                 if( ki==1 )go to 40
                 if( t( ki, ki-1 )==zero )go to 40
                 ip = -1
                 40 continue
                 if( somev ) then
                    if( ip==0 ) then
                       if( .not.select( ki ) )go to 130
                    else
                       if( .not.select( ki-1 ) )go to 130
                    end if
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki-1 ) ) )*sqrt( abs( t( ki-1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! real right eigenvector
                    work( ki+n ) = one
                    ! form right-hand side
                    do k = 1, ki - 1
                       work( k+n ) = -t( k, ki )
                    end do
                    ! solve the upper quasi-triangular system:
                       ! (t(1:ki-1,1:ki-1) - wr)*x = scale*work.
                    jnxt = ki - 1
                    loop_60: do j = ki - 1, 1, -1
                       if( j>jnxt )cycle loop_60
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1 = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_${ri}$laln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( ki, scale, work( 1+n ), 1 )
                          work( j+n ) = x( 1, 1 )
                          ! update right-hand side
                          call stdlib_${ri}$axpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_${ri}$laln2( .false., 2, 1, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+n ), n, wr, zero, x, 2,scale, xnorm, ierr )
                          ! scale x(1,1) and x(2,1) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 2, 1 ) = x( 2, 1 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( ki, scale, work( 1+n ), 1 )
                          work( j-1+n ) = x( 1, 1 )
                          work( j+n ) = x( 2, 1 )
                          ! update right-hand side
                          call stdlib_${ri}$axpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_${ri}$axpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                       end if
                    end do loop_60
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       call stdlib_${ri}$copy( ki, work( 1+n ), 1, vr( 1, is ), 1 )
                       ii = stdlib_i${ri}$amax( ki, vr( 1, is ), 1 )
                       remax = one / abs( vr( ii, is ) )
                       call stdlib_${ri}$scal( ki, remax, vr( 1, is ), 1 )
                       do k = ki + 1, n
                          vr( k, is ) = zero
                       end do
                    else
                       if( ki>1 )call stdlib_${ri}$gemv( 'N', n, ki-1, one, vr, ldvr,work( 1+n ), 1, &
                                 work( ki+n ),vr( 1, ki ), 1 )
                       ii = stdlib_i${ri}$amax( n, vr( 1, ki ), 1 )
                       remax = one / abs( vr( ii, ki ) )
                       call stdlib_${ri}$scal( n, remax, vr( 1, ki ), 1 )
                    end if
                 else
                    ! complex right eigenvector.
                    ! initial solve
                      ! [ (t(ki-1,ki-1) t(ki-1,ki) ) - (wr + i* wi)]*x = 0.
                      ! [ (t(ki,ki-1)   t(ki,ki)   )               ]
                    if( abs( t( ki-1, ki ) )>=abs( t( ki, ki-1 ) ) ) then
                       work( ki-1+n ) = one
                       work( ki+n2 ) = wi / t( ki-1, ki )
                    else
                       work( ki-1+n ) = -wi / t( ki, ki-1 )
                       work( ki+n2 ) = one
                    end if
                    work( ki+n ) = zero
                    work( ki-1+n2 ) = zero
                    ! form right-hand side
                    do k = 1, ki - 2
                       work( k+n ) = -work( ki-1+n )*t( k, ki-1 )
                       work( k+n2 ) = -work( ki+n2 )*t( k, ki )
                    end do
                    ! solve upper quasi-triangular system:
                    ! (t(1:ki-2,1:ki-2) - (wr+i*wi))*x = scale*(work+i*work2)
                    jnxt = ki - 2
                    loop_90: do j = ki - 2, 1, -1
                       if( j>jnxt )cycle loop_90
                       j1 = j
                       j2 = j
                       jnxt = j - 1
                       if( j>1 ) then
                          if( t( j, j-1 )/=zero ) then
                             j1 = j - 1
                             jnxt = j - 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          call stdlib_${ri}$laln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr, wi,x, 2, scale, xnorm, ierr )
                          ! scale x(1,1) and x(1,2) to avoid overflow when
                          ! updating the right-hand side.
                          if( xnorm>one ) then
                             if( work( j )>bignum / xnorm ) then
                                x( 1, 1 ) = x( 1, 1 ) / xnorm
                                x( 1, 2 ) = x( 1, 2 ) / xnorm
                                scale = scale / xnorm
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( ki, scale, work( 1+n ), 1 )
                             call stdlib_${ri}$scal( ki, scale, work( 1+n2 ), 1 )
                          end if
                          work( j+n ) = x( 1, 1 )
                          work( j+n2 ) = x( 1, 2 )
                          ! update the right-hand side
                          call stdlib_${ri}$axpy( j-1, -x( 1, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_${ri}$axpy( j-1, -x( 1, 2 ), t( 1, j ), 1,work( 1+n2 ), 1 )
                                    
                       else
                          ! 2-by-2 diagonal block
                          call stdlib_${ri}$laln2( .false., 2, 2, smin, one,t( j-1, j-1 ), ldt, one, &
                                    one,work( j-1+n ), n, wr, wi, x, 2, scale,xnorm, ierr )
                          ! scale x to avoid overflow when updating
                          ! the right-hand side.
                          if( xnorm>one ) then
                             beta = max( work( j-1 ), work( j ) )
                             if( beta>bignum / xnorm ) then
                                rec = one / xnorm
                                x( 1, 1 ) = x( 1, 1 )*rec
                                x( 1, 2 ) = x( 1, 2 )*rec
                                x( 2, 1 ) = x( 2, 1 )*rec
                                x( 2, 2 ) = x( 2, 2 )*rec
                                scale = scale*rec
                             end if
                          end if
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( ki, scale, work( 1+n ), 1 )
                             call stdlib_${ri}$scal( ki, scale, work( 1+n2 ), 1 )
                          end if
                          work( j-1+n ) = x( 1, 1 )
                          work( j+n ) = x( 2, 1 )
                          work( j-1+n2 ) = x( 1, 2 )
                          work( j+n2 ) = x( 2, 2 )
                          ! update the right-hand side
                          call stdlib_${ri}$axpy( j-2, -x( 1, 1 ), t( 1, j-1 ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_${ri}$axpy( j-2, -x( 2, 1 ), t( 1, j ), 1,work( 1+n ), 1 )
                                    
                          call stdlib_${ri}$axpy( j-2, -x( 1, 2 ), t( 1, j-1 ), 1,work( 1+n2 ), 1 )
                                    
                          call stdlib_${ri}$axpy( j-2, -x( 2, 2 ), t( 1, j ), 1,work( 1+n2 ), 1 )
                                    
                       end if
                    end do loop_90
                    ! copy the vector x or q*x to vr and normalize.
                    if( .not.over ) then
                       call stdlib_${ri}$copy( ki, work( 1+n ), 1, vr( 1, is-1 ), 1 )
                       call stdlib_${ri}$copy( ki, work( 1+n2 ), 1, vr( 1, is ), 1 )
                       emax = zero
                       do k = 1, ki
                          emax = max( emax, abs( vr( k, is-1 ) )+abs( vr( k, is ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( ki, remax, vr( 1, is-1 ), 1 )
                       call stdlib_${ri}$scal( ki, remax, vr( 1, is ), 1 )
                       do k = ki + 1, n
                          vr( k, is-1 ) = zero
                          vr( k, is ) = zero
                       end do
                    else
                       if( ki>2 ) then
                          call stdlib_${ri}$gemv( 'N', n, ki-2, one, vr, ldvr,work( 1+n ), 1, work( ki-&
                                    1+n ),vr( 1, ki-1 ), 1 )
                          call stdlib_${ri}$gemv( 'N', n, ki-2, one, vr, ldvr,work( 1+n2 ), 1, work( &
                                    ki+n2 ),vr( 1, ki ), 1 )
                       else
                          call stdlib_${ri}$scal( n, work( ki-1+n ), vr( 1, ki-1 ), 1 )
                          call stdlib_${ri}$scal( n, work( ki+n2 ), vr( 1, ki ), 1 )
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vr( k, ki-1 ) )+abs( vr( k, ki ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( n, remax, vr( 1, ki-1 ), 1 )
                       call stdlib_${ri}$scal( n, remax, vr( 1, ki ), 1 )
                    end if
                 end if
                 is = is - 1
                 if( ip/=0 )is = is - 1
                 130 continue
                 if( ip==1 )ip = 0
                 if( ip==-1 )ip = 1
              end do loop_140
           end if
           if( leftv ) then
              ! compute left eigenvectors.
              ip = 0
              is = 1
              loop_260: do ki = 1, n
                 if( ip==-1 )go to 250
                 if( ki==n )go to 150
                 if( t( ki+1, ki )==zero )go to 150
                 ip = 1
                 150 continue
                 if( somev ) then
                    if( .not.select( ki ) )go to 250
                 end if
                 ! compute the ki-th eigenvalue (wr,wi).
                 wr = t( ki, ki )
                 wi = zero
                 if( ip/=0 )wi = sqrt( abs( t( ki, ki+1 ) ) )*sqrt( abs( t( ki+1, ki ) ) )
                 smin = max( ulp*( abs( wr )+abs( wi ) ), smlnum )
                 if( ip==0 ) then
                    ! real left eigenvector.
                    work( ki+n ) = one
                    ! form right-hand side
                    do k = ki + 1, n
                       work( k+n ) = -t( ki, k )
                    end do
                    ! solve the quasi-triangular system:
                       ! (t(ki+1:n,ki+1:n) - wr)**t*x = scale*work
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 1
                    loop_170: do j = ki + 1, n
                       if( j<jnxt )cycle loop_170
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_${ri}$dot( j-ki-1, t( ki+1, j ), 1,work( &
                                    ki+1+n ), 1 )
                          ! solve (t(j,j)-wr)**t*x = work
                          call stdlib_${ri}$laln2( .false., 1, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( n-ki+1, scale, work( ki+n ), 1 )
                                    
                          work( j+n ) = x( 1, 1 )
                          vmax = max( abs( work( j+n ) ), vmax )
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+n ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_${ri}$dot( j-ki-1, t( ki+1, j ), 1,work( &
                                    ki+1+n ), 1 )
                          work( j+1+n ) = work( j+1+n ) -stdlib_${ri}$dot( j-ki-1, t( ki+1, j+1 ), 1,&
                                    work( ki+1+n ), 1 )
                          ! solve
                            ! [t(j,j)-wr   t(j,j+1)     ]**t * x = scale*( work1 )
                            ! [t(j+1,j)    t(j+1,j+1)-wr]                ( work2 )
                          call stdlib_${ri}$laln2( .true., 2, 1, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,zero, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one )call stdlib_${ri}$scal( n-ki+1, scale, work( ki+n ), 1 )
                                    
                          work( j+n ) = x( 1, 1 )
                          work( j+1+n ) = x( 2, 1 )
                          vmax = max( abs( work( j+n ) ),abs( work( j+1+n ) ), vmax )
                          vcrit = bignum / vmax
                       end if
                    end do loop_170
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       call stdlib_${ri}$copy( n-ki+1, work( ki+n ), 1, vl( ki, is ), 1 )
                       ii = stdlib_i${ri}$amax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                       remax = one / abs( vl( ii, is ) )
                       call stdlib_${ri}$scal( n-ki+1, remax, vl( ki, is ), 1 )
                       do k = 1, ki - 1
                          vl( k, is ) = zero
                       end do
                    else
                       if( ki<n )call stdlib_${ri}$gemv( 'N', n, n-ki, one, vl( 1, ki+1 ), ldvl,work( &
                                 ki+1+n ), 1, work( ki+n ),vl( 1, ki ), 1 )
                       ii = stdlib_i${ri}$amax( n, vl( 1, ki ), 1 )
                       remax = one / abs( vl( ii, ki ) )
                       call stdlib_${ri}$scal( n, remax, vl( 1, ki ), 1 )
                    end if
                 else
                    ! complex left eigenvector.
                     ! initial solve:
                       ! ((t(ki,ki)    t(ki,ki+1) )**t - (wr - i* wi))*x = 0.
                       ! ((t(ki+1,ki) t(ki+1,ki+1))                )
                    if( abs( t( ki, ki+1 ) )>=abs( t( ki+1, ki ) ) ) then
                       work( ki+n ) = wi / t( ki, ki+1 )
                       work( ki+1+n2 ) = one
                    else
                       work( ki+n ) = one
                       work( ki+1+n2 ) = -wi / t( ki+1, ki )
                    end if
                    work( ki+1+n ) = zero
                    work( ki+n2 ) = zero
                    ! form right-hand side
                    do k = ki + 2, n
                       work( k+n ) = -work( ki+n )*t( ki, k )
                       work( k+n2 ) = -work( ki+1+n2 )*t( ki+1, k )
                    end do
                    ! solve complex quasi-triangular system:
                    ! ( t(ki+2,n:ki+2,n) - (wr-i*wi) )*x = work1+i*work2
                    vmax = one
                    vcrit = bignum
                    jnxt = ki + 2
                    loop_200: do j = ki + 2, n
                       if( j<jnxt )cycle loop_200
                       j1 = j
                       j2 = j
                       jnxt = j + 1
                       if( j<n ) then
                          if( t( j+1, j )/=zero ) then
                             j2 = j + 1
                             jnxt = j + 2
                          end if
                       end if
                       if( j1==j2 ) then
                          ! 1-by-1 diagonal block
                          ! scale if necessary to avoid overflow when
                          ! forming the right-hand side elements.
                          if( work( j )>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+n ), 1 )
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+n2 ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n ), 1 )
                          work( j+n2 ) = work( j+n2 ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n2 ), 1 )
                          ! solve (t(j,j)-(wr-i*wi))*(x11+i*x12)= wk+i*wk2
                          call stdlib_${ri}$laln2( .false., 1, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( n-ki+1, scale, work( ki+n ), 1 )
                             call stdlib_${ri}$scal( n-ki+1, scale, work( ki+n2 ), 1 )
                          end if
                          work( j+n ) = x( 1, 1 )
                          work( j+n2 ) = x( 1, 2 )
                          vmax = max( abs( work( j+n ) ),abs( work( j+n2 ) ), vmax )
                          vcrit = bignum / vmax
                       else
                          ! 2-by-2 diagonal block
                          ! scale if necessary to avoid overflow when forming
                          ! the right-hand side elements.
                          beta = max( work( j ), work( j+1 ) )
                          if( beta>vcrit ) then
                             rec = one / vmax
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+n ), 1 )
                             call stdlib_${ri}$scal( n-ki+1, rec, work( ki+n2 ), 1 )
                             vmax = one
                             vcrit = bignum
                          end if
                          work( j+n ) = work( j+n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n ), 1 )
                          work( j+n2 ) = work( j+n2 ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, j ), 1,work( &
                                    ki+2+n2 ), 1 )
                          work( j+1+n ) = work( j+1+n ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, j+1 ), 1,&
                                    work( ki+2+n ), 1 )
                          work( j+1+n2 ) = work( j+1+n2 ) -stdlib_${ri}$dot( j-ki-2, t( ki+2, j+1 ), 1,&
                                    work( ki+2+n2 ), 1 )
                          ! solve 2-by-2 complex linear equation
                            ! ([t(j,j)   t(j,j+1)  ]**t-(wr-i*wi)*i)*x = scale*b
                            ! ([t(j+1,j) t(j+1,j+1)]               )
                          call stdlib_${ri}$laln2( .true., 2, 2, smin, one, t( j, j ),ldt, one, one, &
                                    work( j+n ), n, wr,-wi, x, 2, scale, xnorm, ierr )
                          ! scale if necessary
                          if( scale/=one ) then
                             call stdlib_${ri}$scal( n-ki+1, scale, work( ki+n ), 1 )
                             call stdlib_${ri}$scal( n-ki+1, scale, work( ki+n2 ), 1 )
                          end if
                          work( j+n ) = x( 1, 1 )
                          work( j+n2 ) = x( 1, 2 )
                          work( j+1+n ) = x( 2, 1 )
                          work( j+1+n2 ) = x( 2, 2 )
                          vmax = max( abs( x( 1, 1 ) ), abs( x( 1, 2 ) ),abs( x( 2, 1 ) ), abs( x(&
                                     2, 2 ) ), vmax )
                          vcrit = bignum / vmax
                       end if
                    end do loop_200
                    ! copy the vector x or q*x to vl and normalize.
                    if( .not.over ) then
                       call stdlib_${ri}$copy( n-ki+1, work( ki+n ), 1, vl( ki, is ), 1 )
                       call stdlib_${ri}$copy( n-ki+1, work( ki+n2 ), 1, vl( ki, is+1 ),1 )
                       emax = zero
                       do k = ki, n
                          emax = max( emax, abs( vl( k, is ) )+abs( vl( k, is+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( n-ki+1, remax, vl( ki, is ), 1 )
                       call stdlib_${ri}$scal( n-ki+1, remax, vl( ki, is+1 ), 1 )
                       do k = 1, ki - 1
                          vl( k, is ) = zero
                          vl( k, is+1 ) = zero
                       end do
                    else
                       if( ki<n-1 ) then
                          call stdlib_${ri}$gemv( 'N', n, n-ki-1, one, vl( 1, ki+2 ),ldvl, work( ki+2+&
                                    n ), 1, work( ki+n ),vl( 1, ki ), 1 )
                          call stdlib_${ri}$gemv( 'N', n, n-ki-1, one, vl( 1, ki+2 ),ldvl, work( ki+2+&
                                    n2 ), 1,work( ki+1+n2 ), vl( 1, ki+1 ), 1 )
                       else
                          call stdlib_${ri}$scal( n, work( ki+n ), vl( 1, ki ), 1 )
                          call stdlib_${ri}$scal( n, work( ki+1+n2 ), vl( 1, ki+1 ), 1 )
                       end if
                       emax = zero
                       do k = 1, n
                          emax = max( emax, abs( vl( k, ki ) )+abs( vl( k, ki+1 ) ) )
                       end do
                       remax = one / emax
                       call stdlib_${ri}$scal( n, remax, vl( 1, ki ), 1 )
                       call stdlib_${ri}$scal( n, remax, vl( 1, ki+1 ), 1 )
                    end if
                 end if
                 is = is + 1
                 if( ip/=0 )is = is + 1
                 250 continue
                 if( ip==-1 )ip = 0
                 if( ip==1 )ip = -1
              end do loop_260
           end if
           return
     end subroutine stdlib_${ri}$trevc

#:endif
#:endfor

     pure subroutine stdlib_ctrevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
     !! CTREVC computes some or all of the right and/or left eigenvectors of
     !! a complex upper triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a complex general matrix:  A = Q*T*Q**H, as computed by CHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**H)*T = w*(y**H)
     !! where y**H denotes the conjugate transpose of the vector y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix.  If Q is the unitary factor that reduces a matrix A to
     !! Schur form T, then Q*X and Q*Y are the matrices of right and left
     !! eigenvectors of A.
               work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           complex(sp), parameter :: cmzero = (0.0e+0_sp,0.0e+0_sp)
           complex(sp), parameter :: cmone = (1.0e+0_sp,0.0e+0_sp)
           
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, over, rightv, somev
           integer(ilp) :: i, ii, is, j, k, ki
           real(sp) :: ovfl, remax, scale, smin, smlnum, ulp, unfl
           complex(sp) :: cdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters
           bothv = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv = stdlib_lsame( side, 'L' ) .or. bothv
           allv = stdlib_lsame( howmny, 'A' )
           over = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           ! set m to the number of columns required to store the selected
           ! eigenvectors.
           if( somev ) then
              m = 0
              do j = 1, n
                 if( select( j ) )m = m + 1
              end do
           else
              m = n
           end if
           info = 0
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else if( mm<m ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTREVC', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! set the constants to control overflow.
           unfl = stdlib_slamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_slabad( unfl, ovfl )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           ! store the diagonal elements of t in working array work.
           do i = 1, n
              work( i+n ) = t( i, i )
           end do
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           rwork( 1 ) = zero
           do j = 2, n
              rwork( j ) = stdlib_scasum( j-1, t( 1, j ), 1 )
           end do
           if( rightv ) then
              ! compute right eigenvectors.
              is = m
              loop_80: do ki = n, 1, -1
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_80
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 work( 1 ) = cmone
                 ! form right-hand side.
                 do k = 1, ki - 1
                    work( k ) = -t( k, ki )
                 end do
                 ! solve the triangular system:
                    ! (t(1:ki-1,1:ki-1) - t(ki,ki))*x = scale*work.
                 do k = 1, ki - 1
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki>1 ) then
                    call stdlib_clatrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', 'Y',ki-1, t, ldt, &
                              work( 1 ), scale, rwork,info )
                    work( ki ) = scale
                 end if
                 ! copy the vector x or q*x to vr and normalize.
                 if( .not.over ) then
                    call stdlib_ccopy( ki, work( 1 ), 1, vr( 1, is ), 1 )
                    ii = stdlib_icamax( ki, vr( 1, is ), 1 )
                    remax = one / cabs1( vr( ii, is ) )
                    call stdlib_csscal( ki, remax, vr( 1, is ), 1 )
                    do k = ki + 1, n
                       vr( k, is ) = cmzero
                    end do
                 else
                    if( ki>1 )call stdlib_cgemv( 'N', n, ki-1, cmone, vr, ldvr, work( 1 ),1, &
                              cmplx( scale,KIND=sp), vr( 1, ki ), 1 )
                    ii = stdlib_icamax( n, vr( 1, ki ), 1 )
                    remax = one / cabs1( vr( ii, ki ) )
                    call stdlib_csscal( n, remax, vr( 1, ki ), 1 )
                 end if
                 ! set back the original diagonal elements of t.
                 do k = 1, ki - 1
                    t( k, k ) = work( k+n )
                 end do
                 is = is - 1
              end do loop_80
           end if
           if( leftv ) then
              ! compute left eigenvectors.
              is = 1
              loop_130: do ki = 1, n
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_130
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 work( n ) = cmone
                 ! form right-hand side.
                 do k = ki + 1, n
                    work( k ) = -conjg( t( ki, k ) )
                 end do
                 ! solve the triangular system:
                    ! (t(ki+1:n,ki+1:n) - t(ki,ki))**h*x = scale*work.
                 do k = ki + 1, n
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki<n ) then
                    call stdlib_clatrs( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT','Y', n-ki, t( &
                              ki+1, ki+1 ), ldt,work( ki+1 ), scale, rwork, info )
                    work( ki ) = scale
                 end if
                 ! copy the vector x or q*x to vl and normalize.
                 if( .not.over ) then
                    call stdlib_ccopy( n-ki+1, work( ki ), 1, vl( ki, is ), 1 )
                    ii = stdlib_icamax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                    remax = one / cabs1( vl( ii, is ) )
                    call stdlib_csscal( n-ki+1, remax, vl( ki, is ), 1 )
                    do k = 1, ki - 1
                       vl( k, is ) = cmzero
                    end do
                 else
                    if( ki<n )call stdlib_cgemv( 'N', n, n-ki, cmone, vl( 1, ki+1 ), ldvl,work( &
                              ki+1 ), 1, cmplx( scale,KIND=sp),vl( 1, ki ), 1 )
                    ii = stdlib_icamax( n, vl( 1, ki ), 1 )
                    remax = one / cabs1( vl( ii, ki ) )
                    call stdlib_csscal( n, remax, vl( 1, ki ), 1 )
                 end if
                 ! set back the original diagonal elements of t.
                 do k = ki + 1, n
                    t( k, k ) = work( k+n )
                 end do
                 is = is + 1
              end do loop_130
           end if
           return
     end subroutine stdlib_ctrevc

     pure subroutine stdlib_ztrevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
     !! ZTREVC computes some or all of the right and/or left eigenvectors of
     !! a complex upper triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a complex general matrix:  A = Q*T*Q**H, as computed by ZHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**H)*T = w*(y**H)
     !! where y**H denotes the conjugate transpose of the vector y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix.  If Q is the unitary factor that reduces a matrix A to
     !! Schur form T, then Q*X and Q*Y are the matrices of right and left
     !! eigenvectors of A.
               work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           complex(dp), parameter :: cmzero = (0.0e+0_dp,0.0e+0_dp)
           complex(dp), parameter :: cmone = (1.0e+0_dp,0.0e+0_dp)
           
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, over, rightv, somev
           integer(ilp) :: i, ii, is, j, k, ki
           real(dp) :: ovfl, remax, scale, smin, smlnum, ulp, unfl
           complex(dp) :: cdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters
           bothv = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv = stdlib_lsame( side, 'L' ) .or. bothv
           allv = stdlib_lsame( howmny, 'A' )
           over = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           ! set m to the number of columns required to store the selected
           ! eigenvectors.
           if( somev ) then
              m = 0
              do j = 1, n
                 if( select( j ) )m = m + 1
              end do
           else
              m = n
           end if
           info = 0
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else if( mm<m ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTREVC', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! set the constants to control overflow.
           unfl = stdlib_dlamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_dlabad( unfl, ovfl )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           ! store the diagonal elements of t in working array work.
           do i = 1, n
              work( i+n ) = t( i, i )
           end do
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           rwork( 1 ) = zero
           do j = 2, n
              rwork( j ) = stdlib_dzasum( j-1, t( 1, j ), 1 )
           end do
           if( rightv ) then
              ! compute right eigenvectors.
              is = m
              loop_80: do ki = n, 1, -1
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_80
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 work( 1 ) = cmone
                 ! form right-hand side.
                 do k = 1, ki - 1
                    work( k ) = -t( k, ki )
                 end do
                 ! solve the triangular system:
                    ! (t(1:ki-1,1:ki-1) - t(ki,ki))*x = scale*work.
                 do k = 1, ki - 1
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki>1 ) then
                    call stdlib_zlatrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', 'Y',ki-1, t, ldt, &
                              work( 1 ), scale, rwork,info )
                    work( ki ) = scale
                 end if
                 ! copy the vector x or q*x to vr and normalize.
                 if( .not.over ) then
                    call stdlib_zcopy( ki, work( 1 ), 1, vr( 1, is ), 1 )
                    ii = stdlib_izamax( ki, vr( 1, is ), 1 )
                    remax = one / cabs1( vr( ii, is ) )
                    call stdlib_zdscal( ki, remax, vr( 1, is ), 1 )
                    do k = ki + 1, n
                       vr( k, is ) = cmzero
                    end do
                 else
                    if( ki>1 )call stdlib_zgemv( 'N', n, ki-1, cmone, vr, ldvr, work( 1 ),1, &
                              cmplx( scale,KIND=dp), vr( 1, ki ), 1 )
                    ii = stdlib_izamax( n, vr( 1, ki ), 1 )
                    remax = one / cabs1( vr( ii, ki ) )
                    call stdlib_zdscal( n, remax, vr( 1, ki ), 1 )
                 end if
                 ! set back the original diagonal elements of t.
                 do k = 1, ki - 1
                    t( k, k ) = work( k+n )
                 end do
                 is = is - 1
              end do loop_80
           end if
           if( leftv ) then
              ! compute left eigenvectors.
              is = 1
              loop_130: do ki = 1, n
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_130
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 work( n ) = cmone
                 ! form right-hand side.
                 do k = ki + 1, n
                    work( k ) = -conjg( t( ki, k ) )
                 end do
                 ! solve the triangular system:
                    ! (t(ki+1:n,ki+1:n) - t(ki,ki))**h * x = scale*work.
                 do k = ki + 1, n
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki<n ) then
                    call stdlib_zlatrs( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT','Y', n-ki, t( &
                              ki+1, ki+1 ), ldt,work( ki+1 ), scale, rwork, info )
                    work( ki ) = scale
                 end if
                 ! copy the vector x or q*x to vl and normalize.
                 if( .not.over ) then
                    call stdlib_zcopy( n-ki+1, work( ki ), 1, vl( ki, is ), 1 )
                    ii = stdlib_izamax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                    remax = one / cabs1( vl( ii, is ) )
                    call stdlib_zdscal( n-ki+1, remax, vl( ki, is ), 1 )
                    do k = 1, ki - 1
                       vl( k, is ) = cmzero
                    end do
                 else
                    if( ki<n )call stdlib_zgemv( 'N', n, n-ki, cmone, vl( 1, ki+1 ), ldvl,work( &
                              ki+1 ), 1, cmplx( scale,KIND=dp),vl( 1, ki ), 1 )
                    ii = stdlib_izamax( n, vl( 1, ki ), 1 )
                    remax = one / cabs1( vl( ii, ki ) )
                    call stdlib_zdscal( n, remax, vl( 1, ki ), 1 )
                 end if
                 ! set back the original diagonal elements of t.
                 do k = ki + 1, n
                    t( k, k ) = work( k+n )
                 end do
                 is = is + 1
              end do loop_130
           end if
           return
     end subroutine stdlib_ztrevc

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$trevc( side, howmny, select, n, t, ldt, vl, ldvl, vr,ldvr, mm, m, &
     !! ZTREVC: computes some or all of the right and/or left eigenvectors of
     !! a complex upper triangular matrix T.
     !! Matrices of this type are produced by the Schur factorization of
     !! a complex general matrix:  A = Q*T*Q**H, as computed by ZHSEQR.
     !! The right eigenvector x and the left eigenvector y of T corresponding
     !! to an eigenvalue w are defined by:
     !! T*x = w*x,     (y**H)*T = w*(y**H)
     !! where y**H denotes the conjugate transpose of the vector y.
     !! The eigenvalues are not input to this routine, but are read directly
     !! from the diagonal of T.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
     !! input matrix.  If Q is the unitary factor that reduces a matrix A to
     !! Schur form T, then Q*X and Q*Y are the matrices of right and left
     !! eigenvectors of A.
               work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldt, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: t(ldt,*), vl(ldvl,*), vr(ldvr,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           complex(${ck}$), parameter :: cmzero = (0.0e+0_${ck}$,0.0e+0_${ck}$)
           complex(${ck}$), parameter :: cmone = (1.0e+0_${ck}$,0.0e+0_${ck}$)
           
           
           ! Local Scalars 
           logical(lk) :: allv, bothv, leftv, over, rightv, somev
           integer(ilp) :: i, ii, is, j, k, ki
           real(${ck}$) :: ovfl, remax, scale, smin, smlnum, ulp, unfl
           complex(${ck}$) :: cdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! decode and test the input parameters
           bothv = stdlib_lsame( side, 'B' )
           rightv = stdlib_lsame( side, 'R' ) .or. bothv
           leftv = stdlib_lsame( side, 'L' ) .or. bothv
           allv = stdlib_lsame( howmny, 'A' )
           over = stdlib_lsame( howmny, 'B' )
           somev = stdlib_lsame( howmny, 'S' )
           ! set m to the number of columns required to store the selected
           ! eigenvectors.
           if( somev ) then
              m = 0
              do j = 1, n
                 if( select( j ) )m = m + 1
              end do
           else
              m = n
           end if
           info = 0
           if( .not.rightv .and. .not.leftv ) then
              info = -1
           else if( .not.allv .and. .not.over .and. .not.somev ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( ldt<max( 1, n ) ) then
              info = -6
           else if( ldvl<1 .or. ( leftv .and. ldvl<n ) ) then
              info = -8
           else if( ldvr<1 .or. ( rightv .and. ldvr<n ) ) then
              info = -10
           else if( mm<m ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTREVC', -info )
              return
           end if
           ! quick return if possible.
           if( n==0 )return
           ! set the constants to control overflow.
           unfl = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           ovfl = one / unfl
           call stdlib_${c2ri(ci)}$labad( unfl, ovfl )
           ulp = stdlib_${c2ri(ci)}$lamch( 'PRECISION' )
           smlnum = unfl*( n / ulp )
           ! store the diagonal elements of t in working array work.
           do i = 1, n
              work( i+n ) = t( i, i )
           end do
           ! compute 1-norm of each column of strictly upper triangular
           ! part of t to control overflow in triangular solver.
           rwork( 1 ) = zero
           do j = 2, n
              rwork( j ) = stdlib_${c2ri(ci)}$zasum( j-1, t( 1, j ), 1 )
           end do
           if( rightv ) then
              ! compute right eigenvectors.
              is = m
              loop_80: do ki = n, 1, -1
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_80
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 work( 1 ) = cmone
                 ! form right-hand side.
                 do k = 1, ki - 1
                    work( k ) = -t( k, ki )
                 end do
                 ! solve the triangular system:
                    ! (t(1:ki-1,1:ki-1) - t(ki,ki))*x = scale*work.
                 do k = 1, ki - 1
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki>1 ) then
                    call stdlib_${ci}$latrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', 'Y',ki-1, t, ldt, &
                              work( 1 ), scale, rwork,info )
                    work( ki ) = scale
                 end if
                 ! copy the vector x or q*x to vr and normalize.
                 if( .not.over ) then
                    call stdlib_${ci}$copy( ki, work( 1 ), 1, vr( 1, is ), 1 )
                    ii = stdlib_i${ci}$amax( ki, vr( 1, is ), 1 )
                    remax = one / cabs1( vr( ii, is ) )
                    call stdlib_${ci}$dscal( ki, remax, vr( 1, is ), 1 )
                    do k = ki + 1, n
                       vr( k, is ) = cmzero
                    end do
                 else
                    if( ki>1 )call stdlib_${ci}$gemv( 'N', n, ki-1, cmone, vr, ldvr, work( 1 ),1, &
                              cmplx( scale,KIND=${ck}$), vr( 1, ki ), 1 )
                    ii = stdlib_i${ci}$amax( n, vr( 1, ki ), 1 )
                    remax = one / cabs1( vr( ii, ki ) )
                    call stdlib_${ci}$dscal( n, remax, vr( 1, ki ), 1 )
                 end if
                 ! set back the original diagonal elements of t.
                 do k = 1, ki - 1
                    t( k, k ) = work( k+n )
                 end do
                 is = is - 1
              end do loop_80
           end if
           if( leftv ) then
              ! compute left eigenvectors.
              is = 1
              loop_130: do ki = 1, n
                 if( somev ) then
                    if( .not.select( ki ) )cycle loop_130
                 end if
                 smin = max( ulp*( cabs1( t( ki, ki ) ) ), smlnum )
                 work( n ) = cmone
                 ! form right-hand side.
                 do k = ki + 1, n
                    work( k ) = -conjg( t( ki, k ) )
                 end do
                 ! solve the triangular system:
                    ! (t(ki+1:n,ki+1:n) - t(ki,ki))**h * x = scale*work.
                 do k = ki + 1, n
                    t( k, k ) = t( k, k ) - t( ki, ki )
                    if( cabs1( t( k, k ) )<smin )t( k, k ) = smin
                 end do
                 if( ki<n ) then
                    call stdlib_${ci}$latrs( 'UPPER', 'CONJUGATE TRANSPOSE', 'NON-UNIT','Y', n-ki, t( &
                              ki+1, ki+1 ), ldt,work( ki+1 ), scale, rwork, info )
                    work( ki ) = scale
                 end if
                 ! copy the vector x or q*x to vl and normalize.
                 if( .not.over ) then
                    call stdlib_${ci}$copy( n-ki+1, work( ki ), 1, vl( ki, is ), 1 )
                    ii = stdlib_i${ci}$amax( n-ki+1, vl( ki, is ), 1 ) + ki - 1
                    remax = one / cabs1( vl( ii, is ) )
                    call stdlib_${ci}$dscal( n-ki+1, remax, vl( ki, is ), 1 )
                    do k = 1, ki - 1
                       vl( k, is ) = cmzero
                    end do
                 else
                    if( ki<n )call stdlib_${ci}$gemv( 'N', n, n-ki, cmone, vl( 1, ki+1 ), ldvl,work( &
                              ki+1 ), 1, cmplx( scale,KIND=${ck}$),vl( 1, ki ), 1 )
                    ii = stdlib_i${ci}$amax( n, vl( 1, ki ), 1 )
                    remax = one / cabs1( vl( ii, ki ) )
                    call stdlib_${ci}$dscal( n, remax, vl( 1, ki ), 1 )
                 end if
                 ! set back the original diagonal elements of t.
                 do k = ki + 1, n
                    t( k, k ) = work( k+n )
                 end do
                 is = is + 1
              end do loop_130
           end if
           return
     end subroutine stdlib_${ci}$trevc

#:endif
#:endfor











     pure subroutine stdlib_sormhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, lwork, &
     !! SORMHR overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! IHI-ILO elementary reflectors, as returned by SGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(in) :: ihi, ilo, lda, ldc, lwork, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*), c(ldc,*)
           real(sp), intent(in) :: tau(*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, lquery
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, nh, ni, nq, nw
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           left = stdlib_lsame( side, 'L' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'T' ) )&
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 .or. ilo>max( 1, nq ) ) then
              info = -5
           else if( ihi<min( ilo, nq ) .or. ihi>nq ) then
              info = -6
           else if( lda<max( 1, nq ) ) then
              info = -8
           else if( ldc<max( 1, m ) ) then
              info = -11
           else if( lwork<nw .and. .not.lquery ) then
              info = -13
           end if
           if( info==0 ) then
              if( left ) then
                 nb = stdlib_ilaenv( 1, 'SORMQR', side // trans, nh, n, nh, -1 )
              else
                 nb = stdlib_ilaenv( 1, 'SORMQR', side // trans, m, nh, nh, -1 )
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SORMHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. nh==0 ) then
              work( 1 ) = 1
              return
           end if
           if( left ) then
              mi = nh
              ni = n
              i1 = ilo + 1
              i2 = 1
           else
              mi = m
              ni = nh
              i1 = 1
              i2 = ilo + 1
           end if
           call stdlib_sormqr( side, trans, mi, ni, nh, a( ilo+1, ilo ), lda,tau( ilo ), c( i1, &
                     i2 ), ldc, work, lwork, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_sormhr

     pure subroutine stdlib_dormhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, lwork, &
     !! DORMHR overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! IHI-ILO elementary reflectors, as returned by DGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(in) :: ihi, ilo, lda, ldc, lwork, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*), c(ldc,*)
           real(dp), intent(in) :: tau(*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, lquery
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, nh, ni, nq, nw
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           left = stdlib_lsame( side, 'L' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'T' ) )&
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 .or. ilo>max( 1, nq ) ) then
              info = -5
           else if( ihi<min( ilo, nq ) .or. ihi>nq ) then
              info = -6
           else if( lda<max( 1, nq ) ) then
              info = -8
           else if( ldc<max( 1, m ) ) then
              info = -11
           else if( lwork<nw .and. .not.lquery ) then
              info = -13
           end if
           if( info==0 ) then
              if( left ) then
                 nb = stdlib_ilaenv( 1, 'DORMQR', side // trans, nh, n, nh, -1 )
              else
                 nb = stdlib_ilaenv( 1, 'DORMQR', side // trans, m, nh, nh, -1 )
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORMHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. nh==0 ) then
              work( 1 ) = 1
              return
           end if
           if( left ) then
              mi = nh
              ni = n
              i1 = ilo + 1
              i2 = 1
           else
              mi = m
              ni = nh
              i1 = 1
              i2 = ilo + 1
           end if
           call stdlib_dormqr( side, trans, mi, ni, nh, a( ilo+1, ilo ), lda,tau( ilo ), c( i1, &
                     i2 ), ldc, work, lwork, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dormhr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$ormhr( side, trans, m, n, ilo, ihi, a, lda, tau, c,ldc, work, lwork, &
     !! DORMHR: overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! IHI-ILO elementary reflectors, as returned by DGEHRD:
     !! Q = H(ilo) H(ilo+1) . . . H(ihi-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans
           integer(ilp), intent(in) :: ihi, ilo, lda, ldc, lwork, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), c(ldc,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, lquery
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, nh, ni, nq, nw
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           nh = ihi - ilo
           left = stdlib_lsame( side, 'L' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'T' ) )&
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 .or. ilo>max( 1, nq ) ) then
              info = -5
           else if( ihi<min( ilo, nq ) .or. ihi>nq ) then
              info = -6
           else if( lda<max( 1, nq ) ) then
              info = -8
           else if( ldc<max( 1, m ) ) then
              info = -11
           else if( lwork<nw .and. .not.lquery ) then
              info = -13
           end if
           if( info==0 ) then
              if( left ) then
                 nb = stdlib_ilaenv( 1, 'DORMQR', side // trans, nh, n, nh, -1 )
              else
                 nb = stdlib_ilaenv( 1, 'DORMQR', side // trans, m, nh, nh, -1 )
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORMHR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. nh==0 ) then
              work( 1 ) = 1
              return
           end if
           if( left ) then
              mi = nh
              ni = n
              i1 = ilo + 1
              i2 = 1
           else
              mi = m
              ni = nh
              i1 = 1
              i2 = ilo + 1
           end if
           call stdlib_${ri}$ormqr( side, trans, mi, ni, nh, a( ilo+1, ilo ), lda,tau( ilo ), c( i1, &
                     i2 ), ldc, work, lwork, iinfo )
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$ormhr

#:endif
#:endfor



     pure subroutine stdlib_claqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
     !! CLAQR2 is identical to CLAQR3 except that it avoids
     !! recursion by calling CLAHQR instead of CLAQR4.
     !! Aggressive early deflation:
     !! This subroutine accepts as input an upper Hessenberg matrix
     !! H and performs an unitary similarity transformation
     !! designed to detect and deflate fully converged eigenvalues from
     !! a trailing principal submatrix.  On output H has been over-
     !! written by a new Hessenberg matrix that is a perturbation of
     !! an unitary similarity transformation of H.  It is to be
     !! hoped that the final version of H has many zero subdiagonal
     !! entries.
               ns, nd, sh, v, ldv, nh, t, ldt,nv, wv, ldwv, work, lwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(ilp), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(sp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(sp), intent(out) :: sh(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
        ! ================================================================
           ! Parameters 
           real(sp), parameter :: rzero = 0.0_sp
           real(sp), parameter :: rone = 1.0_sp
           
           
           ! Local Scalars 
           complex(sp) :: beta, cdum, s, tau
           real(sp) :: foo, safmax, safmin, smlnum, ulp
           integer(ilp) :: i, ifst, ilst, info, infqr, j, jw, kcol, kln, knt, krow, kwtop, ltop, &
                     lwk1, lwk2, lwkopt
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! ==== estimate optimal workspace. ====
           jw = min( nw, kbot-ktop+1 )
           if( jw<=2 ) then
              lwkopt = 1
           else
              ! ==== workspace query call to stdlib_cgehrd ====
              call stdlib_cgehrd( jw, 1, jw-1, t, ldt, work, work, -1, info )
              lwk1 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_cunmhr ====
              call stdlib_cunmhr( 'R', 'N', jw, jw, 1, jw-1, t, ldt, work, v, ldv,work, -1, info )
                        
              lwk2 = int( work( 1 ),KIND=ilp)
              ! ==== optimal workspace ====
              lwkopt = jw + max( lwk1, lwk2 )
           end if
           ! ==== quick return in case of workspace query. ====
           if( lwork==-1 ) then
              work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
              return
           end if
           ! ==== nothing to do ...
           ! ... for an empty active block ... ====
           ns = 0
           nd = 0
           work( 1 ) = cone
           if( ktop>kbot )return
           ! ... nor for an empty deflation window. ====
           if( nw<1 )return
           ! ==== machine constants ====
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_slabad( safmin, safmax )
           ulp = stdlib_slamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=sp) / ulp )
           ! ==== setup deflation window ====
           jw = min( nw, kbot-ktop+1 )
           kwtop = kbot - jw + 1
           if( kwtop==ktop ) then
              s = czero
           else
              s = h( kwtop, kwtop-1 )
           end if
           if( kbot==kwtop ) then
              ! ==== 1-by-1 deflation window: not much to do ====
              sh( kwtop ) = h( kwtop, kwtop )
              ns = 1
              nd = 0
              if( cabs1( s )<=max( smlnum, ulp*cabs1( h( kwtop,kwtop ) ) ) ) then
                 ns = 0
                 nd = 1
                 if( kwtop>ktop )h( kwtop, kwtop-1 ) = czero
              end if
              work( 1 ) = cone
              return
           end if
           ! ==== convert to spike-triangular form.  (in case of a
           ! .    rare qr failure, this routine continues to do
           ! .    aggressive early deflation using that part of
           ! .    the deflation window that converged using infqr
           ! .    here and there to keep track.) ====
           call stdlib_clacpy( 'U', jw, jw, h( kwtop, kwtop ), ldh, t, ldt )
           call stdlib_ccopy( jw-1, h( kwtop+1, kwtop ), ldh+1, t( 2, 1 ), ldt+1 )
           call stdlib_claset( 'A', jw, jw, czero, cone, v, ldv )
           call stdlib_clahqr( .true., .true., jw, 1, jw, t, ldt, sh( kwtop ), 1,jw, v, ldv, &
                     infqr )
           ! ==== deflation detection loop ====
           ns = jw
           ilst = infqr + 1
           do knt = infqr + 1, jw
              ! ==== small spike tip deflation test ====
              foo = cabs1( t( ns, ns ) )
              if( foo==rzero )foo = cabs1( s )
              if( cabs1( s )*cabs1( v( 1, ns ) )<=max( smlnum, ulp*foo ) )then
                 ! ==== cone more converged eigenvalue ====
                 ns = ns - 1
              else
                 ! ==== cone undeflatable eigenvalue.  move it up out of the
                 ! .    way.   (stdlib_ctrexc can not fail in this case.) ====
                 ifst = ns
                 call stdlib_ctrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                 ilst = ilst + 1
              end if
           end do
              ! ==== return to hessenberg form ====
           if( ns==0 )s = czero
           if( ns<jw ) then
              ! ==== sorting the diagonal of t improves accuracy for
              ! .    graded matrices.  ====
              do i = infqr + 1, ns
                 ifst = i
                 do j = i + 1, ns
                    if( cabs1( t( j, j ) )>cabs1( t( ifst, ifst ) ) )ifst = j
                 end do
                 ilst = i
                 if( ifst/=ilst )call stdlib_ctrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                           
              end do
           end if
           ! ==== restore shift/eigenvalue array from t ====
           do i = infqr + 1, jw
              sh( kwtop+i-1 ) = t( i, i )
           end do
           if( ns<jw .or. s==czero ) then
              if( ns>1 .and. s/=czero ) then
                 ! ==== reflect spike back into lower triangle ====
                 call stdlib_ccopy( ns, v, ldv, work, 1 )
                 do i = 1, ns
                    work( i ) = conjg( work( i ) )
                 end do
                 beta = work( 1 )
                 call stdlib_clarfg( ns, beta, work( 2 ), 1, tau )
                 work( 1 ) = cone
                 call stdlib_claset( 'L', jw-2, jw-2, czero, czero, t( 3, 1 ), ldt )
                 call stdlib_clarf( 'L', ns, jw, work, 1, conjg( tau ), t, ldt,work( jw+1 ) )
                           
                 call stdlib_clarf( 'R', ns, ns, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_clarf( 'R', jw, ns, work, 1, tau, v, ldv,work( jw+1 ) )
                 call stdlib_cgehrd( jw, 1, ns, t, ldt, work, work( jw+1 ),lwork-jw, info )
                           
              end if
              ! ==== copy updated reduced window into place ====
              if( kwtop>1 )h( kwtop, kwtop-1 ) = s*conjg( v( 1, 1 ) )
              call stdlib_clacpy( 'U', jw, jw, t, ldt, h( kwtop, kwtop ), ldh )
              call stdlib_ccopy( jw-1, t( 2, 1 ), ldt+1, h( kwtop+1, kwtop ),ldh+1 )
              ! ==== accumulate orthogonal matrix in order update
              ! .    h and z, if requested.  ====
              if( ns>1 .and. s/=czero )call stdlib_cunmhr( 'R', 'N', jw, ns, 1, ns, t, ldt, work, &
                        v, ldv,work( jw+1 ), lwork-jw, info )
              ! ==== update vertical slab in h ====
              if( wantt ) then
                 ltop = 1
              else
                 ltop = ktop
              end if
              do krow = ltop, kwtop - 1, nv
                 kln = min( nv, kwtop-krow )
                 call stdlib_cgemm( 'N', 'N', kln, jw, jw, cone, h( krow, kwtop ),ldh, v, ldv, &
                           czero, wv, ldwv )
                 call stdlib_clacpy( 'A', kln, jw, wv, ldwv, h( krow, kwtop ), ldh )
              end do
              ! ==== update horizontal slab in h ====
              if( wantt ) then
                 do kcol = kbot + 1, n, nh
                    kln = min( nh, n-kcol+1 )
                    call stdlib_cgemm( 'C', 'N', jw, kln, jw, cone, v, ldv,h( kwtop, kcol ), ldh, &
                              czero, t, ldt )
                    call stdlib_clacpy( 'A', jw, kln, t, ldt, h( kwtop, kcol ),ldh )
                 end do
              end if
              ! ==== update vertical slab in z ====
              if( wantz ) then
                 do krow = iloz, ihiz, nv
                    kln = min( nv, ihiz-krow+1 )
                    call stdlib_cgemm( 'N', 'N', kln, jw, jw, cone, z( krow, kwtop ),ldz, v, ldv, &
                              czero, wv, ldwv )
                    call stdlib_clacpy( 'A', kln, jw, wv, ldwv, z( krow, kwtop ),ldz )
                 end do
              end if
           end if
           ! ==== return the number of deflations ... ====
           nd = jw - ns
           ! ==== ... and the number of shifts. (subtracting
           ! .    infqr from the spike length takes care
           ! .    of the case of a rare qr failure while
           ! .    calculating eigenvalues of the deflation
           ! .    window.)  ====
           ns = ns - infqr
            ! ==== return optimal workspace. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=sp)
     end subroutine stdlib_claqr2

     pure subroutine stdlib_zlaqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
     !! ZLAQR2 is identical to ZLAQR3 except that it avoids
     !! recursion by calling ZLAHQR instead of ZLAQR4.
     !! Aggressive early deflation:
     !! ZLAQR2 accepts as input an upper Hessenberg matrix
     !! H and performs an unitary similarity transformation
     !! designed to detect and deflate fully converged eigenvalues from
     !! a trailing principal submatrix.  On output H has been over-
     !! written by a new Hessenberg matrix that is a perturbation of
     !! an unitary similarity transformation of H.  It is to be
     !! hoped that the final version of H has many zero subdiagonal
     !! entries.
               ns, nd, sh, v, ldv, nh, t, ldt,nv, wv, ldwv, work, lwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(ilp), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(dp), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(dp), intent(out) :: sh(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
        ! ================================================================
           ! Parameters 
           real(dp), parameter :: rzero = 0.0_dp
           real(dp), parameter :: rone = 1.0_dp
           
           
           ! Local Scalars 
           complex(dp) :: beta, cdum, s, tau
           real(dp) :: foo, safmax, safmin, smlnum, ulp
           integer(ilp) :: i, ifst, ilst, info, infqr, j, jw, kcol, kln, knt, krow, kwtop, ltop, &
                     lwk1, lwk2, lwkopt
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! ==== estimate optimal workspace. ====
           jw = min( nw, kbot-ktop+1 )
           if( jw<=2 ) then
              lwkopt = 1
           else
              ! ==== workspace query call to stdlib_zgehrd ====
              call stdlib_zgehrd( jw, 1, jw-1, t, ldt, work, work, -1, info )
              lwk1 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_zunmhr ====
              call stdlib_zunmhr( 'R', 'N', jw, jw, 1, jw-1, t, ldt, work, v, ldv,work, -1, info )
                        
              lwk2 = int( work( 1 ),KIND=ilp)
              ! ==== optimal workspace ====
              lwkopt = jw + max( lwk1, lwk2 )
           end if
           ! ==== quick return in case of workspace query. ====
           if( lwork==-1 ) then
              work( 1 ) = cmplx( lwkopt, 0,KIND=dp)
              return
           end if
           ! ==== nothing to do ...
           ! ... for an empty active block ... ====
           ns = 0
           nd = 0
           work( 1 ) = cone
           if( ktop>kbot )return
           ! ... nor for an empty deflation window. ====
           if( nw<1 )return
           ! ==== machine constants ====
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_dlabad( safmin, safmax )
           ulp = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=dp) / ulp )
           ! ==== setup deflation window ====
           jw = min( nw, kbot-ktop+1 )
           kwtop = kbot - jw + 1
           if( kwtop==ktop ) then
              s = czero
           else
              s = h( kwtop, kwtop-1 )
           end if
           if( kbot==kwtop ) then
              ! ==== 1-by-1 deflation window: not much to do ====
              sh( kwtop ) = h( kwtop, kwtop )
              ns = 1
              nd = 0
              if( cabs1( s )<=max( smlnum, ulp*cabs1( h( kwtop,kwtop ) ) ) ) then
                 ns = 0
                 nd = 1
                 if( kwtop>ktop )h( kwtop, kwtop-1 ) = czero
              end if
              work( 1 ) = cone
              return
           end if
           ! ==== convert to spike-triangular form.  (in case of a
           ! .    rare qr failure, this routine continues to do
           ! .    aggressive early deflation using that part of
           ! .    the deflation window that converged using infqr
           ! .    here and there to keep track.) ====
           call stdlib_zlacpy( 'U', jw, jw, h( kwtop, kwtop ), ldh, t, ldt )
           call stdlib_zcopy( jw-1, h( kwtop+1, kwtop ), ldh+1, t( 2, 1 ), ldt+1 )
           call stdlib_zlaset( 'A', jw, jw, czero, cone, v, ldv )
           call stdlib_zlahqr( .true., .true., jw, 1, jw, t, ldt, sh( kwtop ), 1,jw, v, ldv, &
                     infqr )
           ! ==== deflation detection loop ====
           ns = jw
           ilst = infqr + 1
           do knt = infqr + 1, jw
              ! ==== small spike tip deflation test ====
              foo = cabs1( t( ns, ns ) )
              if( foo==rzero )foo = cabs1( s )
              if( cabs1( s )*cabs1( v( 1, ns ) )<=max( smlnum, ulp*foo ) )then
                 ! ==== cone more converged eigenvalue ====
                 ns = ns - 1
              else
                 ! ==== cone undeflatable eigenvalue.  move it up out of the
                 ! .    way.   (stdlib_ztrexc can not fail in this case.) ====
                 ifst = ns
                 call stdlib_ztrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                 ilst = ilst + 1
              end if
           end do
              ! ==== return to hessenberg form ====
           if( ns==0 )s = czero
           if( ns<jw ) then
              ! ==== sorting the diagonal of t improves accuracy for
              ! .    graded matrices.  ====
              do i = infqr + 1, ns
                 ifst = i
                 do j = i + 1, ns
                    if( cabs1( t( j, j ) )>cabs1( t( ifst, ifst ) ) )ifst = j
                 end do
                 ilst = i
                 if( ifst/=ilst )call stdlib_ztrexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                           
              end do
           end if
           ! ==== restore shift/eigenvalue array from t ====
           do i = infqr + 1, jw
              sh( kwtop+i-1 ) = t( i, i )
           end do
           if( ns<jw .or. s==czero ) then
              if( ns>1 .and. s/=czero ) then
                 ! ==== reflect spike back into lower triangle ====
                 call stdlib_zcopy( ns, v, ldv, work, 1 )
                 do i = 1, ns
                    work( i ) = conjg( work( i ) )
                 end do
                 beta = work( 1 )
                 call stdlib_zlarfg( ns, beta, work( 2 ), 1, tau )
                 work( 1 ) = cone
                 call stdlib_zlaset( 'L', jw-2, jw-2, czero, czero, t( 3, 1 ), ldt )
                 call stdlib_zlarf( 'L', ns, jw, work, 1, conjg( tau ), t, ldt,work( jw+1 ) )
                           
                 call stdlib_zlarf( 'R', ns, ns, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_zlarf( 'R', jw, ns, work, 1, tau, v, ldv,work( jw+1 ) )
                 call stdlib_zgehrd( jw, 1, ns, t, ldt, work, work( jw+1 ),lwork-jw, info )
                           
              end if
              ! ==== copy updated reduced window into place ====
              if( kwtop>1 )h( kwtop, kwtop-1 ) = s*conjg( v( 1, 1 ) )
              call stdlib_zlacpy( 'U', jw, jw, t, ldt, h( kwtop, kwtop ), ldh )
              call stdlib_zcopy( jw-1, t( 2, 1 ), ldt+1, h( kwtop+1, kwtop ),ldh+1 )
              ! ==== accumulate orthogonal matrix in order update
              ! .    h and z, if requested.  ====
              if( ns>1 .and. s/=czero )call stdlib_zunmhr( 'R', 'N', jw, ns, 1, ns, t, ldt, work, &
                        v, ldv,work( jw+1 ), lwork-jw, info )
              ! ==== update vertical slab in h ====
              if( wantt ) then
                 ltop = 1
              else
                 ltop = ktop
              end if
              do krow = ltop, kwtop - 1, nv
                 kln = min( nv, kwtop-krow )
                 call stdlib_zgemm( 'N', 'N', kln, jw, jw, cone, h( krow, kwtop ),ldh, v, ldv, &
                           czero, wv, ldwv )
                 call stdlib_zlacpy( 'A', kln, jw, wv, ldwv, h( krow, kwtop ), ldh )
              end do
              ! ==== update horizontal slab in h ====
              if( wantt ) then
                 do kcol = kbot + 1, n, nh
                    kln = min( nh, n-kcol+1 )
                    call stdlib_zgemm( 'C', 'N', jw, kln, jw, cone, v, ldv,h( kwtop, kcol ), ldh, &
                              czero, t, ldt )
                    call stdlib_zlacpy( 'A', jw, kln, t, ldt, h( kwtop, kcol ),ldh )
                 end do
              end if
              ! ==== update vertical slab in z ====
              if( wantz ) then
                 do krow = iloz, ihiz, nv
                    kln = min( nv, ihiz-krow+1 )
                    call stdlib_zgemm( 'N', 'N', kln, jw, jw, cone, z( krow, kwtop ),ldz, v, ldv, &
                              czero, wv, ldwv )
                    call stdlib_zlacpy( 'A', kln, jw, wv, ldwv, z( krow, kwtop ),ldz )
                 end do
              end if
           end if
           ! ==== return the number of deflations ... ====
           nd = jw - ns
           ! ==== ... and the number of shifts. (subtracting
           ! .    infqr from the spike length takes care
           ! .    of the case of a rare qr failure while
           ! .    calculating eigenvalues of the deflation
           ! .    window.)  ====
           ns = ns - infqr
            ! ==== return optimal workspace. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=dp)
     end subroutine stdlib_zlaqr2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$laqr2( wantt, wantz, n, ktop, kbot, nw, h, ldh, iloz,ihiz, z, ldz, &
     !! ZLAQR2: is identical to ZLAQR3 except that it avoids
     !! recursion by calling ZLAHQR instead of ZLAQR4.
     !! Aggressive early deflation:
     !! ZLAQR2 accepts as input an upper Hessenberg matrix
     !! H and performs an unitary similarity transformation
     !! designed to detect and deflate fully converged eigenvalues from
     !! a trailing principal submatrix.  On output H has been over-
     !! written by a new Hessenberg matrix that is a perturbation of
     !! an unitary similarity transformation of H.  It is to be
     !! hoped that the final version of H has many zero subdiagonal
     !! entries.
               ns, nd, sh, v, ldv, nh, t, ldt,nv, wv, ldwv, work, lwork )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ihiz, iloz, kbot, ktop, ldh, ldt, ldv, ldwv, ldz, lwork, n,&
                      nh, nv, nw
           integer(ilp), intent(out) :: nd, ns
           logical(lk), intent(in) :: wantt, wantz
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: h(ldh,*), z(ldz,*)
           complex(${ck}$), intent(out) :: sh(*), t(ldt,*), v(ldv,*), work(*), wv(ldwv,*)
        ! ================================================================
           ! Parameters 
           real(${ck}$), parameter :: rzero = 0.0_${ck}$
           real(${ck}$), parameter :: rone = 1.0_${ck}$
           
           
           ! Local Scalars 
           complex(${ck}$) :: beta, cdum, s, tau
           real(${ck}$) :: foo, safmax, safmin, smlnum, ulp
           integer(ilp) :: i, ifst, ilst, info, infqr, j, jw, kcol, kln, knt, krow, kwtop, ltop, &
                     lwk1, lwk2, lwkopt
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! ==== estimate optimal workspace. ====
           jw = min( nw, kbot-ktop+1 )
           if( jw<=2 ) then
              lwkopt = 1
           else
              ! ==== workspace query call to stdlib_${ci}$gehrd ====
              call stdlib_${ci}$gehrd( jw, 1, jw-1, t, ldt, work, work, -1, info )
              lwk1 = int( work( 1 ),KIND=ilp)
              ! ==== workspace query call to stdlib_${ci}$unmhr ====
              call stdlib_${ci}$unmhr( 'R', 'N', jw, jw, 1, jw-1, t, ldt, work, v, ldv,work, -1, info )
                        
              lwk2 = int( work( 1 ),KIND=ilp)
              ! ==== optimal workspace ====
              lwkopt = jw + max( lwk1, lwk2 )
           end if
           ! ==== quick return in case of workspace query. ====
           if( lwork==-1 ) then
              work( 1 ) = cmplx( lwkopt, 0,KIND=${ck}$)
              return
           end if
           ! ==== nothing to do ...
           ! ... for an empty active block ... ====
           ns = 0
           nd = 0
           work( 1 ) = cone
           if( ktop>kbot )return
           ! ... nor for an empty deflation window. ====
           if( nw<1 )return
           ! ==== machine constants ====
           safmin = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           safmax = rone / safmin
           call stdlib_${c2ri(ci)}$labad( safmin, safmax )
           ulp = stdlib_${c2ri(ci)}$lamch( 'PRECISION' )
           smlnum = safmin*( real( n,KIND=${ck}$) / ulp )
           ! ==== setup deflation window ====
           jw = min( nw, kbot-ktop+1 )
           kwtop = kbot - jw + 1
           if( kwtop==ktop ) then
              s = czero
           else
              s = h( kwtop, kwtop-1 )
           end if
           if( kbot==kwtop ) then
              ! ==== 1-by-1 deflation window: not much to do ====
              sh( kwtop ) = h( kwtop, kwtop )
              ns = 1
              nd = 0
              if( cabs1( s )<=max( smlnum, ulp*cabs1( h( kwtop,kwtop ) ) ) ) then
                 ns = 0
                 nd = 1
                 if( kwtop>ktop )h( kwtop, kwtop-1 ) = czero
              end if
              work( 1 ) = cone
              return
           end if
           ! ==== convert to spike-triangular form.  (in case of a
           ! .    rare qr failure, this routine continues to do
           ! .    aggressive early deflation using that part of
           ! .    the deflation window that converged using infqr
           ! .    here and there to keep track.) ====
           call stdlib_${ci}$lacpy( 'U', jw, jw, h( kwtop, kwtop ), ldh, t, ldt )
           call stdlib_${ci}$copy( jw-1, h( kwtop+1, kwtop ), ldh+1, t( 2, 1 ), ldt+1 )
           call stdlib_${ci}$laset( 'A', jw, jw, czero, cone, v, ldv )
           call stdlib_${ci}$lahqr( .true., .true., jw, 1, jw, t, ldt, sh( kwtop ), 1,jw, v, ldv, &
                     infqr )
           ! ==== deflation detection loop ====
           ns = jw
           ilst = infqr + 1
           do knt = infqr + 1, jw
              ! ==== small spike tip deflation test ====
              foo = cabs1( t( ns, ns ) )
              if( foo==rzero )foo = cabs1( s )
              if( cabs1( s )*cabs1( v( 1, ns ) )<=max( smlnum, ulp*foo ) )then
                 ! ==== cone more converged eigenvalue ====
                 ns = ns - 1
              else
                 ! ==== cone undeflatable eigenvalue.  move it up out of the
                 ! .    way.   (stdlib_${ci}$trexc can not fail in this case.) ====
                 ifst = ns
                 call stdlib_${ci}$trexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                 ilst = ilst + 1
              end if
           end do
              ! ==== return to hessenberg form ====
           if( ns==0 )s = czero
           if( ns<jw ) then
              ! ==== sorting the diagonal of t improves accuracy for
              ! .    graded matrices.  ====
              do i = infqr + 1, ns
                 ifst = i
                 do j = i + 1, ns
                    if( cabs1( t( j, j ) )>cabs1( t( ifst, ifst ) ) )ifst = j
                 end do
                 ilst = i
                 if( ifst/=ilst )call stdlib_${ci}$trexc( 'V', jw, t, ldt, v, ldv, ifst, ilst, info )
                           
              end do
           end if
           ! ==== restore shift/eigenvalue array from t ====
           do i = infqr + 1, jw
              sh( kwtop+i-1 ) = t( i, i )
           end do
           if( ns<jw .or. s==czero ) then
              if( ns>1 .and. s/=czero ) then
                 ! ==== reflect spike back into lower triangle ====
                 call stdlib_${ci}$copy( ns, v, ldv, work, 1 )
                 do i = 1, ns
                    work( i ) = conjg( work( i ) )
                 end do
                 beta = work( 1 )
                 call stdlib_${ci}$larfg( ns, beta, work( 2 ), 1, tau )
                 work( 1 ) = cone
                 call stdlib_${ci}$laset( 'L', jw-2, jw-2, czero, czero, t( 3, 1 ), ldt )
                 call stdlib_${ci}$larf( 'L', ns, jw, work, 1, conjg( tau ), t, ldt,work( jw+1 ) )
                           
                 call stdlib_${ci}$larf( 'R', ns, ns, work, 1, tau, t, ldt,work( jw+1 ) )
                 call stdlib_${ci}$larf( 'R', jw, ns, work, 1, tau, v, ldv,work( jw+1 ) )
                 call stdlib_${ci}$gehrd( jw, 1, ns, t, ldt, work, work( jw+1 ),lwork-jw, info )
                           
              end if
              ! ==== copy updated reduced window into place ====
              if( kwtop>1 )h( kwtop, kwtop-1 ) = s*conjg( v( 1, 1 ) )
              call stdlib_${ci}$lacpy( 'U', jw, jw, t, ldt, h( kwtop, kwtop ), ldh )
              call stdlib_${ci}$copy( jw-1, t( 2, 1 ), ldt+1, h( kwtop+1, kwtop ),ldh+1 )
              ! ==== accumulate orthogonal matrix in order update
              ! .    h and z, if requested.  ====
              if( ns>1 .and. s/=czero )call stdlib_${ci}$unmhr( 'R', 'N', jw, ns, 1, ns, t, ldt, work, &
                        v, ldv,work( jw+1 ), lwork-jw, info )
              ! ==== update vertical slab in h ====
              if( wantt ) then
                 ltop = 1
              else
                 ltop = ktop
              end if
              do krow = ltop, kwtop - 1, nv
                 kln = min( nv, kwtop-krow )
                 call stdlib_${ci}$gemm( 'N', 'N', kln, jw, jw, cone, h( krow, kwtop ),ldh, v, ldv, &
                           czero, wv, ldwv )
                 call stdlib_${ci}$lacpy( 'A', kln, jw, wv, ldwv, h( krow, kwtop ), ldh )
              end do
              ! ==== update horizontal slab in h ====
              if( wantt ) then
                 do kcol = kbot + 1, n, nh
                    kln = min( nh, n-kcol+1 )
                    call stdlib_${ci}$gemm( 'C', 'N', jw, kln, jw, cone, v, ldv,h( kwtop, kcol ), ldh, &
                              czero, t, ldt )
                    call stdlib_${ci}$lacpy( 'A', jw, kln, t, ldt, h( kwtop, kcol ),ldh )
                 end do
              end if
              ! ==== update vertical slab in z ====
              if( wantz ) then
                 do krow = iloz, ihiz, nv
                    kln = min( nv, ihiz-krow+1 )
                    call stdlib_${ci}$gemm( 'N', 'N', kln, jw, jw, cone, z( krow, kwtop ),ldz, v, ldv, &
                              czero, wv, ldwv )
                    call stdlib_${ci}$lacpy( 'A', kln, jw, wv, ldwv, z( krow, kwtop ),ldz )
                 end do
              end if
           end if
           ! ==== return the number of deflations ... ====
           nd = jw - ns
           ! ==== ... and the number of shifts. (subtracting
           ! .    infqr from the spike length takes care
           ! .    of the case of a rare qr failure while
           ! .    calculating eigenvalues of the deflation
           ! .    window.)  ====
           ns = ns - infqr
            ! ==== return optimal workspace. ====
           work( 1 ) = cmplx( lwkopt, 0,KIND=${ck}$)
     end subroutine stdlib_${ci}$laqr2

#:endif
#:endfor




end module stdlib_lapack_eigv_gen
