#:include "common.fypp"
#:set R_KINDS_TYPES = list(zip(REAL_KINDS, REAL_TYPES, REAL_SUFFIX))
#:set C_KINDS_TYPES = list(zip(CMPLX_KINDS, CMPLX_TYPES, CMPLX_SUFFIX))
#:set KINDS_TYPES = R_KINDS_TYPES+C_KINDS_TYPES
! Test sparse matrix norms
module test_sparse_norms
    use testdrive, only: error_type, check, new_unittest, unittest_type
    use stdlib_sparse_constants
    use stdlib_sparse, only: sparse_norm, dense2coo, coo2csr, coo2csc
    use stdlib_linalg_state, only: linalg_state_type
    use stdlib_linalg_constants

    implicit none (type,external)

    contains

    !> Sparse matrix norm tests
    subroutine test_sparse_matrix_norms(tests)
        !> Collection of tests
        type(unittest_type), allocatable, intent(out) :: tests(:)
        
        allocate(tests(0))
        
        #:for k, t, s in KINDS_TYPES
        call add_test(tests,new_unittest("test_sparse_norms_${s}$",test_sparse_norms_${s}$))
        #:endfor
        
    end subroutine test_sparse_matrix_norms
    
    #:for k, t, s in KINDS_TYPES
    !> Test sparse matrix norms for ${t}$ matrices
    subroutine test_sparse_norms_${s}$(error)
        type(error_type), allocatable, intent(out) :: error
        
        integer(ilp), parameter :: n = 3
        real(${k}$), parameter :: tol = 10*sqrt(epsilon(0.0_${k}$))
        ${t}$, allocatable :: A(:,:)
        type(COO_${s}$_type) :: COO
        type(CSR_${s}$_type) :: CSR
        type(CSC_${s}$_type) :: CSC
        type(linalg_state_type) :: err
        real(${k}$) :: expected_fro, expected_one, expected_inf
        real(${k}$) :: norm_fro, norm_one, norm_inf

        allocate(A(n,n))

        ! Create test matrix:
        ! A = [1, 0, 2]
        !     [0, 3, 0]  
        !     [4, 0, 5]
        A = zero_${s}$
        A(1,1) = 1.0_${k}$; A(1,3) = 2.0_${k}$
        A(2,2) = 3.0_${k}$
        A(3,1) = 4.0_${k}$; A(3,3) = 5.0_${k}$
        
        ! Expected norms:
        ! Frobenius: sqrt(1^2 + 2^2 + 3^2 + 4^2 + 5^2) = sqrt(55)
        ! 1-norm: max column sum = max(5, 3, 7) = 7
        ! Infinity norm: max row sum = max(3, 3, 9) = 9
        expected_fro = sqrt(55.0_${k}$)
        expected_one = 7.0_${k}$
        expected_inf = 9.0_${k}$
        
        ! Convert to sparse formats
        call dense2coo(A, COO)
        call coo2csr(COO, CSR)
        call coo2csc(COO, CSC)
        
        ! Test COO format norms
        norm_fro = sparse_norm(COO, 'frobenius', err)
        call check(error, .not. err%error(), 'COO Frobenius norm should not error')
        if (allocated(error)) return
        call check(error, abs(norm_fro - expected_fro) < tol*expected_fro, &
                   'COO Frobenius norm should match expected value')
        if (allocated(error)) return
        
        norm_one = sparse_norm(COO, 1, err)
        call check(error, .not. err%error(), 'COO 1-norm should not error')
        if (allocated(error)) return
        call check(error, abs(norm_one - expected_one) < tol*expected_one, &
                   'COO 1-norm should match expected value')
        if (allocated(error)) return
        
        norm_inf = sparse_norm(COO, 'inf', err)
        call check(error, .not. err%error(), 'COO infinity norm should not error')
        if (allocated(error)) return
        call check(error, abs(norm_inf - expected_inf) < tol*expected_inf, &
                   'COO infinity norm should match expected value')
        if (allocated(error)) return
        
        ! Test CSR format norms  
        norm_fro = sparse_norm(CSR, 'frobenius', err)
        call check(error, .not. err%error(), 'CSR Frobenius norm should not error')
        if (allocated(error)) return
        call check(error, abs(norm_fro - expected_fro) < tol*expected_fro, &
                   'CSR Frobenius norm should match expected value')
        if (allocated(error)) return
        
        norm_one = sparse_norm(CSR, 1, err)
        call check(error, .not. err%error(), 'CSR 1-norm should not error')
        if (allocated(error)) return
        call check(error, abs(norm_one - expected_one) < tol*expected_one, &
                   'CSR 1-norm should match expected value')
        if (allocated(error)) return
        
        norm_inf = sparse_norm(CSR, 'inf', err)
        call check(error, .not. err%error(), 'CSR infinity norm should not error')
        if (allocated(error)) return
        call check(error, abs(norm_inf - expected_inf) < tol*expected_inf, &
                   'CSR infinity norm should match expected value')
        if (allocated(error)) return
        
        ! Test CSC format norms
        norm_fro = sparse_norm(CSC, 'frobenius', err)
        call check(error, .not. err%error(), 'CSC Frobenius norm should not error')
        if (allocated(error)) return
        call check(error, abs(norm_fro - expected_fro) < tol*expected_fro, &
                   'CSC Frobenius norm should match expected value')
        if (allocated(error)) return
        
        norm_one = sparse_norm(CSC, 1, err)
        call check(error, .not. err%error(), 'CSC 1-norm should not error')
        if (allocated(error)) return
        call check(error, abs(norm_one - expected_one) < tol*expected_one, &
                   'CSC 1-norm should match expected value')
        if (allocated(error)) return
        
        norm_inf = sparse_norm(CSC, 'inf', err)
        call check(error, .not. err%error(), 'CSC infinity norm should not error')
        if (allocated(error)) return
        call check(error, abs(norm_inf - expected_inf) < tol*expected_inf, &
                   'CSC infinity norm should match expected value')
        if (allocated(error)) return
        
        ! Test empty matrix case
        COO%nnz = 0
        norm_fro = sparse_norm(COO, 'frobenius', err)
        call check(error, .not. err%error(), 'Empty matrix norm should not error')
        if (allocated(error)) return
        call check(error, norm_fro == 0.0_${k}$, 'Empty matrix norm should be zero')
        if (allocated(error)) return
        
    end subroutine test_sparse_norms_${s}$
    #:endfor

end module test_sparse_norms