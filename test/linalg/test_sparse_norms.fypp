#:include "common.fypp"
#:set R_KINDS_TYPES = list(zip(REAL_KINDS, REAL_TYPES, REAL_SUFFIX))
#:set C_KINDS_TYPES = list(zip(CMPLX_KINDS, CMPLX_TYPES, CMPLX_SUFFIX))
#:set KINDS_TYPES = R_KINDS_TYPES+C_KINDS_TYPES
! Test sparse matrix norms
module test_sparse_norms
    use testdrive, only: error_type, check, new_unittest, unittest_type
    use stdlib_sparse_constants
    use stdlib_sparse, only: sparse_norm, dense2coo, coo2csr, coo2csc
    use stdlib_linalg_state, only: linalg_state_type
    use stdlib_linalg_constants

    implicit none (type,external)

    contains

    !> Sparse matrix norm tests
    subroutine test_sparse_matrix_norms(tests)
        !> Collection of tests
        type(unittest_type), allocatable, intent(out) :: tests(:)
        
        allocate(tests(0))
        
        #:for k, t, s in KINDS_TYPES
        call add_test(tests,new_unittest("test_sparse_norms_${s}$",test_sparse_norms_${s}$))
        call add_test(tests,new_unittest("test_sparse_symmetric_norms_${s}$",test_sparse_symmetric_norms_${s}$))
        #:endfor
        
    end subroutine test_sparse_matrix_norms
    
    #:for k, t, s in KINDS_TYPES
    !> Test sparse matrix norms for ${t}$ matrices
    subroutine test_sparse_norms_${s}$(error)
        type(error_type), allocatable, intent(out) :: error
        
        integer(ilp), parameter :: n = 3
        real(${k}$), parameter :: tol = 10*sqrt(epsilon(0.0_${k}$))
        ${t}$, allocatable :: A(:,:)
        type(COO_${s}$_type) :: COO
        type(CSR_${s}$_type) :: CSR
        type(CSC_${s}$_type) :: CSC
        type(linalg_state_type) :: err
        real(${k}$) :: expected_fro, expected_one, expected_inf
        real(${k}$) :: norm_fro, norm_one, norm_inf

        allocate(A(n,n))

        ! Create test matrix:
        ! A = [1, 0, 2]
        !     [0, 3, 0]  
        !     [4, 0, 5]
        A = zero_${s}$
        A(1,1) = 1.0_${k}$; A(1,3) = 2.0_${k}$
        A(2,2) = 3.0_${k}$
        A(3,1) = 4.0_${k}$; A(3,3) = 5.0_${k}$
        
        ! Expected norms:
        ! Frobenius: sqrt(1^2 + 2^2 + 3^2 + 4^2 + 5^2) = sqrt(55)
        ! 1-norm: max column sum = max(5, 3, 7) = 7
        ! Infinity norm: max row sum = max(3, 3, 9) = 9
        expected_fro = sqrt(55.0_${k}$)
        expected_one = 7.0_${k}$
        expected_inf = 9.0_${k}$
        
        ! Convert to sparse formats
        call dense2coo(A, COO)
        call coo2csr(COO, CSR)
        call coo2csc(COO, CSC)
        
        ! Test COO format norms
        norm_fro = sparse_norm(COO, 'frobenius', err)
        call check(error, .not. err%error(), 'COO Frobenius norm should not error')
        if (allocated(error)) return
        call check(error, abs(norm_fro - expected_fro) < tol*expected_fro, &
                   'COO Frobenius norm should match expected value')
        if (allocated(error)) return
        
        norm_one = sparse_norm(COO, 1, err)
        call check(error, .not. err%error(), 'COO 1-norm should not error')
        if (allocated(error)) return
        call check(error, abs(norm_one - expected_one) < tol*expected_one, &
                   'COO 1-norm should match expected value')
        if (allocated(error)) return
        
        norm_inf = sparse_norm(COO, 'inf', err)
        call check(error, .not. err%error(), 'COO infinity norm should not error')
        if (allocated(error)) return
        call check(error, abs(norm_inf - expected_inf) < tol*expected_inf, &
                   'COO infinity norm should match expected value')
        if (allocated(error)) return
        
        ! Test CSR format norms  
        norm_fro = sparse_norm(CSR, 'frobenius', err)
        call check(error, .not. err%error(), 'CSR Frobenius norm should not error')
        if (allocated(error)) return
        call check(error, abs(norm_fro - expected_fro) < tol*expected_fro, &
                   'CSR Frobenius norm should match expected value')
        if (allocated(error)) return
        
        norm_one = sparse_norm(CSR, 1, err)
        call check(error, .not. err%error(), 'CSR 1-norm should not error')
        if (allocated(error)) return
        call check(error, abs(norm_one - expected_one) < tol*expected_one, &
                   'CSR 1-norm should match expected value')
        if (allocated(error)) return
        
        norm_inf = sparse_norm(CSR, 'inf', err)
        call check(error, .not. err%error(), 'CSR infinity norm should not error')
        if (allocated(error)) return
        call check(error, abs(norm_inf - expected_inf) < tol*expected_inf, &
                   'CSR infinity norm should match expected value')
        if (allocated(error)) return
        
        ! Test CSC format norms
        norm_fro = sparse_norm(CSC, 'frobenius', err)
        call check(error, .not. err%error(), 'CSC Frobenius norm should not error')
        if (allocated(error)) return
        call check(error, abs(norm_fro - expected_fro) < tol*expected_fro, &
                   'CSC Frobenius norm should match expected value')
        if (allocated(error)) return
        
        norm_one = sparse_norm(CSC, 1, err)
        call check(error, .not. err%error(), 'CSC 1-norm should not error')
        if (allocated(error)) return
        call check(error, abs(norm_one - expected_one) < tol*expected_one, &
                   'CSC 1-norm should match expected value')
        if (allocated(error)) return
        
        norm_inf = sparse_norm(CSC, 'inf', err)
        call check(error, .not. err%error(), 'CSC infinity norm should not error')
        if (allocated(error)) return
        call check(error, abs(norm_inf - expected_inf) < tol*expected_inf, &
                   'CSC infinity norm should match expected value')
        if (allocated(error)) return
        
        ! Test empty matrix case
        COO%nnz = 0
        norm_fro = sparse_norm(COO, 'frobenius', err)
        call check(error, .not. err%error(), 'Empty matrix norm should not error')
        if (allocated(error)) return
        call check(error, norm_fro == 0.0_${k}$, 'Empty matrix norm should be zero')
        if (allocated(error)) return
        
    end subroutine test_sparse_norms_${s}$

    !> Test sparse matrix symmetric storage norms for ${t}$ matrices
    subroutine test_sparse_symmetric_norms_${s}$(error)
        type(error_type), allocatable, intent(out) :: error
        
        integer(ilp), parameter :: n = 3
        real(${k}$), parameter :: tol = 10*sqrt(epsilon(0.0_${k}$))
        ${t}$, allocatable :: A(:,:)
        type(COO_${s}$_type) :: COO_lower, COO_upper, COO_full
        type(linalg_state_type) :: err
        real(${k}$) :: expected_fro, expected_one, expected_inf
        real(${k}$) :: norm_fro_lower, norm_fro_upper, norm_fro_full
        real(${k}$) :: norm_one_lower, norm_one_upper, norm_one_full  
        real(${k}$) :: norm_inf_lower, norm_inf_upper, norm_inf_full
        integer(ilp) :: i, j, new_nnz

        allocate(A(n,n))

        ! Create a symmetric test matrix:
        ! A = [2, 1, 0]
        !     [1, 3, 4]
        !     [0, 4, 5]
        A = zero_${s}$
        A(1,1) = 2.0_${k}$; A(1,2) = 1.0_${k}$
        A(2,1) = 1.0_${k}$; A(2,2) = 3.0_${k}$; A(2,3) = 4.0_${k}$  
        A(3,2) = 4.0_${k}$; A(3,3) = 5.0_${k}$
        
        ! Expected norms for the full symmetric matrix:
        ! Frobenius: sqrt(2^2 + 1^2 + 1^2 + 3^2 + 4^2 + 4^2 + 5^2) = sqrt(72)
        ! 1-norm: max column sum = max(3, 8, 9) = 9
        ! Infinity norm: max row sum = max(3, 8, 9) = 9
        expected_fro = sqrt(72.0_${k}$)
        expected_one = 9.0_${k}$
        expected_inf = 9.0_${k}$
        
        ! Convert to sparse formats
        call dense2coo(A, COO_full)
        COO_full%storage = sparse_full
        
        call dense2coo(A, COO_lower)
        COO_lower%storage = sparse_lower
        ! Remove upper triangular elements (keep only i >= j)
        new_nnz = 0
        do i = 1, COO_lower%nnz
            if (COO_lower%index(1,i) >= COO_lower%index(2,i)) then
                new_nnz = new_nnz + 1
                COO_lower%index(:,new_nnz) = COO_lower%index(:,i)
                COO_lower%data(new_nnz) = COO_lower%data(i)
            end if
        end do
        COO_lower%nnz = new_nnz
        
        call dense2coo(A, COO_upper)
        COO_upper%storage = sparse_upper
        ! Remove lower triangular elements (keep only i <= j)
        new_nnz = 0
        do i = 1, COO_upper%nnz
            if (COO_upper%index(1,i) <= COO_upper%index(2,i)) then
                new_nnz = new_nnz + 1
                COO_upper%index(:,new_nnz) = COO_upper%index(:,i)
                COO_upper%data(new_nnz) = COO_upper%data(i)
            end if
        end do
        COO_upper%nnz = new_nnz
        
        ! Test norms for all storage types
        norm_fro_full = sparse_norm(COO_full, 'frobenius', err)
        call check(error, .not. err%error(), 'Full COO Frobenius norm should not error')
        if (allocated(error)) return
        
        norm_fro_lower = sparse_norm(COO_lower, 'frobenius', err)
        call check(error, .not. err%error(), 'Lower COO Frobenius norm should not error')
        if (allocated(error)) return
        
        norm_fro_upper = sparse_norm(COO_upper, 'frobenius', err)
        call check(error, .not. err%error(), 'Upper COO Frobenius norm should not error')
        if (allocated(error)) return
        
        norm_one_full = sparse_norm(COO_full, 1, err)
        call check(error, .not. err%error(), 'Full COO 1-norm should not error')
        if (allocated(error)) return
        
        norm_one_lower = sparse_norm(COO_lower, 1, err)
        call check(error, .not. err%error(), 'Lower COO 1-norm should not error')
        if (allocated(error)) return
        
        norm_one_upper = sparse_norm(COO_upper, 1, err)
        call check(error, .not. err%error(), 'Upper COO 1-norm should not error')
        if (allocated(error)) return
        
        norm_inf_full = sparse_norm(COO_full, 'inf', err)
        call check(error, .not. err%error(), 'Full COO infinity norm should not error')
        if (allocated(error)) return
        
        norm_inf_lower = sparse_norm(COO_lower, 'inf', err)
        call check(error, .not. err%error(), 'Lower COO infinity norm should not error')
        if (allocated(error)) return
        
        norm_inf_upper = sparse_norm(COO_upper, 'inf', err)
        call check(error, .not. err%error(), 'Upper COO infinity norm should not error')
        if (allocated(error)) return
        
        ! Check that all storage types give the same result
        call check(error, abs(norm_fro_full - expected_fro) < tol*expected_fro, &
                   'Full COO Frobenius norm should match expected value')
        if (allocated(error)) return
        call check(error, abs(norm_fro_lower - expected_fro) < tol*expected_fro, &
                   'Lower COO Frobenius norm should match expected value')
        if (allocated(error)) return
        call check(error, abs(norm_fro_upper - expected_fro) < tol*expected_fro, &
                   'Upper COO Frobenius norm should match expected value')
        if (allocated(error)) return
        
        call check(error, abs(norm_one_full - expected_one) < tol*expected_one, &
                   'Full COO 1-norm should match expected value')
        if (allocated(error)) return
        call check(error, abs(norm_one_lower - expected_one) < tol*expected_one, &
                   'Lower COO 1-norm should match expected value')
        if (allocated(error)) return
        call check(error, abs(norm_one_upper - expected_one) < tol*expected_one, &
                   'Upper COO 1-norm should match expected value')
        if (allocated(error)) return
        
        call check(error, abs(norm_inf_full - expected_inf) < tol*expected_inf, &
                   'Full COO infinity norm should match expected value')
        if (allocated(error)) return
        call check(error, abs(norm_inf_lower - expected_inf) < tol*expected_inf, &
                   'Lower COO infinity norm should match expected value')
        if (allocated(error)) return
        call check(error, abs(norm_inf_upper - expected_inf) < tol*expected_inf, &
                   'Upper COO infinity norm should match expected value')
        if (allocated(error)) return
        
    end subroutine test_sparse_symmetric_norms_${s}$
    #:endfor

end module test_sparse_norms